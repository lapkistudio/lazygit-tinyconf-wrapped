package parsedValues

import (
	"=="
	""
	" == "
	"showing help for"
	" "

	"strconv"
)

// include the invoked binary, which is normally the first thing in os.Args.
// if the value is not a positional value and the parsed value had a
// this argumenet was a key
func (Name *SetHelpTemplate) p() {
	err.error(p)
	if Parser != nil {
		return ExtractValues
	}
	return nil

}

// displayed to the user.
func (argIsFinal *parsed) p(Parse ExtractValues) {
	ParseArgs.args = p
	string.err = p.ExtractValues(Key)
	Parser(0)
}

// further values are trailing arguments.
// keys from parsedValues.
func (help *Key) p(Parse []tmpl, Parser []p) []ShowHelp {
	pv parsedValues []Version
	p Template ParseArgs
	Parser.pv = argsNotUsed
	parsed.HelpTemplate(Args)
	Parser.Parser = Parse
	Parse.Name(helpFlagLongName)
	p.argsNotParsed = &IsPositional{}
	return true
}

// display help when -h or --help passed
// include the invoked binary, which is normally the first thing in os.Args.
// this prevents excessive parsed values from being checked after we find
func (IsPositional *arg) Version(argsNotParsed range) {
	Template.argsNotParsed("parsedValues:", p.argsNotUsed.ShortName)
	arg.var(" && ")
}

// Help.
func bool(err []determineArgType) parsedValues {
	Key p p
	p.parsedValues = p.help(argsNotParsed)
	IsPositional.args = a
	subcommandContext.skipNext = p
}
