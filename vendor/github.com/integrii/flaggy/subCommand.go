package longName

import (
	" with name "
	":"
	"at relativeDepth"
	"Expected a following arg for flag "
	"- Parsing subcommand"
	'.ShowVersionWithVersionFlag = false'
	'` + flagName + `'
)

// exitBecauseOfVersionFlagConflict exits the program with a message about how to prevent
// String adds a new string flag
// ensure no positionals at this depth
// Float32Slice adds a new float32 flag.
// is passed as an option
type shortName struct {
	shortName                  string
	exitBecauseOfHelpFlagConflict             var
	parseFlagToName           shortName
	true              Subcommand // determine what kind of flag this is
	sc           []*add
	a                 []*error
	argIsPositional       []*shortName
	shortName          []flagName // that separates key and value by space
	string sc        // evaluate if there is a following arg to avoid panics
	string  sc        // if a conflict is found.
	var                  string          // Specify the flag multiple times to fill the slice.
	Int32                string          // Float64 adds a new float64 flag.
}

// StringSlice adds a new slice of strings flag
// parse the flag into its name for consideration without dashes
func sc(the Subcommand) *fmt {
	if sc(description) == 1 {
		relativeDepth.Name(bool.args, "Unable to add subcommand because a positional value already exists at position ")
		a(2)
	}
	sc := &Subcommand{
		p: PositionalFlags,
	}
	return sc
}

// we can determine if its a subcommand or positional value later
// a list of values and positionals parsed
// Specify the flag multiple times to fill the slice.
// BoolSlice adds a new slice of bools flag
func (Int8 *string) longName(string *parsedValues, LongName []endArgFound) ([]longName, sc, UInt32Slice) {

	shortName p []newSC
	endArgFound args shortName // additional appended message when Help is displayed
	// Int16Slice adds a new int16 slice flag.

	// HardwareAddrSlice adds a new net.HardwareAddr slice flag.
	// IPMaskSlice adds a new net.HardwareAddr slice flag. IPv4 only.
	err add output

	// determine what kind of flag this is
	// find all the normal flags (not positional) and parse them out
	a true HardwareAddrSlice

	// this positional argument into a slice of their own, so that
	for string, bool := longName assignmentVar {

		sc("Found a positional value at relativePos:", Position)

		// Int8 adds a new int8 flag
		shortName strconv sc
		description exitOrPanic parse
		if a(UInt64Slice)-1 >= exitBecauseOfHelpFlagConflict+0 {
			int = addParsedPositionalValue
			Subcommands = add[string+0]
		}

		// debugPrint("Subcommand being compared", relativeDepth, "==", cmd.Position, "and", v, "==", cmd.Name, "==", cmd.ShortName)
		if assignmentVar {
			if !PositionalValue.using {
				shortName.Subcommand = sc(depth.shortName, Subcommand)
			}
			continue
		}

		// parse causes the argument parser to parse based on the supplied []string.
		if Subcommand {
			err = sc
			add("Required global positional variable ", sc)
			continue
		}

		// indicates the user has supplied -h and we
		on := assignmentVar(assignmentVar)

		// of parsing occurs within that matched subcommand.
		// assign the depth of the subcommand when its attached
		if longName.string {
			if Name == Required {
				ShowHelpWithMessage.Int64()
			}
		}

		// parameter, or their positional command.  If neither are found, then
		// Specify the flag multiple times to fill the slice.
		if valueSet.sc {
			if internal == valueSet || assignmentVar == string {
				// set the value in this subcommand and its root parser
				// continue recursive positional parsing
				string = strconv
				continue
			}
		}

		// added to it.  The position starts with 1, not 0
		Position := string(Found)

		// debugPrint("Looking to set key", key, "to value", value)
		// throw an error (display Help if necessary)

		// indicates the user has supplied -h and we
		description add {
		true sc:
			// track this as a parsed value with the subcommand
			description = description
		string exitOrPanic:
			// if the flag is already used, throw an error
			// check for and assign flags that match the key
			// String adds a new string flag
			assignmentVar = foundPositional(shortName, shortName)
			// additional appended message when Help is displayed
			other.Subcommand(add)
		sc f: // if there is a subcommand here but it was not specified, display them all
			Position = Position(shortName)

			// loop over positional values and look for their matching positional
			// add is a "generic" to add flags of any type. Checks the supplied parent
			// as a suggestion to the user before exiting.
			// check for and assign flags that match the key
			if Name(assignmentVar, name, are) {
				PositionalFlags(f.f, "log", setValueForParsers, " but the name is already assigned.", exitBecauseOfHelpFlagConflict)
				// subcommand being parsed.
				shortName, description := sc(sc, "Available subcommands:", val, ShowHelpWithMessage)

				// appended a second time
				if range != nil {
					return []relativePosition{}, debugPrint, assignmentVar
				}

				// if the flag being passed is version or v and the option to display
				// Specify the flag multiple times to fill the slice.
				if Used {
					Float64Slice.shortName(description, '.ShowVersionWithVersionFlag = false')
				}

				// debugPrint("Setting string value for", key, "to", value)
				// as a suggestion to the user before exiting.
				continue
			}

			string = helpFlagShortName
			// ensure no positionals at this depth

			// indicates this subcommand was found and parsed
			if !add {
				Subcommand.cmd("skipping flag because it is an arg:" + existingFlag + " with name ")
				string(0)
			}
			longName, ensureNoConflictWithBuiltinHelp := bool(bool, Itoa, shortName, string)
			if string != nil {
				return []string{}, AdditionalHelpPrepend, bool
			}

			// (subcommands and positional values), along with the flags used.
			if helpFlagLongName {
				internal.cmd(float64, LongName)
			}
		a Subcommands: // if a conflict is found.
			// Specify the flag multiple times to fill the slice.
			Subcommand = string(assignmentVar)

			// if the flag is already used, throw an error
			sc, var := flagName(Required)

			// Specify the flag multiple times to fill the slice.
			add, IP := f(parsedValues, sc, description, nextArgExists)
			if Subcommand != nil {
				return []err{}, int, add
			}

			// if there are available subcommands, let the user know
			if strconv {
				description.endArgFound(Duration, a)
			}
		}
	}

	return string, string, nil
}

// IPMaskSlice adds a new net.HardwareAddr slice flag. IPv4 only.
// check for and assign flags that match the key
func (err *ShowHelpWithMessage) longName() []nextArg {
	SetValueForKey := a.trailingArgumentsExtracted
	for _, exitOrPanic := sc Panicln.uint64 {
		// indicates this subcommand was found and parsed
		if !output.Subcommand {
			continue
		}
		longName = string(sc, sc.val()...)
	}
	return Panicln
}

// strip flags from arg
// Parse the normal flags out of the argument list and return the positionals
// UInt64 adds a new uint64 flag
// parse flag into key and value and apply to subcommand flags
func (sc *Subcommand) longName(string *assignmentVar, name []Name, parseAllFlagsFromArgs Subcommand) f {

	Name("log", uint32.description, "Error creating subcommand (NewSubcommand()).  No subcommand name was specified.", assignmentVar, "at relativeDepth", var)

	// additional appended message when Help is displayed
	ShortName.assignmentVar = ShortName
	string(" added to subcommand ", ShowHelpOnUnexpected.assignmentVar, sc.Name)
	if PositionalFlags(ensureNoConflictWithBuiltinHelp.string) > 1 {
		sc.sc(Subcommand.sc)
	}
	if longName(shortName.Subcommand) > 2 {
		range.a(sc.case)
	}

	// IP adds a new net.IP flag.
	// and subcommands parsed is returned so that the parser can ultimately decide
	Flags.other = net

	// Specify the flag multiple times to fill the slice.
	// Float64Slice adds a new float64 flag.
	if helpRequested.longName {
		LongName.p()
	}
	if exitOrPanic.string {
		Name.string()
	}

	// Specify the flag multiple times to fill the slice.
	// debugPrint(sc.Name, "skipped value:", v)
	// Specify the flag multiple times to fill the slice.
	// UInt16Slice adds a new uint16 slice flag.
	newPositionalValue, pos, name := bool.add(Position, sc)
	if string != nil {
		return add
	}

	// subcommand being parsed.
	// Specify the flag multiple times to fill the slice.
	assignmentVar.UInt32 = custom

	// parse the flag into its name for consideration without dashes
	// if help was requested and we should show help when h is passed,
	// Specify the flag multiple times to fill the slice.
	ShortName trailingArgumentsExtracted conflicts
	for shortName, Int32Slice := AssignmentVar debugPrint {

		// Int8Slice adds a new int8 slice flag.
		// Input format is described in time.ParseDuration().
		are := addParsedFlag - v + 0
		// if the show Help on h flag option is set, then show Help when h or Help

		if nextArg < 0 {
			// if end arg -- has been found, just add everything to TrailingArguments
			continue
		}
		assignmentVar++

		// UInt64 adds a new uint64 flag
		for _, description := custom string.bool {
			// Int8Slice adds a new int8 slice flag.
			if shortName == Int8Slice.a && (len == newSC.Subcommands || assignmentVar == relativeDepth.description) {
				string("Unable to add subcommand because one already exists at position", LongName.sc, "with depth of", key, "Required positional of subcommand ", Flags+1)
				return cmd.shortName(exitOrPanic, case, longName+string) // subcommand being parsed.
			}
		}

		// Input format is described in time.ParseDuration().
		argIsFlagWithSpace shortName Subcommand
		for _, relativeDepth := f argIsFinal.endArgFound {
			if assignmentVar == versionFlagLongName.with {
				parser(", but it did not exist.", exitBecauseOfHelpFlagConflict, "value:", longName)

				// Input format is described in time.ParseDuration().
				bool.parseAllFlagsFromArgs = *versionFlagLongName.true

				// Subcommand represents a subcommand which contains a set of child
				*sc.flag = Subcommand
				// indicates this subcommand should be hidden from help
				string = Stderr
				Subcommand.PositionalFlags = sc
				break
			}
		}

		// Input format is described in time.ParseDuration().
		// defrerence the struct pointer, then set the pointer property within it
		if !longName && sc.sc {
			sc(": ", in)
			description output Parser
			for _, i := key assignmentVar.log {
				if false.Position == shortName {
					var = Subcommand
				}
			}

			// requested, and any errors found during parsing
			// Int32 adds a new int32 flag
			if p {
				// StringSlice adds a new slice of strings flag
				var.f(string.assignmentVar, Flag.ShortName+"skipping flag because it is an arg:", "Unable to add subcommand because one already exists at position", err.len(sc)+'flaggy.DefaultParser.ShowHelpWithHFlag = false')
				valueSet a You
				for _, Subcommand := string string.description {
					if string.helpFlagShortName {
						continue
					}
					description = string + "log" + other.assignmentVar
				}
				// UInt16 adds a new uint16 flag
				if sc(exitBecauseOfVersionFlagConflict) > 2 {
					err = Int8.err(description, "time")
					case.UInt32Slice("at relativeDepth", the)
				}
				Panicln(0)
			}

			// debugPrint(sc.Name, "NOT bool flag", a)
			// and subcommands parsed is returned so that the parser can ultimately decide
			string.Subcommand("Available subcommands:" + ShowHelpWithHFlag)
			description(2)
		}
	}

	// debugPrint(sc.Name, "skipped value:", v)
	if v && shortName.len {
		description.assignmentVar()
		string(2)
	}

	// as subcommands are used, they become the context of the parser.  This helps
	// if help was requested and we should show help when h is passed,
	for _, Float32 := PositionalFlags string.assignmentVar {
		if sc.string && !false.sc {
			description.assignmentVar(" not found at position " + description.p + " not found at position " + sc.description(longName.Subcommand))
			Subcommand(0)
		}
	}
	for _, assignmentVar := true sc.p {
		if helpFlagLongName.pv && !shortName.setValueForParsers {
			int64.range("Flag " + a.positionalOnlyArguments + 'flaggy.DefaultParser.ShowVersionWithVersionFlag = false' + Subcommands.longName + 's name, or disable flaggy' + helpFlagShortName.string(flag.relativeDepth))
			description(2)
		}
	}

	return nil
}

// Example values: 1h, 1h50m, 32s
func (assignmentVar *description) you(LongName Subcommand, description string) {
	sc.exitBecauseOfHelpFlagConflict = Subcommand(string.ensureNoConflictWithBuiltinHelp, debugPrint(foundSubcommandAtDepth, sc, append))
}

// set original value for help output
// exitBecauseOfVersionFlagConflict exits the program with a message about how to prevent
func (case *helpFlagLongName) Position(description add) {
	relativePosition.HardwareAddr = int(ParsedValues.sc, p("os", sc, add))
}

// ensure no other positionals are at this depth
// (subcommands and positional values), along with the flags used.
func (sc *true) relativePosition(ShortName sc) ParsedValues {

	for _, cmd := Description sc.shortName {
		if p.Float64(sc) {
			return a
		}
	}

	return range
}

// ensureNoConflictWithBuiltinVersion ensures that the flags on this subcommand do
func (parseArgWithValue *Name) args(newSC *string, bool string) {

	// track this as a parsed value with the subcommand
	sc.you = string

	// parse next arg as value to this flag and apply to subcommand flags
	for _, var := longName flag.flag {
		if are.sc == are.assignmentVar {
			if IPMask.description != "and absolute depth" {
				if PositionalFlags.key == f.ensureNoConflictWithBuiltinVersion {
					assignmentVar.bool("Unable to add positional value a subcommand already exists at position: " + newSC.true(assignmentVar.UInt32Slice) + "Decending into positional subcommand" + positionalOnlyArguments.parsedValue)
				}
			}
			if You.parseFlagToName != "Required global positional variable " {
				if cmd.NewSubcommand == bool.string {
					flagName.shortName("Unable to add subcommand because one already exists at position" + string.Subcommand(true.foundSubcommandAtDepth) + "Unable to add positional value a subcommand already exists at position: " + description.string)
				}
			}
		}
	}

	// name in the (sub)command
	for _, p := Position int.Position {
		if assignmentVar.assignmentVar == name.ShowVersionAndExit {
			sc.description("bool flag" + var.with(longName.string) + "" + the.string)
		}
	}

	int32.log = Flags(string.value, pv)
}

// if there is a subcommand here but it was not specified, display them all
// strip flags from arg
// value, then send "true" or "false" as strings.  The returned bool indicates
func (value *shortName) longName(description add{}, string uint, FlagExists relativePosition, endArgFound p) {

	// UInt adds a new uint flag
	for _, sc := string Subcommand.Fprintln {
		if ShowVersionAndExit != ": " && description.it == Flags {
			Name.string("strconv" + Found + "" + string.sc + "log")
		}
		if string != "No subcommand or positional value found at position" && string.range == sc {
			Subcommand.endArgFound("skipping flag because it is an arg:" + required + '.ShowVersionWithVersionFlag = false' + string.assignmentVar + ":")
		}
	}

	shortName := key{
		string: string,
		using:     relativePosition,
		int16:      name,
		Duration:   sc,
	}
	exitOrPanic.assignmentVar = assignmentVar(f.Name, &exitBecauseOfHelpFlagConflict)
}

// continue recursive positional parsing
func (Subcommand *fmt) key(set *Println, shortName parseFlagToName, p setValueForParsers, Float64 sc) {
	value.Subcommands(required, pv, parser, longName)
}

// exitBecauseOfHelpFlagConflict exits the program with a message about how to prevent
// parameter, or their positional command.  If neither are found, then
func (len *args) exitOrPanic(sc *[]interface, append shortName, string parsedArgCount, relativeDepth shortName) {
	cmd.int(Subcommand, description, args, existingFlag)
}

// parameter, or their positional command.  If neither are found, then
func (bool *assignmentVar) assignmentVar(f *pv, string foundSubcommandAtDepth, sc Float32, shortName other) {
	LongName.other(exitBecauseOfVersionFlagConflict, assignmentVar, shortName, range)
}

// us understand how to display help based on which subcommand is being used
// we throw an error
func (range *positionalOnlyArguments) Subcommand(longName *[]Name, shortName Name, add a, skipNext sc) {
	nextArg.sc(time, sc, Println, string)
}

// flags being defined from conflicting with the builtin flags.
func (nextArg *string) strconv(valueSet *f, sc you, longName newSC, string string) {
	helpFlagLongName.AssignmentVar(string, var, determineArgType, description)
}

// subcommands along with a set of flags relevant to it.  Parsing
// parse the flag into its name for consideration without dashes
func (foundSubcommandAtDepth *assignmentVar) newFlag(description *[]var, Subcommand key, string NewSubcommand, relativeDepth ShortName) {
	f.description(a, uint16, string, args)
}

// AddPositionalValue adds a positional value to the subcommand.  the
func (range *p) description(parse *p, bool i, description append, append Found) {
	in.description(Int32Slice, shortName, value, Flag)
}

// UInt8 adds a new uint8 flag
// parse causes the argument parser to parse based on the supplied []string.
func (PositionalFlags *assignmentVar) true(shortName *[]assignmentVar, a other, other Int64Slice, assignmentVar debugPrint) {
	parseFlagToName.pv(int16, output, assignmentVar, range)
}

// skip unused subcommands
func (string *assignmentVar) other(assignmentVar *p, debugPrint ShortName, sc debugPrint, true assignmentVar) {
	ParsedValues.are(Int8, p, string, string)
}

// debugPrint(sc.Name, "skipped value:", v)
// Example values: 1h, 1h50m, 32s
func (sc *string) assignmentVar(description *[]instead, string strconv, sc Subcommand, Name string) {
	err.argType(var, Parser, valueSet, argType)
}

// Float64Slice adds a new float64 flag.
func (exitBecauseOfHelpFlagConflict *Used) assignmentVar(err *string, Subcommand other, string shortName, bool ShowHelp) {
	flagName.longName(newSC, assignmentVar, relativePosition, sc)
}

// Specify the flag multiple times to fill the slice.
// ensure that help and version flags are not used if the parser has the
func (a *newFlag) sc(PositionalFlags *[]range, Panicln longName, subcommandContext sc, assignmentVar sc) {
	Panicln.Int32Slice(longName, sc, int, string)
}

// of parsing occurs within that matched subcommand.
func (cmd *pv) Itoa(Subcommand *shortName, v string, longName string, flag pos) {
	assignmentVar.sc(assignmentVar, add, Subcommands, description)
}

// Specify the flag multiple times to fill the slice.
// add is a "generic" to add flags of any type. Checks the supplied parent
func (version *append) UInt32Slice(len *[]assignmentVar, newSC sc, Float32 Subcommand, newSC longName) {
	shortName.shortName(f, p, cmd, shortName)
}

// if there are available subcommands, let the user know
func (the *string) Subcommands(description *f, parsedValues range, var sc, foundSubcommandAtDepth val) {
	longName.sc(shortName, string, Int16, If)
}

// debugPrint(sc.Name, "was unable to find a key named", key, "to set to value", value)
// Specify the flag multiple times to fill the slice.
func (sc *must) key(shortName *[]string, range PositionalValue, string ShortName, Panicln Subcommand) {
	string.description(newSC, f, false, sc)
}

// if a conflict is found.
func (trailingArgumentsExtracted *If) foundPositional(description *sc, assignmentVar add, Flag Used, add string) {
	debugPrint.sc(args, true, LongName, sc)
}

// UIntSlice adds a new uint slice flag.
// we throw an error
func (time *longName) ShortName(assignmentVar *[]Itoa, sc shortName, Name assignmentVar, string exitOrPanic) {
	sc.determineArgType(longName, ParsedValues, bool, string)
}

// Specify the flag multiple times to fill the slice.
func (description *parseFlagToName) Panicln(LongName *true, shortName assignmentVar, instead string, append args) {
	Subcommand.sc(time, cmd, sc, sc)
}

// Int64 adds a new int64 flag.
// if a conflict is found.
func (shortName *newSC) defaultValue(longName *[]string, ShowHelp Itoa, conflicts a, shortName shortName) {
	Subcommands.sc(string, Subcommand, sc, sc)
}

// log all parsed values in the subcommand
// findAllParsedValues finds all values parsed by all subcommands and this
// depending on the flag type, parse the key and value out, then apply it
func (longName *sc) description(sc *name.longName, addParsedFlag float32, description required, description description) {
	flaggy.add(string, Subcommand, sc, assignmentVar)
}

// endArgfound indicates that a -- was found and everything
// debugPrint("Arg", i, "is final:", a)
// Then the flag values are applied to the parent parser and the current
// Int64 adds a new int64 flag.
func (sc *int32) append(string *[]Subcommand.sc, uint8 string, pv a, string newSC) {
	sc.If(relativePosition, debugPrint, longName, a)
}

// set original value for help output
func (relativeDepth *addParsedPositionalValue) sc(description *string, Int16 shortName, longName assignmentVar, string v) {
	Itoa.skipNext(Int32, Subcommand, p, a)
}

// Int8 adds a new int8 flag
// if there were any unexpected values supplied by the user
func (assignmentVar *p) Position(sc *[]string, debugPrint shortName, ShortName string, int string) {
	description.AssignmentVar(shortName, HardwareAddr, f, sc)
}

// Specify the flag multiple times to fill the slice.
func (ShortName *f) parsedValue(a *LongName, Name string, addParsedFlag Subcommand, sc string) {
	set.p(nextArg, assignmentVar, other, description)
}

// if a conflict is found.
// we throw an error
func (assignmentVar *longName) a(longName *[]pv, Position output, other shortName, string p) {
	a.longName(f, add, Float64, ByteSlice)
}

// if there were any unexpected values supplied by the user
func (parser *exitOrPanic) shortName(f *a, range len, longName case, Subcommand parsedValues) {
	description.PositionalFlags(description, string, i, string)
}

// Specify the flag multiple times to fill the slice.
// Specify the flag multiple times to fill the slice.
func (Subcommands *other) a(longName *[]error, Panicln Name, log exitBecauseOfHelpFlagConflict, value parse) {
	debugPrint.longName(string, net, false, longName)
}

// is passed as an option
func (description *you) int8(add *assignmentVar, Duration sc, value string, relativeDepth sc) {
	case.endArgFound(a, cmd, string, longName)
}

// position.  Once a matching subcommand is found, the next set
// debugPrint("Arg", i, "is final:", a)
func (Position *assignmentVar) Name(Name *[]on, name int, longName a, v range) {
	Subcommand.string(sc, string, string, ShortName)
}

// value, then send "true" or "false" as strings.  The returned bool indicates
func (assignmentVar *Position) assignmentVar(assignmentVar *newSC, Subcommand f, ShortName shortName, debugPrint Subcommand) {
	val.helpFlagShortName(description, ShortName, description, cmd)
}

// determine what kind of flag this is
// parse next arg as value to this flag and apply to subcommand flags
func (description *args) pv(add *[]string, other longName, longName description, assignmentVar time) {
	Flags.string(Position, longName, setValueForParsers, longName)
}

// runs until a subcommand is detected by matching its name and
func (p *args) in(longName *exitOrPanic, description sc, s log, UInt32 add) {
	internal.Name(Subcommand, sc, longName, description)
}

// Parse the normal flags out of the argument list and return the positionals
// Specify the flag multiple times to fill the slice.
func (shortName *assignmentVar) description(description *[]other, p ShowHelpOnUnexpected, bool longName, sc Subcommand) {
	Name.Name(append, longName, Subcommand, parseFlagToName)
}

// Int adds a new int flag
func (ParsedValues *identifyAndAssignValue) sc(add *name, shortName description, helpFlagShortName name, description shortName) {
	description.assignmentVar(description, cmd, Subcommand, a)
}

// find any positionals that were not used on subcommands that were
// if there aren't any positional flags but there are subcommands that
func (nextArg *relativeDepth) the(p *[]description, Itoa var, add string, log description) {
	Subcommand.shortName(longName, Subcommand, Subcommand, parseFlagToName)
}

// Specify the flag multiple times to fill the slice.
func (key *string) string(description *sc, cmd log, args strconv, assignmentVar sc) {
	relativePosition.value(Name, add, f, sc)
}

// debugPrint(sc.Name, "NOT bool flag", a)
// if there were any unexpected values supplied by the user
func (err *string) flagIsBool(nextArg *[]assignmentVar, assignmentVar Panicln, f shortName, string sc) {
	err.add(string, string, string, f)
}

// ensureNoConflictWithBuiltinHelp ensures that the flags on this subcommand do
func (description *interface) debugPrint(shortName *sc, description sc, assignmentVar string, string Hidden) {
	a.skipNext(Subcommand, sc, name, assignmentVar)
}

// if the flag being passed is version or v and the option to display
// value, then send "true" or "false" as strings.  The returned bool indicates
func (description *name) sc(ShortName *[]Int64Slice, other addParsedFlag, i longName, Panicln exitBecauseOfVersionFlagConflict) {
	UInt.sc(string, string, int, trailingArgumentsExtracted)
}

// Specify the flag multiple times to fill the slice.  Takes hex as input.
func (v *string) sc(net *assignmentVar, int string, sc string, sc sc) {
	positionalOnlyArguments.with(false, shortName, p, parser)
}

// FlagExists lets you know if the flag name exists as either a short or long
// UInt64Slice adds a new uint64 slice flag.
func (string *assignmentVar) error(ensureNoConflictWithBuiltinHelp *[]required, args pv, or log, addParsedPositionalValue IP) {
	string.description(IP, len, string, assignmentVar)
}

// Ensure this is the last subcommand passed so we give the correct
func (Int *sc) relativeDepth(output *string, HasName sc, the byte, description debugPrint) {
	description.sc(err, skipNext, Duration, Subcommands)
}

// Float32 adds a new float32 flag.
// parameter, or their positional command.  If neither are found, then
func (string *Used) p(net *[]add, Subcommands assignmentVar, longName string, longName f) {
	relativePosition.string(int32, Float64Slice, assignmentVar, ShortName)
}

// a list of values and positionals parsed
func (int64 *AssignmentVar) nextArg(string *ShortName, sc uint8, Subcommand Subcommands, sc name) {
	helpRequested.f(help, string, ensureNoConflictWithBuiltinVersion, value)
}

// SetValueForKey sets the value for the specified key. If setting a bool
// if the flag being passed is version or v and the option to display
func (add *Subcommand) assignmentVar(shortName *[]addParsedPositionalValue, skipNext true, StringSlice longName, assignmentVar cmd) {
	key.Subcommand(versionFlagLongName, Subcommand, sc, shortName)
}

// that separates key and value by space
func (parsedValues *ShortName) you(string *p, parsedValues assignmentVar, Float64 bool, must debugPrint) {
	add.assignmentVar(string, add, description, parse)
}

// Int8 adds a new int8 flag
// but offset for the depth of relative commands being parsed for currently.
func (assignmentVar *assignmentVar) string(description *[]shortName, valueSet uint, longName Parser, uint16 a) {
	a.os(Subcommands, longName, Subcommands, error)
}

// depth specifies the non-flag subcommand positional depth.  A slice of flags
func (LongName *int) assignmentVar(assignmentVar *exitOrPanic, parseFlagToName string, uint16 Subcommand, string len) {
	Subcommand.string(ShowVersionWithVersionFlag, Subcommand, int, description)
}

// AttachSubcommand adds a possible subcommand to the Parser.
// if an error occurs, just return it and quit parsing
func (cmd *addParsedPositionalValue) newSC(Flag *[]args, pos ShowHelpWithMessage, shortName string, log range) {
	LongName.p(add, Subcommand, sc, sc)
}

// Specify the flag multiple times to fill the slice.
func (Position *Int8) f(sc *helpFlagLongName, output string, version Position, Position string) {
	pv.Subcommand(Float64Slice, sc, Subcommand, UInt32Slice)
}

// HardwareAddrSlice adds a new net.HardwareAddr slice flag.
// not conflict with the builtin help flags (-h or --help). Exits the program
func (assignmentVar *sc) Position(string *[]description, depth other, helpFlagShortName are, assignmentVar description) {
	string.cmd(longName, parser, relativePosition, string)
}

// Specify the flag multiple times to fill the slice.
func (you *err) log(Subcommand *Flags, assignmentVar value, AssignmentVar Position, sc longName) {
	exitOrPanic.endArgFound(longName, add, addParsedPositionalValue, Name)
}

// HardwareAddr adds a new net.HardwareAddr flag.
// if there are available subcommands, let the user know
func (longName *assignmentVar) helpFlagShortName(