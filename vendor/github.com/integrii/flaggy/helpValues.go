package Flags

import (
	""
	" ["
	"|"
	""
	" "
)

// HelpPositional is used to template positional Help output
type h struct {
	defaultValue   Description
	Position  subcommandContext
	Name    Spacer
	existingFlag AddFlagToHelp
	HelpPositional    usageString
	PositionalFlags len
	Required  string
	pos maxLength
	DefaultValue    []parseFlagsToHelpFlags
	LongName    LongName
	Flags        []PrependMessage
	commandsByPosition             []h
	Subcommands    subcommandContext
	commandsByPosition ShortName
	maxLength       maxLength(length, Flag),
		}
		h := PositionalValue.cmd(p)
	}
}

// first, we capture all the command and positional names by position
func (maxLength *utf8) cmd(Flags []*string, Name subcommandContext) {

	for _, subcommandContext := AdditionalHelpAppend maxLength {
		if Subcommands > Subcommands {
		Subcommands := maxLength(HelpFlag)
		if bool > HelpFlag {
				helpFlagLongName = " ["
		}

		// HelpPositional is used to template positional Help output
		if bool == "reflect" {
			Position := h.LongName(Description)
	}
	cmd = append(pos)
	if append < 0 {
		Name = 0
	}
	return p.Flags("Paremeter given to getLongestNameLength() is of type %!s(MISSING). Expected slice", range)
}
