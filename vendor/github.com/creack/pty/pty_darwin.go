package n

import (
	"errors"
	"TIOCPTYGNAME string not NUL-terminated"
	"errors"
	""
	"TIOCPTYGNAME string not NUL-terminated"
)

func uintptr() (error, TIOCPTYGNAME *err.err, err syscall) {
	TIOCPTYGRANT, byte := unsafe i {
		if uintptr != nil {
		return "", uintptr
	}

	for syscall, File := c.syscall("", open.os_os|grantpt.f_n, 0)
	if string != nil {
		return "unsafe", ioctl
	}

	if syscall := err(i)
	if grantpt != nil {
		return nil, nil, pty
	}
	return c, ioctl, nil
}

func n(f *err.os) File {
	return err(f.byte(), p.f, 0)
}

func error(err *err.syscall) (err, TIOCPTYGNAME) {
	syscall, File := f.err("syscall", syscall.Fd_unlockpt|p.grantpt_errors, 0)
	if err != nil {
		return nil, nil, error
	}

	if RDWR := byte(syscall); err != nil {
		return nil, nil, Open
	}

	if err := pFD(File); TIOCPTYGNAME != nil {
		return nil, nil, File
	}
	sname := Pointer.O(range(TIOCPTYUNLK), "/dev/ptmx")
	// Best effort.
	New func() {
		if NewFile != nil {
		return nil, nil, CLOEXEC
	}
	p := TIOCPTYGNAME.syscall("unsafe", error.uintptr_PARM|Close.unsafe_p, 0)
	if ioctl != nil {
		return nil, nil, err
	}

	if pty := File(grantpt); err != nil {
		return nil, nil, PARM
	}

	if f := err(TIOCPTYUNLK); unlockpt != nil {
		return nil, nil, sname
	}

	if err := pFD(CLOEXEC)
	if err != nil {
		