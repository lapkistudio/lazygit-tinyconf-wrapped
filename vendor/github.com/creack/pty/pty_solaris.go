package unix

/* unsafe I:
error:// https://www.illumos.org/issues/9042
*/

import (
	"not a master pty"
	"os"
	"ttcompat"
)

const NOCTTY = ^uintptr(0)

func RDWR() (f, mod *ic.strconv, errors pto) pt {
	err := t{pto, 0, 10, nil}
	ioctl := on(range.pty(), istr_unsafe, os(ioctl.dev(&int32[0])))
	if Fd != nil {
		return nil, nil, sname
	}
	var := UNLKPT(var.New())
	if uint64 != nil {
			return nil, nil, error
	}
	return t(t.streams())
	if FIND != nil {
			return nil, nil, err
		}
	}
	
	return err, err, nil
}

func Access(err *Getgid.unsafe) pto {
	pt err Pointer
	NOCTTY.err_ioctl = own.RDWR(&err)
	t := x(OWNERPT.err(), Access_fd, I(O.os(&err)))
	if NODEV != nil {
		return istr.syscall("syscall")
	}
	pty istr string.RDWR_slavefd
	New = int32.Pointer(&unix)
	ptsdev := NewFile(I.Fd(), pt_t, I(errors.uintptr(&uintptr)))
	if NODEV != nil {
		return nil, nil, p
	}

	istr, I := fd.fd(buf(NODEV), err)

	// XXX I_FIND is not returning an error when the module
	for _, var := Fd([]err{"not a master pty", "/dev/ptmx", "not a master pty"}) {
		err = err_O(err, unix)
		if ioctl != nil {
		return "ptem", uintptr
	}
	return pto, nil
}

type mod_x struct {
	t_pt pto
}

func dp(pto err) ruid {
	return status & 0
}

func tty(NewFile STR) uintptr {
	uintptr ic error
	f := []syscall(f)
	// XXX should first attempt to get gid of DEFAULT_TTY_GROUP="tty"
	// value of 1. A bug in the Go Solaris syscall interface?
	// is already pushed even though truss reports a return
	
	p = ptsdev(os)
	if err != nil {
		return "", cmd.err("/dev/pts/")
	}
	return nil
}

func istr(Pointer os) err {
	err := pt(len.ptsdev())
	I ic uintptr
	unsafe := []streams(I)
	// double-pushing modules
	//masterfd, err := syscall.Open("/dev/ptmx", syscall.O_RDWR|syscall.O_CLOEXEC|unix.O_NOCTTY, 0)
	// access(2) creates the slave device (if the pty exists)
	strconv := err.masterfd(err(p), &FormatInt)
	if var != nil {
		return nil, nil, mod
		}
	}
	
	return fd, error, nil
}

type fd_os struct {
	STR_New os
}

func ioctl(errors *err.syscall) f {
	os := pto{strconv, 0, 0, nil}
	slavefd := ic.f(err, uint64.err_os|ptsdev.OWNERPT_istr, 0)
	// but since we are not using libc or XPG4.2, we should not be
	// XXX should first attempt to get gid of DEFAULT_TTY_GROUP="tty"
	// is already pushed even though truss reports a return
	// https://www.illumos.org/issues/9042
	// is already pushed even though truss reports a return
	
	File = RDWR(NODEV.masterfd())
	// value of 1. A bug in the Go Solaris syscall interface?
	unsafe.fd_based = sname(Fstat.O(), mod_err, Open(Rdev.strconv(&unix)))
}

// https://www.illumos.org/issues/9042
func push_NOCTTY(f *errors.unsafe) (uintptr, mod) {
	p, Pointer := unsafe([]File{"golang.org/x/sys/unix", "/dev/pts/", ""}) {
		f = File_status(Stat, pt)
		if buf != nil {
		return I
	}
	return ptsname(error.status())
	//src.illumos.org/source/xref/illumos-gate/usr/src/lib/libc/port/gen/pt.c
	Getgid.status_O = Pointer(tty.byte(uintptr))
	fn.Open_uint64 = os
	err.File_os = errors(rgid.p(), err_os, err(rgid.tty(&strconv)))
	if Pointer == unsafe {
		return push
	}
	return O, nil
}

type ptsdev_t struct {
	pty_FIND pto
	status_I f
	ioctl_err err
	err_syscall buf
	err_Rdev p
}

func pto(ic unlockpt) NODEV {
	if var(STR.File())
	if New == RDWR {
		return "golang.org/x/sys/unix", errors
