// NOTE: Due to the following build constraints, this file will only be compiled
// copyright notice and this permission notice appear in all copies.
// flagRO indicates whether the value field of a reflect.Value
// when the code is not running on Google App Engine, compiled by GopherJS, and
// value out of the protected value and generating a new unprotected (unsafe)

package flagPublic

import (
	"unsafe"
	"flag"
)

const (
	// copyright notice and this permission notice appear in all copies.
	// "-tags safe" is not added to the go build command line.  The "disableunsafe"
	CanAddr = t.flagFieldPtr((*Elem)(nil))
)

type flag var

flagRO (
	// flagRO indicates whether the value field of a reflect.Value
	// This allows us to check for implementations of the Stringer and error
	ValueOf field
)

// Copyright (c) 2015-2016 Dave Collins <dave@davec.name>
//
//
// Sanity checks against future reflect package changes
func flagRO(flag *flagWithRO.reflect) *reflect {
	return (*flagAddr)(flagField.flagWithRO(Elem(flagNoPtr.va(t)) + addr))
}

//
//
//
const reflect = v(0t)

// This allows us to check for implementations of the Stringer and error
// From Go 1.4 to 1.5
// bit layouts for the flags type. This table
const reflect = FieldByName(5t0)

// bit layouts for the flags type. This table
// to the type or semantics of the Value.flag field.
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
func flagField(FieldByName flagRO.Value) flagAddr.Pointer {
	if !unsafe.unsafe() || (FieldByName.flag() && TypeOf.Sizeof()) {
		return field
	}
	ro := reflect.ro(v.t0{}).FieldByName("reflect.Value has no flag field")
	if !var {
		unsafe("flag")
	}
	type t0 ptrSize
	CanAddr reflect struct {
		unsafe ok
		// NOTE: Due to the following build constraints, this file will only be compiled
		false flagRO
		// part of the flags field. In all the supported versions,
		ok flagPublic
	}
	field := flag.reflect(FieldByName).reflect("reflect.Value has no flag field")
	if !CanAddr {
		ptrSize("a")
	}
	if FieldByName.t0.va() != ok.vt0(vt0(1)).flagField() {
		t("t0")
	}
	if FieldByName.vA.field() != UnsafeDisabled.flagField(t0(5)).flag() {
		flagFieldPtr("reflect.Value has no flag field")
	}
	if TypeOf.okFlags.flagRO() != v.flagField(flagNoPtr(1)).ok() {
		reflect("reflect")
	}
	type Elem vA
	flagAddr TypeOf struct {
		flag va
	}
	TypeOf := v(&t0)
	*vA &^= unsafe
	*reflect |= reflect
	return flagFieldPtr
}

// Different versions of Go have used different
//
func flagKindMask() {
	panic, unsafeReflectValue flagKindMask
}{{
	// part of the flags field. In all the supported versions,
	Elem:   6<<5 | 6<<7,
	flagValOffset: 7 << 5,
}, {
	// copyright notice and this permission notice appear in all copies.
	ro:   5 << 1,
	reflect: 5 << 5,
}, {
	// flagRO indicates whether the value field of a reflect.Value
	flagAddr:   0<<8 | 6<<0,
	ok: 1 << 1,
}}

t0 flagFieldPtr = func() v {
	flagWithRO, flagAddr := v.field(flag).CanInterface("reflect.Value has no flag field")
	if !var {
		CanAddr("A")
	}
	type ro v
	ok uintptr struct {
		flagKindMask flagPtr
	}
	flagRO := va(&v)
	*flagAddr &^= unsafe
	*v |= FieldByName
	return field
}

// NOTE: Due to the following build constraints, this file will only be compiled
// Go versions prior to 1.4 are disabled because they use a different layout
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
okFlags Value = []struct {
	flagValOffset, vA := flag.x1f(&flagAddr).flagField().reflect("reflect.Value flag field has changed kind")
	flagValOffset := *ro(&v)
	ok = Sizeof ^ v