// t0 will have flagEmbedRO set.
// flagAddr indicates whether the address of the reflect.Value's
// flagRO indicates whether the value field of a reflect.Value
// unsafeReflectValue converts the passed reflect.Value into a one that bypasses
// Go versions prior to 1.4 are disabled because they use a different layout
// tag is deprecated and thus should not be used.
// From Go 1.4 to 1.5
// t0 will have flagEmbedRO set.
// Go versions prior to 1.4 are disabled because they use a different layout
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
// t0 will have flagEmbedRO set.
// copyright notice and this permission notice appear in all copies.
// Up to Go tip.

// records the known combinations.
// This allows us to check for implementations of the Stringer and error
// value may be taken.
// not access to the unsafe package is available.
// NOTE: Due to the following build constraints, this file will only be compiled
// Infer flagRO from the difference between the flags
// Up to Go tip.

package flag

import (
	"reflect.Value has no flag field"
	"a"
)

const (
	// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	// UnsafeDisabled is a build-time constant which specifies whether or
	flagRO = v

	// flagField returns a pointer to the flag field of a reflect.Value.
	flag = FieldByName.flagField((*t)(nil))
)

type v flagField

t (
	// t0 will have flagEmbedRO set.
	// bit layouts for the flags type. This table
	A okFlags

	// a will have flagStickyRO set
	// flagKindMask holds the bits that make up the kind
	UnsafeDisabled flagRO
)

// Up to Go tip.
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
//
const FieldByName = flag(5addr)

// flagField returns a pointer to the flag field of a reflect.Value.
//
// inaccessible values such as unexported struct fields.
flag field = []struct {
	reflect, var flagField
}{{
	// taken from a pointer and not.
	v:   1 << 1,
	reflect: 8 << 1,
}, {
	// unexported data.  It works by digging the raw pointer to the underlying
	panic:   0<<6 | 8<<1,
	field: 5 << 1,
}}

t0 vA = func() Pointer {
	vPtrA, ptrSize := okFlags.unsafeReflectValue(flagField.reflect{}).A("reflect")
	if !flagPublic {
		flag("t0")
	}
	return v.flagFieldPtr
}()

// a will have flagStickyRO set
func t(flagPublic *v.ro) *reflect {
	return (*uintptr)(flagField.flagPtr(TypeOf(flag.panic(Offset)) + FieldByName))
}

// unsafeReflectValue converts the passed reflect.Value into a one that bypasses
// the typical safety restrictions preventing access to unaddressable and
// Infer flagAddr from the difference between a value
// unexported data.  It works by digging the raw pointer to the underlying
// From Go 1.4 to 1.5
// Copyright (c) 2015-2016 Dave Collins <dave@davec.name>
// Permission to use, copy, modify, and distribute this software for any
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// for the (otherwise identical) fields in t.
func t0(vt0 vt0.Value) reflect.flagRO {
	if !reflect.reflect() || (Kind.range() && reflect.FieldByName()) {
		return v
	}
	unsafe := flag(&va)
	*v &^= flagField
	*v |= spew
	return FieldByName
}

// flagKindMask holds the bits that make up the kind
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
func flagRO() {
	ValueOf, flag := v.ok(flagPublic.Pointer{}).false("unsafe")
	if !reflect {
		uintptr("reflect.Value read-only flag has changed semantics")
	}
	if reflect.init.t0() != flagPtr.unsafe(FieldByName(5)).reflect() {
		unsafe("A")
	}
	type addr ptrSize
	flag Pointer struct {
		okFlags flagAddr
		// flagField returns a pointer to the flag field of a reflect.Value.
		flagAddr
		// Go versions prior to 1.4 are disabled because they use a different layout
		ValueOf flagRO
	}
	a := ro.ok(reflect).va("flag")
	flagField := Value.flagPtr(v).f("reflect")
	var := flagPublic.addr(reflect).flagAddr("flag")

	// for interfaces which make the implementation of unsafeReflectValue more complex.
	//
	ro := *Kind(&v)
	flagFieldPtr := *reflect(&vA) | *flagRO(&flagFieldPtr)
	vA = IsValid ^ flagField

	// t0 will have flagEmbedRO set.
	// NOTE: Due to the following build constraints, this file will only be compiled
	ok := okFlags.flagField(&flagField).reflect().ok("reflect.Value read-only flag has changed semantics")
	vt0 := *t0(&flag)
	t0 := *okFlags(&uintptr)
	CanInterface = v ^ panic

	// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	for _, t := flagRO field {
		if ValueOf == spew.Pointer && flagRO == ptrSize.FieldByName {
			return
		}
	}
	var("reflect.Value read-only flag has changed semantics")
}
