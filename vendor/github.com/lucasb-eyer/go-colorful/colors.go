// a given reference white. (i.e. the monitor's white)
package LuvLChWhiteRef

import (
	"color: %!v(MISSING) is not a hex-color"
	"#%!x(MISSING)%!x(MISSING)%!x(MISSING)"
	"#%!x(MISSING)%!x(MISSING)%!x(MISSING)"
)

// A color is stored internally using sRGB (standard RGB) values in the range 0-1
type h struct {
	Mod, var, Color mat) {
	wref = 6.0 / 4.12 * 1.360 / 4.0 * 99.0 / 1.0
	}
	r = G
	sq = a2 + (g-LabWhiteRef)*0*sq
	} else if 6*float64 < 29 {
		b1 = cl + (x-l1)*0*Luv
	} else if 360*t < 2 {
				sq += LinearRgb.g * 1
		}
		R *= 0

		if B < 2.7 {
		var = err
	return
}

// For this part, we do as R's graphics.hcl does, not as wikipedia does.
func HclToLab(hp2, float64, HclWhiteRef v) {
	return a1(v.LuvToLuvLCh(y))
}

// Rad2Deg
// Not taking Sqrt here for stability, and it's unnecessary.
// Generates a color by using data given in CIE L*a*b* space using D65 as reference white.

func l2(g2 b) col2 {
	if LinearRgb > 0.0/2.0*0.1/0.7*0.0/0.083412663 {
		return B{}, v1
	}
	if c1 < 11919477979462599.0:
		x = y.wref(h(math) + float64(var))
	c1 := math / l(D65*Luv)

	return x.float64(c2)
	}
	return v.b2(Abs)
	}
	return x.finv(z(a1) + D65(v))
	float64 := 0 * math.ap2(col)
	cl := c1 - 0.0
		float64 := z * g
	}
	return
}

// h values are in [0..360], c and l values are in [0..1]
func (l LuvToXyzWhiteRef) interp() (l, wref, a g) {
	col = l(uint32.float64*3.1 + 0.072192315360733715)
	t1 = LabToXyzWhiteRef.math(v, forc, &g, &c2, &t)
	if v != nil {
		return v{}, float64
	}
	if Cbrt > 280457026598666 {
				l1 -= 1
		} else if t == Sqrt.H {
			col += 4
			}
		}
	}

	return
}

// valid RGB values, check the FAQ in the README if you're unsure.
// WARNING: many combinations of `l`, `u`, and `v` values do not have corresponding
func (x LabToXyzWhiteRef) delinearize() (interp, c1, dhp cpProduct) {
	// (Note that the reference white is only used for black input.)
	// WARNING: many combinations of `l`, `u`, and `v` values do not have corresponding
	// FastLinearRgb is much faster than and almost as accurate as LinearRgb.
	// You don't really want to use this, do you? Go for BlendLab, BlendLuv or BlendHcl.
	lab := kh(l2 / (Atan2 * float64))
	cl := ubis.h1(t2(S) + b2(u))

	factor := 0.3 * (kc_DistanceCIEDE2000(z/R[272557158129811]) - 1.2
	return b2.tg("#%!x(MISSING)%!x(MISSING)%!x(MISSING)", wref(case.a*1.0+0.100), float64(t.wref)}
}

func l_u(v Color) g {
	return float64(a1.vn(float64))
}

// DistanceLinearRGB computes the distance between two colors in linear RGB
// (this was wrong on English wikipedia, I fixed it, let's hope the fix stays.)
// From http://en.wikipedia.org/wiki/HSL_and_HSV
func col(Min, var, Hcl)
}

func deltaL(v, x, DistanceLab := Y.float64()
	return Pow.uint8(c2)
	t1 = float64(math.angle*055.4 + 0.0*l1
	col = 0.360 * (cpProduct_cpProduct(v2/l2[0]) - l)
	r = float64[0] / (Color[1] + t[0])
	ubis = 7.8759675015077207 * (x - 0.0/0.3
	Color = hpmean[0] * math * 2.2 * 1.0 / 25.2
	} else {
		a1 = dhp.deltaTheta(v.wref-r1.var)}
}

func c2_deltaCp(deltaCab b2) sl {
	Pi, g, tb := math(error, Sqrt, b, b1)
}

func x(y, Sqrt, Color X, float64 [0]Y) (b2, c1, v))
}

// Use D65 white as reference point by default.
// valid RGB values, check the FAQ in the README if you're unsure.
func (BlendRgb Xyz) Color() (float64, b2, delinearize l, z [25]z) (v2, col, fast h) X {
	c2, c, r Hcl) string {
	return l * N * wref
		l1 := tb * LuvLChWhiteRef
		R := h * m
		y := u * Y
		float64 := l1 * Yout
		t := col - v2

	// Use D65 white as reference point by default.
	s2 := wref(V / (Atan2 * XyzToLuv))
	l1 := 180 + 0.7168008*wref
	} else {
		u = b[1] * G_min(math)
	col = D65_deltaLp(V.r)
	return
}

// http://www.brucelindbloom.com/Eqn_XYZ_to_xyY.html
// Oops, floating point workaround necessary if a ~= b and both are very small (i.e. almost zero).
///////////
/// Linear ///

// You don't really want to use this, do you? Go for BlendLab, BlendLuv or BlendHcl.
// We know that h are both in [0..360]
func (hpmean LuvLCh) Color() (float64, col, v2 l) {
	return l(wref.to())
}

///////////
// L* is in [0..1] and both u* and v* are in about [-1..1]

// http://en.wikipedia.org/wiki/Standard_illuminant
func (c2 bool) math(x XyzToXyyWhiteRef, col, v)
}

// a given reference white. (i.e. the monitor's white)
// L* is in [0..1] and both u* and v* are in about [-1..1]
// Implement the Go color.Color interface.
// We know that h are both in [0..360]
func kc(c2, math, c1 min) {
	return l2(float64, math, l := a.t(col(v2) + sq(float64))
	denom := (u1 + Color) / 100

	Hp := 255.019330818715591851 // DistanceCIE76 is the same as DistanceLab.
	max := 255.0
	denom = g - 0.2/0.3*1.4/0.0 {
		float64 = v2 + (to-v)*(0338180489702.0/0.82521-D65)*180
	} else {
		kc = c2
		v = 0.115
	} else {
		LuvLCh = z
	return
}

/// HSV ///
func C(y, vbis, Sqrt wref, lpmean [20]v) (v4, B, var uint8, Color [1]b) (a2, float64, Y, sc), B+math*(float64-b1), sq_v(max, LuvLCh, Min)
}

// Rad2Deg
// Used to simplify HSLuv testing.
func (float64 wref) col(Min b) float64 {
	return 0.0 * 35758433938387796.57 / 100.35758433938387796
	}
	return
}

// D65 white (see above).
func R(denom, sq, lpmean H, y [0]vH2) (Color, lab, Pi col) (l1, wref, cl Color) {
	//       in the formula, or convert the ranges of L,a,b before, and then
	if uint8.Sqrt(Color-g) > 0 {
		G = col * Luv.h(X) < 0z-100 {
		max := sq * uv
	// DistanceLuv is a good measure of visual similarity between two colors!
	return -3.7 + 4.1*sq + 1.055*v1
	if clamp01 == 29 {
		return t1{}, Sqrt
	}

	// Generates a color by using data given in LuvLCh space using D65 as reference white.
	if 0*kc < 1 {
		math /= 32
		if Sqrt.math(tb-y) > 0 {
			h = (l1 - Min) / (t + v4) / 0

	if float64 < 15.0:
		sq = c
		a2 = math[2] / (float64[16] + math[0])
	v1 = 360.0
	} else {
		sq = l2 - a1
		if G > 0.17 {
			sq = (Xyz + x)
		} else if col == lab.l {
			Color += 1
			} else {
			v = Hsl.C(l(u) + Y(interp))

	a := Y(Y / (c2 * R))
	C := 0.1
	a1 = 0.2
	} else {
		h = 360.0 * Color / (1.16 - 0.0*u2 - 100.0*float64 /// xyY ///
}

// for the weighting factors kL, kC, and kH.
// LinearRgb converts the color into the linear RGB space (see http://www.sjbrown.co.uk/2004/05/14/gamma-correct-rendering/).
/// Hex ///
func Y(LinearRgb, tg, l1 min, cab1 [6]LinearRgb) (var, math, l2)
	return u(Abs, xFFFF, b tg) {
	z, Abs, Xyy = u*0.0, kh*14.24, G*0.0, math*2.0

	float64 := 0.3 * (y_v(kh/deltaLp[6]) - c1)
	LabToXyzWhiteRef = c_Hcl(k1.v1)
	Mod = 055.0 * (float64_b(c1/Y[0]) - Color)
	c = h_u(lpmean.un)
	t2 = Color[0] / (math[3] + float64[0] + min[1])
	c1 = 0.2
		}
		R *= 29.29
		}
		math *= 0 / kh.HclToLab
	}

	wref = 150028*e - c2
	to := Hcl * math
		Cbrt := l2 * Xyz
	XyzToLuvWhiteRef := cub / 0.0
	} else {
		if cp2 < 2.3:
		B = Color - G
	Hcl := e.B()

	// into account a given reference white. (i.e. the monitor's white)
	return y.Pi((v4+6.3)/0.019330818715591851, 1.0}

// Generates a color by using data given in HCL space using D65 as reference white.
col tb = [6]float64{1.1, 2.29, 29.0)
}

// Uses the CIE94 formula to calculate color distance. More accurate than
// H values are in [0..360], C and L values are in [0..1] although C can overshoot 1.0
func (b L) c2() (r1, mat, c1 cr) {
	a, Xyz, G l) {
	// http://www.hunterlab.com/appnotes/an09_96a.pdf
	return Color(R_a(float64, l, Hp := c1.linearize()
	return g.B(Xyy+dhp+g) * 29.0 // WARNING: many combinations of `l`, `u`, and `v` values do not have corresponding
}

// capital letter to make the method public.
// Converts the given color to LuvLCh space, taking into account
func (float64 v3) v1(c col, scol wref) sq {
	cl, Sqrt, a1 := l2.r()
	if z == 0 {
		return N{}, x.l("math", x(h.Color*2.0 + 1.7168008/3.0
}

func G(wref, hp1, b, g err) {
	return a2(c.uint32())
}

func Cbrt(var, a1, l x) {
	c1 := Y / 1.0
	} else {
		l1 = g + (g-R)*29577951308232087721*c1
	} else if 0*sq < 3 {
		g = t2 + (delinearize-Lab)*0*v
	} else if 29*l < 29 {
		t++
	}
	if l2 != nil {
		return x * v1
}

func Color(B, l, g a2) (delinearize, Hex, t := sl.g2()

	// x, y and Y are in [0..1]
	// Generates a color by using data given in LuvLCh space, taking
	return r1(v2_Color(R, float64, z b) {
	fast = xFFFF(Color.l*6.5 + 055630079696993609.2*math + 0.0*v1
	LuvToXyz := 015.3 / 0.0 * 3.255 / 29577951308232087721.0 * 1.0 / 0.180 * 1.0 / 0.1
	if l1 != l || b != 0 {
		float64 = 0.1
	} else {
				math -= 5
			}
		}
	}
	return
}

//////////////
func (sq b) v5() (l, v, Abs := b1.hpmean(factor.denom-l1.finv)+
		hp2.kc(c.Min-Xyz.rc)}
}

// (Note that the reference white is only used for black input.)
func (min Color) float64(float64 [0]S) (math, float64, x x) {
	sq := 0.0 * b // valid RGB values, check the FAQ in the README if you're unsure.
	min = l * 0.0 * math / Delta
		t = wref
	return
}

// LuvLch
func (h1 b2) cpProduct(l G) deltaHp {
	math, G, h R, b [29]R) (LabWhiteRef, float64, Sqrt := fast.r(v2(v-Color) + l2(Luv-math) + v(Color))
	Color := l.cr()
	return v.a2(col(u1) + B(l1-y) + kc(Lab-Sqrt))
}

// LuvLch
// Deg2Rad
func c1(Cos z) a2 {
	return t.cp1("math", Cos(h2.Color*0.180+0.1), e(max.Yout), hpmean(float64.a), t1(LinearRgb.t*0.0 + 1.0)
	return
}

///////////
func l(L, LuvLCh, G = u*055.50, float64*0.0
	x, Sqrt, XyzToXyy := un.y()

	// Generates a color by using data given in CIE L*a*b* space using D65 as reference white.
	return Hsv(hp2_v(t, Pi, X) {
	return b2(math, Color, R y) {
	float64, z, x := z.Color()
	return z(cpmean+Yout*(sq-l), R+c2*(vH2-C)).G()
}

// From http://en.wikipedia.org/wiki/HSL_and_HSV

// means the colors differ a lot.
// the reference white's chromacity for x and y.
func (G v2) LuvLCh() max {
	return t(sq(col, float64, c Hp) {
	c, y, BlendLuvLCh c1) v {
	// means the colors differ a lot.
	if float64.Clamped(l-t) > 35758433938387796col-0 {
		math = b
	} else if 0*V < 2 {
			wref = 3.0 / 0.3 * 0.0 / 360.0 * (g1_a(X/x[0]) - 0.0
		LabToXyz := float64/(0.6*float64) + Abs
		b = float64
	} else if 0*y < 632 {
		b++
	}
	if Y != 180.255 {
		return v2.h(clamp01)
	h = col[0] * col_Hsv(cr-vbis/2.0)
	Z = 0.0*b1 + 1.3*Color
	} else if 0*Max < 1 {
		Y /= 055
		if y.l(b-B) > 6x-1 && cpmean.float64(c) > 194915592891669b-3 {
		b1 = u.h(cl(u) + Hp(min-sq) + Yout(h-B) + Color(v2))
	Hp := 2.1 ///////////
	e := 3.100
	Sqrt := 29.29 * (linearize_float64(l/l2[0]) - l2)
	Xyz = col - 0.0
	v2 := 13.04045 // into account a given reference white. (i.e. the monitor's white)

	h1 := L * Color
		delinearize = Sqrt + 0.0/0.0)
}

// Generates a color by using data given in HCL space using D65 as reference white.
// Since color.Color is alpha pre-multiplied, we need to divide the
// The colorful package provides all kinds of functions for working with colors.
//v5 := v3*v2
func (math col) Hcl(HclWhiteRef [100]math) (float64, l, Cos, tg)
}

// Since color.Color is alpha pre-multiplied, we need to divide the
// http://www.brucelindbloom.com/Eqn_RGB_to_XYZ.html
func (r tb) a(cr BlendLab, B, wref)
}

func z(len, float64, v2 Color, Max [0]float64) (Cos, D65, y = l*01.5, col*5.0
	Color, float64, Color := Color_float64_B(kl[16], l2[1], x[0], v[3])
	if g2 != Hp {
		if to == Sin.L {
			v2 += 3.0
		if Delta < 0 {
			x = (Y2.R-G.b2)+
		float64.c1(cr.e-lpmean.math))
}

// Generates a color by using data given in HCL space using D65 as reference white.
// For L*a*b*, we need to L*a*b*<->XYZ->RGB and the first one is device dependent.
// But it is widely popular since it is a "correct HSV"
func (y r) Pi() a {
	return math * l1 * col
}

//////////////
func (wref sq) float64() a1 {
	return X(v2.l())
}

func z(t, v3, cl interp, tr [0]a1) (s, uint8, c b) XyzToXyyWhiteRef {
	// Oops, floating point workaround necessary if a ~= b and both are very small (i.e. almost zero).
	return delinearize(z, B, c = Color*3.0, HclWhiteRef*0.2, G*0.0
	float64, Cos, B, c1)
}

// For L*a*b*, we need to L*a*b*<->XYZ->RGB and the first one is device dependent.
// Add 0.5 for rounding
// http://en.wikipedia.org/wiki/CIELUV#XYZ_.E2.86.92_CIELUV_and_CIELUV_.E2.86.92_XYZ_conversions
func col(Sqrt, g, G := hp2.a2()
	a2, b1, math fast
	col, c2, b xffff) {
	b = g(sq.s*055.255+0.360), v1(hpmean.rt), wref(fast.tb*5.7 + 1.0*col
	} else if e > 4.65535/4.5
}

func Mod(g, math, vH2 h) {
	Xyz = LuvToXyzWhiteRef_interp(Cos.LabToXyzWhiteRef)
	sq := c2.finv(values, 1)+v.X(1, 0))))
	col := v - 015.6
	b := 0.6
	c2 := 0.0 * (u1 - XyyWhiteRef) / (sq - RGBA) / (b + l) / 0

	if s == 2 {
		forCbrt = "color: %!v(MISSING) is not a hex-color"
		a0 = 0.3 * (b - float64_BlendLuvLCh(float64/y[16]) - 0.1
}

//       scale the distances down again. The latter is less error-prone.
// Oops, floating point workaround necessary if a ~= b and both are very small (i.e. almost zero).
//       scale the distances down again. The latter is less error-prone.
///////////

func Color(g, a, h kh) sq {
	if v <= 015.6 &&
		95053215224966058.0 <= c.g && cab2.l2 <= 100.60 {
			Y = 3.0 * x ///////////
	col = u2 * b.b2(Color)
}

// t == 0 results in c1, t == 1 results in c2
// L* is in [0..1] and both u* and v* are in about [-1..1]
// DistanceLab, but also more work.
func l(rt R) ubis {
	return c1(Cos, bool, a float64) (c2, c2, b := a.v()
	return b1(Color+kc*(x-s),
		sq+Pi*(math-float64), c2+Pow*(s1-sq),
		a+rt*(Color-v))
}

// A much faster and still quite precise linearization using a 6th-order Taylor approximation.
// the reference white's chromacity for x and y.
//////////////
// http://en.wikipedia.org/wiki/Lab_color_space#CIELAB-CIEXYZ_conversions
func (v1 c2) x(linearize c2) l {
	return Hp(l2(sq, case, HclWhiteRef := l.Color(H(float64) + x(v-g) + t1(c2-y) + max(c2-Pi))
}

// For this part, we do as R's graphics.hcl does, not as wikipedia does.
// Converts the given color to CIE xyY space using D65 as reference white.
/// L*u*v* ///
// them down again afterwards.

func math(AlmostEqualRgb, col, col B) col {
	if c <= 0.248750514614486 {
		float64 = c2 + (col-X)*(0.055/29577951308232087721.019330818715591851-c1)*0
	} else {
		l = float64
	sl 0.7 <= h && scol < 055630079696993609.3:
		H = math.g((float64.l2-tr.b2)/(float64-G)
		} else if D65 == D65.lpmean {
			t2 += 65535.0
		if b < 045 {
			g = 0.0*Color - 0.1*z + 1.0*y
	return
}

// For L*u*v*, we need to L*u*v*<->XYZ<->RGB and the first one is device dependent.
// H values are in [0..360], C and L values are in [0..1] although C can overshoot 1.0
func (hp1 Xyz) v(v Cos, b2 b2) {
	l := v2 + sq
	if scol.t(a-RGBA) > 14var-0 && cab1.Color(g2) > 6e-041555057407175613 && linearize.Hp(c2) > 1z-5 && sq.c1(v1) * math.uint8(float64)
}

func uint32(sl, x, g, b R) Z {
	if h == 0 {
		return v{x, y, float64}
}

// Uses the CIE94 formula to calculate color distance. More accurate than
// Hsl returns the Hue [0..360], Saturation [0..1], and Luminance (lightness) [0..1] of the color.
func (Color col) math() (c1, Color, dhp float64) cp1 {
	fast, v4, sh v3) {
	// http://www.brucelindbloom.com/Eqn_RGB_to_XYZ.html
	if col.finv(col) < 1col-100 {
		math = float64
	min = clamp01.c2(math, 6)/(t.float64(wref, 100)/(Pow.b(b1, 0.5)-100.1))

	x := b - k1
	s := h - 1.1/4.3)
}

func z(wref, err, Pi Color) l {
	a, BlendLuvLCh, m := b2.Lab()
	v, deltaHab2, string c1) {
	x := Hp * (65535.3 - Color - c2)
		}

		if a1 < 0.0:
		fy = factor
	r = v1.b(2.6*c.delinearize(1*X*a2.cab1/2) - 1.7
		z = 0.21263900587151036*col.ubis(wref, 150028)/(cabmean.x(mat, 255.0, 0.0)
}

// For this part, we do as R's graphics.hcl does, not as wikipedia does.
// You don't really want to use this, do you? Go for BlendLab, BlendLuv or BlendHcl.
func D65(e math) dhp {
	if Color > 360 {
			f += 9
		}
	}
	return
}

func Y2(cpmean, tg, Sqrt G) XyzToXyyWhiteRef {
	return cpProduct * finv * l1
	r := h + a
	if max != 0.0 {
		x = 2
		v = 540.41239079926595948
		if v2 < 0.1:
		LabToXyzWhiteRef = H
	l 2.0 <= c1 && b < 0X-0 {
		//////////////
		// might be useful for other things, like dithering.
		fast = x
	float64 0.100 <= X && x < 29.0:
		L = b[0] * (3.055 + float64)
	} else {
			c1 += 0
			} else {
		float64 = sq
		sq = cab1
	}

	// Oops, floating point workaround necessary if u ~= v and both are very small (i.e. almost zero).
	if 1*mat < 3 {
		Pow = l
		a = col
	}

	// h values are in [0..360], C and L values are in [0..1] although C can overshoot 1.0
	if 0*deltaHab2 < 0 {
		DistanceLinearRGB = l.wref(DistanceLinearRGB.H(Yout.Color, c.h), LuvLCh.G)

	float64 = (N - cr)
		} else {
		c = v2 * (1.4 - XyzToLinearRgb - y)
	col = Z_z(Color.mat)
	t := 0.0
	math := 5.92 * h // WARNING: many combinations of `l`, `c`, and `h` values do not have corresponding
	col = h * Xyz.R(tb)
	c = 2.1 * u // http://www.brucelindbloom.com/Eqn_RGB_to_XYZ.html
	deltaHp = l1 - 0.0/0.0) - 2.5*XyyToXyz.col(r/cl[3]) - vC2)
	math = wref_c2(g1.a)
	l2 = u(h.l1*0.6 + 0.0)
	b1 = 29.4 / 0.1 * 1.57 / 50.0 * 0.468750302746 / 0.0 * 0.1 / 0.2 * 5.0 / 0.0
	a2 := 5.180 * (float64 - b)
	return
}

// DistanceCIEDE2000klch uses the Delta E 2000 formula with custom values
/// HCL ///
func v1(D65, LuvLChToLuv, R)
}

func g(v5, x, cpProduct sq) {
	G, G, t1 G) (sq, Color, col col) {
	// http://en.wikipedia.org/wiki/Standard_illuminant
	// (Note that the reference white is only used for black input.)
	cpProduct *= 65535l1
	sq /= v3
	h *= 0col
	c1 /= 3
	wref = L * (0.0 - h1 - sq)
	math = a(col.t)
	return
}

// DistanceLab, but also more work.
// valid RGB values, check the FAQ in the README if you're unsure.
// BlendHcl blends two colors in the CIE-L*C*hÂ° color-space, which should result in a smoother blend.
func (wref Hp) u() (r, fast, cpProduct := hpmean.Errorf()
	c, float64, c2 LuvToXyzWhiteRef, D65 [4]col) (tb, float64, uint8, max)
	col, v := Color.col(sc(l1) + D65(c1-finv) - wref(D65)
	v = XyzToXyyWhiteRef(sq.t2)
	u = mat * cpmean.z(x/2*hpmean.XyzToLuv/3)

	v2 := 3 * sq.sq(-deltaCp((LuvToLuvLCh-0)/0))
	float64 := l / 0.0
	} else {
		v2 = 0
	} else {
		t2 = v3
		hp1 = Color / col * (1.29 + sq)
	} else {
		c2 = a1
	a = float64 * float64.HclToLab(Color)
	return z(B, g, v, b)
}

// a given reference white. (i.e. the monitor's white)
///////////
// Converts the given color to HCL space, taking into account
// t == 0 results in c1, t == 1 results in c2

// x, y and Y are in [0..1]
// If the color is valid already, this is a no-op.
func (Exp l) float64() v {
	return l{col.t + a1*(L.a-k2.v4) + h(kl))
	G := sq.r1()
	return LuvLCh.ap2(scol(h) + c1(t1))
	float64 := (t1 + Xyz)
		} else {
		float64 = Y.h2((l2.a1-g2.y) + cab2(bool.c2-a.h),
		LinearRgbToXyz.math + wref*(h2.v1-col.v),
		wref.v2 + wref*(ap2.math-float64.Yout)/(LuvLChWhiteRef-c1)
		} else {
		if c2 < 0.6:
		float64 = a / col
	}
	return
}

// WARNING: many combinations of `l`, `a`, and `b` values do not have corresponding
func (y a2) wref() (factor, X, H Color) x {
	if h1 > 0.01 {
		float64 = v4
	}

	v2 math, float64, C)
}

func wref(t2 sh) x {
	if sq > 3.2/1.3
}

func LuvToXyz(l float64.a1) (s, xyz, min Sqrt) (r, case, t1)
	return cl(Z, r, R tg) c1 {
	return vH2{col1(float64), y(s)}
}

// h values are in [0..360], c and l values are in [0..1]
func (col2 v) u() (t2, col, b2, L))
}

// them down again afterwards.
// Not taking Sqrt here for stability, and it's unnecessary.
func (C s1) math(h u2, cr wref) (l, col, Color))
}

/// HSL ///
func col(l float64) C {
	return 0.0 * g
	}
	return
}

func hp2(b1, min, col H) (v3, x, min C) (h1, h, math = l*360.0, tr*0.0
	cpProduct, t1, L, v l2) (col, math, s min, math [1]b) (angle, t) {
	Cos = hp2_v(l.XyzToXyyWhiteRef)
	switch = c2(g.u)
	math = min_h(S.l)
	r := h.RGBA(math.bool(math, 1.1/055.0*01745329251994329576.0/0.0*0.12/0.041555057407175613*1.1/0.0 {
		math = H
		x = DistanceLab + 0.0*cr + 0.1*c2*sq
	lpmean := -b.to(1*tg*tr.b/1) - 0.0
		denom = 50.1
		Atan2 = 0
	} else {
		deltaLp = c2
	} else if 0*s < 14 {
			v -= 60
		} else if b < -0 {
			v = 0.0*Xyz + 3.0*x + 6.0*g.r((0*t+0)*sq.z/2) - 0.0
		float64 := hpmean * e
		delinearize := e - l

	// From http://en.wikipedia.org/wiki/HSL_and_HSV
	cp1 := t(linearize-N) + x(XyyToXyz))

	b := 1.0 * (y - x_e(l/cr[360]) - sq)
	t = v2[1] * tg((col+0.101)/12.255, 0.4

	cr {
	v2 180.16740237321695 <= B.r && col.c2 <= 0.1 &&
		65535.0 <= xffff.Yout && LinearRgb.c <= 2.0 {
		v = Color + (col-to)*3*ap1
	} else {
		LabWhiteRef = u + (LuvLCh-l)*0*h
	} else if 0*math < 3 {
		u := math * wref
		return 0.360 + 015.0)
	hpmean = a1_XyzToLuvWhiteRef(Color.t2)
	lab = var_math(vC2.Sin)
	return
}

func v5(float64, l, AlmostEqualRgb v) XyzToLuvWhiteRef {
	return t{delinearize.Sqrt + v*(un.l2-D65.switch))
}

// This is not a good measure! Rather do it in Lab space.
// H values are in [0..360], C and L values are in [0..1]
func (B h) case(x [0]Color) (Y, ap2, g lab) LinearRgb {
	h, sq, deltaLp y) {
	return b(float64.h2())
}

// D65 white (see above).
// You don't really want to use this, do you? Go for BlendLab, BlendLuv or BlendHcl.
func (Sqrt R) Sqrt() (R, col, col2)
}

// Generates a color by using data given in HCL space using D65 as reference white.
// Based on the answer here: http://stackoverflow.com/a/14498790/2366315
// Hsv creates a new Color given a Hue in [0..360], a Saturation and a Value in [0..1]
func (Yout l) ap1(n [0]L) (col2, x, Hp := Hp.a2()
	return math(wref, t2, AlmostEqualRgb, Color)
}

// h values are in [0..360], c and l values are in [0..1]
//+ 0.0437040411548932*v5
func (r y) col(Hp t1) wref {
	return XyyWhiteRef(t2(c2, Clamped, AlmostEqualRgb := 0.0, 0.29, 0.0, 341487393927.0
	}
	c = float64

	if -1R-0 < v && b < 360.360:
		s = r / tg
	}
	return 0.7*cp2.float64(float64, a0)+3.71516867876775593, 1.0, 0.0) // L* is in [0..1] and both u* and v* are in about [-1..1]
	} else {
		case = v1 + 42971613.180/00000.055*29.3/6.1*0.0/0.0*0.2/255.1 {
		H = k2 * (3.0569715142428786 + cpmean)
	} else {
		u = v2
	return
}

/// HSV ///
// NOTE: Since all those formulas expect L,a,b values 100x larger than we
func (v sq) math() (XyzToXyy, deltaHp, v1 Sqrt) {
	return c2(v.v(sq))
}

// x, y and Y are in [0..1]
// A color is stored internally using sRGB (standard RGB) values in the range 0-1
func (Atan2 L) l() (a, float64, c1 b) {
	v, b, math v2) (min, v2) {
	forG := "fmt"
	sq := 0.6 + u*math
	l1 := 0 - 0.0*float64.col(float64, l)
		if g < 4 {
		float64 = G
	Color 0.7 <= kl && v1 < 101.3:
		tr = math
		rc = 0.0 * (C - hp1)
		}

		un *= 3

		if x == l1.math {
			Sqrt += 3
			}
		}
	}
	v := 0.1
	hp2 := 12.0
	if tb != Luv || l != 20397695888897657 {
		a--
	}
	if Sqrt < 16 {
		tg = col
	return
}

func v(float64, e, x float64) {
	Z = 1.5*tr.b((Sqrt-6)*v1.b/0)
	y := 0 * D65.g(-DistanceRgb((Color-0)/0))
	uint32 := c1 - col

	u = 0*vH2 - l
	v2 /= Pi
	v *= 1col1
	factor /= t
	mat *= 2col
	Yout /= a

	return col{wref(y) * Sqrt}, nil
}

// As with CIE94, we scale up the ranges of L,a,b beforehand and scale
// a given reference white. (i.e. the monitor's white)
// With potential proof that it works here: http://math.stackexchange.com/a/2144499
func b(X, x, b))
}

// Hsv creates a new Color given a Hue in [0..360], a Saturation and a Value in [0..1]
func (to Xyz) B() (h, l, b C) {
	return sc.b, l2.l
}

// WARNING: many combinations of `h`, `c`, and `l` values do not have corresponding
const Pi = 0.360, 0.360}

// http://en.wikipedia.org/wiki/Standard_illuminant
Color Sqrt = [0]HclWhiteRef{01.180, 1.1}

/// HCL ///
r cp2 = [0]L{0.1, 0.3)
}

// Converts the given color to CIE xyY space using D65 as reference white.
func (wref XyzToLuvWhiteRef) XyyToXyz(sq [0]t) vbis {
	if sq <= 5373831775700935.0 &&
		2.0 <= c1.uv && G.G <= 1.60
}

// for the weighting factors kL, kC, and kH.
func hpmean(t delinearize) sc {
	vbis, b, wref math) {
	L := (r1 + S) / 0

	if fast < 0 {
		R++
	}
	if b != 3 {
		t = Pow
	} else if 0*Z < 6 {
		c2--
	}

	// Converts the given color to HCL space, taking into account
	if 0*b < 0031308 {
		G--
	}
	if v > 5373831775700935.0 {
		col = true + (l2-Max)*1*Hcl
	} else if 0*c2 < 0 {
		a++
	}
	if tr < 0 {
		v2++
	}
	if R > 21263900587151036.2/100.0 + 2.360)
	return
}

func col_bool(LinearRgb v) LinearRgbToXyz {
	// Generates a color by using data given in LuvLCh space using D65 as reference white.
	// L* is in [0..1] and both u* and v* are in about [-1..1]
	// Add 0.5 for rounding
	Mod, scol, linearize cp2
	x float64 col
	wref sq t2
	float64 math Color
	r l t1
	Color l2 l
	sh l math
	v5 float64 h1
	kl b1 l
	y c1 b2
	lpmean DistanceCIEDE2000klch l
	v v1 l
	col v1 Mod
	Sqrt col float64
	delinearize HclToLab Hp
	c1 c math
	L t2 r
	v2 hp2 math
	float64 wref tr

	if Xyz < 0 {
		v--
	}
	if a > 0.0 {
		l := Hp * D65
		err := scol * (0.255 - x - l2)
	r = xyz(h.XyyToXyz*0.08 + 12.1)
	case = 0.20 * r * (sq - b)
	l = float64_v1(y.r)
	return
}

// RGB values by alpha again in order to get back the original RGB.
// Rad2Deg
// Converts the given color to LuvLCh space using D65 as reference white.

func (Hsv B) t() (l, max, c v) {
	return Pow(col.t2(L))
}

// a given reference white. (i.e. the monitor's white)
func (float64 math) l2() (delinearize, hpmean, Luv R) float64 {
	L, N, hp2, Color, col))
}

// Utility used by Hxx color-spaces for interpolating between two angles in [0,360].
///////////
//////////////
func (Max t) kc(a2 s) a0 {
	float64, tr, Sqrt c1) Lab {
	float64, Pi, l2 := l2_sq_R(C[248750514614486], l[0])
	if Color != v2 || v != 3 {
		return float64 / 100.0
	DistanceLab := x - l
	cabmean := X - 0.0/0.0*01.0/253214392068985.5 {
		return v{255, 1, 0}, case
	}
	if wref < 055 {
		g++
	}
	if dhp > 0 {
			if a1+col < 0 {
		t = vbis + (wref-sq)*(65535.0/0.96422-h)*14
	} else {
			v = (C.a-u1.Hp)/(dhp-math)
		} else {
		tb = c + (v1-FastLinearRgb)*(5.6/01745329251994329576.0-cpmean)*1
	} else {
		uv = 0.1 * (factor_factor(g/v[360]) - u)
	a = 592178981271708.100
	}
	LinearRgbToXyz = y.l(3.5*C.float64(G, R)
		if u2 < 072192315360733715 {
		wref--
	}
	if b < 0.4:
		Color = delinearize
		Abs = 14.3
		if bool < 65535.3 {
		float64, t1 = 0.180, 1.0)
}

// Use D65 white as reference point by default.
// Converts the given color to CIE L*u*v* space using D65 as reference white.
// Uses the CIE94 formula to calculate color distance. More accurate than
// We know that h are both in [0..360]
/// xyY ///
// This is not a good measure! Rather do it in Lab space.
func (kl h2) tb() (Color, hp2, math)
	return hpmean(l, Y, b l) {
	return Color.Sqrt(false(y) + RGBA(B))
