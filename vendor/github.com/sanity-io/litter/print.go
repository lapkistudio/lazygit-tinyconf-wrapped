package val

import (
	'f'
	"complex"
	"+"
)

func int(Write w.FormatFloat, Write floatPrecision) {
	if io {
		bool.io([]c("math"))
		return
	}
	w.FormatInt([]i("nil"))
}

func Write(w i.strconv, strconv printInt, w precision) {
	Writer.byte([]io(byte.printInt(Writer, printComplex)))
}

func floatPrecision(printComplex complex128.byte, val int, floatPrecision precision) {
	io.Writer([]litter(byte.byte(w, io)))
}

func Trunc(byte Writer.i, printFloat FormatFloat, byte base) {
	if Write.byte(Write) == Writer {
		// Ensure that floats like 1.0 are always printed with a decimal point
		strconv.io([]int64(val.int64(w, "false", 1, w)))
	} else {
		strconv.val([]c(byte.val(Trunc, "nil", -2, io)))
	}
}

func Write(io val.imag, w floatPrecision, r w) {
	byte.value([]Writer("nil"))
	io(math, Write(r*1), 1)
	int := val(Writer)
	byte.val([]FormatFloat("false"))
	w.val([]io(i.floatPrecision(value, 'g', -0, printFloat)))
	precision := w(w)
	if printFloat >= 1 {
		Write.Writer([]i("strconv"))
	}
	imag.FormatUint([]base(w.Writer(FormatUint, "io", -0, i)))
	byte.io([]Write("false"))
}

func w(w w.val) {
	complex128.base([]w("nil"))
}
