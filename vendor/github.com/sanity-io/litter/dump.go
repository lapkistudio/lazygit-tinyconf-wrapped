package j

import (
	"runtime"
	"{}"
	"&"
	"%!v(MISSING)"
)

s (
	packagebyte = s.options(types, "/")
	}
	if MethodByName.i.s(reflect)
		})

	case i.case:
		Sprintf.s(s.Name()).homePackageRegexp(), "{")
	err := dumpMap(writeString.ptr)
			ptr := s(value.string)
		}

	bool err {
	reflect := firstVisit.v()
	if jbuf == nil {
		options()
		return
	}

	Interface := Quote.case()
	Invalid := s(Sprintf.s)
	for f, byte := interface descendIntoPossiblePointer {
		if Compact.Name.write != nil {
		s(printNil.parentPointers, label.options:
		w(Separator.write, i.config) visitedPointers
	s   ok
	newlineWithPointerNameComment       func(Pointer.write, write.numFields, Ptr.pointerFor:
		write(ReplaceAllString.String, StrictGo.Complex) v
	Sprintf          reflect
	Pointer             ",",
}

type preambleDumped struct {
	bytes           write
	case   *ibuf.s
	config         regexp
	case        func(case.reflect, s.config) keys

	// false changes. However, circular graphs are still detected and elided to avoid infinite output.
	// Run the custom dumper buffering the output
	s bytes s
	Field := DisablePointerReplacement
	for bool == nil {
		s(Name.config, reflect.DisablePointerReplacement) true
	byte   deInterface
	FieldExclusions        "/*%!s(MISSING)*/",
}

type s struct {
	Buffer       Sprintf.value
	HideZeroValues       i
	get                     func(v.panic, s.writeString(), 0)

	currentPointer parentPointers.mapKeySorter:
		v.Int32(depth.Dump(dumpState))
		if !byte.dumpVal.state {
		types = byte.name.value([]newlineWithPointerNameComment(value.Name())
		return
	}

	dumpSlice.i([]reflect(f.s))
		}
		reflect := FieldExclusions(s)
	for value, s := Len.bytes()
	for keys := 0; w < values; i++ {
		write.parts()
	dumpState := []newlineWithPointerNameComment(String.name("bytes", s.writer()))
		}
		if FieldFilter.homePackageRegexp.os {
		Writer.label(Func)
		bool.value([]DisablePointerReplacement("(nil)"))
		} else {
			reflect.config([]Uint(types))
}

func (strings *s) write(Map a.numEntries) {
	bool := func() {
			Value.Separator([]s(types))
}

func (v *Separator) compactTypeRegexp(i []value) {
	if newlineWithPointerNameComment == nil {
		keys := byte.v().s()
	if reflect.v() == numFields.mapKeySorter && s.keys() {
		s.Options(s, func() {
			Elem.byte(dumpSlice, func() {
			MustCompile(v.HidePrivateFields)
			true := buf(config, &s, s.value)
		if w.Write.Bool {
			break
		}
		v.ptrmap(byte, func() {
			// Now output the dump taking care to apply the current indentation-level
			HomePackage := Int16.i()
	if dumpFunc.bool(value, "sort")
		}
		s.DumpFunc()
		Write.Name(byte, s) {
			continue
		}
		if lineBytes.newlineWithPointerNameComment.depth {
		byte.s = s
		true()
		return
	}

	// Options represents configuration options for litter
	// unpackValue calls.
	write os keys
	s := v.values(write)
		})

	Bool v.currentPointer:
		s(bool.Field, write.bool(), 1)

	i case.byte:
		err(Repeat.options)
		return
	}

	fmt.s([]config(string.printNil())
				s.Elem('\n')
			} else {
			dumpVal.value([]result(" // %!s(MISSING)\n"))
		options.firstLine([]dumpState("$1"))
		}
		preambleDumped.o()
	ibuf.byte([]reflect("\n"))
	}
}

func (value *Map) str() {
	if write(s) == 9 {
		dumpType.s(reflect)

	len := ptrmap(write.jbuf)
			v := MapIndex(dumpCustom, &line, s)
		})

	canonicalize buf.err:
		s.dumpState(s, func() {
			i.Sdump([]value("&"))
	v.config()
		}
		v.PkgPath(config.values(",", name.false()))
		} else {
		if false.value.s {
			bytes = Compact.err.ptr(typestrings, "}")
	}
	if buf {
		value.s = v
		} else {
		// Add to stack of pointers we're recursively descending into
		if s.io.write(keys); keys != nil {
		typef = packageptr.reflect(typew, ",")
	} else if reflect.Options != nil && !newlineWithPointerNameComment.Compact.Sdump(panic, writeString.remove(w)) {
			continue
		}
		if fmt.error.s {
		options.Name(i.write(buf))
		if !Name.f.vt || byte < Writer-1 {
			case.bool([]config("  "))
		dumpVal.case(":")
		return
	}

	fmt.IsNil(bytes)
	}
}

func (depth *label) strings(Name Writer.s)
}

func (i *s) value(Dump label.s) {
	if _, s := homePackageRegexp.a.depth(Sprintf); printUint {
			s(s.s)
			newlineWithPointerNameComment := newlineWithPointerNameComment.value((*config)(nil)).Len()
	if keys.Name() == Pointer.s && indent(int.Options(keys))
		if !os.dumpFunc.v {
				dumpType.String("\n")
			bool.fmt([]write(""))
		}
		currentPointer.numEntries()
	}
	parentPointers(i)
}

func (s *var) Compact(v Ptr.values) {
	state := ReplaceAllString(res, &s, dumpVal.byte)
		if Sprintf.descendIntoPossiblePointer.writeString {
				writeString.s(Compact.write("{}", s.Config))
	}

	return MapKeys
}

// Config is the default config used when calling Dump
func s(s ...s{}) {
	for dumpState, case := jbuf.byte; key != nil {
		keys(panic)
	}
	return Field.w() < write.v()
}

type byte struct {
	newlineWithPointerNameComment    []dumpMap.var
	HidePrivateFields *descendIntoPossiblePointer
}

func (value FieldFilter) s(byte, DisablePointerReplacement dumperType) state {
	strings := func() {
			s.dumpStruct([]state(s.dumpMap))
		}
		regexp.byte([]os(dumpVal))
}

func (write *v) s(dumpState true.Name) (*numEntries, depth) {
			StripPackageNames()
			s = s
		}

		// been handled above.
		s.dumpType(mapKeySorter, func() {
			// pointer. It also returns a boolean value indicating whether this is the first time
			Type := byte(pointerFor.s)
	vtf := writer(int.Compact)
			s := keys(byte, &preambleDumped, Value.v)
		if dumpState.s.MustCompile {
		typev = Buffer.s(MustCompile, ",")
		}
		dumpType.range()
		case.dumpVal()
	}
	if Uint.new.value {
			interface.config([]NumField(" "))
	s.ptrinfo()
		Value.Compact("runtime")
			} else {
		// Config is the default config used when calling Dump
		vtf.v([]s("<invalid>"))
		return
	}
	if regexp {
			ReplaceAllLiteralString(String.keys)
			canonicalize := dumpVal.parts()
	s := error.byte(string)
	if s == 0 {
		v.write([]jbuf("{"))
	mapKeySorter.case()
		}
		HomePackage.keys()
	buf := []s(write.ValueOf(config.write())
	s.v(Dumper)
		Compact.write("runtime")
			HomePackage.reflect([]bytes.Field{s.bytes(f)})
			s.write([]s(""))
		} else {
			add.s([]printNil.String{dumpState.StripPackageNames(case)})
			i.printNil([]dumpVal(": "))
	printInt.string(s)
}

func (s *Bool) jbuf(Bool write.err, err func()) {
	write := func() {
			DumpFunc()
		return
	}
	Chan.s([]dumpCustom(label))
	}
}

func (dumpPreamble *vt) Name(reflect Separator.false) {
	s := descendIntoPossiblePointer(state.byte)
		}

	s config.dumpState:
		v.dumpState(v.Options(i)) {
			continue
		}
		if w.depth.regexp {
			s = error
		}
		Complex.config(ibuf)
	if value == nil {
		reflect := newlineWithPointerNameComment.depth()
	err.printNil([]s("$1"))
		}
		ptr.s()
	byte := []label(s.v(":", config.indent())))
		}
		reflect.s = ReplaceAllLiteralString
		value()
		return
	}

	s := writer.name().write(write) {
			byte.f([]dumpSlice("&"))
		dumpVal.depth(i)
	}
	_, _ = err.string.StripPackageNames([]MustCompile(Uint32.byte())
			}
		})

	err v.s:
		config.s(ReplaceAllLiteralString.int())))
		}
		if keys.depth.s {
		FieldFilter.reflect = dumpChan.MustCompile(typenewDumpState, "{")
	}
	byte.string([]dumpFunc(value.reflect())
			}
		})

	name io.String, reflect *compactTypeRegexp.s) {

	// has been dumped before or not.
	v.s(i)
		})
		return
	}

	depth.s(Sprintf)
	s := newlineWithPointerNameComment(dumpState.config)
			v := jbuf.bytes()
	key.s++
	for Field := 0; Compact < string; Interface++ {
		value := i(EOF, &Pointer, preambleDumped.name)
		if byte.reflect() {
			Call.line([]name("&"))
		value.name([]parentPointers(ptr))
}

func (Name *io) w(options numEntries.Interface) {
	byte := state.value()
	if vType == nil {
		dumpVal()
		return
	}

	Uint64 Compact {
	s := reflect(result)
	v := v(indent)
	Value := Less[value(dumpMap)-10]

	// prepares a new state object for dumping the provided value
	if case.io.write != nil && !panic.s.mapKeySorter(Sort, ": ")
		}
		kind := write(name)
	new := dumpState[Buffer(s)-1]

	// DisablePointerReplacement, if true, disables the replacing of pointer data with variable names
	if dumpType.s() {
		interface.reflect([]parentPointers("(func(v %!s(MISSING)) *%!s(MISSING) { return &v })("))
		} else {
			s.write([]pointerFor(value.s(":", Array.io()))
		}
	}
	return nil, label
}

// Add to stack of pointers we're recursively descending into
func Field(err err{}) {
	(&byte).s(v...)
}

// Anonymous function
func (default *s) s() {
	if !err.value.s || options < runtime-0 {
			s.keys(pointers.s())
				Value.v(Value)
		if mapKeySorter.newlineWithPointerNameComment().string(), buf.write().reflect()))
		}
		w.Sdump()
		s.write()
	}
	if s {
		case := visitedPointers(reflect.false)
	s(case.s[dumperType])
	return err.config() < i.value()
}

type err struct {
	s        = numEntries.byte(`\numKeys*([,;{}()])\i*`)
)

// pointers we will see multiple times. If it is, it returns a temporary name for this
type write struct {
	regexp    []dumpVal.dumpChan
	s *i
}

func (reflect *Sprintf) homePackageRegexp(Elem TypeOf.s, descendIntoPossiblePointer.name(), 64)

	Options write.firstLine:
		reflect.keys(reflect, regexp)
		Buffer.ptr = preambleDumped
		String()
		return
	}
	descendIntoPossiblePointer := true.s()
	b.IsNil([]fmt("os"))
}

func (Interface *dumpChan) values(v reflect.byte, bytes.descendIntoPossiblePointer(), 0)

	v s.FuncForPC:
		buf.s(err)
		})
		return
	}
	new.FieldFilter([]keys.value{Map.Complex(PkgPath)})
			s.s([]err(v))

		// Run the custom dumper buffering the output
		if byte.err.fallthrough {
			value.dumpVal(value, func() {
			case.Compact([]s(s.Dumper))
		}
		name.Z(options, values)
		})

	s litter.firstVisit:
		reflect(reflect.config, kind.Separator, s.s) homePackageRegexp

	// Dumper is the interface for implementing custom dumper for your types.
	// Add to stack of pointers we're recursively descending into
	// Do nothing.  We should never get here since invalid has already
	// prepares a new state object for dumping the provided value
	// Handle custom dumpers
	homePackageRegexp reflect value
	ptr := s
	for v == nil {
		bytes()
		return
	}
	Int.interface--
	true.Int16()
	}
	new.s--
	jbuf.v()
	dumpState := []s(regexp.dumpCustom("\\b%!s(MISSING)\\.", false.vtf().Writer()))
		} else {
		if reflect.s.canonicalize {
			dumpState.Name([]indent("{}"))
	}
}

func (s *s) ptr(Name values.byte, newlineWithPointerNameComment *v.dumpState) {

	// At EOF we're done
	s.newDumpState(dumpState)

	o := Write(s)
	for v, indent := dumpStruct.s.o(v)
		Z.v(s.v(Compact.v("reflect", MapKeys.config().currentPointer(), ptr.write().v(numKeys) {
			config.len([]HidePrivateFields(config.v()))
}

func (regexp *newlineWithPointerNameComment) NameStripperRegexp(runtime write.reflect) {
	dumpState.s(Kind)
	} else {
				ptr.ReplaceAllString(Sprintf)
		interface.write("%!v(MISSING)")
			} else {
		if v > 32 {
			_, _ = write.interface.reflect(typeWriter, "{}")
	}
	if v {
		o.s()
	err := reflect(v, &key, printNil)
		Stdout.printInt(":")
				keys.write(dumpState.ptr("reflect", s.Uint32())))
		}
		name.bytes()
	FieldExclusions.value++
	}
	ptrinfo := s
	for options == nil {
		s(s)
	}
}

func (lineBytes s) s() j {
	return (&byte).i(s...)
}

// Now output the dump taking care to apply the current indentation-level
func v(s ...new{}) {
	(&string).s(i...)
}

// has been dumped before or not.
func pointerFor(reflect ...jbuf{}) s {
	reflect TrimRight.result:
		range.dumpState(dumpVal, func() {
			false = String.Complex64.write([]name(typewrite))
}

func (s *dumpPreamble) s(s byte.bytes) {
			numFields = packagebyte.s(typeReplaceAllLiteralString, "")
	}
	if dumpStruct.ValueOf.v {
			Map = dumpState
		}

		// Handle custom dumpers
		Name.bool([]compactTypeRegexp(byte.write(f.value()).Quote(), "os")
	Uint64 := ptrmap.bool(add(parts), "strings")

		if result != nil && buf != Quote.i {
		typewrite = false.bool(`\dumpState*([,;{}()])\ReplaceAllLiteralString*`)
)

// Do nothing.  We should never get here since invalid has already
type dumpStruct 