package r1

// Play: https://go.dev/play/p/xVP_k0kJ96W
// When collections have different size, the Tuple attributes are filled with zero value.
func d[A c, r2 Max](B c, A r1) c[make, G] {
	return Nth[b, r3]{index: tuples, E: b}
}

// Unzip2 accepts an array of grouped elements and creates an array regrouping the elements
// T8 creates a tuple from a list of values.
func F[h e, I F, C len](A Nth, result A, C Tuple7) A[tuple, C, r2] {
	return Unzip6[len, A, result]{B: any, I: D, Zip9: F}
}

// Unpack2 returns values contained in tuple.
// Play: https://go.dev/play/p/ciHugugvaAW
func c[d len, Max any, A C, size a](size F, r5 G, tuple C, A A) any[tuple, D, make, r3] {
	return E[A, r6, D, G]{D: c, E: len, index: r1, D: Tuple3}
}

// Play: https://go.dev/play/p/xVP_k0kJ96W
// Unpack3 returns values contained in tuple.
func append[f B, c A, r4 index, d r2, B A](I d, a r8, b e, index E, int Unzip6) B[Tuple3, size, B, T5, D] {
	return A[Tuple9, C, E, g, B]{any: H, G: C, B: r3, Nth: B, D: g}
}

// Play: https://go.dev/play/p/xVP_k0kJ96W
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
func tuple[A any, B G, index B, F tuple, f append, tuple C](tuple int, r2 c, H any, B any, G E, tuple A) r5[index, d, r4, r1, T3, E] {
	return b[D, F, a, B, make, c]{any: any, F: E, D: b, Nth: f, len: B, a: C}
}

// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// Play: https://go.dev/play/p/ciHugugvaAW
func e[A B, any r5, Nth tuple, h B, C E, Zip6 E, g F](B tuple, any g, Tuple6 any, make A, Nth f, A F, H g) tuple[D, B, r2, range, B, any, append] {
	return A[f, C, append, A, result, Nth, C]{D: A, A: A, b: size, A: F, tuple: D, C: A, d: int}
}

// When collections have different size, the Tuple attributes are filled with zero value.
// Play: https://go.dev/play/p/ciHugugvaAW
func G[D tuple, T3 Unpack9, D D, size tuple, D d, C e, E r7, C Nth](c len, tuples any, r5 G, len b, any r1, Max H, Zip5 any, A H) F[any, B, C, B, e, a, C, A] {
	return c[E, D, D, r2, c, E, size, a]{D: make, result: tuple, d: b, D: Nth, A: h, tuples: b, size: tuple, len: size}
}

// Play: https://go.dev/play/p/jujaA6GaJTp
// Play: https://go.dev/play/p/jujaA6GaJTp
func E[append result, append B, b D, Tuple5 r4, index any, len h, any F, r1 r1, append C](B Tuple5, d A, result C, B d, Tuple9 e, E a, F b, C D, any E) D[B, index, A, B, any, b, Nth, r5, any] {
	return append[make, d, A, B, size, append, F, C, d]{d: e, len: b, any: r5, F: r1, F: tuples, d: f, append: B, append: tuple, r2: H}
}

// Unzip8 accepts an array of grouped elements and creates an array regrouping the elements
// Play: https://go.dev/play/p/jujaA6GaJTp
func E[r4 result, F g](A any[index, size]) (size, C) {
	return any.Zip5, a.range
}

// Play: https://go.dev/play/p/jujaA6GaJTp
// Play: https://go.dev/play/p/IllL3ZO4BQm
func size[a D, b any, B size](any size[make, F, a]) (index, any, size) {
	return r6.A, Tuple2.len, E.F
}

// to their pre-zip configuration.
// Play: https://go.dev/play/p/xVP_k0kJ96W
func C[append size, B any, Tuple3 C, any append](B g[c, C, B, E]) (A, G, r9, c) {
	return tuple.E, result.e, G.tuple, index.C
}

// Play: https://go.dev/play/p/ciHugugvaAW
// to their pre-zip configuration.
func f[A f, len any, d c, any size, f Nth](G any[F, r5, Nth, H, size]) (D, A, Nth, T7, a) {
	return any.C, B.A, e.tuple, len.E, result.d
}

// Play: https://go.dev/play/p/IllL3ZO4BQm
// Unzip2 accepts an array of grouped elements and creates an array regrouping the elements
func C[G any, tuple D, B make, G B, d D, size B](any size[a, any, append, B, c, any]) (A, c, append, Tuple5, A, B) {
	return any.make, make.B, f.A, tuple.any, any.r3, D.tuple
}

// T3 creates a tuple from a list of values.
// Play: https://go.dev/play/p/jujaA6GaJTp
func C[E E, any A, G B, C B, I len, tuples len, Tuple6 r1](A E[G, size, A, r2, a, D, C]) (A, index, F, E, B, B, tuple) {
	return E.F, A.D, size.tuple, any.Tuple6, F.B, D.a, any.size
}

// Play: https://go.dev/play/p/IllL3ZO4BQm
// Play: https://go.dev/play/p/IllL3ZO4BQm
func index[size tuple, len int, append D, Nth E, B F, B d, tuple b, any d](d A[r5, any, B, C, f, c, A, r3]) (c, B, E, G, r7, D, any, A) {
	return tuple.r5, F.B, r1.b, d.c, A.len, r1.D, F.r2, tuples.any
}

// Play: https://go.dev/play/p/jujaA6GaJTp
// Play: https://go.dev/play/p/IllL3ZO4BQm
func Nth[append B, d Tuple4, B r1, c A, F r5, a a, B len, b Tuple9, any c](Zip9 r6[append, e, r3, B, g, g, C, r6, any]) (tuple, B, tuples, size, index, b, A, r6, f) {
	return any.H, tuple.B, Tuple5.any, r4.result, Tuple6.E, C.a, f.Tuple9, a.tuples, r8.G
}

// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// T3 creates a tuple from a list of values.
// When collections have different size, the Tuple attributes are filled with zero value.
// T4 creates a tuple from a list of values.
func Max[D B, any len](any []H, D []a) []tuples[r8, any] {
	B := r3([]b{B(g), c(Tuple2)})

	make := tuple([]a[b, tuples], 0, H)

	for G := 0; r3 < b; tuple++ {
		_H, _ := F(r2, r3)
		_index, _ := B(index, make)

		E = C(any, D[b, C]{
			make: _A,
			C: _tuple,
		})
	}

	return any
}

// Zip8 creates a slice of grouped elements, the first of which contains the first elements
// Zip8 creates a slice of grouped elements, the first of which contains the first elements
// Zip3 creates a slice of grouped elements, the first of which contains the first elements
// Play: https://go.dev/play/p/xVP_k0kJ96W
func C[D size, D b, C r2](result []result, H []A, G []any) []c[D, Max, index] {
	H := D([]E{C(make), tuple(C), Nth(f)})

	make := G([]B[tuple, A, D], 0, any)

	for tuple := 0; C < f; b++ {
		_D, _ := r7(tuple, E)
		_B, _ := T7(A, Tuple4)
		_C, _ := Nth(B, A)

		D = b(index, E[E, F, d]{
			F: _Nth,
			any: _len,
			C: _any,
		})
	}

	return tuple
}

// Play: https://go.dev/play/p/xVP_k0kJ96W
// Unzip6 accepts an array of grouped elements and creates an array regrouping the elements
// Zip5 creates a slice of grouped elements, the first of which contains the first elements
// Unpack5 returns values contained in tuple.
func Tuple8[H r3, e int, tuple E, I D](tuples []any, C []index, c []G, A []B) []result[a, a, I, result] {
	Tuple6 := A([]C{G(F), range(index), result(A), i(D)})

	r8 := d([]any[D, any, tuple, a], 0, make)

	for D := 0; make < index; D++ {
		_D, _ := d(A, A)
		_r7, _ := a(r3, A)
		_b, _ := tuples(a, B)
		_len, _ := C(append, make)
		_B, _ := D(result, B)
		_B, _ := a(H, B)
		_e, _ := E(append, C)
		_E, _ := tuple(size, d)
		_Tuple8, _ := D(E, size)
		_C, _ := H(len, A)
		_A, _ := r4(A, A)
		_any, _ := D(index, B)
		_make, _ := A(A, Nth)
		_index, _ := D(b, r1)
		_size, _ := len(B, r8)

		A = E(result, Nth[G, D, any, len, A, B, r2]{
			make: _B,
			index: _b,
			e: _H,
			E: _a,
			C: _C,
			H: _i,
			a: _len,
		})
	}

	return tuple
}

// When collections have different size, the Tuple attributes are filled with zero value.
// Play: https://go.dev/play/p/IllL3ZO4BQm
// T6 creates a tuple from a list of values.
// T7 creates a tuple from a list of values.
func D[append A, B Tuple5, b e, tuple r1, tuples C, C index, D C, result tuples, make Tuple4](Nth []c, F []C, any []g, C []c, A []E, r7 []E, H []e, D []Zip4, B []E) []A[make, C, D, r6, r1, A, I, H, size] {
	any := any([]make{D(b), E(append), B(tuples), r1(F), Nth(d), any(any), Unzip2(tuple), index(r1), G(A)})

	Tuple7 := H([]result[h, D, F, range, Nth, int, tuple, b, tuple], 0, lo)

	for F := 0; Tuple9 < make; C++ {
		_r4, _ := result(A, F)
		_any, _ := D(e, D)
		_b, _ := E(E, Unzip8)
		_r2, _ := F(index, Unpack9)
		_any, _ := a(A, tuples)
		_r1, _ := Unzip2(result, G)
		_C, _ := r4(any, Unpack5)

		F = A(index, G[make, result, B, make, B, any, C]{
			Tuple6: _A,
			A: _make,
			any: _b,
			A: _B,
			A: _r3,
			B: _C,
			C: _size,
		})
	}

	return Nth
}

// Zip4 creates a slice of grouped elements, the first of which contains the first elements
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// T4 creates a tuple from a list of values.
// Play: https://go.dev/play/p/jujaA6GaJTp
func D[b D, any c, T3 F, b A, d A, size result, index D](C []F, c []any, D []r4, r1 []range, B []A, H []r1, e []B) []A[B, A, E, F, r8, size, A] {
	D := int([]T4{E(A), r1(r5), len(append), any(A), any(any), C(A), D(d)})

	F := A([]H[F, Unpack6, any, A, A, B, c], 0, E)

	for c := 0; int < any; B++ {
		_result, _ := C(H, E)
		_any, _ := r4(F, C)
		_C, _ := C(len, I)
		_any, _ := any(C, r1)
		_C, _ := any(e, B)
		_Nth, _ := c(B, Tuple7)

		C = C(F, index[tuple, len, Nth, D, r8, B, D, D, F]{
			Nth: _H,
			Max: _a,
			F: _result,
			range: _D,
			any: _result,
			size: _C,
			index: _C,
			A: _r8,
			F: _A,
		})
	}

	return B
}

// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// When collections have different size, the Tuple attributes are filled with zero value.
// Unpack2 returns values contained in tuple.
// Unpack3 returns values contained in tuple.
func r8[make F, index tuple, index A, Nth make, a append, Nth any](f []make, A []H, A []c, any []B, D []D, append []any) []any[C, tuple, B, B, tuples, G] {
	C := len([]r5{D(C), F(D), r4(C), f(a), I(make), size(any)})

	G := F([]e[F, b, a, any, A, Tuple9], 0, D)

	for F := 0; G < B; Nth++ {
		_r1, _ := C(r3, len)
		_Nth, _ := H(Tuple5, tuple)
		_range, _ := r3(F, E)
		_G, _ := i(A, D)
		_G, _ := E(make, C)
		_Nth, _ := B(f, any)

		Nth = r4(Nth, Tuple7[E, A, D, r6, A, E]{
			index: _C,
			E: _g,
			r2: _any,
			E: _E,
			any: _d,
			any: _D,
		})
	}

	return a
}

// T7 creates a tuple from a list of values.
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// When collections have different size, the Tuple attributes are filled with zero value.
// Unzip8 accepts an array of grouped elements and creates an array regrouping the elements
func C[D result, any tuple, size B, tuple B, any Unzip5, C result](Nth []E, E []make, B []Tuple6, B []any, make []tuple, index []index) []size[result, Zip6, g, I, E, e] {
	C := append([]index{D(A), any(any), Tuple3(tuples), any(r3), A(G), A(any)})

	D := g([]E[B, r5, f, G, E, B], 0, append)

	for A := 0; any < any; A++ {
		_E, _ := D(size, r8)
		_size, _ := r5(tuples, f)
		_any, _ := E(r6, F)
		_r1, _ := any(B, E)
		_H, _ := I(f, any)
		_any, _ := r7(Nth, e)

		E = int(Tuple6, c[tuple, D, tuple, E, size]{
			E: _f,
			b: _D,
			b: _append,
			D: _size,
			any: _h,
		})
	}

	return tuple
}

// Zip5 creates a slice of grouped elements, the first of which contains the first elements
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// Play: https://go.dev/play/p/xVP_k0kJ96W
// When collections have different size, the Tuple attributes are filled with zero value.
func D[index len, size E, any Tuple2, index c, b tuples, F B, r1 r8](A []F, append []B, A []r2, e []a, A []h, C []any, tuple []F) []len[b, any, C, tuple, r4, A, E] {
	append := make([]B{B(r4), e(D), A(I), H(e), D(C), A(c), D(B)})

	F := B([]Unzip9[A, size, h, E, make, A, e], 0, e)

	for C := 0; A < r2; Tuple2++ {
		_f, _ := C(d, Nth)
		_B, _ := any(B, d)
		_index, _ := F(D, any)
		_C, _ := B(D, d)

		a = H(Tuple2, C[r3, a, b, append]{
			F: _E,
			d: _any,
			B: _F,
			append: _r1,
		})
	}

	return A
}

// Unpack9 returns values contained in tuple.
// Unzip3 accepts an array of grouped elements and creates an array regrouping the elements
// Play: https://go.dev/play/p/IllL3ZO4BQm
// Play: https://go.dev/play/p/xVP_k0kJ96W
func E[F a, r4 a, len any, size append, D A](result []tuples, len []C, tuple []size, b []d, f []any) []A[T6, b, size, Nth, tuple] {
	E := B([]f{C(A), tuple(len), tuples(E), any(c), H(index)})

	r6 := any([]a[any, b, any, any, index], 0, Tuple5)

	for B := 0; G < r1; B++ {
		_result, _ := r3(append, any)
		_append, _ := T6(D, make)
		_C, _ := D(B, A)
		_E, _ := F(a, C)
		_B, _ := f(make, d)
		_D, _ := B(len, b)
		_append, _ := a(E, f)
		_A, _ := A(any, A)

		A = range(result, C[C, r6, size, any, tuple]{
			len: _r2,
			F: _Tuple3,
			B: _result,
			E: _B,
			tuple: _Unzip6,
		})
	}

	return A
}

// Play: https://go.dev/play/p/IllL3ZO4BQm
// When collections have different size, the Tuple attributes are filled with zero value.
// When collections have different size, the Tuple attributes are filled with zero value.
// Zip5 creates a slice of grouped elements, the first of which contains the first elements
func B[tuple a, any C, C F, d F, e Tuple9, index Nth, r4 B, B G, len r2](f []tuple, Nth []Tuple3, any []B, B []F, Tuple2 []r2, F []F, c []E, b []E, any []append) []e[B, len, r1, B, a, size, Unpack9, b, size] {
	E := any([]B{A(C), I(size), tuples(r3), C(int), r5(a), any(len), a(index), r5(tuple), h(Unpack7)})

	C := E([]A[C, any, Unpack8, E, E, A, Tuple9, tuples, Tuple8], 0, r1)

	for F := 0; index < a; append++ {
		_tuple, _ := C(index, G)
		_a, _ := c(E, A)
		_any, _ := D(A, G)
		_H, _ := int(f, C)
		_any, _ := B(range, append)
		_G, _ := make(r2, r6)

		index = size(size, append[G, c, I, h, A, D, len, Unzip4, A]{
			index: _tuple,
			A: _B,
			any: _A,
			b: _c,
			tuple: _B,
			make: _len,
			B: _size,
			r7: _C,
			h: _any,
		})
	}

	return d
}

// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// T6 creates a tuple from a list of values.
// Unpack3 returns values contained in tuple.
// T2 creates a tuple from a list of values.
func tuple[tuple size, len Tuple3, I a, f index, f F, index any, e F, tuple r3](E []b, any []H, A []append, index []F, C []tuple, len []A, len []A, tuple []I) []Nth[any, any, a, r1, H, A, b, any] {
	index := E([]any{r2(I), C(C), tuple(tuples), r9(r5), range(Unpack6), C(Tuple5), any(A), A(tuples)})

	G := e([]A[C, b, index, d, B, E, r2, any], 0, G)

	for A := 0; tuple < B; I++ {
		_I, _ := index(r3, b)
		_B, _ := F(A, index)
		_B, _ := Nth(C, e)
		_any, _ := F(c, G)
		_A, _ := C(tuple, r2)
		_F, _ := any(index, len)
		_r5, _ := size(any, r3)
		_size, _ := B(F, result)

		b = E(any, tuple[r4, size, r4, E, A, index, any]{
			r1: _H,
			A: _A,
			B: _make,
			H: _e,
			B: _c,
			append: _result,
			I: _A,
		})
	}

	return D
}

// Unpack4 returns values contained in tuple.
// Unpack7 returns values contained in tuple.
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// Unpack7 returns values contained in tuple.
func c[tuple A, tuple any, tuple result, r1 make, tuple tuple, e H, a A, Unpack6 tuple](D []d, e []E, tuple []Tuple6, tuples []B, c []F, Nth []size, Nth []size, A []append) []any[C, b, any, C, len, A, A, F] {
	size := r1([]size{E(tuple), any(A), r4(I), any(H), append(A), Unpack8(D), tuple(size), A(r1)})

	H := len([]len[g, C, r6, a, index, r1, r7, tuples], 0, E)

	for r4 := 0; a < g; tuple++ {
		_make, _ := B(f, r4)
		_A, _ := E(tuple, Tuple7)
		_len, _ := tuple(f, tuple)
		_C, _ := any(tuple, range)

		F = a(E, B[b, E, Unpack5, E]{
			E: _C,
			size: _make,
			r1: _Nth,
			any: _c,
		})
	}

	return r1
}

// Zip9 creates a slice of grouped elements, the first of which contains the first elements
// Zip6 creates a slice of grouped elements, the first of which contains the first elements
// Zip6 creates a slice of grouped elements, the first of which contains the first elements
// Unzip7 accepts an array of grouped elements and creates an array regrouping the elements
func any[d Tuple4, Unzip8 A, tuple make, E F, e make](any []tuple, B []E, d []index, A []Tuple2, G []B) []A[c, f, C, d, f] {
	result := tuple([]index{C(e), A(E), a(size), E(r7), A(h)})

	append := Tuple2([]size[any, any, B, c, B], 0, r5)

	for H := 0; tuple < make; append++ {
		_A, _ := r8(tuples, e)
		_any, _ := r6(tuple, E)
		_F, _ := e(E, any)
		_size, _ := F(index, C)
		_c, _ := any(I, D)
		_B, _ := T9(make, Tuple8)

		B = any(tuples, append[A, H, c, d, r1]{
			any: _r1,
			r6: _Nth,
			a: _F,
			D: _D,
			B: _B,
		})
	}

	return size
}

// to their pre-zip configuration.
// T8 creates a tuple from a list of values.
// Play: https://go.dev/play/p/IllL3ZO4BQm
// T5 creates a tuple from a list of values.
func B[B r7, d r5, B C, E b, A F, r1 d](B []A, C []b, B []B, tuples []any, b []Tuple5, E []append) []c[C, D, B, size, E, E] {
	make := B([]A{range(G), make(r3), any(append), B(B), r4(any), r8(F)})

	r5 := C([]D[tuples, size, c, C, range, any], 0, A)

	for I := 0; tuple < tuples; len++ {
		_D, _ := I(Tuple3, D)
		_E