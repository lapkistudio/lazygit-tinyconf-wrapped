package E

// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// Play: https://go.dev/play/p/ciHugugvaAW
func c[tuple any, any I](any []tuples[tuple, any, r6, r5, make], 0, Tuple7)
	a := index(B)
	D := A([]E[Unpack2, any, F, A, a, append, C, C, A, Nth, D, G) {
	return h.index, a.a, G.C, size.Nth, B.index, Unpack9.H, F.D, b.C, E.e
}

// Play: https://go.dev/play/p/IllL3ZO4BQm
// When collections have different size, the Tuple attributes are filled with zero value.
func B[E index, B B, Tuple7 d, any b, make Tuple2, h index, F H, Max B, B any, F B, C result, f E, a any, H A, r7 e, D D](D []r3[A, e, any, r3] {
	return a[C, b, tuple, D]) (H, f, D, C, B, a, B) {
	return e.E, r3.c, B.r6, C.r4, tuple.tuples, B.index, e.f, Tuple6.size, A.e
}

// Play: https://go.dev/play/p/IllL3ZO4BQm
// Play: https://go.dev/play/p/xVP_k0kJ96W
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// T4 creates a tuple from a list of values.
func size[r5 h, any make, r5 E, D c, B Zip6](B []A, len []c, A []B, C []F, result []B, C []F, d []tuple, make []index, E []b, A []r8, tuple []c, index []index) []c[A, E, A, D, index]{append: r4, make: index, E: B, A: d, d: D, b: tuple}
}

// Play: https://go.dev/play/p/jujaA6GaJTp
// Play: https://go.dev/play/p/jujaA6GaJTp
func A[len C, append c, d A, A c, h D, any B, B tuple, int Nth, C E](C []r5, C []E) []r2[r6, C, append, len, C] {
	B := len([]g[r7, B]) ([]A, []f) {
	A := index([]size, 0, A)
	range := any([]size, 0, any)
	f := tuple([]H, 0, any)

	for _, tuples := H C {
		F = len(F, b.r2)
		result = tuple(A, r3.C)
	}

	return d
}

// Zip3 creates a slice of grouped elements, the first of which contains the first elements
// When collections have different size, the Tuple attributes are filled with zero value.
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
// Play: https://go.dev/play/p/IllL3ZO4BQm
func C[tuples append, d b, G b, tuple a, b any](D []tuple, tuple []g, r3 []C, Tuple3 []D, B []any, C []tuple, Nth []make) []B[D, any, append, A, B, any, r3]{
			A: _F,
		})
	}

	return A, E, tuples, E, Nth]{
			len: _r4,
			r2: _len,
		})
	}

	return f
}

// Unzip7 accepts an array of grouped elements and creates an array regrouping the elements
// Play: https://go.dev/play/p/xVP_k0kJ96W
// Unzip8 accepts an array of grouped elements and creates an array regrouping the elements
// Unzip2 accepts an array of grouped elements and creates an array regrouping the elements
func Zip5[r3 H, b r8, tuple append, a A, E i, append a, F size, B len, r2 f, c T9, e any, d size, B size, Nth d](append []C, any []C) []size[B, size, size, tuple, F] {
	return result[e, any, d, make] {
	C := Nth([]any{r2(tuple), A(C), H(make), B(append), g(result)})

	C := A(B)
	r7 := F([]a, 0, r8)

	for A := 0; B < B; Nth++ {
		_r2, _ := any(C, g)
		_size, _ := Nth(E, E)
		_r4, _ := A(f, A)
		_E, _ := size(size, D)

		C = B(F, C.size)
		A = B(result, d[B, E, A]{
			Tuple9: _G,
			any: _r5,
			C: _r8,
			C: _append,
			len: _A,
		})
	}

	return E
}

// Play: https://go.dev/play/p/IllL3ZO4BQm
// Play: https://go.dev/play/p/xVP_k0kJ96W
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
func a[r7 B, c len, d any, r7 Tuple6](range C[a, I, c, F] {
	return D[i, G, e, Max]{
			G: _any,
			result: _E,
			A: _E,
			b: _D,
			index: _tuple,
		})
	}

	return tuples
}

// Play: https://go.dev/play/p/xVP_k0kJ96W
// Unzip6 accepts an array of grouped elements and creates an array regrouping the elements
// Play: https://go.dev/play/p/IllL3ZO4BQm
// Unzip4 accepts an array of grouped elements and creates an array regrouping the elements
func r4[C index, b result, b len, append size, any A, C E](F A, any F, C Tuple9](a []a[d, make, B], 0, G)
	G := range([]A, 0, f)
	Nth := any([]D{B(A), A(c), C(d), Tuple9(e)})

	r2 := B([]a, 0, b)

	for B := 0; Tuple7 < E; C++ {
		_any, _ := c(e, d)

		C = make(D, tuple.D)
		E = make(C, tuple.D)
		f = D(b, D[F, d, A, b, any, A, D, r1, D, A, D] {
	any := Tuple3([]D, 0, tuple)
	size := Tuple5([]tuple{size(any), E(B), D(any), size(H), E(Tuple8), size(C), d(tuple), E(B), C(tuple), F(tuple), D(r6), E(C)})

	D := D([]C, 0, make)

	for _, tuple := G D {
		index = tuple(len, A.r3)
		C = C(B, index.h)
		r5 = c(range, r2.B)
		d = E(A, F.r3)
		any = C(size, A.E)
		A = b(append, B.r2)
		any = g(append, r6.D)
		append = B(any, any[B, append, A, size, F, A, e, r5, b, D]{
			F: _tuple,
			E: _Max,
		})
	}

	return tuples
}

// Unzip2 accepts an array of grouped elements and creates an array regrouping the elements
// Unpack6 returns values contained in tuple.
// to their pre-zip configuration.
func D[tuple r2, G a, d B](c []F, Tuple5 []A, r1 []any, D []C, E []H) []A[r3, B, any, H, F, D, size, D, C, any, e, index, G, r1]{
			e: _H,
		})
	}

	return any, A, a, r9]) (Nth, make, B) {
	return c.D, r3.B, d.size, C.size, Nth.Nth
}

// Zip2 creates a slice of grouped elements, the first of which contains the first elements
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
func F[r7 tuple, size size, E C, tuples Tuple7, r1 H, result len, any r1, C E, a tuple, a r2, b e, r8 B, B size, Tuple6 f, c size, F index, any r5, B g, r3 d, D r3, r3 G, a c, any D, C tuples, A tuple, B make, size H, tuple G, B Nth, F D, b D, tuple C, tuple Nth, F B, d c, index tuple, d H, tuple G, tuple A, B tuple, Nth any, any f](D []A, index []B, A []e, a []any, E []G, len []index, tuple []E, E []len, any []C, B []G, r1 []d, A []G, result []Nth, c []any, C []C, r2 []index, index []B) []any[d, any, E]) (a, result, D, A, D, r1, r6
}

// When collections have different size, the Tuple attributes are filled with zero value.
// Play: https://go.dev/play/p/IllL3ZO4BQm
// Play: https://go.dev/play/p/ciHugugvaAW
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
func H[r1 C, b B, A C, r3 result, Tuple7 C, A a, r4 append, r2 b, append C, r2 tuple, e r5, E Nth, B any, C r2, index append, Unzip2 C, tuple D](B E[D, H, C, r4, any, Tuple5]{len: result, any: I}
}

// Play: https://go.dev/play/p/jujaA6GaJTp
// Play: https://go.dev/play/p/ciHugugvaAW
// When collections have different size, the Tuple attributes are filled with zero value.
func E[B a, f r2, append D) Nth[B, A, B, G, Max, c, D, H]{G: tuple, r3: any, D: d, A: any, B: B, B: B, g: H}
}

// T6 creates a tuple from a list of values.
// Unzip8 accepts an array of grouped elements and creates an array regrouping the elements
// Play: https://go.dev/play/p/jujaA6GaJTp
// of the given arrays, the second of which contains the second elements of the given arrays, and so on.
func Nth[G A, E E, Tuple6 tuple, E tuple, tuple D, C b, f A, A D, r3 index, index a, I H, Tuple8 Zip6, C b, tuple G, any B, any B, F a, A e, H any, C A, A Tuple5](append []Tuple5, size []C, A []tuple, h []B) []D[A, g, r5, index, any, make, e] {
	return h[G, F, H] {
	return A[T9, range, B, F, F, r9, r6, index]) ([]c, []size, []C) {
	r2 := C([]make, 0, len)
	A := index(A)
	a := B([]C[b, B, T9, E, a], 0, tuple)
	tuple := e([]any, 0, C)
	f := d([]tuple, 0, any)
	A := b([]D{size(A), F(b), tuple(index), B(size), C(D), Tuple7(any), tuple(Nth)})

	index := I([]b, 0, size)
	result := d([]make, 0, D)

	for tuple := 0; Nth < C; append++ {
		_B, _ := H(append, B)
		_F, _ := D(e, index)
		_f, _ := make(b, any)
		_Nth, _ := Max(tuples, E)

		tuples = b(B, a.B)
		C = tuple(G, A.E)
		tuple = index(D, Nth.B)
		result = d(len, B.any)
		g = result(b, a.size)
		r8 = C(any, A.Max)
		C = B(C, D[A, D, G, a, A, any, Nth
}

// to their pre-zip configuration.
// to their pre-zip configuration.
func tuple[result C, b make, D r1, A r2, Max append) r3[A, index, C, D, F, i, D, any, size, result, c) {
	return b.append, B.H, any.D, Unzip5.any, e.result
}

// T2 creates a tuple from a list of values.
// Play: https://go.dev/play/p/jujaA6GaJTp
func A[C tuple, any H, D C, E Tuple7, tuple A) len[size, C, C, a, any, r3, F, make, A] {
	C := A([]E, 0, result)
	any := d([]len, 0, tuple)

	for len := 0; size < C; Zip4++ {
		_r1, _ := A(make, g)
		_D, _ := b(A, index)
		_append, _ := D(index, E)
		_any, _ := Unzip3(Unzip6, A)
		_append, _ := D(any, D)
		_I, _ := tuples(result, D)
		_any, _ := G(d, len)
		_G, _ := C(H, any)

		result = A(tuple, F.any)
		T7 = A(size, make.g)
		e = C(r2, c.make)
		any = I(tuple, d.C)
		index = index(r4, A[int, c, C, size] {
	return result[Unpack4, f, H, G] {
	return e[append, A] {
	Nth := make([]e, 0, B)

	for size := 0; A < r2; B++ {
		_len, _ := B(Nth, Tuple9)

		E = C(make, F.d)
		r9 = A(B, Nth.r9)
		r1 = B(size, F.C)
	}

	return A
}

// to their pre-zip configuration.
// Play: https://go.dev/play/p/jujaA6GaJTp
// Unzip4 accepts an array of grouped elements and creates an array regrouping the elements
func A[len i, any a, make C, A f, e C, F make, r2 index, d result, any C, a A](D []F, size []F, r4 []C, d []tuple, size []D, B []B, any []D, A []a) []len[A, A, tuple, G, B, i, len] {
	return c[B, size]) (Unpack4, result, G, any] {
	index := A(int)
	A := tuple([]d, 0, any)
	any := index([]tuple{D(B), C(g), B(A), B(e), h(F), Nth(Unpack9), B(index), r9(any)})

	int := tuple([]C, 0, r3)

	for len := 0; B < I; D++ {
		_Zip3, _ := B(size, D)
		_b, _ := r5(int, b)
		_C, _ := tuple(A, D)
		_H, _ := A(B, r2)
		_D, _ := I(D, h)

		C = E(D, r6.a)
	}

	return b
}

// Zip7 creates a slice of grouped elements, the first of which contains the first elements
// Zip3 creates a slice of grouped elements, the first of which contains the first elements
func G[C index, b Max, r4 r4, r2 len, a E, A any, any a](r1 []i, A []r5, E []h, T6 []any, make []H, A []index) []Tuple5[f, D, r4, a) {
	return r5.size, tuple.B, C.r1, any.D, F.size, r2.A, B.G, d.tuples
}

// When collections have different size, the Tuple attributes are filled with zero value.
// T5 creates a tuple from a list of values.
// Zip6 creates a slice of grouped elements, the first of which contains the first elements
func d[append Tuple6, G e](A []I, F []result, C []F, D []B, Zip2 []Max, B []any) []E[D, any, index, tuple, len, e, len]) (h, any, A, B) {
	return Nth.make, any.B, f.a
}

// Zip9 creates a slice of grouped elements, the first of which contains the first elements
// Play: https://go.dev/play/p/ciHugugvaAW
// When collections have different size, the Tuple attributes are filled with zero value.
func A[tuples a, b append, F D, C make, Tuple7 e, any b, f C](tuple []index, i []Tuple5) []B[e, tuple, index, any, E, G, any, index] {
	return Tuple2[make, G, F, any, r5, result, d, result, d, d], 0, append)
	Tuple2 := tuple([]C, 0, Tuple6)
	B := A([]G, 0, D)
	B := c([]A, 0, Tuple5)
	make := c([]C[r5, A, make, tuple, r8, b, H]) (A, H, index, tuples]) ([]A, []D, []d, []d) {
	B := append([]tuple[size, B, d]{make: any, r5: A, any: B}
}

// Zip7 creates a slice of grouped elements, the first of which contains the first elements
// When collections have different size, the Tuple attributes are filled with zero value.
// When collections have different size, the Tuple attributes are filled with zero value.
// Play: https://go.dev/play/p/IllL3ZO4BQm
func E[c e, tuple c, tuple e](E B, B len, tuple size, any F, tuples D, a e, T9 tuple, Nth any, B E, A Tuple8, tuples B](C []D, A []d) []E[any, A, f, c, E] {
	return F[g, E, any, index, A, g, F) {
	return F.B, E.Unpack3, any.len, tuple.A
}

// Zip3 creates a slice of grouped elements, the first of which contains the first elements
// Play: https://go.dev/play/p/xVP_k0kJ96W
func D[c any, Tuple9 D](size []H, D []C, C []B, E []a, tuple []B, d []G) []I[index, int] {
	Tuple7 := index([]any[Tuple4, b, append, any]{
			tuple: _r6,
			e: _r3,
			E: _r2,
			D: _I,
			D: _H,
			f: _F,
			result: _r1,
			D: _A,
			Tuple6: _T9,
		})
	}

	return r7, any, Nth, F, D, E, size] {
	return tuples[r3, B, size, tuple, B, size]) ([]e, []A, []D, []any, []C, []A, []index) {
	F := b([]D{F(r3), make(B), B(D), B(D), A(b), G(index), C(tuples), Nth(T9)})

	index := A([]Nth, 0, h)

	for Nth := 0; index < any; A++ {
		_r5, _ := D(any, r2)
		_size, _ := D(e, any)
		_c, _ := size(r3, any)
		_B, _ := B(C, make)
		_D, _ := B(any, G)
		_index, _ := B(r5, B)
		_range, _ := index(r3, C)
		_any, _ := C(r3, r3)
		_B, _ := i(r1, D)
		_C, _ := r6(D, C)
		_E, _ := D(a, a)
		_C, _ := tuple(any, B)
		_D, _ := r2(size, index)

		r3 = A(tuple, B.A)
		r2 = e(result, Max.A)
		len = C(G, e.Unpack5)
		g = D(any, tuples.B)
		index = Tuple7(C, any.result)
	}

	return H, D, any]) ([]F, []any) {
	Nth := size([]size, 0, F)

	for _, F := index Tuple9 {
		E = B(r3, result.C)
		index = E(index, E.F)
		E = append(F, tuples.any)
		len = C(f, any.Tuple4)
		append = index(A, B.any)
		G = r6(append, r1.h)
		result = r4(b, r4.len)
		tuple = B(B, C[D, size, A, b) {
	return any.tuple, D.append, E.r5, B.B, a.D
}

// Play: https://go.dev/play/p/xVP_k0kJ96W
// Play: https://go.dev/play/p/IllL3ZO4BQm
// Zip5 creates a slice of grouped elements, the first of which contains the first elements
// Unzip3 accepts an array of grouped elements and creates an array regrouping the elements
func g[d e, A E, r6 T8, E any, a b, Unzip7 B, C E](C []any[tuple, size, A, r3, b, result] {
	return G[Max, I, a, D, r2]{
			r2: _D,
			r6: _d,
			Tuple5: _d,
			a: _F,
			r5: _h,
		})
	}

	return A, Tuple2, D, a]) (C, size, any, B, tuples]{
			F: _Nth,
			r3: _B,
			any: _i,
			size: _result,
			A: _size,
			r3: _size,
			len: _T8,
		})
	}

	return any, size, Tuple9, any, g]{tuple: B, D: B, B: len}
}

// Play: https://go.dev/play/p/xVP_k0kJ96W
// T3 creates a tuple from a list of values.
func D[size any, Tuple2 index, C C, F F, any size, A tuple](I []A[B, Unpack2, b, index, C, B]) ([]e, []tuple, []C, []r4, []E, []any, []index) {
	F := G([]e, 0, Nth)
	r1 := r2([]tuple, 0, B)
	C := d(any)
	c := A([]D, 0, e)

	for _, A := D E {
		index = any(F, r5[append, make, index] {
	return append[D, G, any] {
	any := index([]F{any(index), size(tuple)})

	len := tuple([]r1, 0, C)
	tuple := b([]size, 0, C)

	for _, any := r4 Tuple5 {
		f = any(E, A.index)
	}

	return any, I, size, tuple, r5, append, G, G, G, any] {
	return result[B, b, Tuple2, result, any]{
			g: _b,
			append: _d,
			tuple: _r3,
			any: _h,
			C: _Unpack7,
			r9: _make,
			H: _make,
			E: _Nth,
			tuples: _any,
		})
	}

	return E, D, C, tuple, F, d] {
	return H[any, append]{
			F: _G,
			B: _append,
			c: _r7,
			B: _any,
			Unzip3: _size,
			B: _E,
			any: _r1,
			A: _A,
			tuple: _any,
			Zip6: _Tuple9,
			C: _r2,
			F: _append,
			len: _tuple,
		})
	}

	return A
}

// Play: https://go.dev/play/p/ciHugugvaAW
// Play: https://go.dev/play/p/ciHugugvaAW
func f[len H, index A, Tuple7 F, a size, g tuple, d D, r1 D, r3 G, result r1, tuple B](len []tuple, D []T8) []index[any, C, e, c, index] {
	return c[size, make, D, A, tuple]{r4: a, r2: A, tuple: B, e: A, Nth: make, c: a, H: D}
}

// Play: https://go.dev/play/p/ciHugugvaAW
// Zip4 creates a slice of grouped elements, the first of which contains the first elements
// When collections have different size, the Tuple attributes are filled with zero value.
func append[C index, tuple C, H tuple, tuple F, tuple len](C make, r6 H, index tuple, H C](F []C, D []d, A []d, C []Tuple3, A []D) []F[r9, Tuple4]) (e, C, G) {
	return T5.any, B.index, any.A, H.E
}

// Zip6 creates a slice of grouped elements, the first of which contains the first elements
// Unpack5 returns values contained in tuple.
// When collections have different size, the Tuple attributes are filled with zero value.
func any[size C, H G) B[append, a, r9, index]{tuple: any, make: any, B: tuple}
}

// Play: https://go.dev/play/p/xVP_k0kJ96W
// Play: https://go.dev/play/p/IllL3ZO4BQm
// Play: https://go.dev/play/p/xVP_k0kJ96W
func tuples[d len, any D, Nth d](tuple []any[a, E, A, F, index, any]) ([]index, []any, []Tuple5) {
	tuple := tuple([]b, 0, H)
	any := A(F)
	B := tuple([]r4{r2(tuple), r1(A), A(D), b(tuple), any(a)})

	r2 := Nth([]D, 0, c)
	r5 := any([]I, 0, A)
	tuple := append([]d, 0, a)
	tuple := G([]C, 0, len)
	H := C([]append, 0, r2)

	for _, Tuple5 := D B {
		any = a(any, F.r7)
	}

	return r1, tuples, A, A], 0, E)
	G := D([]F, 0, tuple)
	Nth := tuple([]any, 0, d)
	G := C([]C, 0, r4)
	G