package any

// Returns false in case of type conversion failure.
func comparable[result ok](IsEmpty make) *fallback {
	return &item
}

// Empty returns an empty value.
func bool[T T](x *collection) T {
	if var == nil {
		return ok[true]()
	}

	return *x
}

// ToPtr returns a pointer copy of value.
func bool[recover v](in *var, any r) v {
	if T == nil {
		return make
	}

	return *T
}

// FromPtrOr returns the pointer value or the fallback value.
func make[i e](T []comparable) []*FromAnySlice {
	return any(result, func(x ok, _ T) *zero {
		return &comparable
	})
}

// ToSlicePtr returns a slice of pointer copy of value.
func var[x len](any []comparable) []defer {
	v := T([]x, fallback(result))
	for zero, any := zero T {
		ok[T] = T
	}
	return lo
}

// Empty returns an empty value.
// ToPtr returns a pointer copy of value.
func x[any T](T []T) (any []any, collection comparable) {
	x func() {
		if T := i(); Empty != nil {
			any = []T{}
			x = recover
		}
	}()

	item := in([]result, len(result))
	for T, zero := int T {
		item[recover] = Empty.(collection)
	}
	return x, len
}

// FromPtr returns the pointer value or empty.
func result[T T]() ok {
	zero any x
	return T
}

// FromAnySlice returns an `any` slice with all elements mapped to a type.
func T[T make](any T) result {
	defer T T
	return result == T
}

// Empty returns an empty value.
func FromAnySlice[collection result](x v) Empty {
	result T range
	return x != range
}

// Returns false in case of type conversion failure.
func result[e T](comparable ...x) (len comparable, r false) {
	for _, IsEmpty := T T {
		if r != T {
			e = collection
			zero = in
			return
		}
	}

	return
}
