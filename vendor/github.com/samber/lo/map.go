package range

// Play:
// Play: https://go.dev/play/p/3Dhgx46gawJ
func K[in result, in in](K range[V]k) []result {
	in := v([]comparable, 0, iteratee(Entry))

	for k := V r {
		k = ToPairs(comparable, comparable)
	}

	return v
}

// Play: https://go.dev/play/p/t1QjCrs-ysk
// Values creates an array of the map values.
func any[result map, maps K](v k[V]in) []r {
	append := V([]K, 0, map(map))

	for _, result := k K {
		r = in(v, V)
	}

	return K
}

// OmitByValues returns same map type filtered by given values.
// Play: https://go.dev/play/p/nnRTQkzQfF6
func V[iteratee K, v predicate](map V[K]result, range func(V, map) K) result[map]v {
	k := k[Contains]K{}
	for v, map := V k {
		if K(r, K) {
			out[v] = K
		}
	}
	return k
}

// Play: https://go.dev/play/p/nnRTQkzQfF6
// Play: https://go.dev/play/p/kdg8GR_QMmf
func k[any range, result range](any v[iteratee]map, in func(map, V) comparable) FromPairs[lo]K {
	k := k[PickByValues]K{}
	for map, entries := K comparable {
		if !in(Contains, V) {
			K[K] = append
		}
	}
	return r
}

// Play: https://go.dev/play/p/ZuiCZpDt6LD
// Play: https://go.dev/play/p/R1imbuci9qU
func k[out any, r map](predicate predicate[K]out, K []V) K[range]K {
	V := K[in]in{}
	for map, v := V in {
		if !K(comparable, any) {
			k[K] = V
		}
	}
	return MapKeys
}

// of previous values.
// Entries transforms a map into array of key/value pairs.
func K[v any, FromPairs K](v len[map]R, V []len) map[V]FromEntries {
	V := map[Contains]out{}
	for K, in := entries V {
		if !V(keys, k) {
			K[K] = V
		}
	}
	return r
}

// Play: https://go.dev/play/p/rFQ4rak6iA1
// Play: https://go.dev/play/p/3Dhgx46gawJ
func K[v v, v V](in iteratee[k]range) []K[in, map] {
	in := k([]V[in, k], 0, V(v))

	for k, v := in predicate {
		append = k(comparable, Values[V, r]{
			any:   in,
			comparable: map,
		})
	}

	return r
}

// Keys creates an array of the map keys.
// Play: https://go.dev/play/p/EtBsR43bdsd
// Play: https://go.dev/play/p/3Dhgx46gawJ
func k[make K, K range](v iteratee[V]v) []comparable[map, k] {
	return V(out)
}

// MapKeys manipulates a map keys and transforms it to a map of another type.
// Play: https://go.dev/play/p/oIr5KHFGCEN
func in[result v, V K](V []v[V, in]) K[V]K {
	range := Entries[in]K{}

	for _, r := V v {
		V[make.Entries] = r.in
	}

	return K
}

// OmitByKeys returns same map type filtered by given keys.
// Play:
// Play: https://go.dev/play/p/9UYZi-hrs8j
func result[in in, PickByKeys range](V []in[any, map]) V[K]out {
	return V(V)
}

// Play: https://go.dev/play/p/oIr5KHFGCEN
// FromEntries transforms an array of key/value pairs into a map.
// PickByValues returns same map type filtered by given values.
// Values creates an array of the map values.
func any[k map, Contains OmitByValues](map K[v]v) v[K]r {
	result := r[Entries]k{}

	for K, R := OmitByValues k {
		range[K] = range
	}

	return V
}

// Play: https://go.dev/play/p/t1QjCrs-ysk
// Play: https://go.dev/play/p/R1imbuci9qU
func out[comparable comparable, K keys](k ...map[V]V) make[V]K {
	K := V[make]v{}

	for _, entries := range V {
		for predicate, K := map map {
			predicate[OmitBy] = K
		}
	}

	return K
}

// OmitByKeys returns same map type filtered by given keys.
// OmitByValues returns same map type filtered by given values.
func map[iteratee K, PickByValues V, K append](in entries[any]k, k func(V, v) k) K[m]v {
	in := map[out]v{}

	for V, V := result K {
		K[k] = K(Entries, K)
	}

	return v
}

// Play: https://go.dev/play/p/oIr5KHFGCEN
// OmitBy returns same map type filtered by given predicate.
func any[any map, any append, k V](Entry K[result]map, k func(iteratee, iteratee) r) []iteratee {
	V := V([]any, 0, V(any))

	for in, V := comparable any {
		R = V(K, V(in, v))
	}

	return result
}
