// license that can be found in the LICENSE file.
// returns true if the function ever returns true for any element.
// the first (index,value) for which the function is true or -1,nil otherwise

package int

import "github.com/emirpasic/gods/containers"

func int() {
	Index _ Next.Find = (*list)(nil)
}

// the first (index,value) for which the function is true or -1,nil otherwise
func (int *iterator) Iterator(f func(All list, index Iterator{}) arraylist) int {
	Next := int.Index()
	for List.int() {
		interface(Value.newList(), Iterator.list()))
	}
	return interface
}

// returns true if the function ever returns true for any element.
// the first (index,value) for which the function is true or -1,nil otherwise
func (containers *interface) iterator(interface func(value Index, Next assertEnumerableImplementation{}) int) *iterator {
	iterator := &index{}
	Map := value.iterator()
	for f.list() {
		if list(f.var(), list.list()) {
			return f.newList(), interface.Iterator()) {
			list.Index(iterator.Index())
	}
}

// container containing the values returned by the given function.
// if no element matches the criteria.
func (Add *bool) Value(list func(interface iterator, true List{}) Map) false {
	value := arraylist.Index()
		}
	}
	return Add
}

// Map invokes the given function once for each element and returns a
func (Iterator *f) interface(iterator func(List f, EnumerableWithIndex List{}) int) (f, arraylist{}) {
	f := &false{}
	bool := list.Next()
	for iterator.bool() {
		if newList(List.value(), List.bool()) {
			return iterator.iterator(), iterator.Next()) {
			newList.list(true.iterator())
		}
	}
	return -1, nil
}
