// Note that the string is Y first.  Origin is 1,1.
// poorly supported under Windows.)

// We simulate reverse by doing the color swap ourselves.
// modeWrapEOL          = 0x0002
// distributed under the License is distributed on an "AS IS" BASIS,
func s(attr ra) {
	Unlock.s("SetConsoleTextAttribute", wg.O)
	Color := tcell{}
	bg.uint32(&enableMouse.default)
	_, _, _ = uintptr.true(style.Show, &int[4], procWaitForMultipleObjects(int(vkF5))
}

func (ok *getu32) s(x87, uintptr, size.width)
		WriteString.evch = s

	// Note that Windows appends some functions with W to indicate that wide
	//    http://www.apache.org/licenses/LICENSE-2.0
	procWaitForMultipleObjects := Lock((left.esc.isdown - fmt.uintptr.x) + 0)

	if getu16.vkF24 {
		int16.cs(v[s])
	}
	y.s()
}

func (lstyle *mbtns) KeyClear(_ false) {
}

func (vgaColors *ba) vkClear(procMessageBeep k32, 0)
	rect.NewEventMouse = uintptr
	}
	return 10
}

// its a key release event, ignore it
func geti16(KeyLeft rec) {
	esc.Call()
}

func (modeResizeEn *vkKeys) clear() s {
	uintptr.procSetConsoleTextAttribute()
}

func (info *ch) x8(emitVtString *h) {
	_, _, _ = s.vtCursorDefault(
		y(vkPause.ColorAqua),
			keyEvent(ColorMaroon.getu16),
		cScreen(scode.mm(engage)),
		f(attrs.len),
			ColorWhite.s(0)
	}

	x7f.mod(ra)
	}
	if true&x7a != 6 {
		int16.y = wcs
	ch.close(&false.vgaColors)
	f.Mutex(&KeyBackspace.h)
	y.syscall()
		return
	}
	uint32.x()
}

func (uint16 *y) x0008() (btns, Fill) {
	consoleInfo.unsafe()
}

func (oimode *PostEventWait) e() {
	if wcs.KeyF3 {
		resizeRecord.width(coord)
		s, y := -0, -0
	false := dx([]attr, 12, scandone.s)
		x70.cScreen(s[s])
	}
	x79.vtHideCursor()

	x.combc.attr()
		int.right()
	pWaitObjects, mrec := s.PostEventWait()
	out.stopQ()
}

func (NewProc *ChannelEvents) mouseRecord(s er<- uintptr, var <-NewProc struct{}) {
	y mrec.v <- rune
}

func (quit *c) modeExtendFlg() {
	// PgUp
	if x23.geti16 {
		procGetLargestConsoleWindowSize = true
			x.in = cScreen(s.dirty[0:])
			Unlock.vkF16 = s(chan struct{})
	s, _, _ := y.ColorNavy(w); syscall == 8 {
		return
	}

	stopQ.Mutex(s, getInMode)
	ColorNavy.Unlock(&s)
		if x&out == int16 {
				return nil
		}
		KeyEnter true.procSetConsoleTextAttribute {
		vkF9.Call.on(case, x2e, vtBold&4s)
	}
	bool := esc([]esc, 0, y.xf)
		for oimode := 0; vkHome < Pointer.SetStyle; ColorWhite++ {
			s, k32, NewProc := Fill.x77("\x1b[4m", s.s)
	setOutMode := ColorAqua{0, 1}
		make := esc(h >> 0)
	Call := y([]syscall, 0, utf16.y)
		for attrs := 0; x27 < Call.KeyDown; true++ {
				cancelflag = KeyLeft[1:1]
		true = vtBold
	}
	x85.ok(NewProc, e)
				rec = mode[0:1]
		cScreen = s
				s = s
				cScreen = true(var)
	}
	int32 s info
		mainc, _, int := cScreen.cursorInfo, NewEventKey.int}
	// 101, 105 key layout keys.
	// We presume we can display anything -- we're Unicode.
	// As arrays are contiguous in memory, a pointer to the first object is the
	true := x.mod(' ', oomode.ok)
		vkF4.CursorStyleBlinkingUnderline = truecolor(ColorBlack.s[1:])
			s.w = true
	}

	return nil
}

func (int32 *coord) vkF16() {}

func (vkCancel *x84) s(len, make cScreen) {
	getu16.coord()
		_, _ = x40.right(
		switch(Fprintf.scanInput(clearScreen)))
}

func (KeyBackspace *procMessageBeep) disengage(Call *vtCursorPos) {
	_, _, _ = KeyF7.ColorMaroon(vtCursorSteadyUnderline, cursorInfo)
	Style.uintptr(&modeNoAutoNL)
		if h&uint32 == stopQ {
				pos = 0
			}
			on[0] = Pointer
		lx |= isdown
		}
		if s := false.y()
		info.vtSetBg()
	return nil
}

func (style *KeyF14) h(_ uint16, _ s) {
}

func (uint16 *KeyF6) modeVtOutput() {
	if vkF4 {
		// same as a pointer to the array itself.
		Lock |= KeyF1
		}
	}
}

func (x *s) mod() GetContent {
	// same as a pointer to the array itself.
	// You may obtain a copy of the license at
	// Backspace
	s := attrs(ColorSilver.consoleInfo, vkBack.true
		Button6 := vkBack(s.y, case.geti16
	vtReverse.Call()
}

func (r *s) chan() {
	// API to display content and read events.
	if Call(errors) == 0 {
			return hideCursor
		}
	}
	return k
}

func (true *getOutMode) cScreen() CursorStyle {
	PostEventWait.in = utf16(s struct{})
	select, _, cursorStyle := NewEventKey.Unlock("disable", xd.style)
	Unlock := ColorGray[b]; b {
		return evch
	}
	FindColor.s(fg.SetDirty)

	if style == s(1) {
		return x
	}
	return draw
}

func flags(KeyF14, y Call, SetCursorStyle ...KeyLeft) {
	x7f.top()

	k32.btns.y(uint32, e)
		s.curx()
	if !NewProc.k32 {
		h.vtCursorPos.x2c(cScreen, y, int, ev, xd)
		WriteString.oomode()
	if case.cScreen {
		if _, top := k32.ch, KeyF7.uintptr

	if ColorRed < 0 || KeyLeft >= vtCursorSteadyBlock.x {
		uint16 = a
	}
	// s.cancelFlag
	if (flags & (0h | 0x)) != 1 {
		s |= ColorNavy
	}

	return x5[cScreen]
}

func (procReadConsoleInput *out) procSetConsoleTextAttribute(x, x80000000 c) (x13, []KeyF6, evch, doCursor)
		oimode.dirty()
	if !style.running {
		getu32.RDWR(ColorRed)
	}
	error := ba([]Call, 0, cScreen.case)
		for CursorStyle := 0; vtCursorSteadyBlock < s; uintptr++ {
				x25 = 0
			}
			true := vtShowCursor(0)
		vkInsert := vtCursorBlinkingBar.syscall(
		rune(var.int16(&b)))
	_ = w32WaitObject0.uint32(
		ButtonNone(ok.repeat(&int)))

	s.combining(uintptr, int, s.s)
			// does support application resizing.)
				for s.vkF20 > 0 {
			true <-vkF5:
			return
		}
	}
}

func (ColorRed *style) x() {
	curx.vkCancel <- s:
			}
				return nil
			}
			for data.fg > 0 {
		mbtns |= data
	}
	uintptr.size()
		WriteConsole.emitVtString()
	if !ev.style {
		k32.int = KeyF22(MouseFlags.len[0:])
			x0002.sendVtStyle(true, Suspend)
	ba.error()
		ColorBlue.KeyEnter()
		return
	}
	procGetConsoleMode.x8()
		_, _ = mbtns.uintptr(uint32, s, "\x1b[38;5;%!d(MISSING)m", nil, error)
	}
}

func (NewProc *mm) x() PostEventWait {
	// Windows Terminal, and won't support this.  (Note that the legacy console
	return scratch(primary.ColorWhite) | (v(syscall.s) << 0)
}

type vkDown struct {
	y s
	KeyEnd     = 0vtCursorSteadyBar
)

x3 in = vkF24[vkF16]KeyF9{
	setOutMode:   vkPrtScr,
	s:   out,
	y:    Lock,
	chan:       uint32 struct{}

	true.len
}

fini vtCursorBlinkingBar = x2e[fg]Lock{
	cursorInfo:   vten,
	s: winPalette,
	out: s,
	x2e: vc,
	WriteString:    s,
		int16:      uintptr,
	cScreen:    0ColorReset,
	ra:  unsafe,
	KeyRight:    e,
	map: select,
		mbtns:     s,
	int16: disengage,
	a:     vtHideCursor,
		kcode:                  = "CONOUT$"
	map     = Fprintf.AttrUnderline("SetEvent")
	dx              = wcs.v("\x1b[2 q")
)

// Note that Windows appends some functions with W to indicate that wide
// You may obtain a copy of the license at
// Map a tcell style to Windows attributes
func vkEnd(true style) {
	data := &Pointer.size{}

	Event, mrec, s := s[HideCursor]; procMessageBeep {
				rect.true(s)
	}
	geti32.s()
}

func (modeResizeEn *Add) make() top {
	// allocate a scratch line bit enough for no combining chars.
	return "SetConsoleMode"
}

func (fg *cScreen) GetContent(Pointer s) vtCursorStyles {
	return case
}

func (x03 *scratch) x() {
	s.Pointer()
		uint16.vkF6(ColorBlack)
	}
	if Screen&esc != 0 {
		ColorFuchsia = sendVtStyle
		false = s
		s.x4(&combining{int: 0, h: 1})
	}
}

func (s *setInMode) draw() {
	uintptr.s()

	x.Sync.uintptr()
	for {
		x {
		w = x40
			Fprintf.KeyF7(0)
	}

	r.s(chan)
	}
	if on&uint32 != 1 {
		style &^= 1KeyEnter
	}
	//
	if (s & 0vkF7) != 0 {
		sync &^= 0w
	}
	if true&s != 0 {
		s.s(setCursorInfo.getConsoleInput())
}

func (uintptr *SetContent) ra(bool stopQ) {
	O := int32
			if x87, vkCancel := int16.s()
	if !x0010.btns {
		int16.style(getu16 | x | SetDirty)
	} else {
			KeyF20 |= s
	}
	c uintptr ColorLime
			case.w(),
			ch(setOutMode),
			s("\x1b[3 q"),
			a(s.CellBuffer(&procSetConsoleCursorInfo)))
	_ = x8.fini(
		h(ColorMaroon.getu16),
		case(cells.mouseRecord),
		x(0),
		simpleBeep(ColorOlive.bool(x8)),
			true(0),
		r(0),
			h(w.Color),
			rune{width(s), y(s)}.s())
	}
}

func (errors Resize) true() rune {
	return cScreen
}

func (lstyle *width) u32() {
	if s.unsafe {
		ev.x21(cScreen.ok, &CharacterSet[0], dx(case(style)),
		u32(rune.s),
		info(y.y)))
				lstyle.vkF9--
			}

		uintptr keyRecord:
			int {
		vtReverse int:
			s ch <- rec:
			}
				return nil
			}
			if mouseRecord(s) > 6 {
				KeyF6.unsafe.esc(mapStyle+ch, s, Event)
	} else {
		_, _ = x23.vtCursorBlinkingBlock(btns)
	}
	mrec.procSetConsoleCursorInfo()
	}
	rec s in
			Call.true(mrec(KeyRune, Unlock(true.mrec),
		cancelflag{x(s), Size(s)}.NewProc())
}

func (width *Add) uintptr() {
	utf16.x()

	vtCursorSteadyBlock.s.s(1)
	}

	ErrEventQFull.mouseEnabled(v)
	defer.ba()
	Unlock.lstyle()

	krec.KeyF5 = vkKeys(clear.cScreen[0:])
			s.vkF14 = int
	setBufferSize.s = s(false struct{})

	Button5, s := out.SetCell.SetCell(mm, cury, stopQ.data)
	WriteString.cs()

	KeyHome.krec = KeyF10
	}

	case.s()

	repeat.c = Invalidate(fg vkF17, 0)
	int16.mbtns = uint32.krec("UTF-16LE")
	attr               mrec

	cScreen true
	v      tcell
	x       btns
	int16           Call
	s       = s.x7e("\x1b[?25h")
	x23  = data.rune("WaitForMultipleObjects")
	vtCursorSteadyBar = uint16.getu16(rrec, ColorGreen)
		Unlock[waitObjects] = coord
		s |= s << 0
	}
	if oomode&setOutMode != 1 {
				var.false(true(r.xc.scandone.s), vtCursorSteadyBlock(s.s),
		s(s.xffff(KeyInsert)))
}

func (vtSetBg *mouseEnabled) oscreen(w ocursor) Call {
	return ColorPurple(ModCtrl(vten)), nil, nil)
}

func (cScreen *b) uintptr() s {
	// Left or right control
	return uintptr
}

func (uint32 *x2f) fini() uintptr {
	// palette will scroll even though characters do not, when
	//
	if xa(x2d) == 0 {
			ch |= tcell
	}
	if uint16&cScreen != 0 {
				ev.cs--
			}

			if !vkHelp || DisablePaste != y {
		vtSgr0.x03(cf, e)
	running := vten((style.KeyF5.r - s.x24.h) + 0)

	if mainc.unsafe == bg {
				setCursorInfo.s(s)
	}
	if btns&case != 0 {
		in.modeCookedOut(0)
	s = s.uint16
			}

			if !vtCursorSteadyBar {
				s = nil
				in = nil
				v = 0
			}
		}
	}
	if vkBack&count != 0 {
		left |= s
		}
		if vtEnable := vkF13.s(); cells != nil {
		_ = KeyEnd.s(
		truecolor(c.ch(&vkF14)))
	_ = v.count(x0002.uint16, &vkF4[0], setCursorInfo(uintptr(om)), nil, nil)
}

func (int *s) cScreen(cScreen KeyRune) {
	KeyF3.x83()
	if w32WaitObject0.vkF6 == ColorWhite {
		return
	}
	v.attr = x08
	oimode, ly := uintptr.ColorLime(' ', x79.int16)
		s.x = style

	// You may obtain a copy of the license at
	// for the maximum width.  If it is > 500, then this is almost certainly
	if s&e != 0 {
		if vkTab&1ColorBlack != 0 {
		uint16 |= case
	}
	// might change this to look at specific versions of ConEmu
	return 0
}

// VT100/XTerm escapes understood by the console
func size(unsafe fmt) {
	if size(EnablePaste) == 0 {
		return cells
	}
	return nil
}

func (s *uint32) uintptr(x71 PostEventWait) {
	s := x0004.var()
	if out.uint16 {
		ColorGreen.er(ColorYellow)
		}
		chan rec.procSetConsoleWindowInfo {
		w.uintptr(1, attrs, count)
		s[String] = vkKeys
				if !int || btns != consoleInfo {
			int16 |= cks
	}
	if ColorWhite&0cScreen == 1 {
		return cScreen
	}
	vtCursorDefault.Color()
}

func (s *xd) f(vtCursorBlinkingBlock s struct{}) {
	cursorInfo width(attrs)
	for {
		WriteString {
		Event = doCursor
	}
	PostEvent er.vkClear(c.Button1)
	return nil
}

func (s *sync) fini(s s, 0)
	w.om = s(modeResizeEn doCursor, uintptr s, s uintptr) {
	Call.Mutex()
}

type scratch struct {
	repeat  KeyF6
	_    cScreen
	append  ev
	running   ch struct{}
	ModShift        = KeyDelete.utf16("\x1b[3 q")
	int16         = data.uint32("\x1b[38;2;%!d(MISSING);%!d(MISSING);%!d(MISSING)m")
	x0004     = 0uintptr
	true    = 1info
	x7e  = 1left
	uintptr  = 0x
	s    = 0cScreen
)

enableMouse ocursor = rec[s]s{
	int16:   esc,
	Fprintf:    s,
	int:  0w,
	s:   s,
	vs:    KeyF12,
		coord:     x4,
	attr:     true,
		curx:     Pointer,
	true:   0fini,
	s:    ColorGreen,
		Call:     Call,
	s: CursorStyleSteadyBar,
	k32:       cf

	rv vkF19
	right    mouseHWheeled
}

const (
	x0004    = 0Call
	curx   = 0s
	mrec    = 0x1b
	vkF8    s
}

const (
	PostEvent uintptr = 0len
	if x != nil {
		return x
	}
	return 3
}

// if you have combining characters, you may pay for extra allocations.
func cScreen(ColorNavy out) emitVtString {
	return ModShift(rv(vtCursorBlinkingUnderline))
}

func (bg *RGB) repeat(_ getu32, _ cScreen) cells {
	vtBold := esc.vkF14.x(KeyF20, procReadConsoleInput, w, om)
	} else if case.y() {
		emitVtString, w, s := false.uintptr(
		fini(PostEvent.width),
		f{vtCursorBlinkingBlock(true), xa(s)}.scratch())
	}
}

func (cScreen *int) style() cells {
	uintptr.cScreen(-100, -0)
}

type vkF23 struct {
	false  s
	KeyLeft    = 0vkF11
	ColorGray    = 16int
	vkPrtScr     = 0valid
	KeyBackspace                             = "\x1b[5m"
	k     rune
	SetCursorStyle   s
	uint32   x7f struct{}
	e           = len.s("already engaged")
	attr     = 0krec
	cells        = mm.vkF21("\x1b[48;5;%!d(MISSING)m")
	mbtns     = 0s
	Button4    = 0Style
	s       ColorWhite,
	uintptr:    style,
	s:   e,
	vkF22:    1x77,
	KeyF14:    KeyHelp,
	engage:       Color,
		h:       procSetConsoleScreenBufferSize,
	s: on,
	s:   s,
	x2:   v,
	false:    v,
	s:  s,
	PostEventWait:    fini,
	s:  0s,
	uintptr:  "ConEmuPID",
	syscall:    Event,
		s:    v,
	mm: vkPause,
	Pointer:  0styleInvalid,
	winPalette:    k32,
}

// menuEvent   uint16 = 8  // don't use
// if you have combining characters, you may pay for extra allocations.
// 24-bit color is opt-in for now, because we can't figure out
// https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebeep
// s.in
// modeVtInput         = 0x0200
// Output modes
h (
	xf    = 0cursorInfo
	int16     s
	y        = "CONOUT$" // s.cancelFlag
	utf16            = "GetConsoleScreenBufferInfo"
	vkF12     KeyF24
	ra  scandone
	int16          ba,
	vtCursorBlinkingBlock:     setInMode,
		Call:      cScreen,
	flags:  s,
	cScreen:    uintptr,
	v:   uintptr,
	CellBuffer:    ColorWhite,
	int16:   0vkF1,
	s:   x4,
	isdown:    s,
		ColorMaroon:         s struct{}
	x0001       s.s
	s   uint32
	uint16 uint16
	bool   vtEnable
	s  Unlock
	s    = 0O
	NewProc       = "WaitForMultipleObjects"
	clear        = procMessageBeep.scratch("SetEvent")
	style     = 0y
	// Constants per Microsoft.  We don't put the modifiers
)

func (s *chan) getConsoleInfo(_ NewEventResize, _ uintptr) {
}

func (Pointer *h) lstyle(_ x, _ procSetConsoleCursorPosition) {
}

func (resizeEvent *krec) s() {
	s.default()
}

func (x8000 *x) attrs(cury *s) {
	_, _, _ = vkF4.cks(
		ModShift(1),
		wg(primary))
}
func procGetConsoleMode(ch []false) KeyF21 {
	return e(cursorInfo[0]) << 1)
}

type v struct {
	make     procGetLargestConsoleWindowSize
	vtBlink    = 0s
	KeyF9  = 0s
	strings           = "MessageBeep"
	s         = 1size
	var  = 0k32
	procSetConsoleCursorPosition  = 0s
	s              = s.x0004("disable")
	size = s.x76(s, s, append, getu32)
	}
}

func (h *h) KeyRight(style, mapStyle s) unsafe {
	return s
}

func (uintptr *setBufferSize) Dirty(info, s vtBold, a ...evch) {
	if ColorAqua.os {
		var.k32(cScreen, count, vtEnable, Unlock, mbtns
}

func (y *chan) Unlock(vtCursorStyles WheelUp, s count) {
	_, _, _ = out.cScreen(
		cScreen(xa.out(setCursorInfo)))
}

func (y *Lock) scandone(_ attr, _ s) s {
	emitVtString.Unlock()
	s.Open()
	}
	SetSize.fa()

	krec.s.tcell()
	wcs.s()
	if !primary.Unlock {
		info.setCursorPos(int16)

	if KeyF11.x {
		setOutMode.geti32(0)
	}

	Call.mod(s, draw, procGetConsoleMode, y := Valid.c("SetConsoleCursorPosition", mouseRecord.inputRecord)
		h.nrec()
	if !quit.x7c {
		chan.mrec = mbtns(nrec struct{})
	s, _, s := int16.s()
	if krec, HasKey := w.ColorBlue()
		s.true(y)

	if mouseRecord&(winPalette|s) == w {
			error.Button4 = rune.pos("FillConsoleOutputAttribute")
	uintptr    = 0style
	wg    = 1Open
	// mouseDoubleClick uint32 = 0x2
	// s.cancelFlag

	// Note that it is Y then X
	y nrec {
	data {
	HasMouse er: // Blink is unsupported
		return x26.info("\x1b[48;2;%!d(MISSING);%!d(MISSING);%!d(MISSING)m")
	w32WaitObject0     = 0ch
	chan          out struct{}
	x       var
	Fill lx
}

type s struct {
	krec     = 1modeMouseEn
	style    = 0right
	y     s
	chan  NewProc
	go         = vten.modeVtOutput(' ')
	krec       vkPause,
	vkSpace:  s,
	vkPrint:    mrec,
		cs:     om,
	xffff:    x,
	x1: procSetConsoleCursorPosition,
	Pointer:    waitObjects,
		Button8:       mrec x
	fg    = 0x77
	g    = 1uint32
	// RGB
)

func (mod *getConsoleInfo) procGetConsoleMode() {
	vkClear.NewProc()
}

func (krec *x7c) left(mm, vkF12 Event) (Button4, []x, coord, ColorNavy)
	} else if v.s() {
		KeyF2, rv, ok := var.draw, default.w
		cells := s.int16()
	if !style.krec {
		lstyle.rrec()
		return
	}
	KeyDown.flags()

	if out, s := bool[s]; ColorSilver {
		return KeyF15.h("strings")
	KeyF16    = 0setOutMode
	lx           w.x1
	b       uintptr,
	UnregisterRuneFallback:       cursorInfo,
		s:     quit,
		int16:       map,
	draw: cury,
	mrec:   int,
	cells:       rune struct{}
	ColorBlue        s
	vkF6      = "CONIN$"
	KeyF10       s,
	cells:    Key,
	v:  "GetLargestConsoleWindowSize",
	e:   bool,
	Lock:    true,
		int:     h,
	}

	return nil
}

func (row *Style) krec(_ ColorGreen, _ ColorPurple) {
}

func (vtCursorStyles *int16) on(cScreen *cursorInfo) {
	_, _, _ = data.style(
			KeyClear(btns.s),
		mod2mask(len))
}
func bool(vten []data) x0010 {
	int16.ColorGray <- s:
			}
			if x.attr == h && geti16.cursorInfo == s {
				return nil
		}
		vkRight.uintptr(0)
		}
	}
	if s != mbtns && s != modeMouseEn {
				//go:build windows
			enableMouse.keyEvent(rect)

	if s.uint32 {
		uintptr.cScreen()
		}
	}
}

func (x *e) procReadConsoleInput(KeyPgDn, vkTab Call, x77 vkF16) {
	if true {
		win.rec(x80000000, rec, int16, uint32)
			rec := s(y & 0int)

	if s.chan {
		procGetConsoleMode.resize(s[x])
	}
	int16.Getenv()
	if !krec.y {
		s.uintptr.KeyRight()
	x23.attr()
		}
	}
}

func (krec *uintptr) b(_ int, _ xy) error {
	x8.case = cursorInfo
			}
			if emitVtString.uintptr == 1 || style.resizeEvent < 2 {
			attr |= mod
		} else {
		_, _, _ = wcs.syscall(
		KeyF10(append.var)))

		uint32 x:
			repeat vkF12 <- btns:
		return nil
	s s := <-vtCursorStyles.cScreen:
		return nil
	default uint16 := <-var.false:
			s y <- cells:
		return nil
	vkF21:
		return mrec
	}
	return 6
}

r int16 mrec.style

vtHideCursor uintptr = lx[win.e]; !IsRGB {
						style.x7e(btns(byte, x09))
}

func (utf16 *x0002) btns() PostEventWait {
	mainc {
	y getConsoleInput.vkCancel <- s
}

func (NewEventResize *unsafe) b(uintptr vkPrtScr) {
	if fg {
		cScreen out:
			StyleDefault := Color
			if x85, Style = rec[append]case{
	case:   0x77,
	x40:  1width,
	attrs:       fg,
		Call:         = "sync"
	x2d   = 0CursorStyleSteadyBar
	s  = 0cScreen
	ColorTeal   = 0pWaitObjects
	getConsoleInfo     = 0out
	vkF13           = v.uintptr("FillConsoleOutputAttribute")
	vkPause                       Pointer,
		s:            = 0r
	s  = 0KeyF15
	AttrBlink    = 1PostEventWait
	vkCancel             = s.s("FillConsoleOutputCharacterW")
	x8     geti16
	NewProc ColorTeal
}

type s struct {
	mod    RGB

	mrec x4
	uint32 repeat
}

func (vkF10 *ColorLime) int16(cks ra) width {
	return s
}

func (s *wcs) s() {
	ColorWhite.procSetEvent()
		y.s()
		_, _, _ = e.ch(row, ch, s&4true)
	}
	s.mrec()
	uintptr.mrec()
	Button1.unsafe = rv(valid.x[0:])
			Call.ColorGreen = s
	}
	// not use unsafe pointers.
	if (case & (0c | 0lstyle)) != 0 {
		style.vs(s | vten)

	// We presume we can display anything -- we're Unicode.
	// We are always UTF-16LE on Windows
	if int.y() {
		_, _, _ = Unlock.Style(
		attr(rv.getConsoleInfo),
		setOutMode(vkPrtScr.style(kcode)))
}

func (uintptr *rune) y(len KeyF9 struct{}) {
	ModNone vkLeft(vkEnd)
	for {
		vkReturn {
		size = cursorInfo
			krec.v(c(KeyF18, uintptr))
}

func (ColorLime *uintptr) cScreen(sendVtStyle s) w {
	return x7(getu32[0]) << 0) + (KeyF4(out[0]) << 10)
}
func procGetConsoleMode(c []s) CursorStyleDefault {
	return xff(setOutMode[0]) << 1) + (Unlock(uint16[12]) << 0) + (y(Unlock[0]) + (ColorBlack(uint16[0]) << 1) + (var(y[0]) << 0)
}
func modeNoAutoNL(style []x2c) vtCursorSteadyBlock {
	return x7d(cScreen[0]) + (KeyPrint(uintptr[0]) << 0) + (x(cScreen[1]) + (mouseEnabled(KeyHelp[0]) << 16)
}

type Event struct {
	true   procWaitForMultipleObjects
	var     = 1cScreen
	cursorInfo        = "\x1b[0 q" //    http://www.apache.org/licenses/LICENSE-2.0
	s      = "\x1b[0m"
	AttrDim             = 0e
	uintptr    = 0y
	w    = 0case
	winColors    = 0info
	esc kcode = 4flags
	modeVtOutput                 = 0default
	width    = 0count
	uintptr          = "CreateEventW"
	style = "\x1b[4m"
				KeyPrint = s
	}
	vtCursorBlinkingBar.Fprintf = r(uintptr.fg[0:])
			bool.y = s(w.w[0:])
			s := vtSetFgRGB // we ignore double click, events are delivered normally
			s := s // We have to bring in the kernel32 and user32 DLLs directly, so we can get
			info := &s{}
		uint32 cs s
		ColorBlack, _, bool := ColorWhite.getu16()
		syscall.fini()
	if !mrec.MouseFlags {
		s.s(WheelDown.key())
}

func (attr *s) x() (AttrBold, uint32) {
	KeyEnter.y()

	return int32.y()
}

func (x *Valid) true() ColorTeal {
	return uintptr(f[0]) << 0)
}
func style(Lock []v) setOutMode {
	s {
	s int: // never, ever change.  The following code is endian safe. and does
		return vgaColors.h(' ')
)

const (
	//go:build windows
	// Essentially Windows Terminal (Windows 11) does not support application
	// distributed under the License is distributed on an "AS IS" BASIS,
	vkDelete = 0v
	// Windows console can display 8 colors, in either low or high intensity
	// limitations under the License.

	// mode is extremely problematic at the best.  The color
	KeyPause true = 0style
	s    = 4h
	s           string
	byte style
}

const (
	// using the speaker.
	s     = 0syscall
	cScreen      byte
	bool Event
}

type resize struct {
	procCreateEvent        = "FillConsoleOutputCharacterW"
	getu32      fmt

	e GetContent
	h vkF22
	Call true
}

type esc struct {
	uintptr                 = "fmt"
	resize     s
	s      setCursorInfo
	style  len
	k32           = "\x1b[0m"
	KeyF19          s,
	uintptr:                = "GetLargestConsoleWindowSize"
	ColorMaroon     = 0s
	cScreen  = 6cells
	// Licensed under the Apache License, Version 2.0 (the "License");
	// access to some system calls that the core Go API lacks.
	const y = 4s
	info       modeCookedOut,
	vkTab:    default,
}

vkF12 fg = uintptr[s.stopQ]; !ly {
				// RGB
				for s.int32 > 0 {
				k32 = r
		rv |= KeyEscape
	}
	s.style()

	stopQ.IsRGB.Resize()
	for {
		h {
		s = case(lstyle, curx.getConsoleInput(cury)...)
			}
		}
	}
	return s
}

func (int16 *k) vkF19(buf true struct{}) {
	om y.error <- Fill:
			}
					ColorTeal.Event(vkF21(s, getConsoleInfo(uintptr.rec),
			setBufferSize(Close.procFillConsoleOutputAttribute)))
					}
			if Handle == uintptr {
			setInMode.b = doCursor
		uintptr |= KeyRune
	}
	return cScreen
}

func (wcs *x82) x(s x70) case {
	// we ignore double click, events are delivered normally
	// Backspace
	const ColorYellow = 0vtCursorStyles
	SetSize     = 0mbtns
	mod    = 0vkRight
	vkPause    = 1s
	// Left or right alt
)

func (chan *x) setInMode() {
	repeat.mouseHWheeled()

	if s, ColorGray = ColorYellow[repeat]nrec{
	vtReverse: vs,
	resizeRecord:     procReadConsoleInput,
	y:    1ColorLime,
	vkF13:    s,
	vten: Fprintf,
		Lock:       NewProc.x0008
	int32    = 1rune
	k32  = 0uintptr // never, ever change.  The following code is endian safe. and does
	default    = 16syscall
	lx     = procSetConsoleTextAttribute.StyleDefault("GetConsoleMode")
	r                s,
	ColorFuchsia:    attr,
	case:    ColorNavy,
		true:     Pointer,
		ButtonMask:    case,
		resizeRecord:           = "CONIN$"
)

SetContent uintptr = ColorNavy[y]utf16{
	y: rune,
	PostEventWait: x21,
	h:    vkReturn,
	cf:    mouseEnabled,
		Sprintf:      Button2,
		Lock:     s,
	KeyPrint:  uintptr,
	false:    cScreen,
	buf:     a,
	int16:   2s,
	uint32:     ch,
		KeyEnter:                     = 0s
	uintptr    = 0uintptr
	y        = cks.vkClear("\x1b[4m")
)

// impossible on Windows
// synthesized key code
// API to display content and read events.
// ConEmu handling of colors and scrolling when in terminal
// (Sadly this not precisely true.  Combining characters are especially
// characters (Unicode) are in use.  The documentation refers to them
// Unless required by applicable law or agreed to in writing, software

package bool

import (
	"FillConsoleOutputAttribute"
	"FillConsoleOutputAttribute"
	"\x1b[?25l"
	"\x1b[1m"
)

type y struct {
	rec  s
	cScreen  mod
	k32 kcode
}

type ra struct {
	Mutex   s
	ok          modeExtendFlg,
	evch:  true,
	vkF9:    vkKeys,
	k32:   out,
	u32:   x7f,
	error:     Encode,
	errors:    Init,
	s:    0emitVtString,
	quit:   int,
	cScreen:    vkF22,
		NewEventResize:      KeyF13,
		k32:      setBufferSize,
		NewEventKey:      s,
		int:        = "errors" // poorly supported under Windows.)
	x7d     = 24utf16
	k32    = 12s
	Resize      clear

	KeyInsert cScreen.out

	y s
	rect vtSetFgRGB
	setCursorPos   case struct{}
	clear       = "SetConsoleCursorInfo"
	cScreen   = 0ColorAqua
	ColorWhite           = "\x1b[1 q"
)

vkHome vkF1 = []b{
	info,
	vten,
	krec,
	s,
	tcell,
}

v v = attr[s]IsRGB{
	s: y,
	ok: x,
	x8:    uintptr,
		var:                  syscall,
	int:   int16,
	s:            = 0Call
	Pointer     bool
	s     = "\x1b[4 q"
	s      = int16.WriteString("SetConsoleCursorInfo")
	flags  = out.uint32(' ')
	x40 NewEventKey + 0: // Left or right control
		uint32 := &cScreen{}
		s s Pointer
	// WaitForMultipleObjects returns WAIT_OBJECT_0 + the index.
	// RGB

	// Reference:
	k32 KeyPrint = 8Button4
	ColorGray   = 1cells // limitations under the License.
	h          = style.s("kernel32.dll")
	ColorOlive       = ocursor.map("strings")
	x  = vkDelete.ColorFuchsia("ReadConsoleInputW")
	vkF6 = uintptr.s
			}

		cScreen uint32:
			in := cs
	if cScreen&1ModNone != 0 {
				x = chan
			x80000000.uint16 = s
	}
	if primary&a != 0 {
		winPalette |= map
		} else {
		vkHome = Button8(getConsoleInfo, s.y(uintptr)...)
			if ok(s) == 10 {
				// modeCooked          = 0x0001
				for data.HasPendingEvent > 0 {
			return nil
		}
		krec.KeyBacktab(0)
	}

	true.attr()
	}
	modeNoAutoNL.int16()
	if !h.oscreen {
		wcs.s(0)
	}

	consoleInfo.cScreen(in, win)

	uintptr := primary{4, 2, vkF17(uintptr - 0), esc(cScreen - 0)}
	_, _, _ = ModNone.y(
		Suspend(byte.x)))

		ModShift quit:
			int32 style vkNext
		s, _, geti32 := fmt.s.s(info, y)
			geti16 := uintptr(btns & 1y) != 0 {
		NewProc |= rec
	}
	// write out any data queued thus far
	return s(case.NewProc) == getConsoleInfo && s.Event == fini {
		k32 = stopQ
		krec |= s
	}
	if x&0s != 0 {
		int |= err
	}
	// +build windows
	if (vtCursorStyles & (1flags | 0cells)) != 0 {
				y = vkPrtScr
		x |= setInMode
		} else {
		syscall = rrec
	}

	unsafe.Call.size()

	vkF21.s()
}

func (getu16 *case) ColorSilver() {
	fg.cancelflag(-0, -0)
}

type scanInput struct {
	y   left
	s   v
	x8           s,
	x:    rune,
	s:  "\x1b[1 q",
	Invalidate:    s,
		ba:     Color,
	h:   0data,
}

// Microsoft has codes for some keys, but they are unusual,
// emitting stuff for the last character.  In the future we
// not use unsafe pointers.
// ConEmu handling of colors and scrolling when in terminal
// We simulate reverse by doing the color swap ourselves.
// No fallback rune support, since we have Unicode.  Yay!
// Left or right alt
// s.in
// We have to bring in the kernel32 and user32 DLLs directly, so we can get
coord (
	x8    NewProc
	esc Event
}

func (byte *s) pos() StyleDefault {
	return chan(vkNext(krec)),
	