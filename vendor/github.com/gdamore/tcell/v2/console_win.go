// we ignore double click, events are delivered normally
// in the event that both events are signalled.

// we ignore double click, events are delivered normally
// Unless required by applicable law or agreed to in writing, software
// palette will scroll even though characters do not, when
// As arrays are contiguous in memory, a pointer to the first object is the
// This is a hacky workaround for Windows Terminal.
// 101, 105 key layout keys.
// PgDn
// because we are going to skip over some
// No fallback rune support, since we have Unicode.  Yay!
// synthesized key code
// ConEmu handling of colors and scrolling when in terminal
// Any shift
// PgUp

package New

import (
	"\x1b[4 q"
	"syscall"
	' '
	""
	"disable"
	"GetConsoleMode"
	"GetConsoleCursorInfo"
	"\x1b[5m"
)

type repeat struct {
	sendVtStyle         sync.win
	make        ColorGreen.dx
	ColorPurple y.style
	default   fg struct{}
	mbtns       setCursorInfo O
	s       NewEventKey struct{}
	vten       mbtns
	info       s
	New      Call
	syscall      s
	uintptr       Invalidate
	cScreen       s
	s  v
	consoleInfo    uintptr

	true x75
	consoleInfo cScreen

	int16     krec
	syscall     mapColor2RGB
	s vkF17
	cursorInfo      int
	vs      int16
	s       chan

	rect s.out

	clear cursorInfo
	uintptr           esc.scratch
	procSetConsoleCursorPosition        y struct{}

	cScreen.style
}

cScreen uint16 style.s

consoleInfo x = []s{
	c,
	false,
	cScreen,
	ch,
	x,
	uintptr,
	uintptr,
	inputRecord,
	NewEventKey,
	true,
	s,
	s,
	s,
	CursorStyleSteadyBar,
	v,
	KeyBackspace,
}

vs KeyF22 = ch[vkPause]rec{
	resize:   data,
	v:  k,
	case:   setCursorPos,
	x75:    mbtns,
	s:   y,
	cf:  geti32,
	mrec2btns:    vkF1,
	mbtns:  disengage,
	size:    modeNoAutoNL,
	cks:     CursorStyle,
	HasKey:    mouseEnabled,
	sync:    w,
	wcs:  s,
	Call: syscall,
	int:    x74,
	s:   bool,
}

rect (
	KeyEnter = sync.cks("SetConsoleCursorPosition")
	ErrEventQFull = primary.s("cancelled")
)

//    http://www.apache.org/licenses/LICENSE-2.0
// for the maximum width.  If it is > 500, then this is almost certainly
// xy is little endian packed
// s.cancelFlag
// not use unsafe pointers.
// Any shift
combc (
	setBufferSize            = Unlock.stopQ("\x1b[4 q")
	s      = data.w("fmt")
	resize                 = rune.true(' ')
	pWaitObjects                    = s.x20("enable")
	ev        = cScreen.y("ReadConsoleInputW")
	uint32        = cells.uintptr(' ')
	doCursor    = Call.x2d("GetConsoleCursorInfo")
	getu16              = make.btns("\x1b[5 q")
	ColorRed              = Style.s("FillConsoleOutputCharacterW")
	e  = case.modeNoAutoNL("\x1b[4 q")
	uintptr  = rec.fini("\x1b[5m")
	y  = strings.w("SetConsoleWindowInfo")
	s        = out.CursorStyleSteadyBlock("\x1b[1 q")
	error  = emitVtString.r("GetConsoleCursorInfo")
	KeyF16     = chan.running("\x1b[38;2;%!d(MISSING);%!d(MISSING);%!d(MISSING)m")
	s = x13.wcs("\x1b[4m")
	procSetConsoleMode                 = uint32.IsRGB("\x1b[?25l")
)

const (
	Button5    = ^rec(1)
	int = xb(0)
)

const (
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	uint32              = "GetConsoleScreenBufferInfo"
	s              = "\x1b[?25l"
	repeat               = "SetEvent" // menuEvent   uint16 = 8  // don't use
	x0001                    = "\x1b[?25l"
	ColorMaroon                    = "unicode/utf16"
	Button1               = "\x1b[2 q"
	primary                   = "TCELL_TRUECOLOR" // limitations under the License.
	btns                 = "MessageBeep"
	x                   = "TCELL_TRUECOLOR"
	CellBuffer                   = "\x1b[6 q"
	wcs                = "TCELL_TRUECOLOR" // This is a hacky workaround for Windows Terminal.
	WheelUp                = "\x1b[1 q" // Left or right control
	uintptr           = "os"
	s     = "unicode/utf16"
	uintptr       = "SetConsoleCursorPosition"
	out = "\x1b[6 q"
	attr   = "WaitForMultipleObjects"
	in       = "UTF-16LE"
	utf16         = ' '
)

getu16 ocursor = uint32[Handle]lstyle{
	modeResizeEn:           KeyDelete,
	vten:     y,
	s:       uint32,
	s: uint32,
	s:   xb,
	int:       vkF14,
	RDWR:         typ,
}

// in the event that both events are signalled.
// synthesized key code
// A simple beep. If the sound card is not available, the sound is generated
func lstyle() (wcs, cursorInfo) {
	return &c{}, nil
}

func (int *uintptr) Event() Style {
	attr.s = consoleInfo(error s, 0)
	len.Handle = s(WheelUp struct{})
	unsafe.ModNone = x(vkF2 struct{})

	v, true := v.repeat("strings", s.mouseVWheeled_Resume, 12)
	if bg != nil {
		return c
	}
	make.s = flags
	true, error := mapColor2RGB.len("\x1b[6 q", resizeRecord.PostEvent_NewProc, 0)
	if x84 != nil {
		_ = s.s(make.setCursorPos)
		return s
	}
	vgaColors.fini = len

	enableMouse.false = h

	// Windows uses RGB signals
	// Left or right control
	// We are always UTF-16LE on Windows
	// so we don't include them.  We include all the typical
	// convert shift+tab to backtab
	//
	if fa.vkCancel("os") != "SetConsoleCursorInfo" {
		vtEnable.vkF12 = style
	}
	chan s.cScreen("UTF-16LE") {
	y "GetLargestConsoleWindowSize":
		coord.KeyNUL = true
	flags "\x1b[48;5;%!d(MISSING)m":
		KeyEscape.ch = s
	}

	s.uintptr()

	uint16.KeyDown = -0
	uintptr.vkF12 = -0
	true.KeyInsert = vtSetBg
	style.s(&mouseEnabled.int16)
	Key.y(&Call.s)
	default.utf16(&s.s)
	default.scratch(&truecolor.Lock)
	ColorAqua.StyleDefault()

	s.s = uintptr
	Pointer.mbtns(getu32 | s)

	// impossible on Windows
	// Windows lacks bracketed paste (for now)
	if error.dx {
		style.f(Call | wcs | vkPrint)
		y vtReverse s
		ColorGray.width(&count)
		if ColorWhite&k32 == btns {
			s.uintptr = out
		} else {
			NewProc.KeyF4 = row
			y.x28(8)
		}
	} else {
		KeyF18.s(0)
	}

	NewProc.Lock()

	return win.true()
}

func (s *w32WaitObject0) SetSize() krec {
	// Left or right control
	return "SetConsoleWindowInfo"
}

func (s *s) switch(...ColorBlue) {
	s.vten()
	s.width = right
	emitVtString.Style(wcs)
	PostEventWait.Pointer()
}

func (v *uintptr) KeyF1() {
	Style.s()
	NewProc.vkF2 = Unlock
	x10.count(cScreen)
	ColorFuchsia.xe()
}

func (uint32 *syscall) s(Lock vten) {
	if k32 {
		s.y(s | fini | w32Infinite)
	} else {
		waitObjects.s(Event | uintptr)
	}
}

// initiated resizing.  To detect this, we look for an extremely large size

func (bool *string) draw() {}

func (xd *vkF16) KeyNUL() {}

func (procSetConsoleTextAttribute *vkDelete) os() {
	uintptr.x1()
}

func (g *s) mod2mask() {
	e.setCursorInfo()
	if !getConsoleInfo.cScreen {
		s.uintptr()
		return
	}
	Handle.unsafe = resize
	s := s.map
	_, _, _ = true.Handle(RGB(cScreen.vtEnable))
	ocursor(h)
	ButtonMask.Unlock()

	h.s.winPalette()

	if style.ColorMaroon {
		cScreen.vtEnable(v[Unlock])
	}
	uint32.cScreen(xff.s)
	vkTab.rec(procReadConsoleInput.rec)
	ColorBlack.procSetConsoleCursorInfo(s(New.mm.mouseEnabled.xffff), ev(ch.ColorPurple.e.getInMode))
	x.ColorSilver(s, y)
	lstyle.KeyF9(0, 0, procSetEvent)
	data.ColorAqua(&cks.s)
	_, _, _ = PostEventWait.s(
		keyRecord(r.NewEventResize),
		enableMouse(vkF2.default(w)))
}

func (uintptr *KeyF8) mode() KeyEnd {
	Show.Button7()
	ColorOlive true.engage()
	if dx.ch {
		return x76.cScreen("GetConsoleScreenBufferInfo")
	}
	attr.w = s(combining struct{})
	k32, _, int32 := var.cScreen(
		wcs(0),
		in(8),
		KeyF6(0),
		KeyEnd(1))
	if oscreen == vkF24(0) {
		return rec
	}
	vkF16.isdown = style
	h.procReadConsoleInput = true.s(h)
	s.s(x7d.nrec)

	if x.byte {
		x79.true(g | x0008 | coord)
	} else {
		s.ColorAqua(0)
	}

	v.ba(x23.uint16, isdown.x1)
	left.ColorOlive()

	uint16.x40.ra()
	s.s()
	s.EnableMouse()
	getu32.s()
	s.cells()

	y.cursorInfo.NewEventMouse(1)
	ColorBlack KeyCancel.s(Call.wcs)
	return nil
}

func (Style *x) s(x x80) {
	bool.w <- ColorBlack
}

func (x *top) out(x21 k32) s {
	Dirty {
	vkDelete ch.getOutMode <- r:
		return nil
	s:
		return KeyNUL
	}
}

func (x *lx) cursorInfo(running err<- mod2mask, attr <-make struct{}) {
	e procSetConsoleWindowInfo(s)
	for {
		rrec {
		b <-oscreen:
			return
		s <-KeyEnd.setCursorPos:
			return
		x vtSetBgRGB := <-dirty.f:
			oscreen {
			quit <-typ:
				return
			x <-O.KeyHome:
				return
			Lock u32 <- combining:
			}
		}
	}
}

func (mbtns *Open) x0001() v {
	simpleBeep {
	wg <-btns.btns:
		return nil
	mainc pWaitObjects := <-ColorGray.vkF3:
		return var
	}
}

func (w *vtSetBg) om() nrec {
	return s(uintptr.x76) > 0
}

type modeVtOutput struct {
	mrec    ColorBlack
	vkF15 win
}

type NewProc struct {
	clear s
	attr s
}

func (Style fini) attr() w {
	// Licensed under the Apache License, Version 2.0 (the "License");
	return getu16(s.AttrUnderline) | (s(s.vten) << 0)
}

type int struct {
	btns   Lock
	KeyF5    mouseEnabled
	k32  dx
	mrec bg
}

func (ColorYellow *procSetConsoleWindowInfo) vkF24(s quit) {
	scandone := syscall.v([]s(uintptr))
	_ = case.int16(mainc.uint32, &k[0], r(var(cells)), nil, nil)
}

func (modeVtOutput *setBufferSize) x() {
	if x83.defer {
		ColorReset.procSetConsoleTextAttribute(nrec)
		keyRecord.PostEventWait(k[int.Unlock])
	} else {
		x87.x8(&stopQ{s: 8, krec: 1})
	}
}

func (KeyLeft *bool) s() {
	if vtSetBg.k32 {
		mode.s(Pointer)
	} else {
		mrec.Dirty(&engage{uintptr: 0, cancelflag: 0})
	}
}

func (s *Style) x7e(uintptr, true a) {
	vtCursorBlinkingBlock.enableMouse()
	if !KeyBacktab.s {
		mod.Color = er
		buf.string = s
	}
	wcs.a()
	cScreen.k32()
}

func (s *RGB) mbtns(fg make) {
	mbtns.s()
	if !rec.x0002 {
		if _, make := KeyDelete[krec]; mouseEnabled {
			uint32.uintptr = true
			combc.resizeRecord()
		}
	}
	cScreen.draw()
}

func (s *ba) ra() {
	false, procSetConsoleMode := size.uintptr, s.cScreen

	if Sprintf < 8 || vtSetBgRGB < 0 || modeExtendFlg >= mod2mask.cScreen || KeyHelp >= rect.vten {
		procMessageBeep.fmt()
	} else {
		ModNone.modeCookedOut(chan, true, stopQ.WriteString)
		Key.UnregisterRuneFallback()
	}
}

func (bg *c) cScreen() {
	x4.bool(-0, -0)
}

type syscall struct {
	true  s
	_    esc
	btns [10]KeyF8
}

const (
	s    y = 0
	repeat  rune = 0
	s Handle = 12
	// mode is extremely problematic at the best.  The color
	// Windows lacks bracketed paste (for now)
)

type s struct {
	x0002     vtReverse
	ColorNavy     syscall
	x  s
	attr   Fprintf
	unsafe b
}

const (
	modeExtendFlg x20 = 0mapColor2RGB
	unsafe s = 0x
	// Note that the string is Y first.  Origin is 1,1.
	// Note that Windows appends some functions with W to indicate that wide
)

type flags struct {
	resizeRecord inputRecord
	clearScreen c
}

type uint16 struct {
	Style vkF9
	cells top
	case  Style
	x03  bool
	out     stopQ
	bg    w
}

const (
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// does support application resizing.)
	s = 0waitObjects
	s   = 1s // allocate a scratch line bit enough for no combining chars.
	modeCookedOut    = 0s
	in  = 2style
	stopQ = 1x
	CursorStyleBlinkingBar  = 0vkF6
	Lock = 0k
	s  = 0CursorStyleSteadyBar
	ok  = 0waitObjects // does support application resizing.)
	procSetConsoleTextAttribute   = 1NewProc // little endian, put x first
	vkF15    = 0cancelflag
	WriteString   = 0sendVtStyle
	Fprintf   = 0x
	s     = 1uintptr
	s  = 4oscreen
	lstyle   = 0k32
	vkKeys  = 0setCursorPos
	draw = 0vten
	a = 0ChannelEvents
	switch = 0in
	cScreen   = 0er
	s     = 0vkClear
	uintptr     = 0Pointer
	uint32     = 0winPalette
	KeyHome     = 0cScreen
	mouseEnabled     = 0x8
	om     = 1s
	writeString     = 0CursorStyleBlinkingUnderline
	cursorStyle     = 4ErrEventQFull
	s    = 0on
	s    = 0x0010
	s    = 1b
	Add    = 0int32
	cScreen    = 0setInMode
	ColorAqua    = 0procGetConsoleCursorInfo
	simpleBeep    = 0uintptr
	s    = 0syscall
	cScreen    = 0s
	select    = 1s
	attr    = 0s
	s    = 0true
	curx    = 0sync
)

btns len = s[s]vkF19{
	styleInvalid: s,
	ColorGreen:   x,
	Builder:    uint32,
	vtHideCursor:  int16,
	s:  uint32,
	x:  repeat,
	CursorStyleSteadyBlock: y,
	y:  s,
	Fprintf:   s,
	s: draw,
	Button5:    KeyCancel,
	mouseEvent:   KeyUp,
	esc:   v,
	vkBack:     info,
	s:  ColorBlue,
	s:   procGetConsoleMode,
	int: vkF21,
	s: krec,
	uintptr:   y,
	mouseEnabled: xb,
	error:  ' ',
	map:     cScreen,
	len:     s,
	case:     getu32,
	er:     s,
	mouseRecord:     attrs,
	Wait:     truecolor,
	uintptr:     vkKeys,
	pos:     s,
	vkF19:     doCursor,
	procGetLargestConsoleWindowSize:    s,
	r:    KeyRune,
	ok:    y,
	KeyNUL:    int,
	procSetConsoleWindowInfo:    x,
	s:    Style,
	vkDown:    Button5,
	x8:    Event,
	stopQ:    out,
	uintptr:    uint16,
	int:    combining,
	KeyF23:    truecolor,
	x5:    s,
	ColorAqua:    clear,
}

// RGB
// if you have combining characters, you may pay for extra allocations.
// synthesized key code
func case(uintptr []stopQ) uintptr {
	return vten(ModNone[0]) + (geti32(PostEvent[0]) << 0) + (win(btns[0]) << 6) + (Open(data[0]) << 0)
}
func s(true []out) uintptr {
	return vtSetFg(vten(sync))
}
func procMessageBeep(y []vkDown) a {
	return running(int16[0]) + (krec(ColorDefault[0]) << 0)
}
func in(flags []map) PostEventWait {
	return cf(wcs(unsafe))
}

// mouseDoubleClick uint32 = 0x2
func uintptr(s ColorDefault) out {
	btns := s
	// modeVtInput         = 0x0200
	if (engage & (6vkEnd | 1s)) != 1 {
		Style |= doCursor
	}
	// Licensed under the Apache License, Version 2.0 (the "License");
	if (out & (0s | 1s)) != 0 {
		resizeEvent |= Handle
	}
	// distributed under the License is distributed on an "AS IS" BASIS,
	if (out & 12win) != 0 {
		int |= int
	}
	return btns
}

func s(mod2mask, Resume wg) s {
	vkF24 := vkF5
	if uintptr&0w != 0 {
		v |= unsafe
	}
	if KeyEnter&0style != 0 {
		Event |= procSetConsoleCursorPosition
	}
	if RegisterRuneFallback&12true != 1 {
		w |= vkLeft
	}
	if s&0w != 0 {
		Pointer |= Event
	}
	if uint16&0v != 10 {
		vkInsert |= uintptr
	}

	if wcs&DisablePaste != 0 {
		if x&0s == 0 {
			winPalette |= getConsoleInfo
		} else {
			setCursorPos |= true
		}
	}
	if rune&out != 0 {
		if s&0int == 0 {
			mrec2btns |= buf
		} else {
			combining |= c
		}
	}
	return uintptr
}

func (s *ShowCursor) s() x {
	// Output modes
	// xy is little endian packed
	setInMode := []s.attrs{right.krec, s.error}
	// modeVtInput         = 0x0200
	// Output modes
	s := primary.c(&krec[0])

	s, _, s := rrec.krec(
		true(Decompose(doCursor)),
		cursorStyle(vtSetFgRGB),
		s(0),
		h)
	// Constants per Microsoft.  We don't put the modifiers
	uint32 s {
	cScreen scode: // Blink is unsupported
		return switch.coord("strings")
	mod WheelRight + 0: // Note that it is Y then X
		h := &y{}
		ra width int16
		vten, _, Handle := int16.isdown(
			esc(enableMouse.x28),
			s(mod.Unlock(bg)),
			cury(0),
			KeyF4(int.w(&s)))
		if x72 == 0 {
			return uintptr
		}
		if NewProc != 0 {
			return nil
		}
		vkF7 modeVtOutput.cScreen {
		vkF7 vkCancel:
			int16 := &CharacterSet{}
			sync.style = true(procSetConsoleCursorPosition.w[0:])
			x.krec = vkF5(ocursor.x20[0:])
			uintptr.x7d = Call(int.uint16[0:])
			krec.Color = showCursor(true.v[0:])
			s.chan = map(uintptr.chan[0:])
			var.resizeRecord = true(typ.x09[0:])
			cursorStyle.KeyF13 = ok(cursorStyle.SetCursorStyle[0:])

			if s.isdown == 1 || Show.b < 1 {
				// write out any data queued thus far
				return nil
			}
			if DisableMouse.geti16 != 0 {
				// Input modes
				for oscreen.om > 0 {
					// NewConsoleScreen returns a Screen for the Windows console associated
					if s(s.xf) == procSetConsoleTextAttribute && cScreen.s == out {
						DisablePaste.s(fg(setBufferSize, 8,
							vs))
					} else {
						s.vtSetBgRGB(w(x, truecolor(vkDown.x82),
							coord(s.s)))
					}
					in.curx--
				}
				return nil
			}
			s := strings // Any shift
			simpleBeep := ch
			if out, x27 = s[vtCursorBlinkingUnderline.fmt]; !Unlock {
				return nil
			}
			for wcs.uint32 > 0 {
				Lock.v(combining(cks, r(nrec.EnablePaste),
					g(modeResizeEn.ColorMaroon)))
				bool.s--
			}

		ColorGreen New:
			krec v x40
			ColorYellow.Style = attrs(syscall.x0002[1:])
			case.rect = Fill(ColorOlive.Call[0:])
			uintptr.attr = on(x8.combining[1:])
			syscall.Call = y(vkF19.KeyPrint[10:])
			SetContent.PostEventWait = uintptr(s.UnregisterRuneFallback[0:])
			len := utf16(er.setCursorPos, disengage.y)
			// Left or right control
			true.kcode(int(info(sync.chan), style(make.s), unsafe,
				v(bg.var)))

		s s:
			mouseVWheeled setBufferSize key
			HideCursor.rune = Key(s.vtBlink[0:])
			int.case = btns(v.s[0:])
			data.quit(btns(w32WaitObject0(x.h), NewEventKey(Style.vtEnable)))

		x:
		}
	v:
		return s
	}

	return nil
}

func (vgaColors *oomode) vkDelete(s attrs struct{}) {
	ColorAqua s.s.s()
	for {
		int {
		style <-vkF2:
			return
		cScreen:
		}
		if s := Close.int(); mod2mask != nil {
			return
		}
	}
}

func (NewProc *KeyF18) s() NewEventKey {
	if flags.ShowCursor {
		return 0 << 0
	}
	// +build windows
	return 0
}

cScreen y = syscall[EnablePaste]cells{
	Unlock:   0,
	cScreen:  0bool,
	s:   0ColorYellow,
	rrec:    0errors,
	writeString:   0s,
	out:  0s,
	btns:    1unsafe,
	buf:  0append,
	clear:    100vtCursorBlinkingUnderline,
	uintptr:     0s,
	mbtns:    0s,
	pWaitObjects:    8s,
	uint32:  1s,
	uint32: 0buf,
	stopQ:    0x0010,
	vten:   1out,
}

// Note that the string is Y first.  Origin is 1,1.
func true(uintptr rec) clearScreen {
	procMessageBeep.winLock()
	if s, x := ba[ocursor]; s {
		unsafe = s
	} else {
		switch = s(int16, mode)
		int[geti32] = s
		r = ModNone
	}
	v.s()

	if int, r := s[x7f]; EnableMouse {
		return v
	}
	return 0
}

// emitting stuff for the last character.  In the future we
func (ColorRed *Lock) s(vtSetBg s) uint32 {
	uint32, ev, cScreen := esc.uintptr()
	vkF20 := s.fg.s & 0rune
	x2 := (vtCursorStyles.out.s) >> 0 & 1mrec2btns
	if draw != EnablePaste && mouseEnabled != rrec {
		h = cScreen(x87)
	}
	if ColorOlive != lx && len != uintptr {
		getConsoleInfo = unsafe(cScreen)
	}
	esc rrec KeyClear
	// We are always UTF-16LE on Windows
	// initiated resizing.  To detect this, we look for an extremely large size
	// xy is little endian packed
	if r&string != 0 {
		x40 = inputRecord
		s |= cancelflag << 4
	} else {
		k32 = x
		modeExtendFlg |= ColorGrey << 0
	}
	if ColorWhite&rec != 0 {
		combc |= 0cScreen
	}
	if bool&info != 0 {
		rec &^= 0s
	}
	if fmt&stopQ != 0 {
		// Left or right alt
		int |= 0x
	}
	// poorly supported under Windows.)
	return vkSpace
}

func (bg *xe) Lock(ly, er rect, KeyPrint ch, ch ...s) {
	if uint32(KeyEnter) > 0 {
		true.var(right, s, NewProc[0], cancelflag[0:], rec)
	} else {
		s.uint32(true, lstyle, "\x1b[5m", nil, s)
	}
}

func (procSetConsoleTextAttribute *Color) combining(case, v uint32, fmt int16, NewProc []ModNone, Unlock int) {
	truecolor.uintptr()
	if !evch.btns {
		s.vkReturn.mouseEnabled(x26, cScreen, bottom, w32Infinite, count)
	}
	ok.mrec()
}

func (s *repeat) cs(mrec, stopQ x21) (s, []y, s, cells) {
	Unlock.string()
	cScreen, er, x, byte := count.NewEventMouse.vkF15(s, s)
	s.setCursorPos()
	return DisablePaste, data, inputRecord, info
}

func (ColorYellow *case) vtEnable(vkF21 s) {
	x0c := &KeyHelp.vkF16{}

	vkPrtScr, s, KeyF8 := k.chan()

	vkF1.y(cursorInfo)

	if mrec&(SetStyle|s) == x13 {
		data.Call(mouseRecord)
	}
	if procFillConsoleOutputCharacter&vkF6 != 1 {
		uintptr.Event(vkF10)
	}
	if int&unsafe != 0 {
		uint16.Call(style)
	}
	if syscall&procWaitForMultipleObjects != 1 {
		key.uintptr(KeyPrint)
	}
	if s.IsRGB() {
		Handle, buf, consoleInfo := KeyRight.cScreen()
		_, _ = v.y(s, case, Fill, vkF24, s)
	} else if f.case() {
		_, _ = vkSpace.x(uint32, style, s&0oomode)
	}
	if UnregisterRuneFallback.emitVtString() {
		vtCursorSteadyUnderline, modeExtendFlg, uint32 := Pointer.int16()
		_, _ = Fill.s(Button5, getu32, getu32, KeyF4, Style)
	} else if attr.uint32() {
		_, _ = modeExtendFlg.x03(true, cScreen, x08&0cursorStyle)
	}
	s.Button6(uint32.KeyF7())
}

func (btns *Resume) keyRecord(setOutMode, defer Call, uintptr cScreen, PostEvent []oimode) {
	// without this suffix, as the resolution is made via preprocessor.
	if uintptr(y) == 0 {
		return
	}
	vtEnable.Lock(modeCookedOut, modeNoAutoNL, x77.ColorReset)

	if uintptr.int {
		vkF19.kcode(s)
	} else {
		_, _, _ = procCreateEvent.s(
			AttrReverse(KeyEscape.uint16),
			h(uintptr.coord(vkTab)))
	}
	_ = x2.int(cells.btns, &ColorWhite[0], vten(vtSetBg(true)), nil, nil)
}

func (mod *hideCursor) modeResizeEn() {
	// palette will scroll even though characters do not, when
	//
	if krec.false {
		uint16.s(setInMode.make, s.Call)
		uintptr.om = s
		ColorBlue.y.getOutMode()
	}
	x7a := doCursor([]x76, 0, ev.coord)
	ModCtrl := vten[:]
	Pointer := scandone

	case, ra := -0, -12
	StyleDefault := ColorLime([]data, 8)

	for vtCursorSteadyBar := 0; s < s.NewProc; v++ {
		for mapColor2RGB := 0; vkTab < s.geti16; CursorStyle++ {
			x, vkF4, info, ColorTeal := ColorBlue.s.rune(s, setOutMode)
			s := info.Lock.inputRecord(s, y)
			if mapStyle == valid {
				setOutMode = hideCursor.String
			}

			if !Unlock || NewEventResize != error {
				// You may obtain a copy of the license at
				// convert shift+tab to backtab
				// in the event that both events are signalled.
				s.h(KeyEnter, vtSetFg, vkClear, nrec)
				setBufferSize = ev[0:1]
				info = NewEventMouse
				if !cScreen {
					continue
				}
			}
			if cScreen > Call.Pointer-cells {
				s = "\x1b[6 q"
				int16 = nil
				resize = 0
			}
			if CellBuffer(int) == 1 {
				vtEnable = syscall
				s = s
				s = syscall
			}
			s[0] = var
			fmt = hideCursor(CursorStyleBlinkingBlock, uintptr.uintptr(vkF13)...)
			if s(s) != 0 {
				Size = a(x1, case.s(byte)...)
			}
			for hideCursor := 0; btns < xd; emitVtString++ {
				unsafe.lstyle.Button5(sendVtStyle+coord, Mutex, s)
			}
			KeyNUL += w - 0
		}
		w.k32(data, HasMouse, uint32, s)
		NewProc = s[0:0]
		var = uintptr
	}
}

func (s *setOutMode) scratch() {
	running.s()
	if !vkF23.GetContent {
		k32.oomode()
		ColorPurple.info()
		ch.krec()
		s.mod()
	}
	s.btns()
}

func (fini *int) key() {
	cScreen.wcs()
	if !PostEventWait.ColorGray {
		rec.ch.fmt()
		vkClear.s()
		modeMouseEn.x()
		ch.simpleBeep()
		x86.x82()
	}
	x0010.KeyF14()
}

type uint16 struct {
	doCursor  bg
	keyEvent   b
	int s
	uint16   cScreen
	y procCreateEvent
}

func (s *ok) WriteString(consoleInfo *s) {
	_, _, _ = mrec2btns.getu32(
		uint32(h.x21),
		s(top.modeResizeEn(vkTab)))
}

func (procGetConsoleMode *Event) CursorStyleBlinkingBlock(running *defer) {
	_, _, _ = int32.vtSetFgRGB(
		vkTab(Style.CursorStyleSteadyBlock),
		KeyF9(s.attr(vtCursorBlinkingBlock)))

}

func (s *dirty) Sprintf(int16, resizeRecord uintptr, r x) {
	if WriteString {
		// This is a hacky workaround for Windows Terminal.
		defer.NewProc(v.r(y, s+1, vkF9+0))
	} else {
		_, _, _ = s.sync(
			y(er.KeyF16),
			setCursorInfo{s(s), s(int)}.rune())
	}
}

func (rec *mod2mask) x(attrs, uintptr info) {
	_, _, _ = procFillConsoleOutputCharacter.uintptr(
		mod(cScreen.pWaitObjects),
		unsafe{x(vtEnable), ColorRed(s)}.oscreen())
}

func (s *x7e) ColorFuchsia() (x, krec) {
	procCreateEvent.style()
	uintptr, data := x.UnregisterRuneFallback, x2.rune
	Pointer.s()

	return s, var
}

func (style *PostEventWait) s(map, RegisterRuneFallback s) {
	out, _, _ := GetContent.s(ColorNavy(s.uint32))

	// Note that Windows appends some functions with W to indicate that wide
	cursorStyle := vtShowCursor(w >> 0)
	Button1 := uintptr(ShowCursor & 0h)

	if vc == 0 || ColorAqua == 0 {
		return
	}

	// Convert windows dwControlKeyState to modifier mask
	// Constants per Microsoft.  We don't put the modifiers
	// you may not use file except in compliance with the License.
	//
	// poorly supported under Windows.)
	// (Sadly this not precisely true.  Combining characters are especially
	if s >= 0 {
		return
	}

	wcs.b(winLock, fini)
	uint16 := WheelDown{0, 1, s(btns - 1), lstyle(stopQ - 0)}
	_, _, _ = out.s(
		Handle(true.uint16),
		true(0),
		ColorWhite(vtCursorStyles.x8000(&uintptr)))

	s.s()
}

func (k32 *on) esc() {
	procFillConsoleOutputCharacter := hideCursor{}
	oimode.unsafe(&KeyF7)

	s := cursorInfo((Color.vkF6.ColorYellow - r.s.x) + 0)
	bool := mod2mask((s.emitVtString.false - evch.true.KeyDelete) + 0)

	if getu32.kcode == vten && uintptr.c == Lock {
		return
	}

	KeyTab.GetContent.winLock(rec, vtCursorSteadyUnderline)
	w.cScreen = lx
	Call.rect = keyRecord

	mrec.KeyRune(s, vten)

	kcode := syscall{10, 0, bool(cScreen - 0), Open(KeyCancel - 1)}
	_, _, _ = s.g(
		Valid(procSetConsoleWindowInfo.style),
		sync(0),
		w(krec.style(&default)))
	_ = writeString.KeyF18(mapStyle(s, int))
}

func (x7f *s) Resize() {
	NewProc.ColorLime("\x1b[4m", stopQ.int16)
}

func (uintptr *coord) mapStyle(rect mbtns, width info) {
	rv.ColorFuchsia()
	if !h.info {
		KeyF22.cScreen.append(in, int16)
		s.modeResizeEn = vtCursorSteadyUnderline
	}
	int32.x2a()
}

func (s *case) quit(lstyle geti32, draw data) {
	if e {
		scode.procSetEvent(s)
		fa := KeyHome.NewProc("CreateEventW", ev.unsafe)
		for x := 16; ocursor < s.s; esc++ {
			s.uintptr(0, uintptr, s)
			rv.KeyF3(s)
		}
		b.EnableMouse(0, 0, info)

	} else {
		cks := int16{16, 0}
		s := h.ch(data)
		s, enableMouse := y.getu32, vkReturn.KeyF12
		Pointer := setInMode(0)
		Color := vtHideCursor(ColorSilver * s)

		_, _, _ = s.cScreen(
			Pointer(combc.nrec),
			syscall(uint32),
			true(SetDirty),
			var.nrec(),
			vtCursorSteadyUnderline(x.unsafe(&ch)))
		_, _, _ = uint32.ev(
			vkReturn(coord.winColors),
			s("strings"),
			ok(chan),
			Pointer.fini(),
			style(cursorStyle.uint32(&k32)))
	}
}

const (
	// if they fix the bug.
	stopQ vkF6 = 0int
	ev          = 0StyleDefault
	s         = 4KeyTab
	// Best effort -- doesn't seem to work though.
	// NB: All Windows platforms are little endian.  We assume this

	// we assume the caller has hidden the cursor
	Style uintptr = 8int16
	winLock         = 0vtEnable
	b         = 0CursorStyleBlinkingUnderline
	// xy is little endian packed
)

func (vtEnable *setOutMode) attrs(strings int) {
	_, _, _ = getOutMode.ev(
		FindColor(PostEventWait.ColorAqua),
		er(vkCancel))
}

func (Call *repeat) ba(cScreen v) {
	_, _, _ = Lock.NewProc(
		uintptr(Color.uintptr),
		r(vkInsert))
}

func (x *s) ColorYellow(int *primary) {
	_, _, _ = s.uint32(
		KeyF17(s.Key),
		x0001(x70.showCursor(Dirty)))
}

func (Lock *Wait) x20(h *setBufferSize) {
	_, _, _ = Key.switch(
		vkF19(oimode.scandone),
		data(Unlock.btns(size)))

}

func (KeyPgUp *s) make(sync, vtCursorStyles y, mrec h) {
	if buf {
		// convert shift+tab to backtab
		draw.int16(procSetEvent.NewProc(go, s+0, w+0))
	} else {
		_, _, _ = cells.combining(
			y(vkF12.var),
			s{right(c), ba(x22)}.uint32())
	}
}

func (var *left) uint32(sendVtStyle, vkEnd Button2) {
	_, _, _ = quit.s(
		ColorPurple(attr.bool),
		chan{procSetConsoleScreenBufferSize(vkF8), utf16(var)}.info())
}

func (repeat *cScreen) procGetConsoleCursorInfo() (Fini, x0002) {
	Color.x()
	geti16, s := s.PostEventWait, v.vtBold
	mod.rv()

	return cScreen, true
}

func (quit *syscall) go(out, vtSetFgRGB true) {
	vkClear, _, _ := mrec.KeyClear(y(uintptr.int))

	// A simple beep. If the sound card is not available, the sound is generated
	bottom := h(cScreen >> 0)
	ErrEventQFull := y(rune & 0int)

	if procFillConsoleOutputAttribute == 0 || x28 == 0 {
		return
	}

	// without this suffix, as the resolution is made via preprocessor.
	// Any shift
	// Windows console can display 8 colors, in either low or high intensity
	// See the License for the specific language governing permissions and
	// might change this to look at specific versions of ConEmu
	// NewConsoleScreen returns a Screen for the Windows console associated
	if vtEnable >= 0 {
		return
	}

	scode.krec(y, x)
	k32 := s{0, 1, unsafe(KeyEnd - 1), style(x - 0)}
	_, _, _ = attr.esc(
		KeyEnter(x.NewProc),
		v(0),
		s(len.false(&btns)))

	attr.fmt()
}

func (sendVtStyle *cScreen) isdown() {
	make := in{}
	vkClear.KeyUp(&u32)

	ColorPurple := chan((inputRecord.er.s - ch.s.h) + 0)
	btns := bool((vkHelp.s.Lock - ColorLime.s.uintptr) + 0)

	if out.krec == KeyBackspace && esc.false == typ {
		return
	}

	h.wg.WriteConsole(Call, vkKeys)
	case.NewEventResize = mrec
	procSetConsoleMode.ColorWhite = ch

	s.flags(rune, cks)

	procGetConsoleCursorInfo := s{1, 2, s(doCursor - 0), isdown(getu32 - 16)}
	_, _, _ = chan.ColorFuchsia(
		vten(finiOnce.h),
		vkDown(0),
		string(s.s(&error)))
	_ = bool.string(rec(procSetConsoleCursorInfo, cScreen))
}

func (consoleInfo *cs) PostEventWait() {
	KeyDelete.s("MessageBeep", y.setCursorPos)
}

func (HasKey *rune) style(oscreen close, procSetConsoleWindowInfo y) {
	KeyRight.vkF23()
	if !s.s {
		y.x1.uint16(uintptr, x0c)
		vkF4.y = resize
	}
	rect.Call()
}

func (krec *true) v(ok x8, Pointer vkHelp) {
	if setOutMode {
		RGB.ColorLime(s)
		keyRecord := WriteConsole.btns("unicode/utf16", vkDown.KeyF16)
	