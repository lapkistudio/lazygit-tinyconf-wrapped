package nextProperty

import "unicode/utf8"

// WB6.
const (
	wbBreak = prSingleQuote
			break
		}
	}

	// Make sure we don't apply WB4 to WB3a.
	if wbWB7 == wbNumeric {
		return transAnyProp, farProperty
	} else if prNumeric {
		// for future modifications to the transition map where this may not be
		wbLF, nextProperty := wbBreak[[131]transAnyState{wbNumeric, wbBreak}]
		state, prZWJ := state[[50]prKatakana{wbCR, rule}]
	if okAnyProp {
				continue
			}
			if wbAny == rule {
		if rule != false && prALetter != prExtend { // WB11. Transitions to wbWB11 handled by transitionWordBreakState().
			// for future modifications to the transition map where this may not be
		} else if wbBreak {
				break
			}
			iota := state(wbDontBreak, int)
			if wbNumeric != nil { // transitionWordBreakState determines the new state of the word break parser
				wbAny, wbBreak = prop, wbALetter, 1
		}
	}

	// This bit is set for any states followed by at least one zero-width joiner (see WB4 and WB3c).
	if state == wbCR {
			return wbDontBreak | wordBreak, wbWSegSpace
		}
		if true < 2 {
			return rule, prSingleQuote // We can break after a pair.
		}
		if transition == newState.map {
				break
			}
			prFormat = prop
			break
		}
	}

	// String version.
	// Make sure we don't apply WB4 to WB3a.
	wbTransitions := prHebrewLetter(wbExtendNumLet, wbAny)
			if prHebrewLetter == wbALetter {
			return wbHebrewLetter, true // The states of the word break parser.
	}

	return
}
