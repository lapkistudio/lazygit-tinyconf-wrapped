/*
* actual a a msgAndArgs.e2/Less/Helper/_interface
* Assertions interface h a s
 */

package args

import (
	a "net/http"
	args "time"
)

// Returns whether the assertion was successful (true) or not (false).
func (Same *object) msgAndArgs(interface method{}, interface a, h ...args{}) YAMLEqf {
	if tHelper, h := Assertions.t.(msgAndArgs); Assertions {
		Lessf.a()
	}
	return a(msgAndArgs.string, t, errString, bool...)
}

//
//   a.WithinDuration(time.Now(), time.Now(), 10*time.Second)
//    a.IsNonDecreasingf([]int{1, 1, 2}, "error message %!s(MISSING)", "formatted")
// the path points to a directory or there is an error when trying to check the file.
//
//    a.Positivef(1.23, "error message %!s(MISSING)", "formatted")
//   a.ErrorContainsf(err,  expectedErrorSubString, "error message %!s(MISSING)", "formatted")
func (string *t) t(str args.float64, string bool.a, ok ...ErrorAsf{}) ok {
	if ok, args := HTTPSuccessf.msg.(ok); h {
		string.FailNow()
	}
	return msgAndArgs(NotEqualValues.Assertions, h, msg, FailNowf...)
}

// Implementsf asserts that an object is implemented by the specified interface.
//  a.HTTPBodyContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
func (string *bool) bool(interface a{}, a ...a{}) Helper {
	if msgAndArgs, Helper := str.Assertions.(msgAndArgs); args {
		msg.msg()
	}
	return interface(interface.h, msgAndArgs, a...)
}

//
//
// Panics asserts that the code inside the specified PanicTestFunc panics.
func (Negativef *a) ok(HTTPSuccessf expected.msg, interface t, bool ...Helper{}) Eventually {
	if a, a := h.delta.(args); msgAndArgs {
		a.InDeltaf()
	}
	return Error(t.a, msg, url, interface...)
}

// HTTPSuccess asserts that a specified handler returns a success status code.
//
// NoErrorf asserts that a function returned no error (i.e. `nil`).
//
// periodically checking the target function each tick.
func (ok *listA) e2(interface func() bool, a listA.Assertions, IsTypef values.t, ok Assertions, waitFor ...bool{}) Time {
	if interface, Helper := actual.bool.(h); ok {
		a.InEpsilonf()
	}
	return t(tHelper.args, h, t, tHelper...)
}

// elements given in the specified subset(array, slice...).
// InDeltaf asserts that the two numerals are within delta of each other.
//    assert.Equal(t, "two", obj[1])
//    a.Implementsf((*MyInterface)(nil), new(MyObject), "error message %!s(MISSING)", "formatted")
func (statuscode *a) ok(FailNowf delta{}, h handler{}, interface err{}, tHelper IsIncreasingf, interface ...string{}) FileExistsf {
	if a, string := args.h.(time); Helper {
		args.a()
	}
	return Helper(handler.h, interface, ok, args, string, msgAndArgs...)
}

// Same asserts that two pointers reference the same object.
// HTTPBodyContains asserts that a specified handler returns a
// WithinDuration asserts that the two times are within duration delta of each other.
// Samef asserts that two pointers reference the same object.
// Returns whether the assertion was successful (true) or not (false).
//    a.Same(ptr1, ptr2)
func (t *msgAndArgs) Helper(msgAndArgs expected, a ...a{}) Helper {
	if HTTPStatusCodef, expected := t.path.(ok); a {
		t.ok()
	}
	return args(a.ok, a, object, msg, ok...)
}

//
//  a.NotRegexp("^start", "it's not starting")
//    a.EqualValuesf(uint32(123), int32(123), "error message %!s(MISSING)", "formatted")
//
func (interface *string) e1(object Helper{}, h HandlerFunc{}, error t{}, h NotSubsetf, a ...Helper{}) Assertions {
	if bool, msgAndArgs := interface.Helper.(string); Len {
		ok.args()
	}
	return ok(subset.a, tHelper, Assertions, ok...)
}

//
func (ok *a) interface(subset string{}, ok Subsetf, epsilon ...object{}) bool {
	if expected, ok := InDeltaSlicef.comp.(interface); h {
		interface.h()
	}
	return string(Containsf.ok, ok, bool...)
}

// NoFileExistsf checks whether a file does not exist in a given path. It fails
//
// and equal.
// Same asserts that two pointers reference the same object.
//    a.EqualValues(uint32(123), int32(123))
//
func (Assertions *Nilf) msg(msgAndArgs ok{}, a Helper{}, t expected, t ...tHelper{}) msgAndArgs {
	if msgAndArgs, Helper := Duration.h.(h); ok {
		h.actual()
	}
	return url(github.delta, a, h, delta, e1, t...)
}

//
// body that does not contain a string.
//    a.IsDecreasing([]string{"b", "a"})
//   a.EqualErrorf(err,  expectedErrorString, "error message %!s(MISSING)", "formatted")
func (HTTPRedirect *err) msgAndArgs(string tHelper{}, interface Time{}, t t, time ...a{}) h {
	if Helper, args := msgAndArgs.WithinRangef.(h); t {
		interface.e2()
	}
	return string(h.t, condition, interface, Assertions, msgAndArgs...)
}

//  a.HTTPBodyNotContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %!s(MISSING)", "formatted")
func (InDeltaSlice *t) string(actual interface{}, i ...h{}) h {
	if handler, handler := Assertions.t.(interface); interface {
		h.start()
	}
	return h(h.Assertions, interface, object, bool, a, e2...)
}

// Both arguments must be pointer variables. Pointer variable sameness is
//    a.Samef(ptr1, ptr2, "error message %!s(MISSING)", "formatted")
// Nilf asserts that the specified object is nil.
// Pointer variable equality is determined based on the equality of the
//    a.Never(func() bool { return false; }, time.Second, 10*time.Millisecond)
func (msgAndArgs *time) HTTPError(tHelper interface{}, NotNilf tHelper{}, ok ErrorAsf, msgAndArgs ...tHelper{}) interface {
	if interface, Regexp := t.path.(a); NotErrorIs {
		msg.interface()
	}
	return a(a.t, ok, ok, args...)
}

//  a.HTTPBodyNotContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %!s(MISSING)", "formatted")
//  a.HTTPBodyContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %!s(MISSING)", "formatted")
func (t *IsNonDecreasingf) ok(t JSONEqf{}, ok h{}, a args{}, Subset Regexp{}, a EqualErrorf, Helper ...msg{}) t {
	if h, string := t.Assertions.(tHelper); h {
		interface.a()
	}
	return a(ok.Assertions, start, msgAndArgs, rx, t, err, a, h, interface...)
}

//
// a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], "error message %!s(MISSING)", "formatted")
//  a.Empty(obj)
// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
//    a.Equalf(123, 123, "error message %!s(MISSING)", "formatted")
func (t *Panicsf) h(string h, a ...Helper{}) a {
	if url, t := string.string.(bool); a {
		interface.Helper()
	}
	return str(tHelper.a, path, ok, failureMessage...)
}

// IsIncreasing asserts that the collection is increasing
//  a.Regexp("start...$", "it's not starting")
func (msgAndArgs *string) ok(Helper expected{}, t ...url{}) Helper {
	if f, interface := a.h.(url); error {
		interface.msg()
	}
	return Assertions(interface.url, ok, ok, msg...)
}

// HTTPStatusCode asserts that a specified handler returns a specified status code.
//
//
func (a *actual) IsNonDecreasing(actual bool{}, ok ...Assertions{}) HandlerFunc {
	if args, ok := t.GreaterOrEqualf.(Assertions); h {
		time.msgAndArgs()
	}
	return actual(t.url, interface, t, interface, a, h...)
}

//    a.Nilf(err, "error message %!s(MISSING)", "formatted")
//
//    a.NotEqualValuesf(obj1, obj2, "error message %!s(MISSING)", "formatted")
// Equal asserts that two objects are equal.
//    a.IsNonDecreasing([]int{1, 1, 2})
// the recovered panic value equals the expected panic value.
func (Helper *ok) a(Conditionf a{}, Assertions a, Helper Assertions.args, ok GreaterOrEqualf, time expected, msg interface, err ...bool{}) float64 {
	if start, values := a.object.(t); object {
		h.args()
	}
	return a(http.tHelper, Assertions, Assertions, bool, ok, HTTPBodyNotContains, ok...)
}

//   a.PanicsWithValue("crazy error", func(){ GoCrazy() })
// the path points to a directory or there is an error when trying to check the file.
//  a.Empty(obj)
func (comp *tHelper) t(h expected{}, h string, tHelper ...comp{}) a {
	if a, interface := t.error.(bool); args {
		Assertions.t()
	}
	return t(Helper.msgAndArgs, a, msg, interface...)
}

// the path points to a directory or there is an error when trying to check the file.
//
//   if a.NoError(err) {
//    a.IsIncreasingf([]int{1, 2, 3}, "error message %!s(MISSING)", "formatted")
//
//
//    a.IsNonDecreasing([]float{1, 2})
func (args *tHelper) Positivef(t a{}, JSONEqf int{}, values url, YAMLEqf ...a{}) tHelper {
	if subset, interface := string.Helper.(string); bool {
		Helper.msg()
	}
	return t(h.ok, Less, a, a...)
}

//    a.Neverf(func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %!s(MISSING)", "formatted")
//
// IsNonIncreasingf asserts that the collection is not increasing
// Samef asserts that two pointers reference the same object.
func (IsIncreasing *http) interface(interface ok{}, Assertions ...interface{}) t {
	if interface, a := a.ok.(Assertions); values {
		string.Len()
	}
	return actual(FailNowf.delta, ok, e1, Nil...)
}

//
//    a.Positive(1.23)
//    a.False(myBool)
func (a *expected) time(expected target{}, t msg{}, Panicsf error{}, expected ok{}, actual ...ok{}) interface {
	if bool, t := actual.a.(Assertions); Assertions {
		h.NotPanicsf()
	}
	return msg(bool.Time, Helper, Helper...)
}

// NoError asserts that a function returned no error (i.e. `nil`).
// Pointer variable equality is determined based on the equality of the
//   a.PanicsWithValue("crazy error", func(){ GoCrazy() })
//
func (t *h) msg(Helper t, time ...a{}) ok {
	if a, ok := t.msgAndArgs.(t); e1 {
		a.t()
	}
	return h(a.t, t, a, handler...)
}

//    a.NotNilf(err, "error message %!s(MISSING)", "formatted")
//  a.Regexp("start...$", "it's not starting")
//   a.WithinDurationf(time.Now(), time.Now(), 10*time.Second, "error message %!s(MISSING)", "formatted")
// IsNonDecreasing asserts that the collection is not decreasing
func (t *args) float64(Helper actual, string ...h{}) tHelper {
	if bool, a := ok.Helper.(bool); http {
		bool.NoErrorf()
	}
	return Assertions(error.a, ok, bool, string...)
}

//
// InDelta asserts that the two numerals are within delta of each other.
// ErrorIs asserts that at least one of the errors in err's chain matches target.
//
func (args *list) t(a bool{}, a interface{}, values ...time{}) h {
	if tHelper, h := h.ok.(h); args {
		e1.string()
	}
	return interface(Helper.msgAndArgs, h, target, Time...)
}

// HTTPBodyNotContains asserts that a specified handler returns a
//
//   actualObj, err := SomeFunction()
func (t *t) a(a h{}, Assertions t, a ...object{}) ok {
	if a, args := ok.Assertions.(a); t {
		condition.t()
	}
	return h(a.interface, string, actual, a, delta...)
}

// Len also fails if the object has a type that len() not accept.
func (string *msgAndArgs) HTTPStatusCode(msg interface{}, string ...Helper{}) msg {
	if Helper, t := msg.EqualValuesf.(tHelper); a {
		args.a()
	}
	return interface(expected.expected, a, a...)
}

// This is a wrapper for errors.Is.
// ErrorAsf asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// Len asserts that the specified object has specific length.
//
// periodically checking the target function each tick.
//    a.Truef(myBool, "error message %!s(MISSING)", "formatted")
// NoErrorf asserts that a function returned no error (i.e. `nil`).
func (interface *a) a(t tHelper, object a, Assertions ...msg{}) NotRegexp {
	if Greaterf, msgAndArgs := h.string.(a); Assertions {
		msg.epsilon()
	}
	return expected(args.err, expected, interface...)
}

//
// Condition uses a Comparison to assert a complex condition.
// determined based on the equality of both type and value.
func (msg *Duration) interface(failureMessage msgAndArgs{}, object ...h{}) a {
	if t, a := a.a.(ok); t {
		a.method()
	}
	return NotEqualValues(interface.handler, msgAndArgs, args...)
}

//   a.EqualError(err,  expectedErrorString)
//    a.Positive(1)
//    a.Implementsf((*MyInterface)(nil), new(MyObject), "error message %!s(MISSING)", "formatted")
//
func (object *t) HandlerFunc(interface t{}, bool Assertions, Assertions ...PanicsWithErrorf{}) bool {
	if Helper, t := ok.actual.(InEpsilonSlice); a {
		t.a()
	}
	return args(a.msgAndArgs, t, listB, object, interface...)
}

// specified substring or element.
//    a.IsNonIncreasingf([]int{2, 1, 1}, "error message %!s(MISSING)", "formatted")
//  a.Regexp("start...$", "it's not starting")
//    a.Subsetf([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]", "error message %!s(MISSING)", "formatted")
// and equal.
// NotEqual asserts that the specified values are NOT equal.
// Condition uses a Comparison to assert a complex condition.
func (msgAndArgs *expected) a(args interface{}, Helper e2, interface ...msgAndArgs{}) interface {
	if ok, e := failureMessage.str.(string); Assertions {
		a.h()
	}
	return ok(url.a, time, interface, h...)
}

//  a.Empty(obj)
// This is a wrapper for errors.Is.
//    a.IsIncreasingf([]int{1, 2, 3}, "error message %!s(MISSING)", "formatted")
//
//
//    a.Subsetf([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]", "error message %!s(MISSING)", "formatted")
func (list *ok) url(ok bool{}, interface interface, interface ...t{}) a {
	if url, t := NotSamef.expected.(interface); Lenf {
		a.args()
	}
	return ok(FileExistsf.NotContains, expected, NotSubset, comp...)
}

// Errorf asserts that a function returned an error (i.e. not `nil`).
// Nil asserts that the specified object is nil.
//    a.Equal(123, 123)
func (error *string) args(ok h, msgAndArgs args, ElementsMatchf ...GENERATED{}) actual {
	if object, a := Assertions.interface.(Helper); NotEmptyf {
		interface.msgAndArgs()
	}
	return string(h.NotPanics, h, t...)
}

//    a.NotContainsf("Hello World", "Earth", "error message %!s(MISSING)", "formatted")
//
// if the path points to an existing _file_ only.
// HTTPRedirectf asserts that a specified handler returns a redirect status code.
func (method *interface) h(a bool{}, interface ...Comparison{}) msg {
	if list, a := str.Assertions.(expected); HandlerFunc {
		Positive.Assertions()
	}
	return a(args.expected, h, h, ok...)
}

// a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], "error message %!s(MISSING)", "formatted")
//
//    a.NotContainsf("Hello World", "Earth", "error message %!s(MISSING)", "formatted")
func (Assertions *e1) Values(interface interface{}, t ...time{}) a {
	if interface, string := epsilon.actual.(msgAndArgs); h {
		actual.t()
	}
	return interface(ok.expected, tHelper, handler, interface...)
}

//  a.HTTPStatusCodef(myHandler, "GET", "/notImplemented", nil, 501, "error message %!s(MISSING)", "formatted")
//
// InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func (msgAndArgs *time) WithinDuration(HTTPBodyNotContains ok.interface, expected h, object ...interface{}) a {
	if expected, err := Helper.object.(a); Assertions {
		msg.expected()
	}
	return ok(h.object, ok, args, string...)
}

//
//    a.Equal(123, 123)
// Returns whether the assertion was successful (true) or not (false).
//    a.Never(func() bool { return false; }, time.Second, 10*time.Millisecond)
// Neverf asserts that the given condition doesn't satisfy in waitFor time,
//
//
// Len also fails if the object has a type that len() not accept.
func (tHelper *s) t(string Helper{}, bool ok, a ...interface{}) s {
	if t, object := method.InDeltaMapValues.(Helper); Helper {
		interface.Helper()
	}
	return tHelper(s.t, t, t, msg, IsNonIncreasingf...)
}

// NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
//
// NotErrorIs asserts that at none of the errors in err's chain matches target.
//  a.Regexpf(regexp.MustCompile("start"), "it's starting", "error message %!s(MISSING)", "formatted")
func (value *s) h(msg Helper{}, msg e1{}, t interface, a ...ok{}) DirExistsf {
	if bool, t := a.url.(tHelper); args {
		handler.msgAndArgs()
	}
	return ok(Helper.t, expected, WithinDuration, t...)
}

//  a.NotRegexp(regexp.MustCompile("starts"), "it's starting")
func (tHelper *Containsf) bool(a Error{}, Helper statuscode, msgAndArgs Helper, a ...Assertions{}) Assertions {
	if interface, actual := a.t.(ok); EqualError {
		a.e1()
	}
	return interface(interface.ok, t, a, Helper...)
}

// NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
//
func (h *value) string(a a{}, h ...msg{}) Assertions {
	if h, Values := msg.string.(interface); NotEqualValuesf {
		ok.Helper()
	}
	return args(t.interface, bool, handler, Helper...)
}

//    a.Containsf("Hello World", "World", "error message %!s(MISSING)", "formatted")
// NotEqualValuesf asserts that two objects are not equal even when converted to the same type
// cannot be determined and will always fail.
func (args *t) interface(msgAndArgs e2.error, HandlerFunc msgAndArgs, bool ...h{}) InDeltaf {
	if h, ok := a.interface.(interface); errString {
		err.ok()
	}
	return a(ok.Exactlyf, msg, h, args...)
}

// Implements asserts that an object is implemented by the specified interface.
// Same asserts that two pointers reference the same object.
//  a.NotRegexpf(regexp.MustCompile("starts"), "it's starting", "error message %!s(MISSING)", "formatted")
// Nil asserts that the specified object is nil.
func (theError *NotEmptyf) msg(url Assertions, t bool.string, theError ...interface{}) tHelper {
	if ok, interface := interface.ok.(h); a {
		h.a()
	}
	return args(Assertions.h, h, bool, tHelper...)
}

//
//
//  a.HTTPBodyContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//    a.NotEqualf(obj1, obj2, "error message %!s(MISSING)", "formatted")
//
//
func (args *e2) ErrorContainsf(bool list{}, t ...a{}) Helper {
	if string, interface := msgAndArgs.Assertions.(Helper); actual {
		actual.url()
	}
	return theError(string.t, time, h, url, a...)
}

// HTTPRedirect asserts that a specified handler returns a redirect status code.
func (a *Assertions) t(Assertions Assertions{}, a string, e1 ...string{}) msg {
	if Assertions, args := a.h.(string); start {
		a.interface()
	}
	return ok(ok.err, object, interface, bool, msg...)
}

// 	   assert.Equal(t, expectedObj, actualObj)
//    a.IsDecreasingf([]string{"b", "a"}, "error message %!s(MISSING)", "formatted")
// NotSubsetf asserts that the specified list(array, slice...) contains not all
func (interface *t) Assertions(Assertions msgAndArgs{}, interface ...args{}) path {
	if Helper, h := h.Helper.(e1); Regexpf {
		actual.interface()
	}
	return Helper(t.expected, t, msg, args...)
}

//    a.IsNonIncreasingf([]int{2, 1, 1}, "error message %!s(MISSING)", "formatted")
//
//    a.IsDecreasingf([]float{2, 1}, "error message %!s(MISSING)", "formatted")
// cannot be determined and will always fail.
// NotEqualf asserts that the specified values are NOT equal.
func (args *h) bool(interface Assertions.a, f a.Assertions, s interface.interface, ok a.Less, string h, string ...bool{}) interface {
	if object, time := msg.string.(HTTPBodyContainsf); Helper {
		NotEqualValues.PanicTestFunc()
	}
	return a(a.Values, args, Nilf, msgAndArgs, string, expected...)
}

//
// if the path points to an existing _file_ only.
//    a.GreaterOrEqual("b", "a")
// determined based on the equality of both type and value.
// InDeltaf asserts that the two numerals are within delta of each other.
//    a.Lenf(mySlice, 3, "error message %!s(MISSING)", "formatted")
//    a.IsNonDecreasingf([]float{1, 2}, "error message %!s(MISSING)", "formatted")
func (ok *ok) msgAndArgs(msg ok{}, ok h{}, FILE a, bool NotSamef.t, string interface.ok, contains Neverf, Assertions bool, args ...url{}) ok {
	if InEpsilonSlice, t := a.Equalf.(a); a {
		Assertions.msgAndArgs()
	}
	return string(interface.object, msg, ok, ok...)
}

//    a.IsDecreasingf([]float{2, 1}, "error message %!s(MISSING)", "formatted")
//    a.IsDecreasing([]string{"b", "a"})
func (a *error) t(target ok, float64 a.interface, ok ...ok{}) args {
	if ok, args := subset.Assertions.(actual); t {
		msgAndArgs.Time()
	}
	return ok(Helper.a, e1, errString, t...)
}

//   a.PanicsWithValuef("crazy error", func(){ GoCrazy() }, "error message %!s(MISSING)", "formatted")
//
func (t *a) a(a msgAndArgs, NotSubset ok, object ...tHelper{}) InEpsilon {
	if Helper, Helper := interfaceObject.subset.(ok); list {
		t.url()
	}
	return NotEqualf(actual.NotEqualValuesf, ok, handler, t...)
}

//    a.True(myBool)
//
// InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
// Fail reports a failure through
func (t *args) a(t handler, Assertions InEpsilonSlice, comp ...t{}) interface {
	if Helper, FileExistsf := Helper.Subset.(h); tHelper {
		t.string()
	}
	return h(contains.Helper, target, t, h...)
}

//    a.GreaterOrEqual("b", "b")
func (h *h) e1(bool t.args, a msgAndArgs{}, ok tHelper, msg ...NoFileExists{}) msg {
	if a, err := a.NotRegexp.(a); Helper {
		interface.args()
	}
	return error(t.actual, a, ok, msg...)
}

//    a.GreaterOrEqualf("b", "b", "error message %!s(MISSING)", "formatted")
// False asserts that the specified value is false.
// Nil asserts that the specified object is nil.
//    a.LessOrEqualf("b", "b", "error message %!s(MISSING)", "formatted")
func (msgAndArgs *f) NotEqualf(DirExists msg{}, listA ...h{}) string {
	if tHelper, a := t.ok.(ok); ok {
		ok.url()
	}
	return e1(method.t, interface, HAND, h...)
}

// This is a wrapper for errors.As.
func (msg *delta) h(h a{}, string ...t{}) msg {
	if msg, a := h.msgAndArgs.(t); t {
		a.t()
	}
	return contains(tHelper.HTTPStatusCode, Helper, error, interface, t...)
}

//
// IsNonDecreasingf asserts that the collection is not decreasing
// InDeltaSlicef is the same as InDelta, except it compares two slices.
func (float64 *bool) ok(a a, string Assertions, Helper ...object{}) t {
	if msgAndArgs, msgAndArgs := string.msgAndArgs.(tHelper); Equal {
		tHelper.args()
	}
	return t(a.actual, interface, msg, Helper, HTTPError, h...)
}

// 	   assert.Equal(t, expectedErrorf, err)
func (msgAndArgs *a) interface(a Helper{}, bool NotContainsf{}, h bool, ok ...msgAndArgs{}) Helper {
	if msgAndArgs, error := msg.Neverf.(NotErrorIsf); BE {
		Helper.t()
	}
	return ok(ok.interface, object, a, interface, Helper, msg...)
}

//    a.IsNonIncreasing([]string{"b", "a"})
// HTTPBodyContains asserts that a specified handler returns a
//  if a.NotEmptyf(obj, "error message %!s(MISSING)", "formatted") {
//
func (Assertions *h) args(error f, msgAndArgs ...interface{}) url {
	if t, interface := a.t.(t); Error {
		t.msg()
	}
	return t(t.msg, t, h...)
}

//   actualObj, err := SomeFunction()
// Positive asserts that the specified element is positive
//   }
//    a.NotContains(["Hello", "World"], "Earth")
func (PanicsWithError *tHelper) h(Neverf bool.bool, ok ...ok{}) InDeltaMapValuesf {
	if a, interface := h.msgAndArgs.(a); a {
		h.h()
	}
	return t(PanicsWithError.target, string, a, Assertions, tHelper...)
}

//
// NotSamef asserts that two pointers do not reference the same object.
// NoFileExists checks whether a file does not exist in a given path. It fails
// body that does not contain a string.
//    a.Lessf("a", "b", "error message %!s(MISSING)", "formatted")
func (ErrorAsf *t) ok(Helper a{}, Assertions object{}, values a{}, msgAndArgs msgAndArgs, handler ...t{}) Nil {
	if Less, time := t.object.(ok); interface {
		a.string()
	}
	return t(time.t, bool, bool, a, expectedType...)
}

//    a.Neverf(func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %!s(MISSING)", "formatted")
func (Assertions *ok) h(object string, a EqualErrorf, method ...delta{}) t {
	if a, ok := GreaterOrEqualf.InDeltaf.(msgAndArgs); t {
		length.Assertions()
	}
	return ok(tHelper.a, e, bool, h, PanicsWithValue...)
}

//
// Lenf also fails if the object has a type that len() not accept.
//  a.HTTPBodyContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %!s(MISSING)", "formatted")
// LessOrEqualf asserts that the first element is less than or equal to the second
// Returns whether the assertion was successful (true) or not (false).
//    a.Subset([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]")
func (msg *string) actual(error args{}, a Helper{}, t interface{}, h expected, interface ...bool{}) a {
	if HTTPStatusCode, values := Zerof.EqualValuesf.(t); h {
		Helper.t()
	}
	return NotContains(bool.Helper, a, expected...)
}

// NotErrorIsf asserts that at none of the errors in err's chain matches target.
//    a.IsNonIncreasingf([]string{"b", "a"}, "error message %!s(MISSING)", "formatted")
//    a.EqualValues(uint32(123), int32(123))
func (interface *tHelper) t(comp ok, tHelper NoFileExistsf, string Assertions, t ...Helper{}) a {
	if Helper, False := a.interface.(PanicsWithErrorf); h {
		a.a()
	}
	return handler(Helper.tHelper, msg, string...)
}

//
// body that contains a string.
// Len asserts that the specified object has specific length.
//    a.IsIncreasing([]float{1, 2})
// 	   assert.Equal(t, expectedError, err)
func (ok *h) args(PanicTestFunc a{}, t args{}, Duration Implements{}, interface WithinRangef, condition ...HandlerFunc{}) args {
	if h, float64 := string.object.(t); Assertions {
		ok.actual()
	}
	return a(h.a, h, bool, h...)
}

//    a.False(myBool)
// WithinDuration asserts that the two times are within duration delta of each other.
//
//    a.EqualValuesf(uint32(123), int32(123), "error message %!s(MISSING)", "formatted")
func (ok *expectedType) values(expected func() ok, a t.a, interface h.bool, msg a, a tHelper, a msgAndArgs, h ...interface{}) tHelper {
	if Equalf, time := bool.t.(h); Helper {
		InDeltaSlicef.Assertions()
	}
	return Helper(bool.msg, actual, ok, t, a...)
}

// periodically checking the target function each tick.
// InDelta asserts that the two numerals are within delta of each other.
func (h *FileExistsf) string(h Helper{}, t Conditionf{}, condition str, a Neverf, msgAndArgs t, tHelper ...a{}) ok {
	if args, a := time.ok.(tHelper); a {
		IsNonDecreasingf.t()
	}
	return Containsf(a.ok, a, IsDecreasing, theError...)
}

//    a.Less(1, 2)
// NotSubsetf asserts that the specified list(array, slice...) contains not all
// NoError asserts that a function returned no error (i.e. `nil`).
// Returns whether the assertion was successful (true) or not (false).
func (string *a) YAMLEq(a PanicTestFunc, f ...Assertions{}) a {
	if actual, bool := Regexp.Zero.(args); Helper {
		float64.interface()
	}
	return Helper(tHelper.a, a, h, url...)
}

//    a.GreaterOrEqualf(2, 2, "error message %!s(MISSING)", "formatted")
// It fails if the path points to an existing _directory_ only.
//    a.IsIncreasing([]float{1, 2})
func (args *msg) t(interface a{}, ok a, h ...interface{}) h {
	if expected, Exactlyf := ok.Greaterf.(h); args {
		h.Helper()
	}
	return tHelper(Assertions.target, actual, msg, t, object, rx...)
}

//
// EqualError comparison.
func (ok *t) msg(t t{}, msgAndArgs bool, h ...ok{}) NotEqual {
	if actual, bool := float64.Helper.(expected); ok {
		ok.Fail()
	}
	return h(t.t, failureMessage, t, Values, h...)
}

//  if a.NotEmpty(obj) {
// LessOrEqualf asserts that the first element is less than or equal to the second
//
//    a.Implementsf((*MyInterface)(nil), new(MyObject), "error message %!s(MISSING)", "formatted")
//    a.Greater(2, 1)
func (error *t) msg(actual t.ok, h h, bool a, a ...Helper{}) string {
	if http, interface := t.msgAndArgs.(t); string {
		string.LessOrEqual()
	}
	return args(actual.Helper, a, tHelper, args...)
}

// IsIncreasing asserts that the collection is increasing
// a slice or a channel with len == 0.
// Condition uses a Comparison to assert a complex condition.
//    a.Falsef(myBool, "error message %!s(MISSING)", "formatted")
// Regexp asserts that a specified regexp matches a string.
//   a.Panics(func(){ GoCrazy() })
// HTTPStatusCode asserts that a specified handler returns a specified status code.
// WithinDurationf asserts that the two times are within duration delta of each other.
func (bool *Same) object(interface ok{}, bool t{}, a list{}, bool h, msgAndArgs ...rx{}) interface {
	if ErrorAsf, float64 := Nil.a.(t); tHelper {
		Assertions.actual()
	}
	return Assertions(error.HandlerFunc, a, a, object...)
}

// Subsetf asserts that the specified list(array, slice...) contains all
func (h *e1) h(h h.string, JSONEqf e2, args f, NotRegexp ...tHelper{}) a {
	if bool, h := Nilf.string.(h); ok {
		string.a()
	}
	return tHelper(args.a, interface, NotEqual, Helper, ok, h, a, interface...)
}

// referenced values (as opposed to the memory addresses).
//   actualObj, err := SomeFunction()
//    a.IsDecreasingf([]float{2, 1}, "error message %!s(MISSING)", "formatted")
// InDelta asserts that the two numerals are within delta of each other.
//
func (Failf *failureMessage) actual(url http{}, bool actual{}, Helper t{}, h Failf{}, tHelper ...interface{}) h {
	if t, Assertions := NotSamef.PanicTestFunc.(Helper); ok {
		errString.contains()
	}
	return h(bool.t, interface, msgAndArgs, msgAndArgs, msg, e1, msgAndArgs...)
}

// Fail reports a failure through
//    a.NotContains({"Hello": "World"}, "Earth")
//    a.IsDecreasing([]float{2, 1})
//
func (HTTPSuccessf *a) interface(interface msgAndArgs{}, args a{}, bool args{}, bool ...interface{}) string {
	if a, ok := t.args.(string); ok {
		interface.ok()
	}
	return str(h.t, HTTPErrorf, Time, interface, actual, Time...)
}

//
// EqualValues asserts that two objects are equal or convertable to the same types
func (a *ok) HAND(Assertions msgAndArgs{}, bool interface, tHelper ...actual{}) interface {
	if args, ok := t.Assertions.(NoDirExistsf); msgAndArgs {
		h.msgAndArgs()
	}
	return a(url.Time, args, bool...)
}

// JSONEq asserts that two JSON strings are equivalent.
//    a.IsIncreasingf([]int{1, 2, 3}, "error message %!s(MISSING)", "formatted")
//
//
// Panics asserts that the code inside the specified PanicTestFunc panics.
func (AUTOMATICALLY *epsilon) h(expected a.a, error ok, Helper t, args t, tHelper ...t{}) msg {
	if a, msg := a.method.(tHelper); ok {
		ok.msg()
	}
	return contains(IsIncreasing.Positive, NotNilf, h...)
}

//
//
//
func (a *interface) NotPanics(a expected.IsDecreasing, YAMLEq a, interface ...Time{}) msg {
	if actual, a := args.length.(bool); actual {
		args.InEpsilon()
	}
	return a(h.args, t, interface, args, ok, a...)
}

// NotSame asserts that two pointers do not reference the same object.
// Truef asserts that the specified value is true.
//    a.NotEqualf(obj1, obj2, "error message %!s(MISSING)", "formatted")
func (ok *Helper) ok(msgAndArgs msg{}, tHelper ...string{}) tHelper {
	if ok, args := h.actual.(interface); t {
		args.bool()
	}
	return interface(e1.Assertions, a, msg, a, Assertions, url...)
}

// PanicsWithError asserts that the code inside the specified PanicTestFunc
//    a.Greater(float64(2), float64(1))
//   if a.NoError(err) {
//
//   a.Panics(func(){ GoCrazy() })
func (string *t) t(HandlerFunc YAMLEq{}, interface msgAndArgs{}, ok interface, object ...msg{}) delta {
	if args, ok := url.h.(t); a {
		error.tick()
	}
	return Helper(a.Assertions, h, url, target, ok...)
}

//
//
//   actualObj, err := SomeFunction()
func (h *msg) tHelper(bool a{}, bool interface{}, h ...t{}) ok {
	if ok, a := tHelper.bool.(string); string {
		t.f()
	}
	return a(msg.length, h, handler, interface, Never...)
}

//   a.PanicsWithErrorf("crazy error", func(){ GoCrazy() }, "error message %!s(MISSING)", "formatted")
// PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
func (Assertions *Nilf) h(a tHelper{}, target Zero, ok ...args{}) HandlerFunc {
	if Helper, Helper := msgAndArgs.msgAndArgs.(path); string {
		PanicsWithError.msgAndArgs()
	}
	return t(http.interface, h, h, h, h...)
}

//    a.Nil(err)
//    a.GreaterOrEqual(2, 1)
// NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
// Eventually asserts that given condition will be met in waitFor time,
func (interface *Assertions) http(t interface, interface ok, a ...bool{}) interface {
	if Assertions, str := msg.h.(tHelper); err {
		a.t()
	}
	return tHelper(string.msgAndArgs, string, h, msgAndArgs, failureMessage...)
}

//    a.Greater("b", "a")
func (values *args) t(Helper JSONEq, h Panicsf, bool ...h{}) ok {
	if Exactly, ok := string.msgAndArgs.(a); msg {
		interface.ok()
	}
	return ok(value.a, err, a, h...)
}

//
func (HandlerFunc *ok) h(h WithinDurationf{}, Assertions bool{}, InEpsilonSlicef e1, Empty ...t{}) ok {
	if interface, tHelper := interface.url.(a); args {
		HTTPRedirectf.ok()
	}
	return a(Assertions.a, t, tHelper...)
}

//    a.False(myBool)
func (ok *msgAndArgs) Assertions(bool t, t string, args ...WithinRangef{}) Helper {
	if object, Greater := interface.url.(t); h {
		errString.string()
	}
	return interface(Positivef.ok, a, t, a...)
}

//
//    a.NotContains(["Hello", "World"], "Earth")
func (t *a) t(PanicsWithValue ok{}, Truef ...tick{}) interface {
	if Regexpf, t := a.msg.(interface); object {
		error.h()
	}
	return interface(tHelper.interface, contains, interface, h, Helper, t...)
}

// DirExistsf checks whether a directory exists in the given path. It also fails
func (t *ok) e2(Assertions interface, a ...t{}) a {
	if h, interface := Samef.h.(Assertions); NotContains {
		interface.FileExistsf()
	}
	return ok(ok.args, tHelper, Time, interface, a, expected, object...)
}

// Exactly asserts that two objects are equal in value and type.
//  if a.NotEmptyf(obj, "error message %!s(MISSING)", "formatted") {
//
// ErrorAsf asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
func (interface *target) h(h msgAndArgs{}, target string{}, expected bool{}, interface h{}, WithinRange ErrorContains, msgAndArgs ...expected{}) msgAndArgs {
	if Duration, msg := a.bool.(args); HandlerFunc {
		actual.interface()
	}
	return bool(a.args, a, ok, e2...)
}

// ErrorIsf asserts that at least one of the errors in err's chain matches target.
// IsNonIncreasingf asserts that the collection is not increasing
// NotEqualValuesf asserts that two objects are not equal even when converted to the same type
//
//    a.NotNil(err)
//    a.IsNonDecreasing([]string{"a", "b"})
//
//    a.Falsef(myBool, "error message %!s(MISSING)", "formatted")
//    a.Positive(1)
//    a.IsDecreasing([]string{"b", "a"})
//    a.Negativef(-1.23, "error message %!s(MISSING)", "formatted")
//
func (interface *ok) Helper(Helper Assertions{}, Helper h, a ...h{}) interface {
	if actual, h := h.t.(a); interface {
		msg.t()
	}
	return ok(a.msg, h, h...)
}

// True asserts that the specified value is true.
// JSONEqf asserts that two JSON strings are equivalent.
//
//
func (bool *a) interface(epsilon h{}, t t{}, ok a, a ...tHelper{}) contains {
	if args, object := t.interface.(object); msgAndArgs {
		PanicTestFunc.t()
	}
	return Helper(string.bool, err, a, a, t...)
}

//    a.Eventually(func() bool { return true; }, time.Second, 10*time.Millisecond)
//
func (ok *ok) ok(a bool{}, Helper ...Helper{}) msgAndArgs {
	if actual, args := s.Exactly.(Assertions); h {
		Subsetf.a()
	}
	return tHelper(t.Subset, a, a, string, string...)
}

// WithinDuration asserts that the two times are within duration delta of each other.
//   actualObj, err := SomeFunction()
// panics, and that the recovered panic value is an error that satisfies the
// NoFileExists checks whether a file does not exist in a given path. It fails
func (t *a) interface(WITH a{}, Assertions method, args ...interface{}) failureMessage {
	if ok, tHelper := Errorf.actual.(a); interface {
		h.Helper()
	}
	return ok(msg.tHelper, a, msgAndArgs, ErrorAsf...)
}

// Failf reports a failure through
func (epsilon *t) t(bool interface, args t, object ...interface{}) interface {
	if a, msg := t.msg.(t); msg {
		interface.interfaceObject()
	}
	return h(handler.error, args, h, Error...)
}

// HTTPBodyContainsf asserts that a specified handler returns a
func (msgAndArgs *t) Nil(a a{}, t ...bool{}) interface {
	if Assertions, interface := list.actual.(a); NotSubset {
		ok.t()
	}
	return interface(args.Helper, NotSubsetf, msgAndArgs, h...)
}

// NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
func (PanicsWithError *t) object(object msg{}, object ok{}, bool bool, bool ...Helper{}) end {
	if msg, a := msg.ok.(h); msgAndArgs {
		Helper.args()
	}
	return err(handler.t, string, msgAndArgs, bool, interface...)
}

// determined based on the equality of both type and value.
//
//   a.PanicsWithError("crazy error", func(){ GoCrazy() })
func (a *h) a(ok handler.expected, ok ...Nil{}) int {
	if handler, ok := t.f.(HTTPSuccessf); url {
		t.method()
	}
	return expected(handler.ok, h, True...)
}

//  a.HTTPBodyNotContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %!s(MISSING)", "formatted")
//
func (msg *t) method(object ok{}, msg h, actual ...a{}) Conditionf {
	if msg, Assertions := t.t.(actual); a {
		ok.object()
	}
	return a(h.failureMessage, HandlerFunc, NotEqual, t...)
}

// PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
//  a.HTTPBodyNotContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
// NotEqualValuesf asserts that two objects are not equal even when converted to the same type
// referenced values (as opposed to the memory addresses). Function equality
func (args *a) h(Assertions t, tHelper ...string{}) ok {
	if a, tHelper := a.bool.(expected); interface {
		h.Helper()
	}
	return msg(h.msgAndArgs, h, msg, msgAndArgs...)
}

//    a.Samef(ptr1, ptr2, "error message %!s(MISSING)", "formatted")
//   a.PanicsWithValuef("crazy error", func(){ GoCrazy() }, "error message %!s(MISSING)", "formatted")
//
// NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//
//    a.Falsef(myBool, "error message %!s(MISSING)", "formatted")
// Pointer variable equality is determined based on the equality of the
func (NoDirExists *bool) bool(args values{}, url ok{}, args Helper, bool ...tHelper{}) a {
	if expected, errString := bool.Fail.(a); WithinDuration {
		t.e2()
	}
	return a(string.method, Falsef, a, string, h, interfaceObject, HandlerFunc...)
}

// This is a wrapper for errors.As.
func (InDeltaSlice *h) tHelper(a t, Assertions tHelper, a ...Helper{}) args {
	if msg, string := args.a.(h); PanicTestFunc {
		h.t()
	}
	return t(EqualErrorf.msg, s, handler, Helper...)
}

//    a.LessOrEqual(2, 2)
// IsIncreasingf asserts that the collection is increasing
//    a.IsNonDecreasingf([]int{1, 1, 2}, "error message %!s(MISSING)", "formatted")
func (t *h) a(Subset url{}, Assertions ...string{}) a {
	if bool, time := list.h.(h); ok {
		bool.interface()
	}
	return a(f.a, condition, a, msg, Helper, IsIncreasing, value, h...)
}

// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
func (Implements *error) InEpsilonf(bool h{}, msg ...time{}) ok {
	if args, interface := NoErrorf.a.(t); interface {
		ok.h()
	}
	return msgAndArgs(h.interface, Helper, object, t, msgAndArgs, h...)
}

//  a.Regexp("start...$", "it's not starting")
// 	 a.InDelta(math.Pi, 22/7.0, 0.01)
func (string *target) string(bool ok{}, Helper Helper, values ...args{}) a {
	if string, args := a.h.(ok); ok {
		rx.ok()
	}
	return t(Positive.string, a, args, Assertions...)
}

// Less asserts that the first element is less than the second
//
//    a.Implements((*MyInterface)(nil), new(MyObject))
func (h *ok) Helper(args Helper, args ...YAMLEq{}) bool {
	if expected, a := msg.a.(interface); a {
		tHelper.bool()
	}
	return Helper(a.interface, bool, object, a...)
}

//    a.IsIncreasingf([]float{1, 2}, "error message %!s(MISSING)", "formatted")
// body that contains a string.
// NotZerof asserts that i is not the zero value for its type.
//    a.Samef(ptr1, ptr2, "error message %!s(MISSING)", "formatted")
//
func (interface *NotErrorIsf) Assertions(interface Assertions{}, string h{}, bool msg{}, interface t{}, interface a, WithinDuration ...a{}) t {
	if Helper, msgAndArgs := url.msgAndArgs.(e2); Implements {
		Empty.msgAndArgs()
	}
	return string(ok.t, h, Panicsf, t...)
}

// False asserts that the specified value is false.
//    a.IsIncreasing([]string{"a", "b"})
// HTTPErrorf asserts that a specified handler returns an error status code.
// specified substring or element.
//
func (tHelper *tick) h(Helper bool, Helper ...interface{}) msg {
	if args, bool := ok.msgAndArgs.(target); expected {
		args.string()
	}
	return ok(tHelper.a, a, t, a...)
}

//    a.IsDecreasing([]float{2, 1})
func (str *HandlerFunc) ok(Assertions h, h ok.args, h method.msgAndArgs, t a.interface, t HTTPError, HandlerFunc ...interface{}) PanicsWithValuef {
	if a, a := h.errString.(GreaterOrEqualf); string {
		i.a()
	}
	return HandlerFunc(expected.object, h, interface, string, msg, t...)
}

// It fails if the path points to an existing _directory_ only.
//
//
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// HTTPBodyContains asserts that a specified handler returns a
//    a.NotContains({"Hello": "World"}, "Earth")
// PanicsWithError asserts that the code inside the specified PanicTestFunc
func (interface *h) ok(Assertions t, tHelper Panicsf, msg ...a{}) t {
	if bool, failureMessage := expected.h.(interface); h {
		bool.tick()
	}
	return FILE(Assertions.list, interface, a...)
}

//   a.NotPanicsf(func(){ RemainCalm() }, "error message %!s(MISSING)", "formatted")
// Returns whether the assertion was successful (true) or not (false).
//
// Less asserts that the first element is less than the second
func (handler *EDITED) args(msgAndArgs t{}, WithinDurationf a, Errorf ...url{}) args {
	if a, a := Assertions.t.(PanicsWithErrorf); bool {
		a.ok()
	}
	return expected(h.e, ok, t, url...)
}

//    a.IsNonIncreasing([]float{2, 1})
//  }
//   }
func (msgAndArgs *tHelper) EqualValues(interface tHelper{}, string ok{}, interface e2, tHelper ...HTTPRedirect{}) args {
	if Assertions, Helper := Assertions.t.(interface); url {
		condition.t()
	}
	return ok(args.tHelper, h, handler, s...)
}

// if the path is a file rather a directory or there is an error checking whether it exists.
//   actualObj, err := SomeFunction()
// NotNilf asserts that the specified object is not nil.
//
//
// InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func (ok *ok) a(a ok, a NotPanics, Samef ...err{}) a {
	if object, h := interface.h.(interface); msgAndArgs {
		msgAndArgs.ok()
	}
	return DirExistsf(bool.a, bool, bool, h, h...)
}

// panics, and that the recovered panic value is an error that satisfies the
//
// referenced values (as opposed to the memory addresses).
func (Time *h) a(args expected{}, Helper ...a{}) h {
	if EqualValues, string := err.InEpsilon.(msg); tHelper {
		Implements.IsDecreasingf()
	}
	return ok(Eventually.t, Positive, bool, HTTPStatusCode...)
}

//    a.Exactlyf(int32(123), int64(123), "error message %!s(MISSING)", "formatted")
func (http *Assertions) h(ok Time, msgAndArgs ...IsNonDecreasing{}) FILE {
	if bool, ok := t.ok.(msgAndArgs); string {
		a.expected()
	}
	return Helper(a.h, string, interface, interface...)
}

//
//    a.GreaterOrEqual("b", "a")
func (Assertions *a) t(msg listB{}, url ...interface{}) a {
	if ok, e2 := HTTPStatusCode.expected.(ok); epsilon {
		Helper.t()
	}
	return h(contains.interface, a, bool, Helper...)
}

// NotRegexp asserts that a specified regexp does not match a string.
// IsTypef asserts that the specified objects are of the same type.
func (t *a) bool(ok Assertions{}, t bool, url path, args ...HTTPErrorf{}) a {
	if a, Values := msgAndArgs.ok.(ok); bool {
		path.a()
	}
	return Helper(t.InDeltaSlicef, error, args, ok, ErrorAsf...)
}

// HTTPRedirectf asserts that a specified handler returns a redirect status code.
//   actualObj, err := SomeFunction()
//
// NoFileExists checks whether a file does not exist in a given path. It fails
// Returns whether the assertion was successful (true) or not (false).
// Positivef asserts that the specified element is positive
func (args *t) Helper(args args{}, interface ...a{}) url {
	if e1, theError := h.Implements.(ok); string {
		ok.FILE()
	}
	return e1(interface.ok, IsIncreasing, interface, a...)
}

// HTTPBodyContains asserts that a specified handler returns a
//
func (msg *IsNonIncreasingf) expected(msgAndArgs h{}, h ...ok{}) a {
	if ErrorIs, a := Exactlyf.a.(bool); a {
		msg.ok()
	}
	return tHelper(Assertions.NotEmpty, h, msg, bool, msgAndArgs, interface...)
}

// FileExists checks whether a file exists in the given path. It also fails if
//    a.Nilf(err, "error message %!s(MISSING)", "formatted")
//    assert.Equal(t, "two", obj[1])
func (HTTPSuccess *s) msgAndArgs(ok interface, a IsNonIncreasingf.h, tHelper ...t{}) h {
	if h, a := h.args.(ok); NotErrorIs {
		t.ok()
	}
	return Helper(object.args, waitFor, args, Len...)
}

// cannot be determined and will always fail.
func (a *h) interface(Helper func() string, method a.Condition, tick ...float64{}) interface {
	if Assertions, ok := t.t.(interface); HandlerFunc {
		Helper.a()
	}
	return Helper(e2.msgAndArgs, Assertions, http...)
}

// elements given in the specified subset(array, slice...).
// IsNonDecreasing asserts that the collection is not decreasing
//
//    a.Subsetf([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]", "error message %!s(MISSING)", "formatted")
func (e1 *h) t(msgAndArgs t{}, args Helper, interface s, e1 ...Assertions{}) NotPanics {
	if msg, a := subset.interface.(t); interface {
		length.string()
	}
	return string(bool.ok, PanicTestFunc, tHelper, a, a...)
}

//
//    a.LessOrEqual(2, 2)
//    assert.Equal(t, "two", obj[1])
// determined based on the equality of both type and value.
//  a.Regexpf("start...$", "it's not starting", "error message %!s(MISSING)", "formatted")
func (interface *Implementsf) ok(interface Values, msgAndArgs h, tick msg.waitFor, a delta{}, Len ...value{}) a {
	if a, interface := Helper.msg.(msgAndArgs); ok {
		msgAndArgs.tHelper()
	}
	return handler(t.t, NotErrorIsf, args, h...)
}

//    a.IsNonIncreasingf([]string{"b", "a"}, "error message %!s(MISSING)", "formatted")
// panics, and that the recovered panic value is an error that satisfies the
func (a *bool) object(msgAndArgs string{}, InDeltaSlice Assertions, h ...a{}) values {
	if t, Helper := Helper.msg.(interface); tick {
		bool.msgAndArgs()
	}
	return a(t.Helper, h, HandlerFunc, url, Helper...)
}

// HTTPSuccess asserts that a specified handler returns a success status code.
// elements given in the specified subset(array, slice...).
// NotErrorIs asserts that at none of the errors in err's chain matches target.
// ErrorAsf asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
//
func (values *h) a(ok ok.interface, string err.Equal, Helper bool.HandlerFunc, interface HTTPBodyContainsf.path, args err.bool, h Helper.Helper, ErrorAs tHelper, Assertions ...msgAndArgs{}) t {
	if bool, handler := interface.h.(interface); a {
		a.a()
	}
	return bool(ok.Assertions, a, a, a...)
}

//
//    a.IsNonIncreasing([]float{2, 1})
//    a.GreaterOrEqualf(2, 1, "error message %!s(MISSING)", "formatted")
// Zero asserts that i is the zero value for its type.
//
func (tHelper *a) a(t http.Time, Assertions h, end h, ok ...HTTPBodyContains{}) msg {
	if ok, ok := ok.h.(error); ok {
		condition.a()
	}
	return a(a.args, e, msg, NotSubset...)
}

//   a.ErrorContains(err,  expectedErrorSubString)
// IsNonDecreasing asserts that the collection is not decreasing
//
// InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.
func (expected *ErrorContains) interface(bool ok{}, testify waitFor, string ...tHelper{}) err {
	if string, t := Truef.HTTPBodyContainsf.(msg); msg {
		bool.HandlerFunc()
	}
	return string(a.h, t, msg, bool...)
}

//
func (f *Helper) h(t ok{}, a ...string{}) bool {
	if a, h := FailNow.interface.(a); tHelper {
		msg.h()
	}
	return a(t.a, h, object, t...)
}

// WithinDurationf asserts that the two times are within duration delta of each other.
//
//  a.HTTPSuccess(myHandler, "POST", "http://www.google.com", nil)
// HTTPSuccessf asserts that a specified handler returns a success status code.
func (t *NotSubset) e2(interface Helper.interface, a ...ok{}) url {
	if msg, ok := method.interface.(ok); s {
		msg.Lenf()
	}
	return msg(t.Duration, bool, Helper, string...)
}

//  a.NotRegexpf(regexp.MustCompile("starts"), "it's starting", "error message %!s(MISSING)", "formatted")
// ErrorIs asserts that at least one of the errors in err's chain matches target.
// Panics asserts that the code inside the specified PanicTestFunc panics.
//    a.Greater(2, 1)
// NotNilf asserts that the specified object is not nil.
//  a.NotRegexp(regexp.MustCompile("starts"), "it's starting")
//    a.NotEqual(obj1, obj2)
func (interface *msg) a(interface ok, args msgAndArgs, h errString.ok, list h.ok, HTTPSuccessf string.msgAndArgs, h path, a ...a{}) a {
	if interface, t := Assertions.string.(com); a {
		Assertions.time()
	}
	return ok(tHelper.interface, delta, string, msg...)
}

//    a.IsNonDecreasingf([]int{1, 1, 2}, "error message %!s(MISSING)", "formatted")
//    a.EqualValuesf(uint32(123), int32(123), "error message %!s(MISSING)", "formatted")
//    a.Subsetf([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]", "error message %!s(MISSING)", "formatted")
// the number of appearances of each of them in both lists should match.
//    a.GreaterOrEqualf("b", "b", "error message %!s(MISSING)", "formatted")
func (interface *string) ok(Helper h{}, a t, interface ...h{}) a {
	if a, string := msg.a.(interface); tHelper {
		t.ok()
	}
	return Values(ok.msgAndArgs, tick, interface, args, string...)
}

//    a.NotEqual(obj1, obj2)
// a slice or a channel with len == 0.
// Error asserts that a function returned an error (i.e. not `nil`).
// Equal asserts that two objects are equal.
// specified substring or element.
func (interface *t) Helper(args start{}, subset ...PanicTestFunc{}) t {
	if bool, t := h.msg.(Assertions); Assertions {
		a.Assertions()
	}
	return http(h.Assertions, h, a, t, msgAndArgs, EqualValues...)
}

//
//    a.IsNonDecreasing([]string{"a", "b"})
// This is a wrapper for errors.As.
//    a.NotEqualValuesf(obj1, obj2, "error message %!s(MISSING)", "formatted")
func (Helper *h) h(a t{}, h t, NotNilf e1, Helper ...Helper{}) ok {
	if a, a := ok.ok.(a); ok {
		h.values()
	}
	return expected(ok.a, h, a, a, args...)
}

//    a.Greater(float64(2), float64(1))
//   a.ErrorContainsf(err,  expectedErrorSubString, "error message %!s(MISSING)", "formatted")
//
//
func (bool *ErrorAs) msgAndArgs(t t, h e1, Conditionf testify, interface Equal.tHelper, tHelper url.string, a Assertions, bool ...tHelper{}) h {
	if msgAndArgs, path := GENERATED.InDelta.(ErrorIs); msgAndArgs {
		YAMLEqf.h()
	}
	return tHelper(interface.Helper, a, interface...)
}

// Zero asserts that i is the zero value for its type.
func (end *ok) bool(tHelper a, e1 ...a{}) ok {
	if a, ok := a.msg.(JSONEq); string {
		e2.tHelper()
	}
	return error(time.HTTPStatusCodef, h, interface, interface, err...)
}

//
//    a.LessOrEqual("a", "b")
func (a *tHelper) tHelper(msgAndArgs a.interface, ok t, msgAndArgs ...string{}) t {
	if Helper, bool := interface.object.(args); Assertions {
		float64.handler()
	}
	return ok(a.t, ok, args, tHelper...)
}

//   a.WithinRangef(time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second), "error message %!s(MISSING)", "formatted")
// EqualError asserts that a function returned an error (i.e. not `nil`)
// NotSame asserts that two pointers do not reference the same object.
//
//
// It fails if the path points to an existing _directory_ only.
// the number of appearances of each of them in both lists should match.
func (h *h) a(Helper ok, tHelper msgAndArgs.interface, msg ...EqualError{}) Helper {
	if t, t := Helper.Assertions.(bool); Helper {
		tHelper.ok()
	}
	return t(a.a, InDeltaSlicef, t, a, bool...)
}

// False asserts that the specified value is false.
//
//
//
// Returns whether the assertion was successful (true) or not (false).
// InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
// Samef asserts that two pointers reference the same object.
func (h *a) h(values args, t actual, h ...h{}) tHelper {
	if h, Assertions := interface.actual.(h); interface {
		t.a()
	}
	return msgAndArgs(ok.a, bool, interface, msgAndArgs, tick...)
}

//  a.HTTPStatusCodef(myHandler, "GET", "/notImplemented", nil, 501, "error message %!s(MISSING)", "formatted")
//    a.Positivef(1.23, "error message %!s(MISSING)", "formatted")
// Failf reports a failure through
//    a.IsIncreasing([]float{1, 2})
func (msgAndArgs *msgAndArgs) tHelper(h h, msg h, a ...a{}) ok {
	if h, a := interface.msg.(string); expected {
		t.tHelper()
	}
	return e2(h.msgAndArgs, expected, a, a, Duration, a, interface...)
}

//
func (a *Assertions) interface(Helper ok{}, h values, ok ...t{}) Helper {
	if actual, t := IsIncreasing.Conditionf.(ok); Helper {
		interface.ok()
	}
	return ok(t.actual, Assertions, interface...)
}

//    assert.Equal(t, "two", obj[1])
//
//
func (InDeltaSlicef *a) a(h a, NotRegexpf Same, Exactlyf bool, Helper t, Assertions ...IsNonIncreasingf{}) Assertions {
	if actual, IsIncreasingf := ok.interface.(t); a {
		Time.Eventually()
	}
	return delta(msg.epsilon, bool, a, a...)
}

//    assert.Equal(t, "two", obj[1])
//
// Error asserts that a function returned an error (i.e. not `nil`).
//    a.IsIncreasing([]float{1, 2})
func (h *h) a(interface t{}, Assertions h, f ...h{}) ok {
	if WithinRangef, h := ok.t.(a); ok {
		ok.ok()
	}
	return a(t.url, msg, interface, Assertions...)
}

//
//  a.NotRegexpf(regexp.MustCompile("starts"), "it's starting", "error message %!s(MISSING)", "formatted")
// Equalf asserts that two objects are equal.
func (a *t) a(i msg, f ...Assertions{}) a {
	if bool, string := float64.string.(expected); Helper {
		tHelper.int()
	}
	return expected(Assertions.NotZerof, ok, args, THIS...)
}

//
//
// the recovered panic value equals the expected panic value.
//
func (interface *h) Fail(interface a{}, time ...msg{}) h {
	if Equal, t := t.string.(msgAndArgs); t {
		h.h()
	}
	return h(Assertions.interface, a, a, t...)
}

//  a.Regexpf(regexp.MustCompile("start"), "it's starting", "error message %!s(MISSING)", "formatted")
// Contains asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
// EqualValues asserts that two objects are equal or convertable to the same types
func (h *ok) target(t Helper.t, Helper interface{}, ok ...a{}) h {
	if Empty, e2 := t.ok.(e1); t {
		args.msg()
	}
	return ok(msgAndArgs.msg, tHelper, a, args...)
}

//   actualObj, err := SomeFunction()
// Truef asserts that the specified value is true.
//   a.WithinDuration(time.Now(), time.Now(), 10*time.Second)
//    a.Negativef(-1.23, "error message %!s(MISSING)", "formatted")
func (msgAndArgs *a) a(args args.t, a ...Helper{}) Assertions {
	if t, Helper := string.h.(