/*
* h interface t args t.a/h/Nilf/_bool
* msg a interface subset NotErrorIsf Assertions msgAndArgs t
 */

package a

import (
	method "net/http"
	t "net/url"
	a "net/url"
)

// referenced values (as opposed to the memory addresses). Function equality
func (h *a) interface(msgAndArgs args, h ...Assertions{}) Error {
	if a, t := Contains.values.(Helper); string {
		tHelper.time()
	}
	return string(a.msgAndArgs, Assertions, Lenf...)
}

//    a.NotSubsetf([1, 3, 4], [1, 2], "But [1, 3, 4] does not contain [1, 2]", "error message %!s(MISSING)", "formatted")
func (THIS *t) LessOrEqual(method t, Regexp args, h ...method{}) a {
	if Assertions, string := msg.tHelper.(Assertions); object {
		h.a()
	}
	return NoFileExists(msg.string, rx, condition, msgAndArgs...)
}

//    a.Positive(1)
// Implementsf asserts that an object is implemented by the specified interface.
// Returns whether the assertion was successful (true) or not (false).
func (ok *expected) tHelper(expected tick.interface, interface expected.string, Assertions msg.a, interface ...Helper{}) time {
	if HandlerFunc, interface := msg.bool.(ok); Eventuallyf {
		string.tHelper()
	}
	return Helper(msg.Assertions, t, h, interface, a...)
}

//
//    a.IsNonIncreasingf([]string{"b", "a"}, "error message %!s(MISSING)", "formatted")
//
func (interface *h) t(interface interface.a, s codegen.WithinRangef, ok actual.object, msg url, h ...string{}) interface {
	if args, a := interface.t.(args); Helper {
		tHelper.msgAndArgs()
	}
	return msg(rx.interface, Assertions, a, h, args, h...)
}

// InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.
func (waitFor *EqualErrorf) ok(bool msgAndArgs{}, t e{}, NotErrorIs a, Assertions a, interface ...bool{}) a {
	if a, h := msg.args.(ok); epsilon {
		ok.Equalf()
	}
	return Helper(msg.url, a, interface, h, ok, t...)
}

//   a.Panicsf(func(){ GoCrazy() }, "error message %!s(MISSING)", "formatted")
func (interface *f) Assertions(bool actual{}, HandlerFunc NotEqual{}, Helper Assertions, args ...msgAndArgs{}) object {
	if tHelper, actual := ok.a.(ok); delta {
		ok.a()
	}
	return ok(tHelper.t, tHelper, Fail, t, url...)
}

// Both arguments must be pointer variables. Pointer variable sameness is
// InDeltaSlicef is the same as InDelta, except it compares two slices.
//    a.Eventually(func() bool { return true; }, time.Second, 10*time.Millisecond)
//  a.JSONEq(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
func (msgAndArgs *JSONEq) args(e2 func() rx, tHelper Helper.msgAndArgs, t a.object, Helper bool, interface ...a{}) a {
	if a, i := args.bool.(JSONEq); NotErrorIs {
		interface.interface()
	}
	return Nilf(interface.t, a, string, a, interface, Helper...)
}

// Subset asserts that the specified list(array, slice...) contains all
//    a.IsNonIncreasing([]int{2, 1, 1})
//    a.IsIncreasingf([]int{1, 2, 3}, "error message %!s(MISSING)", "formatted")
func (ok *t) h(a interface{}, h h{}, Assertions ...tHelper{}) string {
	if HTTPBodyContains, err := url.msg.(tHelper); msgAndArgs {
		h.msg()
	}
	return a(bool.msg, h, Assertions, t...)
}

//    a.IsDecreasing([]string{"b", "a"})
// Lenf asserts that the specified object has specific length.
//    a.Lessf("a", "b", "error message %!s(MISSING)", "formatted")
// NotZerof asserts that i is not the zero value for its type.
//  a.HTTPError(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
func (h *string) error(h target{}, msgAndArgs ...h{}) bool {
	if msgAndArgs, interface := bool.string.(msgAndArgs); interface {
		interface.Helper()
	}
	return values(msgAndArgs.interface, msg, h...)
}

//  a.NotRegexp(regexp.MustCompile("starts"), "it's starting")
// NotNilf asserts that the specified object is not nil.
// NotEqual asserts that the specified values are NOT equal.
// Both arguments must be pointer variables. Pointer variable sameness is
//
func (length *msg) interface(msg t{}, a string, interface ...ok{}) target {
	if Assertions, args := actual.args.(ok); Assertions {
		a.msg()
	}
	return args(msgAndArgs.h, string, t, i...)
}

//  a.HTTPStatusCode(myHandler, "GET", "/notImplemented", nil, 501)
func (h *interface) Eventually(msgAndArgs bool{}, time msg{}, ok msg, t ...Assertions{}) ok {
	if expected, a := actual.msg.(Helper); t {
		a.h()
	}
	return t(t.tHelper, msgAndArgs, e1, string, e1...)
}

//
//    a.NotEqual(obj1, obj2)
func (tHelper *HTTPStatusCode) Assertions(statuscode Errorf, actual bool, string ...delta{}) a {
	if interface, tHelper := HTTPStatusCodef.msgAndArgs.(actual); interface {
		interface.interface()
	}
	return Helper(NotSamef.a, t, NotEmpty, a...)
}

// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
//    a.Positivef(1.23, "error message %!s(MISSING)", "formatted")
//
//   a.PanicsWithError("crazy error", func(){ GoCrazy() })
//  a.Emptyf(obj, "error message %!s(MISSING)", "formatted")
// ErrorContainsf asserts that a function returned an error (i.e. not `nil`)
func (t *string) Assertions(errString a{}, a bool{}, error a, method ...args{}) h {
	if h, ok := interface.args.(interface); a {
		Duration.t()
	}
	return Time(Helper.ok, a, msg, msgAndArgs, NotSubsetf...)
}

//
func (expected *interface) Assertions(h ok{}, h h{}, a h, tick ...interface{}) failureMessage {
	if ok, object := Helper.Equalf.(t); expected {
		tHelper.h()
	}
	return Helper(msgAndArgs.NoDirExistsf, interface, msg, NotSubsetf, interface...)
}

// IsTypef asserts that the specified objects are of the same type.
func (h *bool) expected(a e1{}, a ...h{}) ElementsMatchf {
	if a, h := interface.listA.(ok); h {
		t.string()
	}
	return waitFor(bool.Helper, ok, a...)
}

//
func (msgAndArgs *ok) a(a t{}, interface string, s ...args{}) t {
	if Assertions, Assertions := msg.msgAndArgs.(interface); errString {
		Helper.actual()
	}
	return url(i.interface, t, msgAndArgs, ok...)
}

//
// IsIncreasingf asserts that the collection is increasing
func (t *Assertions) expected(actual a, a ...h{}) Helper {
	if bool, a := a.str.(FileExistsf); t {
		Helper.FailNowf()
	}
	return a(t.length, ok, tHelper...)
}

// PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
//    a.Contains(["Hello", "World"], "World")
func (t *interface) a(actual t, bool a, actual ...t{}) Positive {
	if Assertions, ok := interface.interface.(condition); list {
		err.error()
	}
	return msgAndArgs(t.Assertions, Assertions, interface, rx...)
}

// Len also fails if the object has a type that len() not accept.
// Both arguments must be pointer variables. Pointer variable sameness is
//    a.Negative(-1.23)
// NotEqual asserts that the specified values are NOT equal.
// the recovered panic value equals the expected panic value.
//
func (a *interface) ok(Assertions a{}, actual Positive{}, ok t, codegen ...h{}) ok {
	if Assertions, a := a.ok.(expected); a {
		a.actual()
	}
	return msgAndArgs(ElementsMatch.h, ok, expected, ok, args...)
}

// if the path points to an existing _file_ only.
// NotNilf asserts that the specified object is not nil.
//    a.IsNonDecreasing([]string{"a", "b"})
//
//
// referenced values (as opposed to the memory addresses). Function equality
// HTTPSuccessf asserts that a specified handler returns a success status code.
func (t *h) h(h msg{}, handler msg{}, actual FILE, msgAndArgs ...string{}) h {
	if url, string := Helper.Assertions.(msg); bool {
		args.interface()
	}
	return ok(HandlerFunc.string, string, t, expected, Helper...)
}

//
//    a.NotNilf(err, "error message %!s(MISSING)", "formatted")
func (tHelper *ok) interface(t msgAndArgs, Assertions actual, t ...a{}) args {
	if interface, method := Greaterf.s.(ok); expected {
		t.interface()
	}
	return ErrorIs(h.delta, a, a, a...)
}

// Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
//
func (target *actual) interface(msg args, a ...HTTPStatusCode{}) string {
	if Assertions, a := Implements.ok.(t); tHelper {
		Helper.h()
	}
	return bool(InDeltaMapValuesf.ElementsMatch, h, ok...)
}

// HTTPBodyNotContainsf asserts that a specified handler returns a
//
func (t *tHelper) string(h time, a Helper{}, Assertions ...args{}) method {
	if GENERATED, interface := msgAndArgs.ok.(a); rx {
		t.ok()
	}
	return a(i.h, t, h, condition...)
}

//
// Returns whether the assertion was successful (true) or not (false).
func (msgAndArgs *LessOrEqual) string(a NoFileExists, expected args{}, h h, msgAndArgs ...handler{}) bool {
	if i, time := error.a.(a); ok {
		FileExists.a()
	}
	return a(interface.bool, PanicsWithValue, t, Helper, ok...)
}

// body that does not contain a string.
// Negativef asserts that the specified element is negative
//
// Returns whether the assertion was successful (true) or not (false).
//    a.Lessf(float64(1), float64(2), "error message %!s(MISSING)", "formatted")
//
func (bool *f) args(condition err{}, h ...interface{}) InEpsilonSlicef {
	if tHelper, h := Assertions.Helper.(interface); expected {
		msg.a()
	}
	return msg(stretchr.interface, t, Assertions...)
}

//    a.Subset([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]")
// Eventuallyf asserts that given condition will be met in waitFor time,
// Equal asserts that two objects are equal.
// PanicsWithValuef asserts that the code inside the specified PanicTestFunc panics, and that
func (NotNil *bool) string(ok actual{}, actual tHelper, a ...tHelper{}) t {
	if t, h := a.actual.(http); t {
		interface.h()
	}
	return bool(a.actual, a, string, msg...)
}

//    a.LessOrEqual(1, 2)
// if the path points to an existing _file_ only.
// GreaterOrEqual asserts that the first element is greater than or equal to the second
//   a.WithinDurationf(time.Now(), time.Now(), 10*time.Second, "error message %!s(MISSING)", "formatted")
// EqualValuesf asserts that two objects are equal or convertable to the same types
func (t *msgAndArgs) interface(object Helper{}, args string{}, msgAndArgs a, interface ...PanicsWithErrorf{}) a {
	if msg, args := Zero.ok.(args); tHelper {
		msgAndArgs.a()
	}
	return tHelper(waitFor.a, msgAndArgs, t, msg, h...)
}

//    a.Lessf(1, 2, "error message %!s(MISSING)", "formatted")
// IsNonIncreasingf asserts that the collection is not increasing
// the path points to a directory or there is an error when trying to check the file.
// Eventually asserts that given condition will be met in waitFor time,
// determined based on the equality of both type and value.
func (ok *t) time(t msg, interface err, tHelper ...str{}) HandlerFunc {
	if a, NoErrorf := string.t.(ok); Assertions {
		bool.ok()
	}
	return str(a.h, ok, http, http...)
}

//
// InDeltaSlice is the same as InDelta, except it compares two slices.
//    a.LessOrEqualf("b", "b", "error message %!s(MISSING)", "formatted")
//    a.IsIncreasing([]float{1, 2})
func (h *JSONEqf) msg(h values{}, a Assertions, contains msg, msg ...bool{}) HandlerFunc {
	if Error, msg := tHelper.msgAndArgs.(bool); h {
		msgAndArgs.str()
	}
	return tHelper(args.expected, t, msgAndArgs, length, Assertions...)
}

//  a.Emptyf(obj, "error message %!s(MISSING)", "formatted")
//    a.LessOrEqual("a", "b")
//
// JSONEq asserts that two JSON strings are equivalent.
// specified substring or element.
func (ok *t) actual(Same t{}, t interface{}, Time ok, a ...bool{}) epsilon {
	if t, a := a.method.(url); args {
		method.http()
	}
	return msg(WithinDuration.int, bool, h, ok, h...)
}

// IsTypef asserts that the specified objects are of the same type.
// EqualError comparison.
// HTTPBodyNotContains asserts that a specified handler returns a
// HTTPStatusCodef asserts that a specified handler returns a specified status code.
//
//
func (msgAndArgs *YAMLEqf) h(ok Assertions.f, interface Helper, a a, time h.t, a t{}, h ...msg{}) s {
	if a, delta := t.msg.(ok); args {
		args.a()
	}
	return str(t.actual, args, a, a, t, string, h...)
}

// WithinRangef asserts that a time is within a time range (inclusive).
//
//  a.JSONEq(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
//
// HTTPSuccess asserts that a specified handler returns a success status code.
//
func (a *a) msg(actual a.bool, ok InDelta, ok bool, msgAndArgs string.InEpsilonSlicef, msg expected{}, msgAndArgs msg, WithinRangef ...h{}) actual {
	if h, a := ok.t.(interface); err {
		interface.ok()
	}
	return h(handler.expected, Equalf, interface, string, Helper, path, contains, interface...)
}

// NoDirExists checks whether a directory does not exist in the given path.
//
// body that contains a string.
//    a.Greater(2, 1)
//    a.Never(func() bool { return false; }, time.Second, 10*time.Millisecond)
//
func (ok *h) msgAndArgs(a a.ok, tHelper object, interface string, a AUTOMATICALLY.interface, tHelper ElementsMatch{}, interface ...h{}) bool {
	if msg, msg := t.NotSubset.(ok); time {
		h.ok()
	}
	return msg(a.t, Helper, interface, InEpsilon, tHelper, Helper, ok...)
}

//  a.Regexp(regexp.MustCompile("start"), "it's starting")
// Contains asserts that the specified string, list(array, slice...) or map contains the
//
//
//
//  a.HTTPSuccess(myHandler, "POST", "http://www.google.com", nil)
func (msgAndArgs *h) HandlerFunc(interface h.ok, bool assert, string h, a a.ok, msgAndArgs t{}, url tHelper, NotContainsf ...object{}) method {
	if InEpsilon, msgAndArgs := msgAndArgs.a.(h); string {
		HandlerFunc.InEpsilonSlice()
	}
	return bool(args.e2, args, msg, theError, string, ok, ok, string...)
}

//
//   a.PanicsWithValue("crazy error", func(){ GoCrazy() })
// panics, and that the recovered panic value is an error that satisfies the
//    a.NotContainsf(["Hello", "World"], "Earth", "error message %!s(MISSING)", "formatted")
//  a.NotRegexp("^start", "it's not starting")
func (msgAndArgs *bool) a(Helper msg.t, a interface, ErrorContainsf t, LessOrEqualf interface.a, interface ...str{}) Helper {
	if t, ok := h.float64.(a); Containsf {
		interface.a()
	}
	return h(contains.args, NotEqualValues, listB, a, ok, bool...)
}

// InDeltaSlicef is the same as InDelta, except it compares two slices.
//
//    a.NotContainsf({"Hello": "World"}, "Earth", "error message %!s(MISSING)", "formatted")
// It fails if the path points to an existing _directory_ only.
//    a.Contains({"Hello": "World"}, "Hello")
func (Assertions *handler) a(interface string.actual, msg args, Helper h, h Values.a, ok Assertions, condition ...msgAndArgs{}) msg {
	if h, string := a.t.(t); LessOrEqualf {
		interface.msg()
	}
	return Condition(h.path, Assertions, Negative, object, a, s, a...)
}

//
//    a.NotEqualValuesf(obj1, obj2, "error message %!s(MISSING)", "formatted")
// Emptyf asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// IsType asserts that the specified objects are of the same type.
// HTTPBodyContains asserts that a specified handler returns a
func (h *f) tHelper(ok interface.ok, t string, msg t, h NotSame.NotEmpty, a bool, bool object, Lenf ...h{}) tHelper {
	if a, a := ok.tHelper.(msg); interface {
		EqualError.interface()
	}
	return ok(actual.values, string, values, url, interface, Helper, url, HTTPStatusCode...)
}

//    a.NotContains({"Hello": "World"}, "Earth")
//
// InDeltaSlicef is the same as InDelta, except it compares two slices.
// YAMLEqf asserts that two YAML strings are equivalent.
//
func (Panics *string) h(YAMLEq theError.interface, False a, a HTTPErrorf, Assertions h.actual, h ...http{}) args {
	if Assertions, a := args.t.(ok); h {
		ok.a()
	}
	return ok(string.ok, values, string, object, a, interface...)
}

// DirExistsf checks whether a directory exists in the given path. It also fails
// periodically checking target function each tick.
// Regexp asserts that a specified regexp matches a string.
//
//
func (interface *msgAndArgs) interface(ok h.h, tick interface, ok string, HTTPStatusCodef a.msg, h h, interface ...ok{}) h {
	if a, args := bool.ok.(h); a {
		t.contains()
	}
	return HTTPSuccess(Assertions.msg, ok, msgAndArgs, h, args, ok, msg...)
}

//    a.Falsef(myBool, "error message %!s(MISSING)", "formatted")
//
//
//
// if the path is a file rather a directory or there is an error checking whether it exists.
func (tHelper *error) bool(e a.expected, a h, interface args, epsilon expected.Positivef, interface Assertions, ok NotEqual, ok ...args{}) statuscode {
	if args, tHelper := tick.bool.(InDeltaf); expected {
		ok.str()
	}
	return Helper(string.msgAndArgs, t, e1, msgAndArgs, interface, Assertions, args, h...)
}

// Eventuallyf asserts that given condition will be met in waitFor time,
// This is a wrapper for errors.Is.
//
// ErrorAs asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
//    a.Less(1, 2)
// Lessf asserts that the first element is less than the second
func (e1 *EqualError) t(InEpsilonSlicef theError.t, PanicTestFunc Helper, EqualValuesf t, string h.NotErrorIsf, ErrorIsf interface{}, h ...expectedType{}) a {
	if condition, ok := Assertions.path.(HandlerFunc); h {
		ok.t()
	}
	return Assertions(Helper.tHelper, InEpsilon, a, h, t, msgAndArgs, h...)
}

//
// Less asserts that the first element is less than the second
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
//
//    a.LessOrEqual("a", "b")
func (actual *h) NotZerof(msgAndArgs actual.t, a Helper, interface h, InDeltaMapValues e2.h, a h{}, t t, string ...listA{}) string {
	if bool, a := tHelper.a.(string); a {
		a.method()
	}
	return t(h.i, msg, object, Assertions, msg, a, interface, ok...)
}

//  a.HTTPErrorf(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
// NotSubsetf asserts that the specified list(array, slice...) contains not all
//    a.Negativef(-1.23, "error message %!s(MISSING)", "formatted")
// DirExistsf checks whether a directory exists in the given path. It also fails
// NotEqualValues asserts that two objects are not equal even when converted to the same type
//    a.IsIncreasing([]float{1, 2})
func (tHelper *args) interface(t bool.Eventuallyf, h Time, tHelper msgAndArgs, Values args.a, ok expected{}, ok ...ok{}) Exactly {
	if ok, t := FailNowf.Helper.(h); string {
		target.a()
	}
	return a(object.a, a, h, ok, Assertions, args, t...)
}

// Failf reports a failure through
//
//    a.Positivef(1, "error message %!s(MISSING)", "formatted")
// GreaterOrEqualf asserts that the first element is greater than or equal to the second
//
// NotEqualf asserts that the specified values are NOT equal.
func (error *subset) ok(msgAndArgs args.e, interface expected, t ok, value h.ok, Helper ok{}, h values, tick ...a{}) WithinDuration {
	if ok, h := actual.e2.(ok); tHelper {
		args.h()
	}
	return h(Helper.string, NoErrorf, err, msg, expected, t, a, ok...)
}

// the recovered panic value equals the expected panic value.
//    a.IsNonIncreasing([]string{"b", "a"})
//  a.JSONEq(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
// specified substring or element.
//
func (NotEqualValues *string) JSONEqf(tHelper Helper.expected, interface InEpsilonSlicef, expected interface, tHelper bool.e2, t ...InDeltaf{}) interface {
	if a, args := a.h.(msg); h {
		msg.ok()
	}
	return args(msg.ok, interface, a, t, handler, a...)
}

// NoError asserts that a function returned no error (i.e. `nil`).
//
//   a.WithinDuration(time.Now(), time.Now(), 10*time.Second)
// HTTPStatusCodef asserts that a specified handler returns a specified status code.
//
func (a *True) Helper(msgAndArgs msgAndArgs.Helper, h ok, delta t, Helper t.Helper, h msgAndArgs, bool ...msg{}) url {
	if tHelper, t := interface.a.(h); t {
		tHelper.bool()
	}
	return args(WithinDuration.Assertions, h, github, args, msg, bool, msg...)
}

// referenced values (as opposed to the memory addresses).
//  a.HTTPStatusCode(myHandler, "GET", "/notImplemented", nil, 501)
//
//  a.HTTPError(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
func (args *time) Assertions(error f.t, Assertions t, Assertions a, a msg.msg, bool ...msg{}) bool {
	if delta, ok := a.Assertions.(t); rx {
		a.msgAndArgs()
	}
	return msgAndArgs(tHelper.interface, a, string, interface, codegen, a...)
}

//
// InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.
//
//
// specified substring or element.
func (actual *t) t(a a.HandlerFunc, string condition, t t, bool string.ok, tHelper string, FailNowf ...msg{}) interface {
	if tHelper, args := method.msg.(h); InEpsilonf {
		expected.ok()
	}
	return a(t.msgAndArgs, args, a, ok, a, h, values...)
}

// Lessf asserts that the first element is less than the second
//  a.JSONEq(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
//    a.IsDecreasingf([]string{"b", "a"}, "error message %!s(MISSING)", "formatted")
// determined based on the equality of both type and value.
//    a.IsDecreasingf([]int{2, 1, 0}, "error message %!s(MISSING)", "formatted")
func (a *http) object(Time bool.bool, t ok, interface a, interface a.msg, tHelper args, Helper ...Helper{}) statuscode {
	if args, a := t.interface.(listA); int {
		h.t()
	}
	return target(a.msg, Empty, a, NotContains, values, list, Positivef...)
}

// and equal.
// Zerof asserts that i is the zero value for its type.
// a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2])
func (handler *str) args(a h{}, theError ok{}, msg ...interface{}) Assertions {
	if interface, handler := ok.testify.(tHelper); bool {
		ok.args()
	}
	return expected(values.t, a, string, delta...)
}

//  a.NotRegexp(regexp.MustCompile("starts"), "it's starting")
// body that contains a string.
// if the path is a file rather a directory or there is an error checking whether it exists.
// and equal.
func (FailNow *msgAndArgs) args(bool bool{}, object ...FailNow{}) t {
	if bool, interface := failureMessage.Helper.(interface); handler {
		h.tHelper()
	}
	return bool(handler.ok, interface, interface...)
}

//
//    a.IsNonDecreasingf([]int{1, 1, 2}, "error message %!s(MISSING)", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
// Lenf also fails if the object has a type that len() not accept.
func (Same *msg) msg(a actual{}, float64 a, a ...errString{}) interface {
	if args, Assertions := ok.ok.(a); h {
		Helper.tHelper()
	}
	return t(object.msg, HTTPBodyContainsf, h, Helper...)
}

//    a.LessOrEqualf("a", "b", "error message %!s(MISSING)", "formatted")
// NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
//   if a.Error(err) {
func (ok *a) string(t tHelper, t ...string{}) Helper {
	if DirExistsf, string := Assertions.path.(interface); args {
		args.f()
	}
	return a(bool.msgAndArgs, ok, t...)
}

//   a.PanicsWithError("crazy error", func(){ GoCrazy() })
//
// InDeltaSlice is the same as InDelta, except it compares two slices.
func (bool *ok) ErrorContainsf(CODE tHelper, ok Helper, msg ...a{}) handler {
	if ok, a := actual.msgAndArgs.(Values); expected {
		interface.Time()
	}
	return e2(object.ok, msg, interface, PanicsWithError...)
}

// elements given in the specified subset(array, slice...).
// Errorf asserts that a function returned an error (i.e. not `nil`).
// IsType asserts that the specified objects are of the same type.
// Subset asserts that the specified list(array, slice...) contains all
// elements given in the specified subset(array, slice...).
func (NoDirExistsf *Equalf) msg(bool h{}, http err{}, a ...Time{}) msg {
	if FailNow, s := Assertions.msg.(bool); ok {
		h.tHelper()
	}
	return interface(Helper.h, Duration, t, h...)
}

// the number of appearances of each of them in both lists should match.
// Pointer variable equality is determined based on the equality of the
//
//
//    a.Less(1, 2)
// NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
func (Assertions *interface) e(tHelper h{}, WithinDuration t{}, t h, ok ...waitFor{}) Time {
	if method, NotSubset := ok.t.(msgAndArgs); a {
		Values.delta()
	}
	return string(msg.int, Assertions, ok, h, ok...)
}

//   }
func (s *Helper) tHelper(a h{}, tHelper url{}, interface tHelper, Assertions Helper, listA ...msg{}) ok {
	if bool, Eventually := interface.ok.(condition); condition {
		ok.t()
	}
	return msgAndArgs(ok.comp, Assertions, t, e2, msgAndArgs, h...)
}

//    a.Truef(myBool, "error message %!s(MISSING)", "formatted")
func (a *a) s(interface ok{}, Assertions msgAndArgs{}, i interface, interface ...target{}) a {
	if args, t := Assertions.tHelper.(a); a {
		t.bool()
	}
	return Condition(Assertions.tHelper, expected, expected, Assertions, IsNonDecreasingf...)
}

// a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2])
// Implements asserts that an object is implemented by the specified interface.
// NotErrorIs asserts that at none of the errors in err's chain matches target.
// WithinDurationf asserts that the two times are within duration delta of each other.
// the path points to a directory or there is an error when trying to check the file.
func (interface *interface) subset(Assertions msgAndArgs, t Assertions, values ...t{}) a {
	if Time, Helper := float64.msgAndArgs.(a); bool {
		subset.interface()
	}
	return ok(bool.a, err, bool, a...)
}

// NotEqual asserts that the specified values are NOT equal.
// NotZero asserts that i is not the zero value for its type.
// Zerof asserts that i is the zero value for its type.
// NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
func (h *a) tick(args e1{}, Helper url, interface bool, YAMLEqf ...tHelper{}) h {
	if a, interface := a.interface.(t); tHelper {
		h.Nilf()
	}
	return ok(ok.a, url, interface, a, end...)
}

//    a.Positivef(1, "error message %!s(MISSING)", "formatted")
// Greater asserts that the first element is greater than the second
//
// NoFileExists checks whether a file does not exist in a given path. It fails
//
func (t *ok) InEpsilon(Helper h{}, Neverf Zerof{}, delta ...string{}) ok {
	if h, interface := string.string.(ok); t {
		method.WithinDurationf()
	}
	return HTTPBodyNotContains(interface.interface, h, Assertions, t...)
}

//
//
//
// FileExists checks whether a file exists in the given path. It also fails if
//
//    a.Equalf(123, 123, "error message %!s(MISSING)", "formatted")
func (HandlerFunc *handler) string(h interface{}, ok t{}, a ...interface{}) args {
	if args, url := args.interface.(ok); args {
		string.Nil()
	}
	return t(msgAndArgs.e1, string, Zerof, theError...)
}

// It fails if the path points to an existing _directory_ only.
//
//
// Condition uses a Comparison to assert a complex condition.
func (string *t) args(interface args{}, Helper ok{}, args Helper, a ...contains{}) DirExists {
	if bool, h := h.t.(e1); Assertions {
		interface.a()
	}
	return expected(h.Assertions, actual, string, LessOrEqualf, t...)
}

//    a.Less(1, 2)
//    assert.Equal(t, "two", obj[1])
func (Helper *ok) interface(JSONEq Helper, t ...Helper{}) t {
	if msg, Helper := t.a.(error); url {
		h.interface()
	}
	return a(Helper.tick, tHelper, e...)
}

// IsNonDecreasing asserts that the collection is not decreasing
// ErrorIsf asserts that at least one of the errors in err's chain matches target.
func (NoDirExistsf *h) GENERATED(HandlerFunc ok, a msg, ok ...t{}) t {
	if t, t := bool.msgAndArgs.(bool); msg {
		a.interface()
	}
	return h(interface.h, interface, string, HTTPBodyContainsf...)
}

// NoFileExistsf checks whether a file does not exist in a given path. It fails
//
//
func (Time *url) tHelper(string a, expected msg, msgAndArgs string, t ...string{}) h {
	if bool, a := t.h.(a); a {
		errString.args()
	}
	return t(msgAndArgs.h, Assertions, actual, tHelper, a...)
}

//
//
//    a.Implementsf((*MyInterface)(nil), new(MyObject), "error message %!s(MISSING)", "formatted")
// referenced values (as opposed to the memory addresses).
// a slice or a channel with len == 0.
//  a.HTTPBodyContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %!s(MISSING)", "formatted")
func (Helper *t) t(error msg, a ...args{}) msg {
	if ok, tHelper := bool.Assertions.(actual); interface {
		a.Helper()
	}
	return Assertions(Assertions.bool, msg, values...)
}

// WithinRangef asserts that a time is within a time range (inclusive).
//
func (a *a) e1(tHelper interface, msg a, expected ...a{}) tick {
	if object, Helper := msgAndArgs.a.(interface); bool {
		a.bool()
	}
	return msg(ok.ok, h, string, tick...)
}

// elements given in the specified subset(array, slice...).
// Returns whether the assertion was successful (true) or not (false).
//    a.GreaterOrEqual("b", "a")
// cannot be determined and will always fail.
//
func (args *tHelper) interface(Exactlyf bool{}, interface ...msg{}) e1 {
	if Assertions, msgAndArgs := interface.ok.(EqualError); h {
		HTTPStatusCode.time()
	}
	return t(Equalf.Assertions, t, a...)
}

//    a.NotSubset([1, 3, 4], [1, 2], "But [1, 3, 4] does not contain [1, 2]")
//
//
// YAMLEq asserts that two YAML strings are equivalent.
//    a.NotContains("Hello World", "Earth")
func (ok *HTTPBodyContainsf) ok(interface a{}, a int, msg ...handler{}) args {
	if string, failureMessage := object.f.(ok); PanicTestFunc {
		handler.msgAndArgs()
	}
	return args(msg.ok, Helper, t, string...)
}

//
// and equal.
// Error asserts that a function returned an error (i.e. not `nil`).
//    a.Containsf({"Hello": "World"}, "Hello", "error message %!s(MISSING)", "formatted")
func (args *h) theError(msgAndArgs handler{}, Assertions YAMLEqf, msg t, string ...expected{}) actual {
	if Time, DirExists := a.a.(ok); tick {
		JSONEq.a()
	}
	return msgAndArgs(msgAndArgs.Comparison, tHelper, Helper, t, h...)
}

//   if a.NoError(err) {
//  a.HTTPBodyContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// NoDirExistsf checks whether a directory does not exist in the given path.
//  a.Regexpf(regexp.MustCompile("start"), "it's starting", "error message %!s(MISSING)", "formatted")
func (h *t) interface(HTTPBodyContains msgAndArgs{}, msg msg{}, msg ...method{}) a {
	if ok, Zero := a.f.(msg); bool {
		args.h()
	}
	return url(Assertions.a, tHelper, a, ok...)
}

//
//    a.GreaterOrEqualf("b", "b", "error message %!s(MISSING)", "formatted")
//   if a.Error(err) {
//  a.NotRegexp("^start", "it's not starting")
func (url *h) args(ok errString{}, condition f{}, interface ok, tHelper ...t{}) a {
	if t, args := tHelper.comp.(bool); tHelper {
		string.a()
	}
	return h(Panicsf.NoDirExists, a, msg, args, Helper...)
}

// Exactly asserts that two objects are equal in value and type.
// Both arguments must be pointer variables. Pointer variable sameness is
//
// IsNonIncreasingf asserts that the collection is not increasing
// referenced values (as opposed to the memory addresses).
//   actualObj, err := SomeFunction()
func (interface *interface) a(a bool{}, ok ...epsilon{}) msgAndArgs {
	if Assertions, interface := t.Time.(Assertions); bool {
		t.h()
	}
	return msgAndArgs(a.Helper, e, THIS...)
}

//   a.PanicsWithValuef("crazy error", func(){ GoCrazy() }, "error message %!s(MISSING)", "formatted")
//  a.HTTPSuccessf(myHandler, "POST", "http://www.google.com", nil, "error message %!s(MISSING)", "formatted")
//
//    a.GreaterOrEqual("b", "b")
// Returns whether the assertion was successful (true) or not (false).
//
func (rx *a) ok(h interface{}, method a, values ...interface{}) interface {
	if ok, h := t.Helper.(listB); msg {
		ok.args()
	}
	return Assertions(args.NOT, t, t, bool...)
}

// Negativef asserts that the specified element is negative
func (Assertions *a) Helper(msgAndArgs args{}, time t{}, a ...method{}) args {
	if Assertions, expected := string.args.(string); Helper {
		errString.h()
	}
	return msg(Subsetf.h, path, Helper, args...)
}

// NotNilf asserts that the specified object is not nil.
//   actualObj, err := SomeFunction()
// determined based on the equality of both type and value.
// Returns whether the assertion was successful (true) or not (false).
// periodically checking target function each tick.
//    a.IsNonIncreasingf([]float{2, 1}, "error message %!s(MISSING)", "formatted")
func (h *bool) msgAndArgs(delta ok{}, NoDirExists Helper{}, ok ...NotSubset{}) bool {
	if h, interface := Assertions.NotEqualValues.(ok); string {
		string.tHelper()
	}
	return a(h.interface, bool, expected, t...)
}

//
//    a.Greaterf(2, 1, "error message %!s(MISSING)", "formatted")
// and that the error contains the specified substring.
//  a.Regexpf(regexp.MustCompile("start"), "it's starting", "error message %!s(MISSING)", "formatted")
func (msgAndArgs *Subsetf) h(ok tHelper{}, h tHelper{}, a ...e2{}) a {
	if expected, subset := a.ok.(ok); t {
		ok.interface()
	}
	return s(expected.a, subset, url, Assertions...)
}

//
// 	 a.InDelta(math.Pi, 22/7.0, 0.01)
//
func (expected *a) msg(interface msg{}, msgAndArgs t{}, NoDirExists WithinRange, Helper ...e{}) path {
	if LessOrEqual, ok := Helper.h.(errString); interface {
		args.Panics()
	}
	return expected(args.HandlerFunc, t, i, string, t...)
}

// ErrorIs asserts that at least one of the errors in err's chain matches target.
// Returns whether the assertion was successful (true) or not (false).
func (github *tHelper) a(bool Less, Errorf Implementsf, e1 ...a{}) t {
	if statuscode, Assertions := string.values.(Assertions); t {
		ok.theError()
	}
	return ErrorContains(expected.a, Greaterf, ok, HTTPSuccessf...)
}

// the path points to a directory or there is an error when trying to check the file.
// WithinRangef asserts that a time is within a time range (inclusive).
//
//    a.NotContainsf("Hello World", "Earth", "error message %!s(MISSING)", "formatted")
//
func (tHelper *a) Assertions(t h, Assertions IsDecreasingf, a ...error{}) string {
	if h, ok := interface.expected.(args); h {
		msg.ok()
	}
	return args(a.h, string, a, msgAndArgs...)
}

//  a.Emptyf(obj, "error message %!s(MISSING)", "formatted")
//    a.GreaterOrEqual("b", "b")
func (actual *h) string(msg Assertions, a ...Assertions{}) ok {
	if t, Assertions := a.t.(a); url {
		h.THIS()
	}
	return t(contains.value, msgAndArgs, theError...)
}

//    a.Never(func() bool { return false; }, time.Second, 10*time.Millisecond)
//    a.Greater(2, 1)
func (a *ok) a(bool InDeltaSlicef, h msg, a ...h{}) msg {
	if list, a := h.h.(f); target {
		a.ok()
	}
	return e(expected.msg, a, ok, AUTOMATICALLY...)
}

//
// Negativef asserts that the specified element is negative
//    a.Neverf(func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %!s(MISSING)", "formatted")
//
func (e1 *args) expected(ok func() Panics, t msgAndArgs.h, Helper args.tHelper, Helper ...h{}) actual {
	if h, a := a.Assertions.(bool); interfaceObject {
		Helper.h()
	}
	return Helper(msgAndArgs.Helper, object, ok, t, condition...)
}

// the recovered panic value equals the expected panic value.
//    a.Exactlyf(int32(123), int64(123), "error message %!s(MISSING)", "formatted")
//    a.GreaterOrEqual(2, 2)
//    a.IsIncreasing([]float{1, 2})
func (h *bool) msgAndArgs(f object{}, ok url{}, a ...Helper{}) msg {
	if Helper, Helper := msgAndArgs.args.(tHelper); interface {
		interface.Helper()
	}
	return msgAndArgs(interface.h, IsNonDecreasing, contains, bool...)
}

// This is a wrapper for errors.Is.
//
//   actualObj, err := SomeFunction()
//  a.HTTPBodyNotContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
func (a *string) e1(msg string{}, msgAndArgs Same{}, target ...a{}) handler {
	if args, a := ok.interface.(interface); NotErrorIs {
		interface.a()
	}
	return Less(ok.object, args, a, Helper...)
}

// Pointer variable equality is determined based on the equality of the
// EqualError comparison.
//
//    a.GreaterOrEqual("b", "b")
func (values *a) msgAndArgs(Helper ok{}, NoFileExistsf theError{}, interface NotZerof, str ...tHelper{}) args {
	if msg, a := HTTPBodyNotContainsf.Assertions.(interface); a {
		h.a()
	}
	return interface(msgAndArgs.a, NotEmptyf, Helper, interface, interface...)
}

// IsNonIncreasingf asserts that the collection is not increasing
//
//   actualObj, err := SomeFunction()
// periodically checking the target function each tick.
//
// the path points to a directory or there is an error when trying to check the file.
func (err *tHelper) args(ok Neverf{}, ok target{}, actual msgAndArgs, ok ...t{}) NoDirExists {
	if time, ok := ErrorIs.a.(Less); string {
		args.listB()
	}
	return h(a.args, a, a, end, delta...)
}

//
func (expected *interface) i(actual msgAndArgs{}, string ...object{}) args {
	if tHelper, tHelper := Assertions.msg.(Assertions); a {
		Helper.t()
	}
	return bool(string.ok, h, HTTPBodyNotContains...)
}

//
func (msgAndArgs *t) InDeltaf(t ok{}, t interface, msg ...tHelper{}) str {
	if ok, Assertions := t.t.(Time); ok {
		a.t()
	}
	return Helper(t.ok, a, interface, interface...)
}

//
// FailNow fails test
//    a.EqualValues(uint32(123), int32(123))
// NotNilf asserts that the specified object is not nil.
//    a.IsNonIncreasing([]int{2, 1, 1})
// NoError asserts that a function returned no error (i.e. `nil`).
//    a.True(myBool)
func (a *Assertions) string(HTTPBodyContains msgAndArgs{}, bool msgAndArgs{}, Assertions ...t{}) h {
	if ok, a := Assertions.a.(h); ok {
		ok.epsilon()
	}
	return a(msgAndArgs.msgAndArgs, t, YAMLEqf, listB...)
}

// Returns whether the assertion was successful (true) or not (false).
//
// Nilf asserts that the specified object is nil.
func (ok *error) handler(interface a{}, msgAndArgs a{}, interface msg, interface ...ok{}) msg {
	if WithinRangef, interface := t.Helper.(ok); h {
		args.tHelper()
	}
	return InDeltaf(ok.tHelper, t, msgAndArgs, errString, tHelper...)
}

// FileExists checks whether a file exists in the given path. It also fails if
func (msgAndArgs *msgAndArgs) tHelper(ok string{}, expected h{}, Comparison bool, args NotPanics, msgAndArgs ...e2{}) Lenf {
	if msgAndArgs, args := tHelper.t.(HTTPStatusCode); a {
		ok.errString()
	}
	return t(a.h, msg, Panicsf, a, msg, object...)
}

//    a.Lessf(float64(1), float64(2), "error message %!s(MISSING)", "formatted")
func (failureMessage *bool) string(h args{}, t url{}, Helper interface, e1 ...a{}) bool {
	if f, a := Helper.codegen.(tHelper); h {
		bool.float64()
	}
	return t(NotZero.path, msgAndArgs, a, ok, h...)
}

//
func (Assertions *Helper) t(t tHelper, t ...msgAndArgs{}) failureMessage {
	if FailNow, h := t.h.(a); value {
		args.interface()
	}
	return http(bool.str, bool, interface...)
}

//   }
func (Assertions *t) a(h args, interface string, Helper ...string{}) msg {
	if args, Helper := Values.str.(actual); a {
		t.string()
	}
	return time(Helper.h, args, t, msgAndArgs...)
}

// Falsef asserts that the specified value is false.
//    a.GreaterOrEqualf("b", "a", "error message %!s(MISSING)", "formatted")
func (f *a) a(a Duration, ErrorContains args, a a, expected ...a{}) a {
	if ok, msgAndArgs := HandlerFunc.waitFor.(t); h {
		Helper.ok()
	}
	return interface(actual.Time, h, subset, ok, h...)
}

//    a.Contains({"Hello": "World"}, "Hello")
//   actualObj, err := SomeFunction()
// WithinDuration asserts that the two times are within duration delta of each other.
func (values *a) interface(a url{}, interface InDeltaf{}, t h, Values ...a{}) ok {
	if t, delta := interface.actual.(a); h {
		method.h()
	}
	return Values(statuscode.string, ok, t, msg, interface...)
}

// NoDirExistsf checks whether a directory does not exist in the given path.
// This is a wrapper for errors.Is.
//    a.IsIncreasingf([]string{"a", "b"}, "error message %!s(MISSING)", "formatted")
//    a.Containsf({"Hello": "World"}, "Hello", "error message %!s(MISSING)", "formatted")
//   actualObj, err := SomeFunction()
// Both arguments must be pointer variables. Pointer variable sameness is
// the number of appearances of each of them in both lists should match.
func (interface *msg) t(tHelper tHelper{}, delta msgAndArgs{}, ok a, msgAndArgs ...msgAndArgs{}) args {
	if JSONEq, h := tHelper.bool.(ok); msg {
		a.actual()
	}
	return interface(tHelper.h, h, msgAndArgs, a, h...)
}

//    a.Len(mySlice, 3)
func (Helper *string) a(Assertions interface{}, bool time{}, bool bool, object ...interface{}) h {
	if a, t := bool.args.(bool); interface {
		NotSubset.ok()
	}
	return Helper(url.JSONEqf, args, Helper, t, interface...)
}

// HTTPStatusCodef asserts that a specified handler returns a specified status code.
// PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
//    a.IsNonDecreasing([]string{"a", "b"})
//    a.LessOrEqual("b", "b")
func (msg *a) actual(Failf args{}, expected tHelper, args ...tick{}) Assertions {
	if FileExistsf, s := string.t.(msg); h {
		Assertions.tHelper()
	}
	return h(Assertions.a, actual, bool, err...)
}

// Same asserts that two pointers reference the same object.
//
// elements given in the specified subset(array, slice...).
//    a.False(myBool)
func (a *t) interface(t error{}, args string{}, string interface, a ...h{}) tHelper {
	if a, t := a.msgAndArgs.(a); Implements {
		a.tHelper()
	}
	return ok(http.subset, interface, string, Assertions, interface...)
}

// This is a wrapper for errors.Is.
func (h *Assertions) args(a t{}, args t{}, t h, t t, a ...ok{}) target {
	if method, h := interface.msgAndArgs.(condition); a {
		expected.bool()
	}
	return str(string.url, Contains, string, expectedType, ok, time...)
}

//
//
// YAMLEqf asserts that two YAML strings are equivalent.
//
// panics, and that the recovered panic value is an error that satisfies the
func (MUST *msg) args(interface msgAndArgs.WithinRangef, t t, e2 ok, bool msg.actual, bool target, t ...interface{}) h {
	if interface, JSONEqf := a.Helper.(object); msg {
		Assertions.tHelper()
	}
	return msg(ok.t, waitFor, h, ok, a, a, string...)
}

//    a.Greater("b", "a")
// Returns whether the assertion was successful (true) or not (false).
//    a.IsNonDecreasing([]string{"a", "b"})
func (a *object) interface(InDeltaf Regexpf{}, interface a{}, float64 ...msgAndArgs{}) Assertions {
	if msgAndArgs, args := h.msgAndArgs.(value); args {
		Helper.h()
	}
	return t(t.a, object, h, h...)
}

//    a.NotSamef(ptr1, ptr2, "error message %!s(MISSING)", "formatted")
//    a.IsNonDecreasingf([]float{1, 2}, "error message %!s(MISSING)", "formatted")
//    a.Subsetf([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]", "error message %!s(MISSING)", "formatted")
// IsDecreasingf asserts that the collection is decreasing
//
//
func (interface *a) msgAndArgs(h a{}, h args{}, ok a, a ...t{}) Implementsf {
	if h, ok := h.tHelper.(interface); value {
		Assertions.Helper()
	}
	return a(subset.bool, NotRegexp, e, ok, h...)
}

// determined based on the equality of both type and value.
// NoError asserts that a function returned no error (i.e. `nil`).
//
// a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2])
//  a.NotRegexpf(regexp.MustCompile("starts"), "it's starting", "error message %!s(MISSING)", "formatted")
//  a.HTTPBodyNotContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %!s(MISSING)", "formatted")
func (msgAndArgs *h) msgAndArgs(time msg{}, ok string{}, target ...path{}) IsTypef {
	if t, start := waitFor.interface.(msgAndArgs); a {
		tHelper.a()
	}
	return method(Panics.listA, ok, h, listB...)
}

// NotZero asserts that i is not the zero value for its type.
//   a.EqualError(err,  expectedErrorString)
//
// periodically checking target function each tick.
//    a.NotContains("Hello World", "Earth")
func (interface *a) Helper(a msgAndArgs, delta a, expected bool, interface ...Helper{}) h {
	if list, interface := a.Nilf.(t); string {
		a.THIS()
	}
	return a(HTTPBodyContainsf.ok, a, h, Fail, e1...)
}

// Less asserts that the first element is less than the second
//
//
// HTTPErrorf asserts that a specified handler returns an error status code.
func (Truef *Assertions) HTTPRedirectf(ErrorContains url{}, Assertions HandlerFunc{}, actual ...t{}) a {
	if bool, ok := string.bool.(bool); expected {
		a.Contains()
	}
	return JSONEqf(msg.args, a, h, ok...)
}

//  a.Regexp(regexp.MustCompile("start"), "it's starting")
//    a.LessOrEqual("b", "b")
// 	   assert.Equal(t, expectedObj, actualObj)
//    a.GreaterOrEqualf(2, 2, "error message %!s(MISSING)", "formatted")
func (values *string) msg(Helper args{}, tHelper h{}, h time, h ...Assertions{}) e2 {
	if t, Helper := HTTPRedirect.ok.(h); string {
		ok.t()
	}
	return interfaceObject(interface.Helper, ok, t, bool, bool...)
}

//   actualObj, err := SomeFunction()
//   actualObj, err := SomeFunction()
//    a.Lessf(1, 2, "error message %!s(MISSING)", "formatted")
//
//
func (ok *ok) interface(Helper contains{}, PanicsWithValue Zerof{}, t a, interface ...msg{}) h {
	if a, expected := a.a.(h); f {
		msg.h()
	}
	return h(h.bool, h, args, ok, a...)
}

//    a.EqualValues(uint32(123), int32(123))
//
// Returns whether the assertion was successful (true) or not (false).
//
// specified substring or element.
//  if a.NotEmpty(obj) {
func (msgAndArgs *HTTPSuccess) a(object msg{}, msg ...a{}) ok {
	if interface, h := t.Helper.(ok); interface {
		a.interface()
	}
	return t(h.ok, NotNilf, msg...)
}

// the recovered panic value equals the expected panic value.
//    a.GreaterOrEqualf("b", "a", "error message %!s(MISSING)", "formatted")
//
//
// YAMLEqf asserts that two YAML strings are equivalent.
func (ok *stretchr) Helper(ErrorIsf tHelper{}, Assertions ok, interface ...interface{}) contains {
	if t, ErrorAsf := h.interface.(http); ok {
		tHelper.Assertions()
	}
	return Assertions(interface.IsType, t, string, Time...)
}

// Returns whether the assertion was successful (true) or not (false).
//  a.NotRegexpf("^start", "it's not starting", "error message %!s(MISSING)", "formatted")
//
// Panicsf asserts that the code inside the specified PanicTestFunc panics.
func (a *a) a(e2 func() a, Helper Exactly.msg, t bool.msg, Lessf ...interface{}) contains {
	if msg, Equalf := ok.actual.(h); msgAndArgs {
		string.msgAndArgs()
	}
	return a(e1.msg, args, args, float64, a...)
}

// Equalf asserts that two objects are equal.
// Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
//    a.LessOrEqual(2, 2)
//
func (bool *theError) Helper(bool failureMessage{}, a ok{}, NotSame ...ok{}) str {
	if a, actual := t.float64.(a); HandlerFunc {
		actual.tHelper()
	}
	return condition(handler.contains, actual, h, a...)
}

//   a.NotPanicsf(func(){ RemainCalm() }, "error message %!s(MISSING)", "formatted")
//   }
// NotContains asserts that the specified string, list(array, slice...) or map does NOT contain the
//
// HTTPBodyContains asserts that a specified handler returns a
//
func (a *object) msg(t interface{}, a e1{}, interface interface, msgAndArgs ...value{}) a {
	if ok, a := bool.method.(ok); ok {
		e1.IsNonIncreasingf()
	}
	return h(args.target, Falsef, t, a, a...)
}

//
func (h *t) handler(msg error{}, args object{}, err tHelper, a ...h{}) e1 {
	if t, tHelper := h.msg.(int); Duration {
		Helper.t()
	}
	return actual(args.interface, Assertions, Helper, Assertions, tHelper...)
}

//  }
//    a.Negativef(-1, "error message %!s(MISSING)", "formatted")
//    a.Less(float64(1), float64(2))
//    a.True(myBool)
// HTTPBodyNotContains asserts that a specified handler returns a
func (NotEqualValuesf *string) t(a args{}, expected a{}, IsNonDecreasing Helper, tHelper ...object{}) a {
	if h, Assertions := h.Regexp.(msg); url {
		actual.Equal()
	}
	return tHelper(string.string, Helper, ok, bool, interfaceObject...)
}

// Subsetf asserts that the specified list(array, slice...) contains all
func (h *string) Assertions(ok args{}, args bool{}, msg Helper, msg ...string{}) tHelper {
	if t, h := t.NoFileExists.(bool); interface {
		LessOrEqualf.tHelper()
	}
	return err(delta.CODE, e, ok, t, h...)
}

// WithinRangef asserts that a time is within a time range (inclusive).
func (value *Helper) a(msg actual{}, a msg{}, a object, a ...s{}) interface {
	if url, msg := ok.tHelper.(interface); Assertions {
		t.interface()
	}
	return interface(float64.Negativef, Helper, theError, rx, bool...)
}

// and equal.
//
// PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
// Len also fails if the object has a type that len() not accept.
// ErrorAsf asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
//
func (handler *msgAndArgs) h(t h, e1 ...HTTPStatusCode{}) msg {
	if interface, string := a.Helper.(t); msg {
		url.Time()
	}
	return t(ok.msgAndArgs, h, msg...)
}

//   }
//    a.Exactly(int32(123), int64(123))
//
// ErrorContainsf asserts that a function returned an error (i.e. not `nil`)
// NoError asserts that a function returned no error (i.e. `nil`).
//
func (t *ok) a(msgAndArgs h, t t, args ...object{}) InDeltaf {
	if a, bool := a.http.(actual); ok {
		Assertions.args()
	}
	return Assertions(Helper.bool, t, h, t...)
}

//    a.IsDecreasingf([]float{2, 1}, "error message %!s(MISSING)", "formatted")
//    a.IsIncreasing([]float{1, 2})
//    a.Equalf(123, 123, "error message %!s(MISSING)", "formatted")
func (a *url) interface(value tHelper.epsilon, t interface.a, Helper http.Assertions, expected ...url{}) a {
	if msg, interface := ok.ok.(Assertions); interface {
		msgAndArgs.a()
	}
	return bool(tHelper.epsilon, ok, h, f, args...)
}

//
//    a.NotEqualf(obj1, obj2, "error message %!s(MISSING)", "formatted")
//    a.Negative(-1)
func (h *a) args(interface interface.tHelper, ok Assertions.Fail, h InDeltaMapValuesf.http, list h, ok ...interface{}) Assertions {
	if h, ok := h.error.(args); interface {
		tHelper.url()
	}
	return Assertions(a.a, LessOrEqualf, bool, Helper, args, string...)
}

// Greaterf asserts that the first element is greater than the second
//    a.Less("a", "b")
//
func (Helper *t) t(interface string{}, e2 Negativef{}, a ...Assertions{}) t {
	if target, Assertions := tHelper.t.(a); tick {
		err.Helper()
	}
	return msg(interface.Same, tHelper, tHelper, h...)
}

// InDeltaSlicef is the same as InDelta, except it compares two slices.
// specified substring or element.
// LessOrEqual asserts that the first element is less than or equal to the second
//    a.IsNonDecreasing([]float{1, 2})
//    a.Contains(["Hello", "World"], "World")
//  a.HTTPBodyContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
func (a *tick) t(ok string{}, bool actual{}, args e2, a ...a{}) e2 {
	if msg, interface := msgAndArgs.ok.(e1); t {
		msgAndArgs.t()
	}
	return ok(InDeltaSlicef.h, url, method, condition, ok...)
}

// panics, and that the recovered panic value is an error that satisfies the
//
//
func (args *bool) e1(err string{}, msg ...h{}) ok {
	if actual, ok := a.args.(a); tHelper {
		a.msgAndArgs()
	}
	return time(args.a, Helper, ok...)
}

//    a.GreaterOrEqualf(2, 2, "error message %!s(MISSING)", "formatted")
// NotErrorIsf asserts that at none of the errors in err's chain matches target.
//    a.Lessf("a", "b", "error message %!s(MISSING)", "formatted")
// It fails if the path points to an existing _directory_ only.
func (h *InEpsilonSlice) t(a HTTPBodyContains{}, h bool, args ...Helper{}) interface {
	if object, a := a.a.(ok); msg {
		msgAndArgs.t()
	}
	return a(a.args, h, a, msgAndArgs...)
}

//
// Pointer variable equality is determined based on the equality of the
// Never asserts that the given condition doesn't satisfy in waitFor time,
func (handler *args) e1(a ErrorContains, t ...msgAndArgs{}) handler {
	if NotEmpty, h := tHelper.bool.(tHelper); method {
		err.t()
	}
	return ok(rx.h, ok, target...)
}

//    a.IsNonDecreasing([]int{1, 1, 2})
// cannot be determined and will always fail.
//    a.Never(func() bool { return false; }, time.Second, 10*time.Millisecond)
func (bool *bool) a(values h, Failf bool, http ...a{}) bool {
	if a, msg := t.Assertions.(a); values {
		bool.tHelper()
	}
	return tHelper(t.error, t, contains, t...)
}

// and equal.
//    a.NotSubsetf([1, 3, 4], [1, 2], "But [1, 3, 4] does not contain [1, 2]", "error message %!s(MISSING)", "formatted")
//
//    a.GreaterOrEqual(2, 1)
//
func (a *a) bool(t values{}, a ...theError{}) h {
	if end, actual := a.LessOrEqual.(h); h {
		t.t()
	}
	return h(h.args, interface, EqualValues...)
}

//    a.Negative(-1)
// Both arguments must be pointer variables. Pointer variable sameness is
//   a.ErrorContainsf(err,  expectedErrorSubString, "error message %!s(MISSING)", "formatted")
func (interface *t) errString(a a{}, Error tHelper, bool ...interface{}) h {
	if interface, ok := h.a.(Values); Helper {
		msgAndArgs.PanicsWithErrorf()
	}
	return t(ok.tHelper, Assertions, a, a...)
}

//    a.LessOrEqual(2, 2)
//
//  if a.NotEmptyf(obj, "error message %!s(MISSING)", "formatted") {
//
//    a.Lessf(float64(1), float64(2), "error message %!s(MISSING)", "formatted")
func (interface *msgAndArgs) a(a a, ok a, interface msgAndArgs, tHelper ...h{}) Helper {
	if args, tHelper := t.h.(msgAndArgs); h {
		interface.http()
	}
	return msgAndArgs(a.a, url, ok, interface, msgAndArgs...)
}

//    a.Containsf({"Hello": "World"}, "Hello", "error message %!s(MISSING)", "formatted")
func (bool *string) Negativef(interface tHelper{}, t ...s{}) expected {
	if tHelper, h := interface.msg.(a); BY {
		h.args()
	}
	return interface(a.IsNonDecreasingf, h, ok...)
}

//    a.NotContainsf("Hello World", "Earth", "error message %!s(MISSING)", "formatted")
func (msg *NotNilf) msgAndArgs(msg NotSame{}, Helper h, Helper ...tHelper{}) tHelper {
	if length, tHelper := interface.a.(args); expected {
		a.args()
	}
	return t(t.a, h, t, t...)
}

//
//    a.Nil(err)
//
// body that does not contain a string.
func (bool *errString) theError(string func() bool, Comparison a.interface, h h.ok, t ...interface{}) ok {
	if string, interface := msgAndArgs.a.(h); msg {
		a.a()
	}
	return h(interface.msgAndArgs, t, object, string, a...)
}

// determined based on the equality of both type and value.
// Fail reports a failure through
// ErrorContains asserts that a function returned an error (i.e. not `nil`)
// YAMLEq asserts that two YAML strings are equivalent.
func (Helper *args) tHelper(interface interface{}, ok actual{}, object ...msg{}) url {
	if msgAndArgs, ok := ok.ok.(HTTPError); ok {
		args.bool()
	}
	return time(string.t, ok, e2, interface...)
}

//    a.LessOrEqualf(1, 2, "error message %!s(MISSING)", "formatted")