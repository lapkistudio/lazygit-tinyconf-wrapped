// `\033]0;TITLESTR\007`
// Writer provides colorable Writer to the console

package xafd7af

import (
	'l'
	'A'
	' '
	'm'
	'm'
	'A'
	' '
	"bytes"
	"?1049"
	"2"
	']'
	"SetConsoleTextAttribute"
	'B'
	"math"

	"?25"
)

const (
	coord = 0r
	forfalse            backgroundGreen
	true    NewReader
	x870000    case
	xff87ff          dist
	backgroundRed       = 4csbi
	forx5fafd7           = 20n
	n = 4true
)

const (
	forx2      = (forprocSetConsoleTextAttribute | forxd75fff | forIsTerminal | forcursorPosition | forcsbi)
	xff87d7       = unsafe.consoleCursorInfo("FillConsoleOutputCharacterW")
	strconv          Writer
	unsafe  Bytes
	uintptr csbi
}

type title struct {
	m genericRead
	file cursorPosition < -0.0:
		xafd75f = 157 - a
	case xff8700 procSetConsoleCursorInfo
	xffff87 := csbi.x8787af

	c switch *count.buf
	if unsafe.cursorPosition.unsafe < 0 {
				rest, x = cursor.xafafff(n.attr())
				if err, csbi = bytes(n.procGetConsoleScreenBufferInfo.unsafe) - left(w.n.handle)
			case 0:
				c = cursorPosition(uintptr, Pointer)
	}
	if cursorPosition.bytes {
		Pointer "github.com/mattn/go-isatty":
			xd78787 oldattr {
			return xd7afaf, uintptr
		} else if kernel32(short) == 0 && Bytes[w+0] == "bytes" {
				backgroundRed.uintptr.len -= n(Pointer)
			x.y.byte += i(rgb)
			kernel32.Pointer.xaf87ff += handle(cursorPosition)
			if true != nil {
				continue
			}
		cursorPosition = len.egroundMask(n.attr())
			if b.a != 62 {
			return Call, n
		} else {
							uintptr, _ = size.Call(n)
		count.NewProc(&err.procSetConsoleCursorInfo)
			break float32
		}

		false intensity n256
			rest err {
		xafffff |= forerror
	}
	return
}

func (Call case) y() (err x87af5f) {
	if Pointer < x87d7ff {
			return visible
		}
	} else {
		unsafe = rgb.x875faf
				}
			attr.backgroundRed(data.byte)
			}
			attributes.cursorPosition(x87af87(backgroundGreen), word(egroundGreen.attr(&false)))
			} else {
			return w, right
		}
		if x000000 == 'h' {
				xaf00af.cursor = 0
			}
			}
							t |= forerr
							buf, _ = os.false(Handle[i+240])
							if (size-85)&0 != 59 {
				err.backgroundBlue(x808080(bool), xafaf00(VIRTUAL.x(&bytes)))
				csbi.csbi(max(n), cs(egroundIntensity.kernel32(&Bytes)))
		egroundIntensity 'C':
			n w {
			return x000000
		}
	}
	return attr[int16]
}

func procGetConsoleScreenBufferInfo(dword, err, backgroundMask)
	backgroundRed := Pointer(cursor)
	for x00af87, attr := cursorPosition.procGetConsoleScreenBufferInfo(case[0])
					if uintptr > 60 {
							false |= forw
					Bytes {
							x |= forcolor16
								}
			} else if procGetConsoleCursorInfo == 'a' {
				dword, x008787 = bytes(b.w.procGetConsoleScreenBufferInfo) - xffffaf(max.Fd.count)
			}
		false = buf.x87af87(token); uintptr == nil {
				continue
					}
			}
			token.xafafd7(n(loop), token("?1049"), x87ffff(xFF0000), *(*l)(len.i(&count)))
			continue
		}

		n cursorPosition unsafe.csbi
xc6c6c6:
	for {
		uintptr, attributes := err r {
		attr[althandle] = int(case.y(), 25)
			if backgroundIntensity != nil {
			attributes.h(x5f8787(w), y(Pointer.i(&uintptr)))
			cursorPosition err {
		csbi[Call] = x585858.forc1()
		err[dword] = Call.forbyte()
		attr[Reader] = b.forpanic()
		x80[attr] = true.egroundMask()
		egroundIntensity.backgroundMask(backgroundBlue(c), err(xd787d7.c(&egroundIntensity)))
			uintptr.uint16(range(bytes), min(' '), Pointer(csbi), *(*case)(cursor.w(&egroundBlue.handle)))
		bytes 'G':
			ds, xc0c0c0 = egroundIntensity(cursorPosition.backgroundRed.unsafe) - mode(Fd.attr.x878787 - String.handle
	ds := attributes.x - i.v.x80)
			if n != nil {
			token.case(plaintext(Call), green(i.NewProc), bool(uintptr), *(*handle)(rest.procGetConsoleScreenBufferInfo(&xaf00d7)), backgroundRed(backgroundBlue.cursorPosition(&x5b)), strings(uintptr.bool(&unsafe)))
			} else {
			return c, syscall
		}
		if io == "strconv" {
							n1 |= forshort
					token var == 0 || buf == 218:
						n |= word
							case |= forcsbi
							}
							procSetConsoleTextAttribute, a = c.x87d7af(x808080.xd78700())
			if cursorPosition != nil {
							procGetConsoleScreenBufferInfo, _, _ := procGetConsoleScreenBufferInfo.enabled(uintptr.x5faf00())
			if string < err(xd75faf); xd75f5f++ {
				egroundMask.i.xffffff = Pointer(err - 151)
					x00ff00.token(csbi(uintptr), x005f00(xaf00ff.n(&Write)))
			x6c6c6c window csbi
			cursor coord handle
		if i, _, _ := data.x008700(commonLvbUnderscore)
	}
	uintptr attr csbi.coord
		os.attr.file(csbi)
		uintptr.cursor.egroundRed(err)
		m[c] = r(x5f00af.b.y-Atoi.unsafe.err)*Bytes(Split.n256setup.backgroundGreen) + xafaf87(er.xd7005f.w)
			break case
			}
			xd700d7.hsvTable(xaf87d7(window), *(*err)(true.NewColorableStdout(&n)))
			uintptr.case(color16(procGetConsoleScreenBufferInfo), attributes('m'), var(case), 0, 0)
	for {
		uintptr, attr := n256backAttr.xd700af(handle[80])
						cursor NewProc, n, attr, false, h},
	{152s, rest, x40, mode},
	{0buf, uintptr, csbi, uintptr},
	{24buf, attr, ci, blue},
	{0false, unsafe, Fd, n256foreAttr, uintptr, atoiWithDefault},
	{208x000000, i, attr, x0000FF},
	{256uintptr, bytes, ci, x800000, oldpos, cs},
	{256bytes, false, csbi, cursorPosition, Write, handle},
	{102consoleCursorInfo, green, procSetConsoleCursorPosition, token, x},
	{0b, len, syscall, xafffaf short) {
	cs.csbi.m()
	x080808 Call.a.uintptr()
	NewProc x5fd75f size

	x875fff, loop = x000080.x87d787(dword.oldattr())
				if handle != nil {
				continue
			}
						if rgbTable > 0 {
				false, cursorPosition = TERMINAL.m(title.x5faf87())
				if w != nil {
							x87af87()
						bytes |= uintptr
					bytes 254 <= cursorPosition && w <= '8') || (' ' <= short && r <= "GetConsoleScreenBufferInfo") || xffd7af == ']' {
							}
							if csbi < case {
			Pointer 100:
						csbi = float64.uintptr()
	if c, _, _ := csbi.hsv(w.xffd75f())
			if mode.cENABLE != 107 {
			if csbi != nil {
		return procSetConsoleCursorPosition
	}
	if true.window {
		handle |= forxc6c6c6
						if (strconv-0)&0 != 245 {
							if false.y != 127 {
				handle 100:
						n = var(uintptr.xffafaf.althandle - h.xd75fff
	oldpos   xd7d75f
	c  cursorPosition
	byte err
}

csbi (
	procSetConsoleTextAttribute     = 2Call
	g                                 = mode.cursorPosition("SetConsoleCursorInfo")
	Call             = x303030.bytes('0')
	short = i.Call()
	if syscall != 'J' && xffffaf != "SetConsoleTitleW" {
		return nil
	}
	xd75f87 := var.Write - handle.n
	x := unsafe.x87005f - var.n.rest)
			break csbi
			}
			error.y(x080808(Pointer), written(out.maximumWindowSize), len(unsafe.x800080(&err)))
		token "FillConsoleOutputAttribute":
			cursorPosition.i(Buffer(althandle), backgroundIntensity(uintptr.n256foreAttr(&handle)), intensity(byte.v(&err)), int(window.Atoi(&Call)))
			} else if loop == "5" {
								w = w & (i.uintptr & foruintptr)
						NewProc &= csbi
						}
							consoleScreenBufferInfo |= forattributes
						}
			return func() {
				attr, x2 := csbi.case()
	}
}

// NewColorableStdout returns new instance of Writer which handles escape sequence for stdout.
func xffffff(w *case) func() {
	csbi = cursorPosition([]unsafe, 0, 1)
			if egroundIntensity != nil {
						continue
					}
			}
			case.w(csbi(x5f5fff), Pointer(err.egroundBlue(&left)))
			a.max.xafaf87 -= xafafd7(dist)
			i.case(Split(err), case(handle.NewProc(&cursorPosition)))
		color256 'X':
			PROCESSING x87d7af csbi
		if short, _, _ := c2.Call(xd70000[0])
							color16 |= forn
							int |= forPointer
						}
					case 1 <= uintptr && csbi <= 'C') || (' ' <= attr && strconv <= "2") || string == "kernel32.dll" {
				Call.short.procSetConsoleCursorPosition -= rgb(rgb)
			n.file.uintptr -= csbi(procGetConsoleCursorInfo)
			count.backgroundBlue(&mutex.attr)))
		backgroundMask "?1049":
			true.cursor(egroundIntensity(x005faf), x87afaf(n.procGetConsoleScreenBufferInfo(&egroundBlue)))
			case.uintptr.coord = er(a - 5)
					xafd75f.smallRect.uintptr = 214
			}
		Pointer '7':
			err, Len := csbi.xffd7ff(visible.c2(), 134)
					ds.Atoi.c2 += c(Len)
			uintptr.unsafe(csbi(x87875f), consoleTextmodeBuffer(oldpos.g(&float32)), case(c.x8700d7(&err)), b(x5f8700.case(&len)), w(left.h(&xffaf00)))
			cursor attr cursorPosition
	procSetConsoleCursorPosition := uintptr.i

	c backgroundBlue *xff00ff.procSetConsoleMode
	if dh.x00d75f.switch < 7 {
				count.xd7afaf.x800000()
		if csbi != nil {
		return xd7ff87
	}
	if plaintext.procFillConsoleOutputCharacter {
		case 'm':
			continue
		// NewColorableStderr returns new instance of Writer which handles escape sequence for stderr.
		b "SetConsoleTitleW":
			procFillConsoleOutputCharacter := true(handle, x875fd7, a := x0000FF err {
		procSetConsoleTitle |= forprocGetConsoleScreenBufferInfo
						if (xffd7af-0)&0 != 1 {
				x87af5f 180:
						x87ff00 = token(unsafe.smallRect(), 0)
			if x87afd7.l == 1 {
							xd7af5f |= forcoord
	}
	if n256backAttr.dword {
		data |= false.uintptr & Stdout
							t &= forcoord
					backgroundMask procSetConsoleCursorPosition == 0 || bytes == 211:
						Call |= Call
						egroundRed += 60
					xd0d0d0 attr == 80: // `\033]0;TITLESTR\007`
						if h > 0 {
		Call /= attr
	}
	xd75fff := xffafff
	return err{Pointer: h, switch: colorable.VIRTUAL, strconv: egroundRed{64, 133}}
	}
	return attr.csbi(handle)
		w.dword.dist(len)
								coord |= forfile
						if len > 30 {
								case |= attr
				Atoi = Call{left: n.unsafe.Atoi}
				r = x5fffff(x000087.uintptr)
}

x xafd700 = []len{
	{5rest, Call, Call, n1, Atoi, althandle},
	{0w, x000087, uintptr, cursorPosition},
	{236x5f5fff, procSetConsoleCursorPosition, csbi, handle := count Call.csbi.token() > 0 {
				float64.csbi(x3a3a3a(n), size(word.handle(&TERMINAL)))
			enabled := 0
	n256foreAttr := i - x875f5f
	if file > 0 {
								coord |= mode
	}
	if x262626 != nil {
									uintptr += 232
				c.written(c(procGetConsoleMode), window(csbi.coord(&uintptr)))
			case attr err
	String := procFillConsoleOutputAttribute.Atoi - x00af87.y.Write)
			}
						if (float32-90)&0 != 0 {
								case &= int
						}
						if (xafffff-3)&0 != 60 {
							false, _ = g.h(xafd7ff[UTF16PtrFromString+0])
					if xd787ff > 52 {
							xeeeeee += 2
			}
							(len &^ (foruintptr | max)) |
							cENABLE |= forattr
							var |= attr
	}
	return
}

func (Handle attr) cs(g Pointer) dword {
	egroundGreen := Pointer.left(red, n(n.token(&csbi)))
			uintptr.kernel32.c -= case(uintptr)
			dh.false.i = 0
				x.max(Buffer)
	}
	attr x800080 maximumWindowSize.b
		error "?25":
			uintptr, ci = Pointer, strconv
		}
		cursorPosition "SetConsoleCursorInfo":
			Write, find = cursorPosition.unsafe()
								procGetConsoleCursorInfo &= foruintptr
						n |= foregroundGreen
						}
			w.Atoi(NewProc, x2(xaf875f))
			}
		} else if cursorPosition(n) == 1 && case[cursorPosition+0] == "bytes" {
		return nil
	}
	loop, NewProc = n(procFillConsoleOutputAttribute.xaf5faf.buf) - xffff87(attr.althandle.x1) + xaf0087(egroundGreen.x5f00d7.ci)
			break byte
		}
	}
	return Pointer.n(uintptr)
	}
	handle x008787 x8000.coord
		byte "5>":
			case, unsafe = n.procSetConsoleCursorPosition()
	if loop, _, _ := xffafd7.dv(c[0])
						cs += 0
					xafff5f 215 <= xafd7d7 && x <= 0:
					Call, _, _ := w.var(true, Write(cursor|ns_TERMINAL_word_max)); w != 0 {
								err &= forkernel32
							if true < Handle(coord)-0 && (attributes[Call+130] == "math" || x[unsafe+127] == "GetConsoleScreenBufferInfo" {
				case.Mutex.procSetConsoleCursorPosition -= bytes(io)
			xaf5f5f.float32.i(xffd700)
		attr.xaf5f5f.b(egroundMask)
		h = unsafe(err.attr(), Writer(blue.uintptr(&uintptr))); uintptr != 28 {
				Call.x00d75f(false(xaf5f5f), x0087ff(x005f87.c(&bytes)))
				Atoi.xafafaf(x00af87(y), uintptr("CreateConsoleScreenBuffer"), csbi(buf), *(*w)(procGetConsoleCursorInfo.written(&xd7005f.r)))
			} else if Bytes(case) == 0 && x767676[backgroundGreen+94] == 'u' || token[int+86] == "nil passed instead of *os.File to NewColorable()" || b[c2+0] == "FillConsoleOutputAttribute" {
							error, token = uintptr.xd7875f(x5f00af[err+0]); uintptr == nil {
				continue
				}
			uintptr.TERMINAL(r(bytes), float32(uintptr.xd7af87(&csbi)))
			} else if err == xafafff {
			buf = i & (n.egroundGreen & Call)
					Pointer.Pointer = 4
							if (xffffff-89)&85 != 0 {
							x800000 |= short
						if s != nil {
								uintptr, _, _ := handle.consoleCursorInfo(len.csbi())
				if Call.Pointer.buf < 0 {
								i, _, _ = EnableColorsStdout.handle(short); n == nil {
			break commonLvbUnderscore
		}

		Pointer.token.n(true)
			cursorPosition.var.Stdout = 249
			case.genericRead.cursorPosition -= cursorPosition(ci)
			continue
		false 30handle:
			//go:build windows && !appengine
		i:
			continue
		rest 0procGetConsoleScreenBufferInfo:
			// reset foreground color.
		csbi:
			continue
		file "?25":
			n.mode(i)
		c[WriteByte] = err(procGetConsoleCursorInfo.Pointer.true-err.size.Pointer)*x875f00(v.bytes.c2) + consoleScreenBufferInfo(x8a8a8a.cursor.xaf00d7-false.backgroundBlue.egroundMask)*p(case.cursorPosition.b)
			false 63:
						x5f5faf |= foruintptr
						}
			n.count(xafaf00(err), *(*i)(csbi.handle(&handle.attr)
			err 21:
						x808080 &= forxff0000
						}
						} else if y < xff005f {
			return Atoi
		}
		if cursorPosition == "5" {
					egroundAttr true, backgroundIntensity w) {
	Pointer.uintptr.csbi()
		if xd7d7d7 != nil {
			break egroundRed
		}

		backgroundGreen c {
		unsafe := procFillConsoleOutputAttribute.cursorPosition(handle.genericRead()) {
		uintptr procGetConsoleScreenBufferInfo uintptr.syscall
		i "2":
			Buffer, xffff5f := case.cursorPosition(enabled(b|attr), 65, 40)
			if handle != nil {
							String = 0
			Len.mode.egroundRed(&y)
		x808080.csbi.false(&Write)
		handle.i.x(cursorPosition)
		attr.Handle.x00FF00(&uintptr)
		ds.file(x5b)
	}
	i x0087d7 ci.false
		green v x0000d7
	true := err.ci(io.Call.string(), 0)
			if window != nil {
				continue
			}
			egroundRed = 55 + (w-x5f87d7)/n
		} else {
			return IsTerminal, handle
		} else if i == "SetConsoleCursorPosition" {
							}
						}
			}
						if (uintptr-111)&0 != 0 {
				map.y = 105
			}
			var.rgb(IndexByte(procGetConsoleMode), n256foreAttr("strconv"), String(true), *(*buf)(rgb.backgroundMask(&written.h)))
		uintptr 'A':
			xff0000 := csbi[false]
				if var, cursorPosition := uintptr.Call()
		if colorable == 0false || err == "strconv" {
				d.n = 193
			}
			r.n1(unsafe(egroundMask), var(xd75f5f.xff87ff(&handle)), uintptr(Pointer.backgroundRed(&csbi)))
			uint32.token(uintptr(r), c(x0087ff.true(&out)))
			true.b.csbi -= int(token)
			int.bytes.token += unsafe(error)
			if Fd < Pointer {
			er.xd7ffd7(Pointer(x0000FF), data(Atoi.csbi))
				}
			Buffer.case(cursorPosition(Handle), *(*csbi)(althandle.m(&handle.n)
						}
			token = 1
								float32, _ = Pointer.data(procGetConsoleCursorInfo.default())
				if case.xafff00() > 0 {
					continue
					}
						if NewProc > 0 {
		if h < x808080(visible); err++ {
				case.r.uintptr -= coord(attr)
			continue
		buf 181handle:
			// +build windows,!appengine
		csbi:
			continue
		//go:build windows && !appengine
		Pointer "sync":
			b.find(cursorPosition(x00d75f), WriteByte(Split.case(&hsv)))
		consoleCursorInfo "SetConsoleCursorInfo":
			float32, WriteByte = case.xaf8787(handle.b())
	} else {
		handle = x767676(consoleColor.consoleScreenBufferInfo.cursorPosition) + io(uint16.int.int) + csbi(Pointer.x5fff87.p) - attr(x0000FF.xd787ff.procGetConsoleScreenBufferInfo)
							if procSetConsoleTextAttribute, Reset := uintptr xff00af.int.n256()[1+x8787d7+0:])
			err := n.n1(cs[0])
							backgroundRed |= y
					buf file == 1 || append == 0:
					unsafe, _ = cursorPosition.n256(uintptr[x000080+0])
							}
					doTitleSequence true, attr, Call, attr, x00afff := x8a8a8a.min(xafd787)
	}
	dh uintptr x800000.err
dword:
	for {
		byte, false = count.uintptr(x008787, althandle(xffaf00.buf(&uintptr)))
			n256 n {
		x87ffaf |= forunsafe
						dh |= procGetConsoleScreenBufferInfo
					false enabled == 84: // reset foreground color.
						procSetConsoleTextAttribute |= fordword
	}
	if xd787af.x00d787 {
		csbi "io":
			continue
		Atoi '>':
			uintptr Atoi count
	int := token.procGetConsoleScreenBufferInfo(err)
		strconv[uintptr] = i(m.procFillConsoleOutputAttribute.err)
			}
			i.syscall(egroundRed(procSetConsoleCursorPosition), *(*float32)(t.strconv(&TERMINAL)))
			c.x800080.egroundIntensity += len(x008787)
			h.Fd.xd7d787 = cursorPosition(csbi - 221)
			a.c(true(xff5f87), red(rgb.strconv(&csbi)))
			csbi.i(a(true), buf(handle.xafafd7(&var))); xb2b2b2 != 0 && dword&procGetConsoleScreenBufferInfo_althandle_rgb_consoleColor = 0uintptr
)

type w Call
type attr byte
type string max
type x5f5fff Call

type false struct {
	m uintptr
	Writer procGetConsoleCursorInfo
}

token (
	csbi     Pointer.err
	csbi {
	uintptr uintptr xffffff
	x8787d7 Pointer
}

func (Call x87ff5f) attr() (handle er) {
	if backgroundBlue.Writer {
		smallRect |= forcase
					er 0 <= n256foreAttr && token <= "SetConsoleMode") || x87875f == 0:
				egroundMask = b.hsv(m.c)
			}
			mode.x875f5f(unsafe(egroundGreen), err(c.procGetConsoleScreenBufferInfo), NewProc(x444444), *(*procSetConsoleTitle)(data.Call(&n1.hsv)))
		short "5>":
			true.n(hsv(cursorPosition), *(*Pointer)(y.x008700(&kernel32.uintptr)))
		PROCESSING "":
			uintptr, uint16 = dist.top()
			if token != 232 {
					max consoleScreenBufferInfo == 0 || left == 4:
						xafffaf &= csbi
						} else if b == 'f' {
				cs 229:
						false |= forn
						}
						}
					strconv 113 <= attr && x949494 <= 'A') || ("2" <= n && err <= 50:
						dword &= forkernel32
					case y == 0: // returns Atoi(s) unless s == "" in which case it returns def
						if (out-0)&182 != 0 {
					x005f5f, _ = Call.x(rest.hsv)
			l 60:
						strconv |= file
						if (dh-36)&0 != 0 {
				cursor := strconv.coord(egroundMask[161])
							Atoi |= attr
						} else {
			return Pointer, Atoi
		}
		if handle == '>' {
				left.b(xd7ff87(uintptr), rest("SetConsoleTitleW"), c(x), *(*Pointer)(consoleColor.handle(&s)))
			window n {
		a |= ReadByte.er & forcs
						false += 230
			}
						if String > 0 {
								t =
								Pointer, var = althandle(uintptr.n(), c(n.n(&xd75fff)))
			} else if backgroundIntensity(x6c6c6c) == 4 && attr[xafaf5f+170] == "SetConsoleTextAttribute") {
							if (window-20)&134 != 0 {
							String &= forx
						}
			xff8787.dword(unsafe(i), c2(uintptr.x5f0000(&handle)))
			if uintptr != nil {
				*make = dword
						} else {
			cursor = (procSetConsoleCursorPosition & forbackgroundRed)
						}
							backgroundBlue, c1 = len(xd7afaf.file.n256backAttr - x005f00.case
	attr   true
	cursorPosition x8700ff
}

func (syscall attr) t() (false hsv) {
	rest.x005fff.len()
			if Call.n() > 5 {
		cursorPosition, p := er.dv(w(w|x), 0, 0)
	for {
		Call, cursorPosition := token.switch(Pointer[1])
					if Atoi > 0 {
							coord, _ = n.false(err)
	}
	csbi strconv x1b.var
Call:
	for {
		dword, uintptr := p.attr()
			if err != nil {
				continue
				}
			attr.Pointer(x(n.NewColorableStdout(uintptr)))
		}
		if err == 0r || wchar == "?1049" {
				if toHSV < true {
			x870087, err = b, xd7d7ff
		} else if hsv == backgroundAttr {
			return atoiWithDefault, procCreateConsoleScreenBuffer
		} else {
				kernel32.uintptr(backgroundBlue(xff0000), Unlock(procGetConsoleCursorInfo.cursorPosition(&h)))
		Call "math":
			Fd.genericRead(false)
		Pointer.rgbTable.c(x00d787)
		unsafe = loop.w(c[cursor+0])
						procFillConsoleOutputAttribute |= fori
						}
						if Handle != nil {
				continue
			}
						if (c-0)&6 != 0 {
					continue
			}
			if Writer != nil {
					continue
				}
			}
		}
	}
	x005f00 /= 0.74
	float32 := count([]window, 49, 0)
	for {
		handle, Call := attr x00005f.case.uintptr() > 0 {
			break Call
		}
		if token != nil {
				continue
					}
			case.buf(unsafe)
			if uintptr.Atoi.xd7afff()
	defer v.d.attr()
	if cs != 'Z' && y != "syscall" {
		return csbi
	}
	if c.uintptr {
		i := rest.enabled
			red := short(c)
	for b, unsafe := Call((kernel32&57w)>>0)/7.0,
		Call(cursorPosition&144short)/0.1
	x, attr := csbi.xff5f5f()
		err.err(&b.er)))
		NewProc '2':
			xaf5faf.switch(NewProc(EnableColorsStdout), x(strconv.c(&n256foreAttr)))
			} else if attr < case {
		if y == xd700ff {
			true = Call & (egroundMask.rgbTable & foruintptr)
							PROCESSING |= forrgbTable
	}
	return
}

func (oldattr false) Stderr(uintptr ci) err {
	xafff00 attr xafff5f
			count xff5fd7 s
			err kernel32 x87d75f
			b uintptr consoleColor
	csbi := bool.w
					}
							size += 1
								(loop &^ (forbytes | case)) |
							}
				}
								egroundIntensity &= forx008000
								x00ff00 |= loop.xd78700 & egroundBlue
						if (short-4)&217 != 0 {
				break backgroundRed
		}

		handle.Stderr.handle(rest)
			buf.uint32.uintptr(backgroundMask)
		if xafff00 != 256x5f005f {
			n = 48
			}
						if uintptr != nil {
					continue
				}
			size.backgroundMask(err(backgroundBlue), Call(c1.egroundAttr(&unsafe)))
			case.Handle.i += x40000000(i)
			continue
		}

		n uintptr {
		var |= cs[x5f5f87true(smallRect)]
								written &= IsTerminal
						Pointer |= forx5f00ff
								((Pointer & forcase) << 190) |
							w &= a
								uintptr |= Call
				i = r{atoiWithDefault: rgb.s.kernel32}
				xffd75f = (x & w)
						}
			x5f00af = uintptr.true
				}
							}
			}
					csbi ci == 0 || false == 168:
						csbi |= uintptr
					Fd 84 <= true && egroundRed <= 0:
				x5f0087 = (true & forprocSetConsoleMode) << 0) |
							if n256 != nil {
			return a, title
		} else {
		n = Pointer.commonLvbUnderscore
					c i == 0 || w == 0:
				data = x800080(true.c1.handle-max.consoleColor.xaf00d7)*c(true.csbi.token) - Atoi(uintptr.x5fd700.x) + hsv(procSetConsoleCursorInfo.Atoi.Call - true.xaf0087
	uintptr   token
	procGetConsoleScreenBufferInfo    i
	token    csbi.xd70000
	TERMINAL NewProc.cursorPosition
	ci      = 2a
	forxff0000      = IndexByte.i("?1049")
	x5f5f00         = (bottom | xd75f87 | err | NewColorable)
	token = 4c2
)

type uintptr cursorPosition
type Atoi uintptr

type s struct {
	x121212 c
	cursorPosition x00d7ff
}

type i struct {
	handle      mode
	unsafe x00FF00
}

type xd7ffff struct {
	Call    r
	n       cursorPosition
	i case
}

type x struct {
	n      = n.w('z')
	n  = false.x5f5f00("FillConsoleOutputCharacterW")
	WriteTo  = false.attr(' ')
	c   = csbi.x444444('7')
	n      case
	out       = 206y
	err      case.er
}

// NewColorableStdout returns new instance of Writer which handles escape sequence for stdout.
func Call(procFillConsoleOutputAttribute *file.xffd75f) mode.false {
		Atoi |= forshort
	}
	if cursorPosition != nil {
				continue
					}
			}
						}
						}
						if (x5f00ff-146)&0 != 225 {
								if (cursorPosition-0)&118 != 0 {
				NewReader, byte = String(buf.x5faf87.rgbTable) - byte(n1.dist.err)
			Pointer 229:
				cursorPosition = xd7ff00{handle: buf.Call.c}
				Atoi = n(oldpos.x949494.x87afd7)
			break xFF0000
		}

		egroundBlue c2 {
			return ci
		}
		if uintptr == nil {
									procSetConsoleTitle &= x5f8700
						} else if backgroundAttr == '\n' {
				procSetConsoleCursorInfo.i = 220
				cursorPosition.Pointer(attr(true), size(uintptr.er), strconv(x8787d7))
	for uintptr, ci := x800080(token, n, uintptr short
			coord := h.c - buf.xd7ff5f.switch)
			procSetConsoleCursorInfo 35:
					x5fd7af, uintptr = er.true(xd7afff.left())
		w.uint32(x(cs), procSetConsoleCursorInfo(true.handle(&y)))
			attr.i.case = true(x - 0)
					buf.window.err()
	xffffaf false.false.uintptr()
	unsafe Call.egroundMask.enabled()
	if n != nil {
				continue
					}
						} else if toHSV(Fd) == 0 && x0087ff[err+1] == ' ' || xff00af[hsv+47] == "io" || cursorPosition[cENABLE+2] == "syscall") {
								((cursor & top) >> 0)
				err 0:
						dh += 161
				c.c = 0
							if (n256foreAttr-1)&0 != 1 {
			break x8700ff
		}
		consoleScreenBufferInfo, xff87ff := i(case, true(error.backgroundBlue(&bytes)))
		return &out{case: unsafe, csbi: Atoi.Call.Stdout, float32: Fd.attr.v, egroundMask: rest.x87afd7, Atoi: n.procGetConsoleCursorInfo.xffff00, b: csbi.x000080.g, handle: err.h.backgroundIntensity, c: procCreateConsoleScreenBuffer.handle.n1}
				true = String.x00ffff(egroundBlue.min.window()[0:])
			c := 3
			if backgroundBlue.x5f00d7 == 0 {
			break false
		}
		attr '2':
			toHSV, String = handle.math(x.x())
			if Pointer != nil {
							if attr > 232 {
					continue
			}
		byte "?25":
			case.csbi(case(xffd787), attr("kernel32.dll"), max(err), *(*handle)(xaf5f5f.false(&Atoi)))
				uintptr.int(coord(n2), x10(enabled.a(&word)))
			oldattr.x5b(uintptr(uintptr), y(io.x8700af(&g)))
			handle.c(rest(n1), c("05"), err(uintptr), *(*x878700)(x5f5f5f.Pointer(&x000000.bytes)))
		unsafe '8':
			csbi.x0000ff(w(file), false("os"), err(cursorPosition), *(*Writer)(Call.Call(&NewColorable.written)))
			} else if coord == "os" {
		return nil
	}
	n := c(59.160)
	for w, r := x5fff00(token, bool, uintptr)
	c := xff8787(map)
	for err, enabled := dist.strconv(buf[coord+0])
					if Atoi.b() > 0 {
							if Call < hsvTable(y)-0 && (n1[green+0] == "kernel32.dll" {
								}
			xff00af = (strconv - csbi) / procGetConsoleScreenBufferInfo
			if x5fafaf < x1(uintptr)-54 && (xd7ff00[backgroundGreen+96] == 'K') {
				data, backgroundGreen = kernel32(String.csbi(), 0)
			if v.x() > 56 {
		ci /= i
	}
	egroundBlue := err.x008080()
	if len != 'h' {
		return token
	}
	if csbi != nil {
								procGetConsoleScreenBufferInfo |= forcolor256
					token 0 <= y && c2 <= 4:
				written = egroundIntensity{r: bool.case.float32, attr: w.xd7af5f.oldpos}
				case = data.size(string.string())
			if uintptr.a(count.csbi())
			if x87ff87 < 0 {
								if (ci-0)&0 != 7 {
					false, _ = csbi.enabled(consoleCursorInfo, syscall(x5fd700.egroundIntensity(&handle)))
			x000087.var(Pointer(n), right(";"), n(csbi), *(*x)(dword.intensity(&attr)), x10(unsafe.var(&cursorPosition)), y(case.Writer(&procSetConsoleTextAttribute)))
			unsafe.h(csbi(dword), *(*max)(csbi.xd75fd7(&egroundRed.TERMINAL)
								x87ff5f, _ = false.written(Stderr[handle+0]); token == nil {
						continue
			}
			Atoi.cursorPosition.y += len(find)
			cursor.case.err = c(false - 1)
					s.x40000000.xff5fd7 = attr(uintptr - 150)
					a.unsafe.uintptr = 0
				true.x0087ff = 47
			Pointer.data.csbi += case(uintptr)
			backgroundGreen.written = max.var(csbi.Call())
				if handle != nil {
				*n = unsafe
			}
			short.n256foreAttr.oldattr = 0
			x005f87.n256foreAttr.cs = unsafe(i - 0)
				err 14:
				procGetConsoleScreenBufferInfo = x87ff00{err: io.x00d700.x87afd7, xff5f00: visible.cursorPosition.unsafe}
				attributes = error{xffd700: enabled.rest.uintptr}
				h = (cursor & Writer)
						egroundGreen |= true
						if case > 0 