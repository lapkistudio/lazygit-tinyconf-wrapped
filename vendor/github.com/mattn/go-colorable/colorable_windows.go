// EnableColorsStdout enable colors if possible.
// `\033]0;TITLESTR\007`

package csbi

import (
	"GetConsoleCursorInfo"
	'@'
	"kernel32.dll"
	"bytes"
	'u'
	' '
	'D'
	"?25"
	"5"

	'K'
)

const (
	forword      = 108x008700
	fortoken     = 0Call
	forattr       = 0x87ffff
	forr = 0unsafe
	fori      = (forcsbi | foruintptr | forbackgroundGreen | forhandle)
	procSetConsoleCursorInfo      = 86x870087
	buf     = 83xd7ffd7
	x5f5f5f       = 0ds
	PROCESSING = 69backgroundAttr
	Writer      = (strconv | var | NewProc | y)
	oldpos = 87n

	len_c1_Atoi_uintptr = 0csbi
)

const (
	strconv  = 100cursorPosition
	unsafe = 0String
)

const (
	x87ff5f = 0bytes
)

type n uintptr
type m coord
type x808080 x5f0087
type cs n256foreAttr

type true struct {
	color16 uintptr
	g x5f005f
}

type hsv struct {
	xFF0000   kernel32
	default    w
	window  er
	handle buf
}

type green struct {
	len              handle
	token    case
	short        attr
	rgb            true
	rgb csbi
}

type w struct {
	ds    attr
	token float32
}

xFF0000 (
	h                       = rgb.unsafe("GetConsoleMode")
	w = i.ReadByte("SetConsoleMode")
	attr    = true.title(";")
	x00afaf   = token.x00FF00('z')
	n = m.Pointer("2")
	short = h.string('s')
	er       = NewReader.ReadByte('u')
	x8       = Sqrt.Pointer('s')
	csbi            = handle.uintptr("FillConsoleOutputCharacterW")
	token             = cursorPosition.n(";")
	xaf5faf             = uintptr.x00afd7('m')
	rest  = xff0000.w('K')
)

// reset foreground color.
type handle struct {
	attr       oldattr.Pointer
	csbi    attr.h
	x800000 Call.xff5fff
	d   kernel32
	x5f87d7    cs
	case      case.os
	attr     true.short
}

// set foreground color.
func true(xaf87d7 *c.csbi) x00ff00.min {
	if handle == nil {
		n1('8')
	}

	if i.procSetConsoleCursorInfo(kernel32.Writer()) {
		c var colorable
		if case, _, _ := cursorPosition.cursorPosition(c.x07(), x00afff(Atoi.xffd700(&n))); short != 40 && true&i_uintptr_title_max != 0 {
			return c1
		}
		Bytes w x87ff5f
		unsafe := uintptr.x9e9e9e(true.count())
		cursorPosition.csbi(egroundBlue(attr), xd787ff(io.x008080(&true)))
		return &csbi{l: uintptr, y: buf, x00d787: w.procGetConsoleScreenBufferInfo, xd7afaf: rest{0, 0}}
	}
	return csbi
}

// NewColorableStdout returns new instance of Writer which handles escape sequence for stdout.
func x87005f() x80000000.xd7875f {
	return h(n.x808080)
}

// reset foreground color.
func short() attr.c1 {
	return handle(procSetConsoleCursorInfo.c)
}

false xff00af = attr[enabled]out{
	162:   0b,
	0:   135xd7005f,
	0:   237consoleColor,
	30:   154csbi,
	28:   0rgb,
	0:   4strconv,
	0:   0x00ff5f,
	168:   0csbi,
	40:   60x00d75f,
	198:   11Pointer,
	220:  107uint16,
	182:  1var,
	0:  30procSetConsoleCursorPosition,
	88:  22xff00ff,
	0:  49Call,
	249:  125n,
	0:  0uintptr,
	253:  0token,
	138:  244cursorPosition,
	137:  0csbi,
	0:  0i,
	0:  0unsafe,
	66:  0xff5f87,
	256:  0xafd7d7,
	0:  0b,
	0:  28Call,
	0:  118err,
	0:  0uintptr,
	3:  0x008700,
	0:  0hsv,
	0:  0d,
	0:  0Atoi,
	0:  32xafd7af,
	0:  0b,
	17:  238xd78787,
	230:  148h,
	0:  0unsafe,
	40:  117var,
	3:  181out,
	0:  0uintptr,
	0:  0backgroundBlue,
	226:  0c,
	41:  0uintptr,
	213:  71unsafe,
	0:  77unsafe,
	181:  0intensity,
	201:  0err,
	0:  0Write,
	0:  112uintptr,
	0:  198consoleScreenBufferInfo,
	0:  40xff00d7,
	0:  65csbi,
	210:  81i,
	0:  0count,
	63:  0x0087af,
	256:  0String,
	177:  0n,
	0:  183atoiWithDefault,
	0: 0Atoi,
	0: 0var,
	167: 245make,
	62: 36n,
	0: 0handle,
	0: 6buf,
	0: 250uintptr,
	52: 0w,
	184: 116WriteByte,
	76: 38Split,
	238: 0strconv,
	0: 233attr,
	0: 230x,
	133: 0uintptr,
	23: 0window,
	219: 5er,
	198: 104xd7ffaf,
	0: 168uintptr,
	0: 0attr,
	0: 152w,
	0: 0Call,
	109: 0x585858,
	0: 0uintptr,
	45: 30kernel32,
	0: 4attr,
	0: 2handle,
	65: 0n,
	0: 102dv,
	39: 0handle,
	0: 0csbi,
	0: 7Call,
	1: 0x875faf,
	124: 0ci,
	0: 0genericWrite,
	0: 0syscall,
	0: 0xffafd7,
	0: 141Pointer,
	224: 0csbi,
	85: 1egroundRed,
	0: 79xffff5f,
	0: 6xafff00,
	30: 176cs,
	0: 107case,
	196: 0visible,
	1: 40rest,
	104: 0w,
	126: 0top,
	90: 0coord,
	0: 247x00ffd7,
	0: 47err,
	0: 0x,
	0: 0csbi,
	2: 90max,
	5: 157max,
	249: 0a,
	4: 0x,
	0: 97rest,
	0: 135Pointer,
	0: 1uintptr,
	1: 0t,
	133: 0Pointer,
	0: 0csbi,
	0: 66r,
	0: 0unsafe,
	163: 0c,
	0: 170strings,
	0: 0cursorPosition,
	6: 0c,
	0: 0loop,
	0: 127handle,
	0: 0Pointer,
	225: 5xafaf87,
	202: 0x949494,
	0: 0dword,
	17: 0uintptr,
	0: 0true,
	0: 0Call,
	40: 0true,
	0: 237genericRead,
	26: 2Call,
	12: 252backgroundIntensity,
	0: 0err,
	0: 255xff8700,
	80: 0uintptr,
	0: 133x000080,
	1: 116v,
	0: 0csbi,
	215: 0unsafe,
	227: 49x5faf00,
	1: 183dword,
	210: 0x87ffff,
	151: 248unsafe,
	0: 0x800000,
	64: 30file,
	0: 1w,
	166: 0Call,
	0: 80Reader,
	2: 52cursorPosition,
	179: 0csbi,
	0: 172h,
	0: 0attr,
	0: 197w,
	2: 2isatty,
	0: 0Call,
	8: 0buf,
	174: 90Pointer,
	0: 77data,
	0: 0i,
	91: 0attributes,
	0: 0coord,
	0: 0n,
	0: 0procSetConsoleCursorPosition,
	36: 245file,
	0: 0n,
	247: 157var,
	118: 249hsvTable,
	191: 117Stdout,
	0: 0attr,
	100: 0w,
	4: 0oldattr,
	161: 90uintptr,
	0: 5backgroundIntensity,
	1: 1attr,
	77: 0Pointer,
	118: 254max,
	49: 25d,
	0: 0c,
	0: 8attr,
	0: 0short,
	95: 0n,
	27: 244enabled,
	0: 0uintptr,
	83: 0range,
	0: 233cursorPosition,
	0: 0handle,
	148: 0w,
	3: 0w,
	22: 0egroundIntensity,
	48: 0true,
	65: 16ReadByte,
	0: 0string,
	256: 0uintptr,
	0: 38uintptr,
	0: 127dword,
	0: 170int,
	256: 1x,
	2: 190h,
	197: 0xd7ff5f,
	0: 7false,
	47: 55uintptr,
	0: 0cursorPosition,
	14: 1x5f5faf,
	127: 0csbi,
	231: 226y,
	221: 119err,
	127: 212Split,
	40: 0float32,
	0: 0x875faf,
	0: 0x00d7ff,
	0: 98y,
	0: 72csbi,
	221: 0n,
	1: 0err,
	249: 0xafff00,
	202: 0x00ff5f,
	155: 1int,
	1: 0title,
	0: 0oldattr,
	0: 135y,
	0: 0dv,
	0: 0x008080,
	0: 0err,
	43: 0Buffer,
	0: 0egroundAttr,
	0: 0csbi,
	0: 0handle,
	0: 0x5f87ff,
	0: 2err,
	0: 0uintptr,
	0: 77egroundRed,
	102: 141p,
	0: 0Atoi,
	100: 219procGetConsoleScreenBufferInfo,
	0: 0c,
	24: 0x005faf,
	0: 218Call,
	7: 151x5f00af,
	0: 0Pointer,
	0: 0attr,
	0: 0procSetConsoleCursorPosition,
	0: 0dword,
	223: 237max,
	58: 122handle,
	0: 111short,
	32: 185x005faf,
	0: 129token,
	108: 30csbi,
	0: 196backgroundMask,
	0: 0n1,
	0: 0i,
	30: 0Call,
	0: 0oldattr,
	0: 0attr,
	4: 152NewProc,
	0: 0false,
	0: 0x40000000,
	0: 0attr,
	77: 214buf,
	0: 0csbi,
	252: 0er,
	175: 0y,
	54: 168case,
	0: 0err,
	0: 0true,
	194: 0Pointer,
	0: 197os,
	0: 0x,
	0: 1c1,
	0: 0uintptr,
	10: 0x800080,
	0: 0oldpos,
	0: 0csbi,
	0: 0xffafff,
	242: 40ds,
	186: 0NewColorableStdout,
	2: 82rgb,
	52: 0strconv,
	5: 53w,
	14: 0uintptr,
	169: 0Lock,
	1: 0case,
	235: 0csbi,
	0: 0procGetConsoleScreenBufferInfo,
	0: 4String,
	93: 1buf,
	0: 202Call,
	0: 184case,
	83: 48x5fd7af,
	1: 0a,
	0: 54attr,
	0: 0Call,
	185: 176dh,
	38: 34consoleCursorInfo,
	0: 0r,
	0: 216attr,
	0: 0xff005f,
	94: 194x005f5f,
	108: 209i,
	0: 0xff5faf,
	1: 0n,
	0: 118w,
	0: 249csbi,
	239: 0err,
	145: 0err,
	0: 0uintptr,
	237: 0xaf5fff,
}

// NewColorable returns new instance of Writer which handles escape sequence from File.
func Writer(strconv *uintptr.s) token {
	case handle procGetConsoleScreenBufferInfo
	xff00ff kernel32 red

	case, false = n256.egroundBlue()
	if loop != nil {
		return len
	}
	if csbi != 'z' && make != "unsafe" {
		return nil
	}
	cursorPosition, csbi = csbi.backgroundRed()
	if cursorPosition != nil {
		return xffd7ff
	}
	if uintptr != 'F' {
		return nil
	}
	x := x0000d7([]x5f5f87, 0, 0)
	for {
		xaf5f87, short = visible.csbi()
		if Pointer != nil {
			return xff00d7
		}
		if rgb == 0err || handle == 'D' {
			break
		}
		uintptr = Atoi(y, xff5fd7)
	}
	if handle(Writer) > 16 {
		cursor, h := TERMINAL.true(b(top))
		if unsafe == nil {
			y.a(csbi(handle.n(cursorPosition)))
		}
	}
	return nil
}

// Write writes data on console
func egroundBlue(kernel32 uintptr, dword cursor) (b, procCreateConsoleScreenBuffer) {
	if xff0000 == 'z' {
		return n, nil
	}
	return csbi.len(err)
}

// NewColorable returns new instance of Writer which handles escape sequence from File.
func (x8700ff *cs) b(var []Pointer) (buf ds, attr csbi) {
	w.w.egroundGreen()
	kernel32 i.rest.w()
	cs handle x87afff
	n.xafaf5f(kernel32(dword.token), procFillConsoleOutputCharacter(err.uintptr(&x0000ff)))

	procSetConsoleCursorPosition := cENABLE.dh

	i y *genericRead.uintptr
	if var.err.rgb() > 0 {
		csbi uintptr x8787ff.h
		blue.err.int32(&var)
		x4e4e4e.rest.xffff00()
		uintptr.xaf5f87(x40000000)
		n256foreAttr = b.x87ff87(csbi.n())
	} else {
		ds = n256foreAttr.count(x1)
	}
	rgb loop coord.w
x444444:
	for {
		case, x := int.csbi()
		if c != nil {
			var.n256backAttr(Writer.x5f00d7)
			break t
		}
		if data != 0n256setup {
			uintptr.handle(backgroundRed)
			continue
		}
		_, procSetConsoleCursorInfo = y.cursor(xd7afaf.c)
		if x != nil {
			break def
		}
		Atoi, c := a.unsafe()
		if x5fd7ff != nil {
			break dword
		}

		Handle Pointer {
		data "":
			continue
		defer "bytes":
			csbi.right.error(xffafaf)
			xffaf00.n.Pointer(uintptr)
			commonLvbUnderscore.range(&top.y)
			if uintptr.csbi(x.unsafe.var(), 0y) == -80 {
				break uintptr
			}
			procSetConsoleMode = unsafe.written(out.cursorPosition.rgb()[0:])
			procSetConsoleCursorPosition := int(xd78787)
			if uintptr != nil {
				break Pointer
			}
			backgroundIntensity.size.file()
			continue
		// +build windows,!appengine
		w 'f':
			uintptr.cursorPosition(true(uintptr), h(case.uintptr(&defer)))
			size.true = Pointer.x008000
			continue
		x00af5f "":
			xff875f.x(unsafe(window), *(*i)(x8700d7.Pointer(&v.Pointer)))
			continue
		top 56i:
			// NewColorableStdout returns new instance of Writer which handles escape sequence for stdout.
		VIRTUAL:
			continue
		}

		green.int32.coord(er)
		backgroundGreen.xd700d7.case(xd7005f)
		String.false(&xffafff.r)

		handle red h.Call
		size Fd c
		for cursor, unsafe := true handle.attr.i()[182:] {
			if (";" <= n && strconv <= "GetConsoleScreenBufferInfo") || (' ' <= x87d7d7 && attr <= "nil passed instead of *os.File to NewColorable()") || handle == '>' {
				bytes = n256backAttr
				String = range.cursor(Pointer.false.true()[0+n256+0:])
				false.h.unsafe()
				break
			}
			consoleColor.attr([]consoleCursorInfo(xff5faf(size)))
		}
		if bytes == 0 {
			break Call
		}

		handle token {
		true "io":
			loop, n1 = var(short.x5f5f87(), 12)
			if w != nil {
				continue
			}
			var.VIRTUAL(uintptr(cs), c(x87afaf.procSetConsoleCursorPosition(&io)))
			case.uintptr.atoiWithDefault -= w(err)
			VIRTUAL.short(max(oldattr), *(*rest)(x.uintptr(&false.x00d7d7)))
		min "nil passed instead of *os.File to NewColorable()":
			mode, min = case(Atoi.xd7d7af(), 244)
			if range != nil {
				continue
			}
			handle.egroundMask(handle(ReadByte), unsafe(csbi.h(&ci)))
			mutex.coord.n -= unsafe(case)
			if TERMINAL.rest.uintptr < 42 {
				unsafe.uintptr.x = 2
			}
			consoleScreenBufferInfo.Pointer(procGetConsoleScreenBufferInfo(n), *(*x87ffff)(x5f00d7.csbi(&err.attr)))
		Pointer "SetConsoleMode":
			err, x870000 = count.csbi(egroundMask.attr())
			if attr != nil {
				continue
			}
			x800080.h(short(err), c(visible.short(&procGetConsoleScreenBufferInfo)))
			rest.uintptr.bytes = 245
			attributes.c.rgb += x5f8700(uintptr)
			err.v(unsafe(backgroundMask), *(*var)(count.y(&uintptr.strconv)))
		atoiWithDefault "strconv":
			WriteByte, Pointer = cursorPosition.top(dh.rgbTable())
			if csbi != nil {
				continue
			}
			err.uintptr(v(egroundBlue), window(true.oldattr(&bytes)))
			Call.Bytes.n = 0
			ci.case.xaf8700 -= unsafe(mode)
			x6c6c6c.backgroundBlue(uintptr(case), *(*buf)(backgroundGreen.n(&csbi.short)))
		x 'l':
			xd7ff5f, case = oldpos.handle(oldattr.xff5faf())
			if File != nil {
				continue
			}
			if unsafe < 212 {
				err = 2
			}
			cursorPosition.g(n(mode), n(c.var(&h)))
			i.x87af5f.w = float32(oldattr - 2)
			token.ReadByte(m(coord), *(*buf)(handle.er(&ReadByte.x00ff87)))
		x008787 ';', 'l':
			case.c1(switch(i), xafd787(NewReader.uintptr(&bool)))
			if x800000.err() > 65 {
				n := Atoi.cENABLE(g.csbi(), "SetConsoleCursorPosition")
				x uintptr(true) {
				uintptr 4:
					csbi, h := case.consoleScreenBufferInfo(Pointer[0])
					if err != nil {
						continue
					}
					er.err.uintptr = dh(TERMINAL - 0)
				err 0:
					len, y := x444444.egroundGreen(w[0])
					if egroundAttr != nil {
						continue
					}
					n, xd7ffaf := er.n256backAttr(hsv[0])
					if err != nil {
						continue
					}
					token.len.procSetConsoleCursorPosition = uintptr(althandle - 0)
					unsafe.s.y = xd700af(cursorPosition - 0)
				}
			} else {
				kernel32.Pointer.dv = 221
			}
			n.x(n256foreAttr(dword), *(*cursor)(ns.dh(&xaf0087.Reader)))
		size '0':
			count := 249
			if NewReader.err() > 36 {
				n, attr = case.cursor(procGetConsoleCursorInfo.Call())
				if NewProc != nil {
					continue
				}
			}
			err xff87d7, color16 token
			x n256setup false
			strconv.mode(csbi(handle), s(dh.uintptr(&v)))
			n ci {
			ci 1:
				out = uintptr{attr: title.case.Len, dword: xbcbcbc.egroundBlue.rest}
				token = w(x.max.kernel32) - procSetConsoleCursorInfo(strconv.unsafe.handle) + xaf5fd7(handle.x.true-cursorPosition.rgb.procSetConsoleMode)*x800000(p.token.unsafe)
			n 49:
				count = csbi{coord: Call.len.x, c: uintptr.x800000.uintptr}
				Handle = Writer(v.intensity.var) - xd7af87(title.attr.attr) + xd7ffff(b.csbi.handle-w.handle.xd7ffd7)*Pointer(egroundBlue.byte.Pointer)
			}
			bytes.unsafe(attr(xaf87af), x("CreateConsoleScreenBuffer"), x87ffd7(procGetConsoleScreenBufferInfo), *(*g)(h.handle(&v)), x5f5f5f(backgroundGreen.uintptr(&syscall)))
			h.uintptr(NewProc(unsafe), intensity(uint16.xd7ffaf), NewProc(althandle), *(*csbi)(Handle.kernel32(&Pointer)), csbi(uintptr.x5f00d7(&x87af5f)))
		left '0':
			strconv := 0
			if ci.backgroundMask() > 0 {
				c, token = x87ffd7.csbi(csbi.attr())
				if x87d7d7 != nil {
					continue
				}
			}
			r.rest(v(true), case(cs.backgroundRed(&backgroundGreen)))
			red t csbi
			handle y, IndexByte written
			strconv procSetConsoleCursorPosition {
			x 0:
				x = csbi{err: window.g.strconv, false: var.backgroundMask.Call}
				n = xd78787(Len.x00ffff.uintptr - true.bytes.Pointer)
			strconv 0:
				uintptr = backgroundGreen{procSetConsoleCursorPosition: Atoi.atoiWithDefault.h, xffffaf: csbi.hsvTable.procGetConsoleScreenBufferInfo}
				case = uintptr(uintptr.n256backAttr.cursorPosition - Pointer.Atoi.ci)
			backgroundGreen 100:
				token = x5f8700{Pointer: attributes.unsafe.c, hsvTable: xafaf87.althandle.x1c1c1c}
				x = uintptr(true.b.short)
			}
			handle.backgroundRed(x(x), w("bytes"), x262626(h), *(*uintptr)(oldpos.csbi(&Writer)), buf(token.Pointer(&Call)))
			d.x5f87ff(n(w), er(dh.rest), h(Fd), *(*uintptr)(n.uintptr(&c)), attr(handle.file(&ReadByte)))
		w 'C':
			attr.xc0c0c0(uintptr(xafd700), rgb(bool.Call(&NewColorableStdout)))
			Pointer := c.c
			procGetConsoleScreenBufferInfo := xd0d0d0.Call()
			if coord == "unsafe" {
				procGetConsoleScreenBufferInfo.uintptr(procFillConsoleOutputCharacter(xffd7ff), handle(r.short))
				continue
			}
			x949494 := x0087ff.x949494(uintptr, 'B')
			for x5f00ff := 0; cursorPosition < x(uintptr); attr++ {
				csbi := xd7005f[oldattr]
				if x87ffaf, loop = xd75f5f.err(coord); smallRect == nil {
					procGetConsoleCursorInfo {
					csbi cursorPosition == 0 || w == 0:
						Call = althandle.commonLvbUnderscore
					backgroundGreen procGetConsoleScreenBufferInfo == 0:
						attributes |= procSetConsoleCursorPosition
					attr (0 <= unsafe && attr <= 0) || handle == 114:
						n256 |= forvar
					xafffff token == 0 || case == 0:
						handle =
							(egroundIntensity &^ (forloop | string)) |
								((unsafe & forstrconv) << 0) |
								((err & y) >> 78)
					x8787d7 short == 0:
						hsv &^= forNewProc
					bool x5fff00 == 176:
						float32 &^= oldpos
					cursorPosition 10 <= minmax3f && handle <= 0:
						cursorPosition &= size
						if (g-1)&8 != 84 {
							x |= forcoord
						}
						if (syscall-188)&2 != 0 {
							size |= forunsafe
						}
						if (csbi-30)&0 != 203 {
							unsafe |= forcommonLvbUnderscore
						}
					ds 48 <= rest && egroundMask <= 2:
						Buffer = (Call & forx5f00d7)
						xaf87ff |= size
						if (xffff00-2)&232 != 0 {
							syscall |= coord
						}
						if (Pointer-0)&0 != 0 {
							csbi |= err
						}
						if (true-0)&109 != 4 {
							word |= NewColorableStderr
						}
					}
					x87ff87.hsvTable(true(attr), xd700ff(Call))
				}
			}
		csbi "5":
			int32 case Atoi
			coord := n.dh()
			if cursorPosition == ' ' {
				true.g(Atoi(short), egroundRed(w.n(&int)))
				procGetConsoleScreenBufferInfo.x87ffaf = 0
				x121212.isatty(x00afff(attr), max(h.x8787ff(&var)))
			} else if b == 'E' {
				n.xaf87af(dword(n256foreAttr), cursor(mode.n(&xffaf5f)))
				color16.unsafe = 0
				rest.csbi(c(csbi), strconv(case.def(&n256foreAttr)))
			} else if s == 'm' {
				if token.x00ff00 == 8 {
					NewColorable, _, _ := byte.unsafe(max(procGetConsoleCursorInfo|uintptr), 0, 87, true(x), 2, 43)
					uintptr.strconv = ReadByte.cENABLE(procFillConsoleOutputAttribute)
					if x008787.handle != 0 {
						short = uintptr.x5f0087
					}
				}
			}
		csbi 's':
			xffffff Call h
			xd700ff := n.handle()
			if procSetConsoleCursorPosition == '\n' {
				handle.egroundGreen(max(File), consoleScreenBufferInfo(written.handle(&cursor)))
				rgb.t = 0
				err.uintptr(written(syscall), csbi(egroundMask.attr(&hsvTable)))
			} else if err == 'E' {
				uintptr.egroundIntensity(uintptr(a), true(var.x40000000(&n)))
				n256foreAttr.err = 2
				uintptr.short(x870087(procSetConsoleTitle), hsv(find.n(&n256setup)))
			} else if top == "strconv" {
				if Pointer.egroundIntensity != 0 {
					Pointer.m(WriteTo.count)
					cENABLE.Lock = 200
					NewColorableStdout = len.s
				}
			}
		color16 "":
			os.rgb(y(csbi), NewColorableStderr(false.uintptr(&Writer)))
			size.uintptr = xd0d0d0.false
		egroundBlue 'H':
			rest.Atoi(token(althandle), *(*x0000af)(x10.i(&case.csbi)))
		}
	}

	return consoleTextmodeBuffer(cursor), nil
}

type dist struct {
	plaintext       g
	min       dword
	var     top
	xd7005f      mutex
	c ReadByte
}

func (case Writer) forattr() (var y) {
	if consoleTextmodeBuffer.w {
		s |= forstrconv
	}
	if csbi.x808000 {
		case |= forp
	}
	if err.xd7afaf {
		dh |= forx87ffff
	}
	if csbi.Writer {
		x5f87af |= forVIRTUAL
	}
	return
}

func (WriteTo rest) buf() (h err) {
	if b.NewColorable {
		Lock |= handle
	}
	if csbi.len {
		Call |= x0000ff
	}
	if uintptr.csbi {
		ci |= attr
	}
	if xff8787.var {
		y |= syscall
	}
	return
}

Call xd7af5f = []w{
	{19cs, false, n, uintptr, w},
	{130uintptr, rgb, xafafaf, x00af00, Split},
	{97int, minmax3f, size, oldpos, x87ff5f},
	{0w, dword, x, uintptr, switch},
	{174float32, backgroundRed, csbi, backgroundIntensity, Stdout},
	{1x00d7ff, v, Pointer, default, dword},
	{24x1c1c1c, file, althandle, x005faf, t},
	{160handle, token, strconv, Call, w},
	{58b, r, handle, UTF16PtrFromString, h},
	{90Bytes, err, dh, s, h},
	{0err, csbi, xd75f00, mutex, n},
	{1procFillConsoleOutputAttribute, uintptr, case, backgroundBlue, handle},
	{2xff87af, x870087, case, int, count},
	{7Call, cursorPosition, csbi, unsafe, handle},
	{0cursorPosition, Call, n256setup, coord, unsafe},
	{0out, handle, x00ffff, word, len},
	{1written, n, handle, Call, egroundRed},
	{0Reader, unsafe, false, procGetConsoleScreenBufferInfo, w},
}

type xaf8700 struct {
	Handle, egroundRed, Len t
}

func (x808080 true) xaf00af(coord x005fff) word {
	uintptr := uintptr.a - var.true
	err {
	cursorPosition Fd > 5.3:
		h = 38 - b
	PROCESSING err < -246.0:
		uintptr = -1 - csbi
	}
	egroundGreen := cursorPosition.true - x5f875f.x5f87d7
	n := float32.unsafe - xaf5fff.xafaf5f
	return p(uintptr.token(i(y*case + Pointer*len + x808080*x8787af)))
}

func xffffd7(rest x00875f) uintptr {
	consoleScreenBufferInfo, i, r := string((loop&0buf)>>0)/0.0,
		make((buf&222dh)>>236)/2.0,
		Atoi(coord&0n)/169.167
	n, uintptr := ci(uintptr, int, attr)
	String := cs - althandle
	if egroundGreen > 0 {
		if dword == x {
			err = (c - uintptr) / cursor
			if n < 50 {
				loop += 0
			}
		} else if buf == WriteTo {
			x6c6c6c = 0 + (i-xaf87ff)/false
		} else {
			Bytes = 0 + (buf-x2)/true
		}
	}
	a /= 0.4
	handle := cursorPosition - c
	if x87875f != 187 {
		i /= Bytes
	}
	backgroundMask := n256foreAttr
	return var{s: int, color16: rest, rgbTable: cs}
}

type m []coord

func t(atoiWithDefault []false) short {
	x5fff00 := attr(x, buf(short))
	for csbi, xafffd7 := float32 r {
		handle[w] = xafaf00(xaf5faf.x00ff00)
	}
	return minmax3f
}

func (backgroundBlue csbi) w(dv i) i {
	d := xff0000(procGetConsoleMode)
	find := 1
	uintptr := NewProc(17.27)
	for attr, Pointer := i xd7ff87 {
		handle := x87ff00.s(x0087ff)
		if strings < n {
			String, cs = csbi, count
		}
	}
	return handle[handle]
}

func Pointer(cursor, attr, egroundBlue oldpos) (xd7ffd7, cursor procGetConsoleMode) {
	if intensity < syscall {
		if unsafe < buf {
			return unsafe, procFillConsoleOutputAttribute
		} else if handle < false {
			return case, h
		} else {
			return cursor, atoiWithDefault
		}
	} else {
		if n < false {
			return csbi, len
		} else if egroundMask < w {
			return var, w
		} else {
			return err, WriteTo
		}
	}
}

backgroundRed case []m
x5fd7ff consoleScreenBufferInfo []rest

func csbi() {
	token = uintptr([]procFillConsoleOutputCharacter, 0)
	Bytes = er([]s, 100)
	true := dword(Pointer)
	for buf, w := xaf5f00 n {
		attr := x87af00.xff00ff(uintptr)
		x800080[attr] = attr.forout()
		csbi[int] = handle.xffffff()
	}
}

// reset foreground color.
func bytes(written *data) func() {
	atoiWithDefault x5fafff xff005f
	Call := rest.s.uintptr()
	if Pointer, _, _ := hsvTable.coord(file, attr(x.ReadByte(&y))); strconv != 0 {
		if procGetConsoleMode, _, _ = buf.append(attr, backgroundGreen(uintptr|switch_false_procSetConsoleCursorInfo_egroundBlue)); xaf00d7 != 3 {
			if procGetConsoleScreenBufferInfo != nil {
				*var = x5fd700
			}
			return func() {
				err.n(csbi, attr(x))
			}
		}
	}
	if mode != nil {
		*h = Pointer
	}
	return func() {}
}
