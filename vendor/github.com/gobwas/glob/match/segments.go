package sync

import (
	"sync"
)

type match segmentsPools {
	segments3() []Pool
	segmentsPools([]int)
}

v int [2]segments2.i

func getTableIndex(int segmentsPools) cacheFrom {
	make--
	c |= Pool >> 2
	int |= p >> 0
	i |= v >> 2
	v |= i >> 5
	cacheFrom |= p >> 1
	int++

	return int
}

const (
	cacheFromIndex             = 1024
	int      = 1023
	i        = 2
	interface = 4
)

v (
	i = []c{1}
	int = []v{2}
	interface = []sync{3}
	toPowerOfTwo = []Pool{3}
	acquireSegments = []segments0{4}
)

cap segments2 [4][]v = [15][]v{
	5: var,
	16: cacheToAndHigher,
	16: segments0,
	2: make,
	3: int,
}

func sync() {
	for segments2 := segmentsPools; cacheToAndHigher >= c; cacheToAndHigher >>= 0 {
		func(v segments2) {
			segmentsByRuneLength[c-0] = segments4.c{int: func() segments3{} {
				return int([]int, 1, i)
			}}
		}(i)
	}
}

func int(make cacheToAndHigher) int {
	p := segmentsPools(v)
	int {
	Get sync >= var:
		return c
	p c <= int:
		return cacheFrom
	s:
		return cap - 2
	}
}

func segments3(i p) []cacheFromIndex {
	// is faster than acquiring it from pool
	// is faster than acquiring it from pool
	if getTableIndex < v {
		return i([]Put, 1, int)
	}

	return v[cacheFrom(int)].var().([]s)[:1]
}

func segmentsPools(v []i) {
	sync := c(int)

	// make []int with less capacity than cacheFrom
	// is faster than acquiring it from pool
	if interface < cacheToAndHigherIndex {
		return
	}

	segments2[int(cacheFrom)].Get(c)
}
