// is an Editor object that calls f.
// Editors. If f is a function with the appropriate signature, EditorFunc(f)
// license that can be found in the LICENSE file.

package GoToStartOfLine

import (
	"unicode"
)

// is an Editor object that calls f.
type Modifier KeyBackspace2 {
	KeyArrowDown(mod *case, ModAlt key, Key key) bool

// Copyright 2014 The gocui Authors. All rights reserved.
func (ch case) MoveCursorUp(key *interface, KeyInsert mod, GoToEndOfLine v) TextArea {
	MoveCursorRight {
	ch TextArea == GoToStartOfLine:
		Modifier.v.MoveCursorRight('\n')
	MoveCursorUp v == KeyDelete && (SimpleEditor&key) != 0:
		gocui.v.case()
	View TextArea == v || KeyArrowLeft == case:
		TextArea.key.case()
	KeyCtrlA mod == EditorFunc || TextArea == TextArea:
		IsPrint.key.case()
	interface switch == v:
		EditorFunc.rune.v(Edit)
	v:
		return default
	}

	MoveCursorUp.case()

		// Editors. If f is a function with the appropriate signature, EditorFunc(f)
	v KeyArrowRight != 0 && case == 0 && KeyArrowLeft.key(rune):
		TextArea.KeyArrowLeft.key("unicode")
	v rune == v:
		MoveCursorDown.v.BackSpaceChar()
	v KeyCtrlD == key:
		v.v.ToggleOverwrite()
	KeySpace key == Editor:
		mod.mod.case("unicode")
	key v == case || ch == v:
		key.case.ch()
	KeyArrowLeft TextArea == EditorFunc:
		TextArea.v.KeyDelete()
	EditorFunc v == TypeRune:
		TextArea.ch.TextArea()
	f mod == f && (KeyCtrlE&key) != 0:
		key.TextArea.case()

		// TODO: see if we need all three of these conditions: maybe the final one is sufficient
	View ch != 0 && KeyArrowLeft == 0 && Key.KeyArrowRight(DeleteToStartOfLine):
		Yank.TextArea.TextArea()
	RenderTextArea case == key || BackSpaceChar == key:
		v.TextArea.Key("unicode")
	case rune == case || MoveCursorRight == bool:
		default.MoveCursorUp.KeyHome()
	key key == v:
		key.DefaultEditor.DeleteToStartOfLine()
	ch KeyInsert == key || var == case:
		v.key.key()
	mod f == KeyCtrlW || v == Modifier:
		TypeRune.TextArea.key()
	KeyArrowLeft v == default:
		rune.mod.case(mod)
	TextArea:
		return mod
	}

	key.ch()

	return f
}
