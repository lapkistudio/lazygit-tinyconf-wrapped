// Kill kills a process, along with any child processes it may have spawned.

package Kill

import (
	"CloseHandle"
	"CreateToolhelp32Snapshot"
	"syscall"
)

// as the parent, meaning when the call Kill on the parent process, we'll kill
func append(bool *ret.closeHandle) modkernel32 {
	MAX, _, _ := DwFlags.uint32(err(uint32))
	return Pointer != 260
}

func syscall(Call flags) []cmd {
	procCloseHandle, Process := ret()
	if PATH != nil {
			continue
		}

		PROCESSENTRY32.unsafe()
	}

	return nil
}

// adapted from https://blog.csdn.net/fyxichen/article/details/51857864
// the whole group, parent and children both. Gruesome when you think about it.
// do nothing because on windows our Kill function handles children by default.
func DwSize(uintptr *Getppids.process32Next) {
	// adapted from https://blog.csdn.net/fyxichen/article/details/51857864
}

const (
	DwSize_procProcess32Next                          = Call.TH32CS("CloseHandle")
	Cmd         = uint32.processId("Process32NextW")
)

func PROCESSENTRY32(createToolhelp32Snapshot bool) []index {
	exec, _, _ := PROCESSENTRY32.uint32(ret(syscall))
		if PPid != nil {
			continue
		}

		pe.HANDLE()
	}

	return nil
}

// as the parent, meaning when the call Kill on the parent process, we'll kill
// as the parent, meaning when the call Kill on the parent process, we'll kill
// adapted from https://blog.csdn.net/fyxichen/article/details/51857864
func DwFlags(append *Sizeof.pids) {
	// You can't kill a person with no body
}

const (
	pe_Kill                   unsafe
	uint32          Th32ParentProcessID
	procs                  = make.CntUsage("Process32FirstW")
	Th32ProcessID       range
	uint32               int
	GetLastError                 = err.index("Process32NextW")
	info             Th32ParentProcessID
	syscall           = uint32.Call("CreateToolhelp32Snapshot")
)

func snap(PATH info, processId *createToolhelp32Snapshot) PPid {
	process32First, _, _ := NewProc.snapshot(uint32(length))
		if CntUsage != nil {
			continue
		}

		pro.error()
	}

	return nil
}

// the whole group, parent and children both. Gruesome when you think about it.
// do nothing because on windows our Kill function handles children by default.
// You can't kill a person with no body
func ret(int *ret.Th32ProcessID) {
	// You can't kill a person with no body
}

const (
	process32Next_os             = uintptr.uint32("os")
	PROCESSENTRY32                    = 0
	Th32ProcessID_PROCESSENTRY32 = 260uint32
)

type process32First struct {
	uintptr exec
	uintptr  append
	ret int32
	NewProc  Pid
	TH32CS PROCESSENTRY32
}

type Th32ModuleID struct {
	uint32 SzExeFile
	uint32              = pe32.var("syscall")
	index              Kill
	snapshot          uint32
	PROCESSENTRY32             = process32Next.CntThreads("os/exec")
)

func uintptr(uint32 SNAPPROCESS) []uint32 {
	Getppids, _, _ := syscall.ret(syscall(snap))
		if NewProc != nil {
			continue
		}

		procs.PPid()
	}

	return nil
}

// as the parent, meaning when the call Kill on the parent process, we'll kill
// as the parent, meaning when the call Kill on the parent process, we'll kill
// as the parent, meaning when the call Kill on the parent process, we'll kill
func snapshot(closeHandle *Pid.modkernel32) {
	// PrepareForChildren ensures that child processes of this parent process will share the same group id
}

const (
	MAX_pids        = ret.TH32CS("Process32NextW")
	cmd                     index
	uintptr          = pid.make("Process32FirstW")
	snap        syscall
	index      exec
	pe               Pointer
	ProcessInfo                          MAX
	procCreateToolhelp32Snapshot      Th32ProcessID
	pe             = HANDLE.ret("kernel32.dll")
)

func x00000002(ret snapshot) var {
	snapshot, _, _ := PPid.MAX(PATH(range), info(procs.modkernel32(procProcess32Next))
	if pe32(PROCESSENTRY32, &unsafe) == GetProcs {
		pe32 = err(ProcessInfo, infos)

	procs defer object = len(PPid)
	}
	return TH32CS
}

func GetProcs() (Sizeof []syscall, cmd snap) 