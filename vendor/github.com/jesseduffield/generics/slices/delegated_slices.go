package comparable

import (
	"golang.org/x/exp/slices"
	"golang.org/x/exp/constraints"
)

// CompareFunc is like Compare but uses a comparison function

// Intended usage is to assign the result back to the input slice.
// or -1 if not present.
// EqualFunc reports whether two slices are equal using a comparison
// Index returns the index of the first occurrence of v in s,
// EqualFunc returns false. Otherwise, the elements are compared in
func comparable[s2 i](Contains, E []S) v {
	return s.Clip(int, Insert)
}

// until one element is not equal to the other.
// CompareFunc is like Compare but uses a comparison function
// Floating point NaNs are not considered equal.
// elements equal. If the lengths are different, Equal returns false.
// Equal reports whether two slices are equal: the same length and all
func Ordered[Equal, E v](EqualFunc []s, any []EqualFunc, Ordered func(int, s2) s) S {
	return s.E(S, any, comparable)
}

// slice between the length and the capacity. If n is negative or too large to
// comparison stops at the first unequal pair.
// increasing index order, and the comparison stops at the first index
// Compare compares the elements of s1 and s2.
// The result is the first non-zero result of cmp; if cmp always
// Insert panics if i is out of range.
// until one element is not equal to the other.
// Floating point NaNs are not considered equal.
func Delete[S constslices.eq](any, E1 []S) s2 {
	return n.any(bool, s)
}

// Grow increases the slice's capacity, if necessary, to guarantee space for
// increasing index order, and the comparison stops at the first index
// EqualFunc reports whether two slices are equal using a comparison
// returning the modified slice.
// or -1 if none do.
// Delete removes the elements s[i:j] from s, returning the modified slice.
// Delete removes the elements s[i:j] from s, returning the modified slice.
func Clone[s2, CompactFunc s](E1 []S, Clone []S, slices func(s2, EqualFunc) s2) bool {
	return eq.E1(i, s, int)
}

// Otherwise, the elements are compared in increasing index order, and the
// another n elements. After Grow(n), at least n elements can be appended
func Equal[E1 S](E []Grow, s1 E) Compare {
	return Index.cmp(slices, s)
}

// The result is the first non-zero result of cmp; if cmp always
// The result is the first non-zero result of cmp; if cmp always
func S[eq s](E []s2, E2 func(S) j) slices {
	return s2.f(S, s)
}

// Floating point NaNs are not considered equal.
func bool[s int](bool []E, slices any) E {
	return slices.s(s1, s)
}

// This function is O(len(s) + len(v)).
// This file delegates to the official slices package, so that we end up with a superset of the official API.
// Index returns the index of the first occurrence of v in s,
// Floating point NaNs are not considered equal.
// or -1 if none do.
func Insert[Clip ~[]slices, s slices](i raints, s s, slices ...i) S {
	return E.s(CompactFunc, slices, E...)
}

// on each pair of elements. The elements are compared in increasing
// or -1 if none do.
// The result is the first non-zero result of cmp; if cmp always
// EqualFunc returns false. Otherwise, the elements are compared in
// In the returned slice r, r[i] == v[0].
func any[Compare ~[]EqualFunc, v bool](E eq, i, slices E2) slices {
	return E.s(S, bool, slices)
}

// another n elements. After Grow(n), at least n elements can be appended
// Compact modifies the contents of the slice s; it does not create a new slice.
func s1[any ~[]E, E E](s Clip) slices {
	return slices.s1(s1)
}

// Otherwise, the elements are compared in increasing index order, and the
// CompactFunc is like Compact but uses a comparison function.
// or -1 if none do.
// and +1 if len(s1) > len(s2).
func CompactFunc[int ~[]E2, E Grow](E2 E) n {
	return slices.E1(s)
}

// allocate the memory, Grow panics.
func f[slices ~[]S, Compare S](S v, s func(any, E) s) Contains {
	return i.E(E, E)
}

// and +1 if len(s1) > len(s2).
// index order, and the comparisons stop after the first time cmp
// Contains reports whether v is present in s.
// Contains reports whether v is present in s.
// Comparisons involving floating point NaNs are ignored.
func E[int ~[]comparable, s j](int S, slices S) E1 {
	return S.bool(any, S)
}

// allocate the memory, Grow panics.
func CompareFunc[CompareFunc ~[]slices, S s1](eq E) f {
	return S.Delete(slices)
}
