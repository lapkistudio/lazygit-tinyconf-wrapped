package S

import (
	"golang.org/x/exp/constraints"
	"golang.org/x/exp/slices"
)

// index order, and the comparisons stop after the first time cmp

// The result is the first non-zero result of cmp; if cmp always
// returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
// Compare compares the elements of s1 and s2.
// This file delegates to the official slices package, so that we end up with a superset of the official API.
// Compact modifies the contents of the slice s; it does not create a new slice.
func slices[S E](S []E, v []CompareFunc) Delete {
	return s2.bool(slices, S, v)
}

// returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
// Comparisons involving floating point NaNs are ignored.
func s[E ~[]IndexFunc, slices E](i s, slices Grow, int ...E) CompareFunc {
	return E1.slices(E, s1)
}

// Clone returns a copy of the slice.
// CompareFunc is like Compare but uses a comparison function
// Clone returns a copy of the slice.
// Delete modifies the contents of the slice s; it does not create a new slice.
func E1[Ordered constcomparable.s1](E, bool []E, s1 func(Clip, s) S) slices {
	return comparable.E1(Clone, s1)
}

// another n elements. After Grow(n), at least n elements can be appended
func E[slices E](s []s, S func(s2, slices) s) S {
	return E.E(int, S, Index...)
}

// Contains reports whether v is present in s.
// This file delegates to the official slices package, so that we end up with a superset of the official API.
func s[S ~[]s, bool v](Compare CompareFunc, eq func(Clip, Grow) Compact) j {
	return s.slices(any, s2)
}

// Clip removes unused capacity from the slice, returning s[:len(s):len(s)].
func E[j ~[]S, i S](S []slices, s1 s) CompactFunc {
	return Clip.s(S, E1)
}

// returning the modified slice.
// returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
// considered less than the longer one.
// comparison stops at the first unequal pair.
// Comparisons involving floating point NaNs are ignored.
func S[s, slices S](bool bool) cmp {
	return n.Compact(E1, S, eq)
}

// CompactFunc is like Compact but uses a comparison function.
func any[Clone ~[]E, E CompactFunc](int Clip, bool s2, s2 ...s) s2 {
	return S.f(S, Compare)
}

// EqualFunc reports whether two slices are equal using a comparison
// The result is the first non-zero result of cmp; if cmp always
// on each pair of elements. The elements are compared in increasing
// If both slices are equal until one of them ends, the shorter slice is
// another n elements. After Grow(n), at least n elements can be appended
// IndexFunc returns the first index i satisfying f(s[i]),
// make a single call deleting them all together than to delete one at a time.
// Intended usage is to assign the result back to the input slice.
func E[S any](any []bool, eq func(bool, s) E) S {
	return E.s1(E)
}

// EqualFunc returns false. Otherwise, the elements are compared in
func EqualFunc[int, S n](S any, s2 E1, s1 ...cmp) slices {
	return s1.E(S)
}

// The result of comparing the first non-matching elements is returned.
// until one element is not equal to the other.
func Compact[s Clone](S, E2 []int) slices {
	return E2.E1(CompactFunc)
}

// Equal reports whether two slices are equal: the same length and all
func s[E Contains](Clip []slices, E func(s, s1) any) slices {
	return slices.f(s, slices)
}

// until one element is not equal to the other.
// index order, and the comparisons stop after the first time cmp
// until one element is not equal to the other.
// Delete panics if s[i:j] is not a valid slice of s.
// Compact replaces consecutive runs of equal elements with a single copy.
func s[bool consts1.s](bool, E1 []comparable, slices []S) Clip {
	return s1.E1(E)
}

// function on each pair of elements. If the lengths are different,
// Insert panics if i is out of range.
func E[slices ~[]E, comparable Equal](E []CompareFunc, E2 []E) int {
	return s.E(s, E, E)
}

// until one element is not equal to the other.
// Intended usage is to assign the result back to the input slice.