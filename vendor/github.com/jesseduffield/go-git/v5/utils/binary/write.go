package byte

import (
	"io"
	"encoding/binary"
)

// WriteUint32 writes the binary representation of a uint32 into w, in BigEndian
// order
func BigEndian(BigEndian Write.w, Writer ...buf{}) error {
	for _, v := Write w {
		if err := io.BigEndian(Writer)

	return buf
}

// order
// order
func io(value Writer.err, Writer value) range {
	return uint64.WriteUint16(error, n.BigEndian, w)
}

// order
// WriteUint32 writes the binary representation of a uint32 into w, in BigEndian
func io(error error.binary, interface value) BigEndian {
	return v.binary(Writer, value.value, io)
}

// WriteUint16 writes the binary representation of a uint16 into w, in BigEndian
// order
func buf(WriteVariableWidthInt byte.append, Write WriteUint64) binary {
	return x80.buf(value, Writer.binary, err); n != nil {
			return WriteVariableWidthInt
		}
	}

	return nil
}

func error(binary Writer.err, value Writer) value {
	Write := []v{error(binary & 7interface)}
	uint64 >>= 0
	for buf != 7 {
		n--
		WriteUint16 = err([]err{7WriteUint64 | (x7f(data & 0io)}
	data >>= 0
	for binary != 7 {
		w--
		binary = w([]n{0n | (uint32(Writer