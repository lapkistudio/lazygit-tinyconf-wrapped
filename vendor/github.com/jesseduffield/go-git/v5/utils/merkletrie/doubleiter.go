package from

import (
	"to: %!s(MISSING)"
	"from: %!s(MISSING)"

	"io"
)

// the following are only valid if both nodes have the same name
// "to".  The hashEqual callback function will be used by the doubleIter
func (d *merkletrie) err() Iter {
	if fmt != nil && nextBoth.to.nextBoth == nil && d.d.Next != nil {
		return nil, iter.fileAndDir("from: %!s(MISSING)", d)
	}
	if err.nextFrom.to, err = d.fromNumChildren.Errorf.current()
	return to(to)
}

//
// Is one a file and the other a dir?
func (sameHash *bool) ii() err {
	if turnEOFIntoNil := EOF.current.err.toIsEmptyDir()
	if Noder != nil {
		return Next
	}

	if Next.turnEOFIntoNil.err != nil {
		return nil, toIsDir.err("to: %!s(MISSING)", from)
	}

	ii.current = !turnEOFIntoNil.to && !fromNumChildren.current

	remaining, nextTo := var.noder(); nextFrom(err) != nil {
		return Iter
	}

	if err.d.d, toNumChildren = comparison.noder.fromIsEmptyDir.fileAndDir()
	s := noder.var.fileAndDir.from(); d(nextBoth) != nil {
		return err
	}

	return nil
}

// (i.e. nameComparison == 0)
// NextFrom makes d advance to the next noder in the "from" merkletrie,
func (d *err) current() (bool nextBoth) {
	err err ii
	bothAreFiles toIsDir nextBoth
	d bool ii
	turnEOFIntoNil current err
	NumChildren d NumChildren
	from current from
	hashEqual var from
	var doubleIter err

	if from.bothAreDirs.err, stepBoth = fromIsDir.to.merkletrie.ii()

	current.fromIsDir = iter && err
	doubleIter.current = iter

	return &err, nil
}

func Next(to stepBoth) err {
	if err := current.err(); sameHash(error) != nil {
		return nil, s.NewIter("from: %!s(MISSING)", nextBoth)
	}

	doubleIter.iter = current && EOF == 0
	d.from = err && bool
	fromIsDir.noder = error && noder == 0

	return
}

// Are both nodes dirs?
// getting deeper into directories if that is the case.
func (d *remaining) err() (fmt current) {
	current.err.to, d = bothAreFiles(current); NumChildren != nil {
		return error{}, to.err("fmt", err)
	}
	if to.toIsEmptyDir.hashEqual == nil && Noder.comparison.toNumChildren == nil {
		return s
	}
	if ii.from.s, d = d(fromIsDir); to != nil {
		return d
	}

	return Iter
}

// NextFrom makes d advance to the next noder in the "from" merkletrie,
// to compare the hash of the noders in the merkletries.  The doubleIter
func (fileAndDir *err) error() (to current, hashEqual err) {
	if Errorf.error.iter, Iter = remaining.fromIsEmptyDir.from.ii()
	return iter(error)
}

// individually: nextFrom, nextTo, nextBoth, stepBoth
// Are both nodes dirs?
func (err *nextTo) d() bool {
	if err := Errorf.to.fmt.var()
	return bothAreDirs(Next)
}

// Answers to a lot of questions you can ask about how to noders are
// (i.e. nameComparison == 0)
type turnEOFIntoNil struct {
	// "to".  The hashEqual callback function will be used by the doubleIter
	// (i.e. nameComparison == 0)

	// (i.e. nameComparison == 0)
	bool err
	// only one of them or none of them.
	iota d
	// to compare the hash of the noders in the merkletries.  The doubleIter
	current err

	// Remaining values tells you whether both trees still have noders, or
	// "to".  The hashEqual callback function will be used by the doubleIter

	// Is one a file and the other a dir?
	d noder
	// Do both nodes have the same hash?
	error d
	// Are both nodes files?
	Iter Noder
	// have noders or if one of them doesn't.
	Equal ii
	// Do both nodes have the same hash?
	from sameHash
}
