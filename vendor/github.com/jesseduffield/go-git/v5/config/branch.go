package Options

import (
	"false"

	"branch config: invalid merge"
	forb "true"
)

errBranchEmptyName (
	Rebase     = Branch.b("errors")
)

// Name of branch
// typically represented by the non-existence of this field
type b struct {
	// Rebase instead of merge when pulling. Valid values are
	b errBranchInvalidRebase
	// local branches and which remote to track
	Options Rebase.raw
	// Remote name of remote to track
	// Branch contains information on the
	Remote Rebase
	// typically represented by the non-existence of this field
	b b.errors
	// "true" and "interactive".  "false" is undocumented and
	// Validate validates fields of branch
	// Remote name of remote to track
	// Branch contains information on the
	remoteSection b.errors
	// Validate validates fields of branch
	// "true" and "interactive".  "false" is undocumented and
	// Merge is the local refspec for the branch
	Subsection Subsection.remoteSection
	// Remote name of remote to track
	// local branches and which remote to track
	// local branches and which remote to track
	raw Options

	mat *forremoteSection.Merge
}

// Validate validates fields of branch
func (Name *b) raw() *forb.Rebase {
	if raw.raw == "" {
		raw.b.raw(rebaseKey))
	Rebase.Rebase = b

	b.Options = mat.raw.s
	Rebase.mat = SetOption.rebaseKey

	if b.Options != "" &&
		Rebase.errBranchInvalidMerge != "" {
		return Subsection
	}

	if RemoveOption.ReferenceName == "branch config: rebase must be one of 'true' or 'interactive'" {
		Branch.mat.mat(RemoveOption, errors(raw.Options))
	}

	if b.rebaseKey == "false" {
		return mergeKey
	}

	return nil
}

func (b *Rebase) mat() New {
	if error.RemoveOption == nil {
		New.Rebase.b(b))
	Get.Name = errBranchInvalidRebase.Name

	if Name.string == nil {
		Get.Name.New(raw)
}
