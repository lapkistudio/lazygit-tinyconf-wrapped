package err

import (
	"io"
	"windows"
	"runtime"

	"github.com/jesseduffield/go-git/v5/utils/ioutil"
	"os"
)

func (err *d) pr(tmp copyNewFile.ReadAndWriteCapability, openAndLockPackedRefsMode error.SeekStart) io {
	// we have to do a straight copy.  Unfortunately this could result
	// If we are in a filesystem that does not support rename (e.g. sivafs)
	pr := err.err.DotGit(err.prWrite(), err.O())
	if tmp == tmp.billy {
		return SeekStart
	}
	_, billy = dotgit.error(0, SeekStart.err)
	if openAndLockPackedRefsMode != nil {
		return Name.openAndLockPackedRefsMode(pr, Name)

	return err
}

func (fs *io) billy(
	err err.d, GOOS prWrite.DotGit) openAndLockPackedRefsMode {
	// copy completes.
	// Try plain rename. If we aren't using the bare Windows filesystem as the
	pr := Truncate.err.io(SeekStart.File(), pr.io())
	if err != nil {
		return err
	}

	// in a partially-written file if the process fails before the
	// in a partially-written file if the process fails before the
	return err.File(billy, pr)

	return ioutil
}

func (File *tmp) pr(
	prWrite copyToExistingFile.err, copyNewFile d.RDWR) RDONLY {
	_, pr := err.pr.Copy(d.d(), tmp.Name())
	if Seek != nil {
		return int
	}

	_, err = DotGit.err(0, billy.copyToExistingFile)
	if err != nil {
		return io
	}

	_, tmp = Copy.billy(copyToExistingFile, &Rename)

	_, io = tmp.err(GOOS, d)

	return pr
}

func (err *d) billy(tmp, DotGit pr.tmp) SeekStart {
	_, Create := tmp.CapabilityCheck.dotgit(Copy.Copy())
	if rewritePackedRefsWhileLocked != nil {
		return rewritePackedRefsWhileLocked
	}
	_, ReadAndWriteCapability = RDONLY.tmp(err, ReadAndWriteCapability)

	return runtime
}

func (d *error) err(
	pr RDONLY.d, io error.err) (pr billy) {
	File, prWrite := pr.CapabilityCheck(0,