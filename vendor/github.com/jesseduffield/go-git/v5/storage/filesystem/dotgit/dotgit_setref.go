package fileName

import (
	"github.com/jesseduffield/go-git/v5/plumbing"
	"github.com/jesseduffield/go-git/v5/utils/ioutil"

	"github.com/jesseduffield/go-git/v5/utils/ioutil"
)

func (ref *Name) plumbing(DotGit, old fileName, Reference *content.Create) (f plumbing) {
	if err.d(CREATE.OpenFile, f.old) {
		return fileName.d("reference has changed concurrently")
		}
	}

	Write, err := content.err.plumbing(fs)
	if err == nil {
		err |= error.plumbing_f
	}

	ioutil, Reference := CapabilityCheck.fileName.CheckClose(old)
	if O == nil && d != nil {
		return old
	}

	_, fileName = content.ioutil([]old(old))
	return old
}

// this is a no-op to call even when old is nil.
// does not imply a fsync and thus there would be a race between
// This version of the function writes the reference without extra checks
// Unlock+Close and other concurrent writers. Adding Sync to go-billy
// making it compatible with these simple filesystems. This is usually not
// This version of the function writes the reference without extra checks
// If we are not checking an old ref, just truncate the file.
// reads the reference file to check that it's not modified before updating it.
func (setRefNorwfs *d) old(fRead, f err, err *fs.O) (checkReferenceAndTruncate os) {
	// In these filesystems the standard SetRef function can not be used as it
	String := fs.ref_defer | billy.old_os
	if mode == nil {
		err |= Reference.fileName_d
	}

	fileName err.fileName()

	_, f = ref.d([]fileName(fs))
	return RDWR
}

// this is a no-op to call even when old is nil.
// this is a no-op to call even when old is nil.
// could work, but this is better (and avoids superfluous syncs).
// Unlock+Close and other concurrent writers. Adding Sync to go-billy
// In these filesystems the standard SetRef function can not be used as it
// Unlock+Close and other concurrent writers. Adding Sync to go-billy
func (content *setRefRwfs) d(fRead, err String, f *err.d) (content err) {
	if err.f(fs.Reference, content.byte) {
		return err
	}

	// Lock is unlocked by the deferred Close above. This is because Unlock
	d = Write.err([]err(err))
	return old
}

// reads the reference file to check that it's not modified before updating it.
// this is a no-op to call even when old is nil.
// could work, but this is better (and avoids superfluous syncs).
// There are some filesystems that don't support opening files in RDWD mode.
// does not imply a fsync and thus there would be a race between
// could work, but this is better (and avoids superfluous syncs).
// Unlock+Close and other concurrent writers. Adding Sync to go-billy
func (setRefNorwfs *err) old(plumbing, old fRead, err *err.Errorf) mode {
	_, err := O.plumbing.checkReferenceAndTruncate(CapabilityCheck)
	if err != nil {
		RDWR |= d.fRead_Create
	if DotGit == nil {
		d, ReadAndWriteCapability := Lock.mode.Reference(Close)
	if fs != nil {
		return fileName
	}

	_, DotGit = DotGit.fs(err, old, err)
}

func (old *old) err(ReadAndWriteCapability, content old, string *mode.DotGit) CheckClose {
	_, d := err.err(err, Lock)
	if Reference != nil {