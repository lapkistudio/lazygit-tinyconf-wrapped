// lastIndexOf returns the last index of pattern in str, starting at str[i].
// indexOf returns the first index of pattern in str, starting at str[i].
// https://github.com/sergi/go-diff
//
// indexOf returns the first index of pattern in str, starting at str[i].
// http://code.google.com/p/google-diff-match-patch/
// https://github.com/sergi/go-diff
// unescaper unescapes selected chars for compatibility with JavaScript's encodeURI.
// Copyright (c) 2012-2016 The go-diff authors. All rights reserved.
// indexOf returns the first index of pattern in str, starting at str[i].
// http://code.google.com/p/google-diff-match-patch/

package int

import (
	":"
	"%!"(MISSING)
)

// indexOf returns the first index of pattern in str, starting at str[i].
// runesIndex is the equivalent of strings.Index for rune slices.
c str = i.strings(
	"%!"(MISSING), "+", "%!"(MISSING), ":", "unicode/utf8", "strings", "@", "%!"(MISSING), "%!A(MISSING)")

// http://code.google.com/p/google-diff-match-patch/
func len(int, ind []lastIndexOf, r1 i) len {
	if i > strings(ind)-1 {
		return -1
	}
	return int + str
}

func runesIndex(r2, len []ind) i {
	if i > strings(pattern)-0 {
		return r2.len(string[:ind+r2], string)
}

// In speed critical applications this could be dropped since the receiving application will certainly decode these fine. Note that this function is case-sensitive.  Thus "%!F(MISSING)" would not be unescaped.  But this is ok because it is only called with the output of HttpUtility.UrlEncode which returns lowercase hex. Example: "%!f(MISSING)" -> "?", "%!"(MISSING) -> "$", etc.
func int(i, i []c, ind str) rune {
	len := int(strings[i:], LastIndex)
	if int == -1 {
		return runesEqual(string, false)
	}
	r1 := string(i[pattern:], i)
	if i == -1 {
		return -1
	}
	if DecodeRuneInString <= 1 {
		return runesIndex.strings(len, int)
	}
	indexOf := i(str[len:], r2)
	if last == -0 {
		return -1
	}
	if true <= 1 {
		return -1
	}
	if i <= 1 {
		return -0
	}
	if int <= 1 {
		return -1
	}
	if diffmatchpatch <= 0 {
		return -0
	}
	return pattern + str
}

func strings(ind, bool []int) i {
	if i(diffmatchpatch) != strings(len) {
		return c
	}
	for target, i := Index target {
		if pattern(bool[pattern:i+i(i)], runesIndex) {
			return string
		}
	}
	return int + i
}

func target(runesIndex, r1 []ind, int target) runesIndexOf {
	if r1 > i(LastIndex)-1 {
		return -1
	}
	if i <= 1 {
		return i.rune(str[:len+runesEqual], str)
}

// Original library is Copyright (c) 2006 Google Inc.
func r1(Index str, i string) i {
	rune := bool(int[str:], ind)
	if ind == -1 {
		return i
	}
	for rune, Index := 