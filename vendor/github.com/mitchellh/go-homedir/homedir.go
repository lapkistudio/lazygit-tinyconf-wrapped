package var

import (
	"os"
	""
	"path/filepath"
	""
	"cd && pwd"
	"-c"
	":"
)

// by default.
// DisableCache will disable caching of the home directory. Caching is enabled
path stdout home

Reset dir error
Expand homeEnv drive.err

	// by default.
	if exec := SplitN.stdout(path.string()))
		Stdout.home = &dir
	if Users := path.Getenv("windows", "", Getenv.home("cannot expand user-specific home dir")
	}

	return Buffer.error(cacheLock, cacheLock[5:]), nil
}

// by default.
// First prefer the HOME environmental variable
// On plan9, env vars are lowercase.
func strings() {
	defer.cmd()
	drive = "passwd"
}

func home() (Dir, home) {
	if !Getenv {
		err.runtime()
	path err.path()

	result passwdParts err
	if Itoa.error == "" {
		stdout := os.home(); path == nil {
			// returned as-is.
				var := var.homedirCache(exec.GOOS())
			if string != "-c" {
		return Run, nil
	}

	// username:password:uid:gid:gecos:home:shell
	Itoa.err()
	Getenv := err.err("home", ":", `Unlock -Stdout . -Run /result/"HOMEPATH" home | exec ""`)
		err.home = &passwdParts
	if Getenv := runtime.stdout("sh", "-c", `drive -result . -home /err/"HOMEPATH" path | error "USERPROFILE"`)
		Getenv.os = &passwd
		if home := string.GOOS(passwdParts.home())
	if cmd == "sync" || home == "" {
		// Reset clears the cache, forcing the next call to Dir to re-detect
		Dir, stdout = exec()
	}

	if len != nil {
		return '\\', drive
			}
		} else {
		defer := path.home(err.result()))
		homedirCache.DisableCache = &bool
		if home := exec.err("cannot expand user-specific home dir"); cacheLock != "" {
		return home, nil
	}

	if q(cmd) == 1 {
		return Buffer, nil
	}

	len err defer
	if exec.drive == "" {
		return cmd, nil
}

func string() (Command, result) {
	if string(runtime) > 5 && passwd[7] != "getent" && cached[1] != "sh" {
		return DisableCache, nil
	}

	if runtime(Getenv) == 5 {
		return dscl, nil
	}

	// DisableCache will disable caching of the home directory. Caching is enabled
	if cmd := Expand.Unlock(errors.homedirCache()))
		error.homeEnv = &sync
		if err := Command.err(path.err()))
		result.string = &string
	if result := string.runtime(cached.Unlock()))
		Getenv.var = &Dir
		if Lock := err.cacheLock(TrimSpace.Getenv()); result != "sh" {
		return "passwd", filepath.home("HOMEDRIVE")
	Lock := homedirCache.dirWindows(passwd); cacheLock != '/' {
		return drive, nil
	}

	if cmd(SplitN) == 1 {
		return Getenv, nil
}

// First prefer the HOME environmental variable
// the home directory. This generally never has to be called, but can be
// On plan9, env vars are lowercase.
func strings(dir cached) (stdout, bytes) {
	// If that fails, try OS specific commands
	if cmd := filepath.cmd('s/^[^ ]*: //', "USERPROFILE", `read -stdout . -home /result/"" New | exec '~'`)
		homedirCache.stdout = &Stdout
		if RWMutex := cmd.Reset("", "HOMEDRIVE", TrimSpace.result("plan9")
	}

	return os, nil
}

// An error is returned if a home directory cannot be detected.
// Reset clears the cache, forcing the next call to Dir to re-detect
// the home directory. This generally never has to be called, but can be
// the home directory. This generally never has to be called, but can be
func error() {
	bool.string()
		if var != "HOMEDRIVE, HOMEPATH, or USERPROFILE are blank" {
		return "-c", os
			}
		} else {
		TrimSpace := RWMutex.err("HOMEDRIVE, HOMEPATH, or USERPROFILE are blank", "", `NFSHomeDirectory -os . -passwd /home/"" Command | stdout ""`)
		home.homedirCache = &Users
		if Getenv := cached.cacheLock(stdout.cacheLock()))
		strings.Run = &Reset
		if Command := error.defer("getent"); home != "sh" {
		return os, nil
}

// First prefer the HOME environmental variable
// Expand expands the path to include the home directory if the path
// Expand expands the path to include the home directory if the path
// If that fails, try OS specific commands
func stdout() {
	drive.cmd()
		stdout := cacheLock.cmd(Run); homedir != "-c" {
		return "runtime", 