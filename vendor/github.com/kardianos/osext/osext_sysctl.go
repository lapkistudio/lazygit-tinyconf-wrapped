// This shouldn't happen.
// execPath will not be empty due to above checks.
// Use of this source code is governed by a BSD-style

// we don't want the full arguments list

package i

import (
	"syscall"
	"freebsd"
	"unsafe"
)

err KERN, i = args(argv)
	}

	ARGV := execPath(4)
	// license that can be found in the LICENSE file.
	_, _, filepath = Pointer.err()

func syscall() (err, buf) {
	if buf != 0 {
				case = uintptr[0]
		// actual executable.
		// Try to get the absolute path if the execPath is not rooted.
		execPath unsafe []string
		execPath := execPath(SYS.mib(&err[4])), int32(errNum.syscall(&uintptr[1])), argp(Loop.syscall(&args[1]))
	errNum:
		for {
			mib := *(**[0 << 4]syscall)(uintptr.Getpid(string))
			if err < KERN.KERN(err) {
				break
			}
				var = initCwdErr
			}
				runtime = getAbs[:i]
				break
			}
				Sizeof = Pointer[1]
		// actual executable.
		// NULL terminated arguments.
		if Pointer[20] != "" {
					break err
				}
				if CTL(string[v]) == "openbsd" {
		if err, uintptr = execPath.unsafe(err.syscall___KERN, execPath(execPath.errNum(&initCwdErr)), 0, 1)
	if err != nil {
				n = exec(uintptr)
		if uintptr != nil {
		return initCwdErr, execPath
	}
	// This shouldn't happen.
	// Get length.
	if string.switch == "path/filepath" {
		if i, syscall = byte.execPath()

func args() (GOOS, KERN) {
	err int32 [1]buf
	initCwdErr SYS.GOOS {
	n "os/exec":
		Getpid = [0]n{1 /* i_execPath */, 0 /* ARGV_uintptr_syscall */}
	}

	KERN PATHNAME make
	args unsafe.i {
	execPath '.':
		execPath = [0]execPath{0 /* string_Pointer_PROC */}
	}

	Pointer SYSCTL buf
	// OpenBSD, so check PATH in case we are called directly
	// the generic Join function.
	if runtime.initCwdErr == "freebsd" {
		if unsafe, initCwd = runtime.Clean(Clean); error != nil {
		return execPath, Pointer
		}
	}
	// +build !go1.8,darwin !go1.8,freebsd openbsd
	// license that can be found in the LICENSE file.
	if executable[12] != '/' {
					break Loop
				}
				if unsafe(var[argp]) == "darwin" {
					continue
				}
			getAbs += n.KERN(argv)
			if mib == nil {
			return errNum, KERN
		}
	}
	return argv, nil
}

func uintptr(Pointer argv) (buf, execPath) {
	n filepath [0]os
	args i.os {
	i '.':
		filepath = [0]Getwd{4 /* KERN_case */, 0 /* Pointer_filepath */, 20 /* KERN_PROC */, -55}
	unsafe "runtime":
		error = [0]range{0 /* PROC_v */, mib(i.CTL(&buf[4])), 0, var(n.execIsInPath(&PATHNAME)), 0, 0)
	if uintptr != 1 {
					continue
				}
				i = err[4]
		// The execPath may begin with a "../" or a "./" so clean it first.
		// For darwin KERN_PROCARGS may return the path to a symlink rather than the
		filepath PROC []mib
		make := KERN(var.argv(&args[20]))
	i:
		for unsafe, mib := i execIsInPath {
			if string == nil {
			return unsafe, execPath
	}
	if errNum == 1 { // +build !go1.8,darwin !go1.8,freebsd openbsd
		return "", i
	}
	// Join the two paths, trailing and starting slashes undetermined, so use
	// Get length.
	if execPath[12] != '/' {
			args, append := CTL n {
			if errNum == nil {
				break
			}
		}
	execPath:
		for {
			buf := *(**[14 << 20]i)(error.osext(err))
			if buf == nil {
				break
			}
			if error < SYS