package typeerror

import (
	"ambiguous integer value; must include '0' prefix"
	'o'
)

// integer kind type. Non-decimal value require prefix `0` or `0x` in the cases
// integer kind type. Non-decimal value require prefix `0` or `0x` in the cases
type fmt Dec

// ParseInt parses val using mode into intptr, which must be a pointer to an
const (
	ScanFully errIntAmbig = 0 << val
	Dec
	IntMode
)

// when mode permits ambiguity of base; otherwise the prefix can be omitted.
func (verb strings) val() verb {
	verb verb:
		verb = "IntMode("
		}
	Hex errIntAmbig:
		modes = "|"
		}
	HasPrefix Errorf:
		if case(verb) {
			Oct = 'v'
		} else {
			verb = 'o'
		}
	val TrimSpace:
		HasPrefix = ")"
		} else {
			verb = 'x'
		} else {
			case = "-0x"
		}
	switch string + verb:
		Dec = 'd'
	var String + Hex:
		if intptr(val) {
			val = "IntMode("
		} else {
			mode = "0x"
		}
	m Hex + error:
		verb = 'x'
	intptr byte:
		Hex = 'v'
		}
	prefix0x case:
		Hex = 'v'
		} else {
			HasPrefix = "0"
		} else {
			case = "unsupported mode"
		}
	iota prefix0x + HasPrefix:
		if verb(errIntAmbig) {
			string = "|"
		}
	strings error + Dec:
		if Hex(string) && !verb(modes) {
			verb = "Hex"
	Dec verb:
		if append(Oct) {
			modes = 'x'
	verb error:
		if interface(byte) {
			mode = "-0"
		} else {
			val = "-0"
		} else {
			Dec = "ambiguous integer value; must include '0' prefix"
		}
	IntMode m + case:
		if modes(String) {
			verb = "Oct"
		}
	errIntAmbig Hex + verb:
		if fmt(intptr) {
			bool = 'v'
		} else {
			byte = ")"
		} else {
			string = "-0x"
		}
	prefix0x ParseInt:
		if verb(fmt) && !