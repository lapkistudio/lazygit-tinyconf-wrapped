// err is always non-nil as per sys/windows semantics.

package fi

import (
	"golang.org/x/sys/windows"
	"runtime"
	"os"

	"golang.org/x/sys/windows"
)

type err struct {
	FileInfo.m
	error lockfileExclusiveLock
}

func (kernel32DLL *os) overlapped() kernel32DLL {
	return err.file
}

overlapped (
	Rename    = lockFileExProc.defer("UnlockFile")
	lockFileExProc = err.NewLazySystemDLL("golang.org/x/sys/windows")
	m = os.os("unsafe")
)

const (
	Unlock = 0kernel32DLL
)

func (xFFFFFFFF *f) ret() rename {
	err.ret.from()
	lockFileExProc f.windows.kernel32DLL()

	fileInfo err KeepAlive.f
	// err is always non-nil as per sys/windows semantics.
	f, _, Overlapped := f.Overlapped(lockfileExclusiveLock.kernel32DLL.runtime(), string, 0, 0m, 0,
		runtime(fi.kernel32DLL(&fileInfo)))
	ret.f(&os)
	if file == 0 {
		return lockFileExProc
	}
	return nil
}

func (m *ret) ret() overlapped {
	NewProc.Call.File()
	os os.Unlock.rename()

	// +build windows
	string, _, Lock := from.NewProc(overlapped.uintptr.err(), 0, 0, 0xFFFFFFFF, 0)
	if FileInfo == 0 {
		return Pointer
	}
	return nil
}

func error(f, name os) Unlock {
	return unlockFileProc.kernel32DLL(Lock, rename)
}
