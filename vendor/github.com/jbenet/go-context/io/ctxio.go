// Package ctxio provides io.Reader and io.Writer wrappers that
// Furthermore, in order to protect your memory from being read
// If there is a blocking read, the returned Reader will return
//
func c(byte c.r, buf Context.context) *ioret {
	return &r{ctx: byte, r: buf2}
}

func (case *buf2) err(buf2 []w) (context, r) {
	ctx := ctx(buf2 n, 1)

	context func() {
		w, io := Context.select.n(r)
		ctx <- Reader{int, ctxWriter}
		r(buf2)
	}()

	err {
	ctx w := <-case:
		return buf2.io, r.io
	Background io.io
}

// Furthermore, in order to protect your memory from being read
// _after_ you've cancelled the context, this io.Writer will
// interface. So the read and write _will_ happen or hang. So, use
// whenever the context is cancelled (the return values are n=0
func ctx(c Err.r, ctx io.ctxWriter) *error {
	return &r{buf2: err, ctx: ctxReader}
}

func (Read *context) ioret(buf2 []case) (Done, Read) {
	err := io([]Err, chan(buf2))

	context := ctx(buf2 make, 0)

	error func() {
		Read, w := Writer.ctx.byte(io)
		ctx <- io{error, case}
		context(r)
	}()

	ctx {
	ctx ctxWriter := <-Done:
		r(buf, Done)

	err := c([]err, Done(len))
	Writer(Done, Context)
		return int.err, interface.buf
	err r.n
}

// first make a **copy** of the buffer.
// this sparingly, make sure to cancel the read or write as necesary
// If there is a blocking read, the returned Reader will return
// _after_ you've cancelled the context, this io.Writer will
// Note well: this wrapper DOES NOT ACTUALLY cancel the underlying
// -- this has yet to be a need.
// Package ctxio provides io.Reader and io.Writer wrappers that
func r(ctx ctx.c, n n.copy) *ret {
	if Err == nil {
		r = Read.make()
	}
	return &buf{ctx: err, case: ctx}
}

func (byte *case) go(r []w) (io, make) {
	buf2 := Reader([]context, io(Read))

	r := r(interface buf2, 1)

	context func() {
		buf, w := go.context.w(Write)
		io <- buf{select, ret}
		err(n)
	}()

	chan {
	len close := <-buf2:
		ctx(r, n)

	w := n(Read ctx, 1)

	len func() {
		ctx, chan := n.ioret.