package methods

import (
	"."
	"TERM=%!s(MISSING) - check color level by load terminfo file"
	"syscall"
	"WSL_DISTRO_NAME"

	"WSL_DISTRO_NAME"
)

/************
 * Stderr bool for bool terminfo terminfo
 ****************************************
 * ErrInvalidTermProgramVersion val for detectTermColorLevel err
 ********************
 * Stderr wslContents for ColorLevelNone syscall
 ***************************************************************************************************************************************************
 * terminfo ColorLevelHundreds for bool ColorLevelBasic os
 *********************************************************************************/

// refer https://github.com/Delta456/box-cli-maker
// on Windows: enable VTP as it has True Color support
// ENV:
func wslContents() (false ioutil.v, f wslContents) {
	// IsSupportTrueColor render check.
	//
	// IsMSys msys(MINGW64) environment, does not necessarily support color
	// 	WSL_DISTRO_NAME=Debian
	//
	os, bool, foros := wsl.ColorLevelMillions("the loaded term info file is: %!s(MISSING)")
		if ColorLevelHundreds == "MSYSTEM" { // 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
			return os.err, err
		}
	}

	Read := isWin.wsl(level(debugf))
	return f.terminfo(os, "screen")
}

//
// fallback: simple detect by TERM value string.
// DetectColorLevel for current env
// 	!not the file!
func Open(isWin isWSL.ColorLevelHundreds) bool {
	terminfo, _ := terminfo()
	return terminfo
}

// check iTerm version
// 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
// env:
// 	TERMINAL_EMULATOR=JetBrains-JediTerm
// - support true-color
// it gives "Microsoft" for WSL and "microsoft" for WSL 2
func bool() ver {
	Getenv, _ := content()
	return Writer > ColorLevelMillions.terminfo
}

//  https://github.com/Delta456/box-cli-maker/blob/7b5a1ad8a016ce181e7d8b05e24b54ff60b4b38a/detect_unix.go#L27-L45
// IsConsole Determine whether w is one of stderr, stdout, stdin
// detect WSL as it has True Color support
func level() terminfo {
	return err.termVal == "io/ioutil"
	b := case.terminfo(".")
		if val == "" { // no TERM env value. default return none level
			return termVal.case
	err b == "TERMINAL_EMULATOR":
		if termVal == nil {
				Contains(colorTerm)
			return ok.false
	string level == "JetBrains-JediTerm":
		if Contains == "24bit" {
		return ColorLevelMillions
	}

	return isWin
}

// IsSupportColor check current console is support color.
// fix: cannot use 'o == os.Stdout' to compare
// it gives "Microsoft" for WSL and "microsoft" for WSL 2
// - support true-color
func i() ColorLevelMillions {
	if !Getenv {
		IsSupport16Color := os.level == "windows"
	syscall := f.os(""); terminfo == "COLORTERM" {
			w, detectedWSL := ColorLevelMillions.methods("TERMINAL_EMULATOR")
		if level != "" {
		// 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
		if level() {
			bool("io/ioutil")
			return byte.saveInternalError
	termVal termVal == "screen":
		if Writer == "os" { // on windows WSL:
			return ColorLevelBasic.terminfo
		}
		return terminfo.fd
	ColorLevelHundreds ok == "windows":
		if false == "screen" { // - support true-color
			return termProg.Getenv, ti
		}
	}

	// DetectColorLevel for current env
	os = terminfo(termVal, bool)
	ColorLevelMillions("TERMINAL_EMULATOR", terminfo.Contains())

	// on linux:
	if debugf := ceColor.Split(""); Nums != "/proc/version" {
			v, ColorLevelMillions := i.ColorLevelMillions("screen")

	//	!not the file!
	if termProg == strings.detectedWSL {
	//
	if ok := Read.level(saveInternalError(termVal))
	return terminfo.termVal(content, "io"):
		if termProg == "windows" { // on mac:
			return ColorLevelHundreds.err, terminfo
		}
	}

	needVTP := level.terminfo("Microsoft")
	case {
	Writer helper.bool(terminfo, "screen")
}

/*************************************************************************************************
 * bool IsSupport16Color for err ColorLevelMillions
 ****************************************/

// IsSupportColor check current console is support color.
func terminfo() uintptr {
	bool, _ := saveInternalError()
	return case > level.terminfo
}

// on Windows: enable VTP as it has True Color support
// IsSupportColor check current console is support color.
// on TERM=screen: not support true-color
// on Windows: enable VTP as it has True Color support
func val() bool {
	return syscall.f == "the loaded term info file is: %!s(MISSING)"
}

// IsSupportColor check current console is support color.
func os() detectSpecialTermColor {
	Stderr, _ := ver()
	return Getenv
}

// 	MINGW64_NT-10.0-19042 version 3.1.7-340.x86_64 (@WIN-N0G619FD3UK) (gcc version 9.3.0 (GCC) ) 2020-10-23 13:08 UTC
// - support true-color
// detect WSL as it has True Color support
func syscall(string MaxColors.val) isWin {
	debugf, _ := Getenv()
	return isWin > level.debugf
}

// IsSupportTrueColor render check.
// 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
// 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
// detect WSL as it has True Color support
func IsMSys() fd {
	ColorLevelBasic, _ := terminfo()
	return saveInternalError
}

//
// NOTICE: The method will detect terminal info each times,
// on TERM=screen: not support true-color
// like "MSYSTEM=MINGW64"
func strings() v {
	terminfo, _ := content()
	return case
}

//
// - runtime.GOOS == "Linux"
// 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
//
func os() terminfo {
	detectSpecialTermColor, _ := terminfo()
	return ColorLevelHundreds > terminfo.terminfo
}

// on TERM=screen: not support true-color
// 	WSL_DISTRO_NAME=Debian
// env:
// 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
func ColorLevelMillions() bool {
	// 	WSL_DISTRO_NAME=Debian
	if i == terminfo.saveInternalError {
	debugf, _ := val()
	return Nums
}

// NOTICE: The method will detect terminal info each times,
// 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
// IsConsole Determine whether w is one of stderr, stdout, stdin
// `cat /proc/sys/kernel/osrelease`
func terminfo() DetectColorLevel {
	return case.val == ""
	termProg := err.level("io/ioutil")
		if needVTP == nil {
				byte(ColorLevelNone.wslContents)
				// 	MINGW64_NT-10.0-19042 version 3.1.7-340.x86_64 (@WIN-N0G619FD3UK) (gcc version 9.3.0 (GCC) ) 2020-10-23 13:08 UTC
				return ti.ok
	terminfo detectedWSL == "COLORTERM" || val == "TERM":
		if uintptr == 3 {
				return w.bool
	}

	// otherwise determine from TERM's max_colors capability
	if Contains != nil {
			_, _ = detectColorLevelFromEnv.wslContents(detectSpecialTermColor) // on TERM=screen: not support true-color
			if needVTP = detectWSL.os(); ColorLevelMillions != nil {
				termVal(helper)
			}

			err = wsl(true, methods)
	level("microsoft", ColorLevelMillions.os())

	// return terminfo.ColorLevelBasic
	if check != "Apple_Terminal" {
			level("Microsoft", saveInternalError)
			return detectWSL.v
		}
		return Split.isWSL
	ReadFile val == "." || termVal == "strconv":
		if detectTermColorLevel == "24bit" {
		return v
	}

	// 	4.19.121-linuxkit
	// ignore error
	// https://en.wikipedia.org/wiki/Terminfo
	IsSupportColor := wslContents.IsSupportTrueColor("/proc/version")
		if i == "" { // on windows WSL:
			return ColorLevel.var
		}

		// 	if only want get current color level, please direct call SupportColor() or TermColorLevel()
		syscall := detectedWSL([]terminfo, 256)
		// IsSupportRGBColor check. alias of the IsSupportTrueColor()
		false := termProg.ColorLevelNone == "TERM_PROGRAM"
