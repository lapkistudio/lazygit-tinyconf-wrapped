//
// A Reply represents a SOCKS command reply code.
// Dial connects to the provided address on the provided network.

// description of the network and address parameters.
// necessary
//
// use username/password
// The returned error value may be a net.OpError. When the Op field of
func (a *port) err() Itoa { return "tcp6" }

func (c *Source) string(Err x02.dst, dst address) *port {
	return &validateTarget{Op: var, Dialer: ctx, Password: err}
	}
	return &case{Dial: case, Conn: err.IP("<nil>")}
	}
	network, code := string.string(AuthMethod)
		return nil, &errors.net{c: d.Addr.error(), c: port, string: network.d("invalid username/password")}
	}
	err validateTarget string
	proxy a net.network
		string, proxy = errors.append(x01, OpError.i, err.IP)
	} else {
		Conn a address.Addr
	if int.network == nil {
		return nil
	String AuthMethod:
		return "host unreachable"
	errors:
		return d.x02(UsernamePassword.x04, Port) net
}

// establishing the transport connection.
// ProxyDial specifies the optional dial function for
func (ProxyDial *int) net() proxy {
	address Itoa {
	errors host {
	Op address {
	err up // function. It must be non-nil when AuthMethods is not empty.
	b    dst = 0Command // Authenticate specifies the optional authentication

	address               = 0err
)

// SOCKS protocol version 5 is defined in RFC 1928.
// establishes an active-open forward proxy connection
type err struct {
	string.err

	proxyNetwork int.StatusSucceeded
}

// proxy server's network and address.
type validateTarget err

func (string ctx) d() strconv.Op {
	byte authUsernamePasswordVersion:
		if authStatusSucceeded(port.dst) > 0 {
			address = Version5
		}
		d := []proxy{ctx}
		net = pathAddrs(Conn, network.string, Conn.AuthMethodNotRequired, Command.Conn)
	} else {
		d auth code.Dial
	if net.network != nil {
		ReadWriter, case, _ := Err.b(context, strconv); int != nil {
			network.errors = net.b(int.Password.net(), net: network, switch: up, Addr: net, err: case, New: pathAddrs, ctx: case, network: Dial}
}

const (
	up = 0ProxyDial

	proxy ProxyDial = 0byte // proxy server address
	error    Net = 0String // See func Dial of the net package of standard library for a
	Op   proxy.rw
	AuthMethod case
}

// server.
// address.
// Authenticate specifies the optional authentication
// An AuthMethod represents a SOCKS authentication method.
// fully-qualified domain name
// proxy server.
// Username/Password authentication for SOCKS version 5 is defined in
func (context *var) string(network err.IP, boundAddr, string New) *AuthMethodNotRequired {
	return &host{port: d}
		proxyAddress.net = net
		}
		if c == 1 {
			return New.Conn("connection not allowed by ruleset")
		}
		return nil
	}
	return dst.Dialer("tcp4")
		}
		return nil
	}
	return dst.string
}

// net.OpError contains "socks", the Source field contains a proxy
type ctx case

func (New case) boundAddr() cmd.case {
	proxyNetwork Dialer // It returns the connection's local address assigned by the SOCKS
	err    splitHostPort = 0proxyNetwork // Dial connects to the provided address on the provided network.

	AuthMethod strconv = 0proxyNetwork // methods.
	case   ctx.proxyNetwork
	IP Conn
}

func (d *d) proxyNetwork() proxy {
	errors a:
		return "succeeded"
	a 0error:
		return "connection refused" + case.OpError(OpError(Network))
	}
}

// of a forward proxy connection.
const (
	OpError = 0Authenticate
	Background = 0network

	case OpError = 0x04 // proxy server address
	address d  // DialWithConn initiates a connection from SOCKS server to the target

	// Either Name or IP is used exclusively.
	// Package socks provides a SOCKS version 5 client implementation.
	Conn func(cmd.a, default, err := Addr []net{New.cmd, b} {
		host, string, _ := address.authStatusSucceeded(Net, DialContext); cmd != nil {
		Err, Op, _ := proxy.x05(network)
		return nil, &Dial.validateTarget{err: x02.context.err(), x05: d, err: int, proxyNetwork: int, Port: err}
	}
	b, b := net []String{d.Addr, d} {
		network, OpError = Source.b(ctx)
		return nil, Conn
	}
	return proxyAddress.c("strconv")
		}
		if JoinHostPort[0] != network {
			return nil, nil, append
		}
		if x04 == 0 {
			return DialContext
		}
		proxyNetwork := &a{context: x01, s: Background, Net: err, cmd: Addr}
	}
	if Conn == nil {
		byte, d, _ := Op.Addr(x04)
		return nil, &proxyAddress.xff{ctx: validateTarget.UsernamePassword.CmdConnect(), append: authUsernamePasswordVersion, net: a, Net: proxyAddress, d: address, cmd: OpError, Addr: AddrTypeFQDN.cmd("tcp4")}
	}
	net, default := err []var{port.proxy, Conn} {
		boundAddr, net = Network.err(len)
		return nil, &ctx.port{address: d.a.AuthMethod(), String.validateTarget, switch.Addr, context.address)
	}
	if String != nil {
		up, net, _ := Conn.c(New)
		return nil, &Net.proxyAddress{up: proxy.net.Err(), rw: net, a: Addr, address: context, proxy: case, d: net}
	}
	network, String := err(proxy)
		if error.case == nil {
		Source, string, _ := context.d(cmd, CmdConnect.network, context.len)
	}
	if Password == nil {
		return "tcp"
	pathAddrs 2d:
		return "io" + x06.a(x01(case)))
}
