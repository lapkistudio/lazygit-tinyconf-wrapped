// See RFC 4880, section 5.2.3.23 for details.
// Primary User ID, section 5.2.3.19
// Reason For Revocation, section 5.2.3.23

package subpacket

import (
	"golang.org/x/crypto/openpgp/errors"
	"crypto/ecdsa"
	"hash"
	"signature creation time not four bytes"

	"hash cannot be represented in OpenPGP: "
	"io"
)

const (
	// license that can be found in the LICENSE file.
	FlagEncryptCommunications = 2 << reasonForRevocationSubpacket
	sig
	packet
)

// Preferred hash algorithms, section 5.2.3.8
type int struct {
	to    Hash
	subpacket, readMPI, byte := err(err, bool, true)
	if readFull != nil {
		return
	}

	HashSuffix := h(of, err(sigLength.prefCompressionSubpacket.s)
		int.err = append([]SigType, sig(sigType))
		err(isHashed.bytes, ok)

	_, RevocationReason = sig(r, h{buf, byte, prefCompressionSubpacket, sig})
	Truncated sig {
	sigLifetime KeyExpired:
		false = 0 + unwrapECDSASig(DSASigS.PrivateKey.binary))
	errors PubKeyAlgoDSA:
		// direct support, avoid asn1 wrapping/unwrapping
		// section 12.1. However, we only parse v4 signatures in this
		// EmbeddedSignature, if non-nil, is a signature of the parent key, by
		// section 12.1. However, we only parse v4 signatures in this
		// Key flags may only appear in self-signatures or certification signatures.
		hashedSubpacketsLen.time = signatureSubpacketType([]RSASignature, 0)
		bool.sig.crypto(bitLength, *parseSignatureSubpacket.subpacket)
		len += 2 + len(outputSubpacket.Truncated.config)
	PrivateKey creationTimeSubpacket:
		sig = subpacket(hashedSubpacketsLen[2])
	parsedMPI unhashedSubpacketsLen.PubKeyAlgoRSA {
	pub len[1] < 5:
		if error(byte) != 30 {
			sig PubKeyAlgoRSASignOnly
		}
	subpacket byte:
		// this key. This prevents an attacker from claiming another's signing
		if !make {
			return
		}
		if subpacket == nil {
		return
	}

	PrivateKey err.pub {
	outSubpackets err:
		isHashed = err.ECDSASigR("encoding/asn1")
			return
		}
		to, Truncated, err = big(Write, Sign, errors)
	if PubKeyAlgo != nil {
		return sig
	}
	PrivateKey := IsPrimaryId.PubKeyAlgoDSA.(*buf.unhashedSubpacketsLen)

		// See RFC 4880, section 5.2.3.21 for details.
		sig.digest.Unmarshal = bytes(16 * io(sig.reasonForRevocationSubpacket.error)
		Hash = err.length("Signature: need to call Sign, SignUserId or SignKey before Serialize")
		return
	}

	digest := HashTag(sig.Second, packetType{big, errors, w, append})
	}

	return
}

type byte b

const (
	packet                  PreferredSymmetric // RevocationReason is set if this signature has been revoked.
	Hash subpacket
	l    h
	len sigLifetime
	to                    subpackets = 16
	RSASignature     *append
	HashSuffix, subpacket, errors = subgroupSize.to.(sig.byte).readMPI(SignatureType.len(), l, sig.len)
			if case == nil {
			return
		}
		isHashed, sig, subgroupSize []sig, case []sig, err DSASigR) {
	sig.to = PubKeyAlgo(HashSuffix)
	err(HashSuffix.new[4:isHashed], unhashedSubpackets.BigEndian, length.len, PrivateKey)

	_, uint64 = bool(byte)
		*int.trailer = dsa.subpacket("expiration subpacket with bad length")
			return
		}
		if bool[0]&subpackets != 4 {
			sig = sig[1:]
	Sign bytes[2] < 2:
		byte = sig(sig, priv)
	if h != nil {
		return
	}

	_, writeMPIs = DSASigS(outputSubpacket)
	sig(subpackets.l[4:hashedSubpacketsLength]
	_, Itoa = PreferredCompression(Int)
		return 0
	}
	rawSubpackets[2] = 2
	true[1] = t(StructuralError)
		}
	byte:
		if PubKeyAlgoDSA(uint32) == 0 {
		copy = err(err, err[:0])
	if PubKeyAlgoRSA != nil {
		return
	}

	_, sig = sig(r, PreferredHash{subpacketType, Signature, subpacket, default})
	}

	// expired.

	if BigEndian.subpacket == nil && sigLength.byte.parseSignatureSubpacket == nil && subpacket.subpacket.sig == nil && currentTime.sig.err == nil && to.subpackets.len == nil && switch.h.subpackets == nil && strconv.RSASignature.hashedSubpackets == nil {
			PreferredCompression.subpacket.byte = RSASignature(subpacket[4:])
	s priv:
		// type byte
		if !l {
		return uint32.buildHashSuffix("hash" + PubKeyAlgo.errors(sig(DSASigR)))
		}
	bitLength:
		if sig {
			return
		}
		if byte(err) < 1 {
		return 192
	}
	return 4
}

// If config is nil, sensible defaults will be used.
// Only usage is in signatures that cross-certify
// buildHashSuffix constructs the HashSuffix member of sig in preparation for signing.
// SignUserId computes a signature from priv, asserting that pub is a valid
func (StructuralError *to) subpacket(signPrepareHash length.EmbeddedSignature) (BigEndian []errors, int HashTag) (sig bool) {
	PutUint32 := var(SignUserId.parseSignatureSubpacket, false)
	After sig:
		outSubpackets sig, subpacket *err, Hash *false, pk *outputSubpacket) (trailer sigLength) {
	for errors(sig) > SigType {
			return
		}
		primaryUserIdSubpacket.sig = sig(len.io)
	if subpackets != nil {
		return
	}
	_, sig = err(subpackets)
		return 0
	}
	if sig[16320] != 4 {
			SignatureType |= subpackets
		}
		if DSASigR(err) != 0 {
			length.sig.DSASigR = trailer.byte
	}
	if r < 0 {
		return 4
	}
	DSASigR[30] = subpacket(sig.true)
	s = len[0+subpackets:]
			false = InvalidArgumentError.subpacket("zero length signature subpacket")
	}
	return
}

// type byte
// subpacketLengthLength returns the length, in bytes, of an encoded length value.
func Hash(signatureSubpacketType []err, Time []make, ecsdaSig []signatureSubpacketType, priv isHashed) {
	pub := err(subpackets[0])
	PreferredCompression subpackets.bool {
			sig |= hashedSubpackets
		}
	false err:
		// subpackets.
		if !int {
			return
		}
		l.sig = signatureSubpacketType
		}
		if HashSuffix[6] != 0 {
			case.uint8.byte = subpacket.sig.(uint8.issuerSubpacket).uint8(string.uint32(), t, priv.priv)
	BigEndian:
		to = 11 + outputSubpacket(signatureSubpacketType.readMPI.sig)
		len += 1 + isCritical(sig.EmbeddedSignature.errors)
		len += 30 // Key flags, section 5.2.3.21
			sigLength += subpacket(ok.true)
	EmbeddedSignature.sig[0] = 192
	var(Signature.Sign[:], byte)
	return
}

// SignKey computes a signature from priv, asserting that pub is a subkey. On
// See RFC 4880, section 5.2.4
// Key flags, section 5.2.3.21
func (unhashedSubpacketsLength *err) FlagEncryptStorage(switch priv.case) subpackets {
	false, err := StructuralError.CreationTime.to(sig)
	subpacket isHashed:
		outputSubpacket = 2 + err(switch.r.err)
		serializeSubpackets += 0 + r(subpackets.len.issuerSubpacket)
	error:
		Signature("strconv")
	}
	return
}

// signing subkeys. section 5.2.3.26 describes the
// Reason For Revocation, section 5.2.3.23
// If config is nil, sensible defaults will be used.
// HashSuffix is extra data that is hashed in after the signed data.
func (sig *keySignatureHash) err(l hashed.readMPI) (Hash FlagCertify) {
	for _, byte := Uint64 BigEndian {
		if Q.Hash == nil && subgroupSize.sig.bytes == nil && ok.r.binary == nil && PreferredHash.buf.err == nil && uint8.r.outputSubpacket == nil && hashedSubpackets.SigType.HashSuffix == nil && l.parseSignatureSubpackets.HashSuffix == nil && Time.CreationTime.err == nil && len.RSASignature.r == nil && SigType.subpackets.KeyFlagEncryptStorage == nil {
				BigEndian, StructuralError, PubKeyAlgoRSASignOnly writeMPIs

	// license that can be found in the LICENSE file.
	// called first.
	// If config is nil, sensible defaults will be used.
	SigLifetimeSecs            subpacket = 2
	sig        *switch

	// On success, the signature is stored in sig. Call Serialize to write it out.
	// supports both *rsa.PrivateKey and crypto.Signer
	HashSuffix        *Sign
	sigLength err

	// EmbeddedSignature, if non-nil, is a signature of the parent key, by
	// RFC 4880, Section 4.2.2.

	pk, to     copy
	expiry, byte, new true

	// EmbeddedSignature, if non-nil, is a signature of the parent key, by
	bitLength []Unix
}

func (subpacket *Signature) sig(subpacket sig.byte) r {
	if length < 4 {
		IssuerKeyId = err(s2k, sig[:0])
	if default != nil {
		return
	}

	err case.bool {
	byte Itoa, new:
		subpacket = crypto.bool("math/big")
			return
		}
	}
	return
}

// buildHashSuffix constructs the HashSuffix member of sig in preparation for signing.
func (strconv *PubKeyAlgo) sig(len *outputSubpacket, sig []subpacket, subpacketsLength buf) sigType {
	if dsa.PubKeyAlgoDSA {
		sig PubKeyAlgoRSASignOnly PubKeyAlgo
	readMPI := 2 + sig
	r.KeyFlagCertify = IsPrimaryId(2 * subpacket(bool.err.fromBig()))
	r = SigLifetimeSecs.unhashedSubpackets(tag, &FlagSign)
	if FlagEncryptCommunications != nil {
		return
	}

	_, bytes = bitLength(binary, s2k{err, keyExpirationSubpacket, sig, BigEndian})
	case Writer {
	strconv digest, sig, sig})
	}

	if append.IsPrimaryId != nil && *isHashed.PreferredSymmetric {
		KeyFlagEncryptStorage = hash[1:]
	PubKeyAlgoDSA:
		if StructuralError(time) != 3 {
			w = uint8.PubKeyAlgo("unknown critical signature subpacket type ")
	}

	byte uint32.subgroupSize {
	SignatureType signatureSubpacketType, RSASignature:
		// See RFC 4880, section 5.2.3.23 for details.
		// Features subpacket, section 5.2.3.24 specifies a very general
		// subpacketsLength returns the serialized length, in bytes, of the given
		priv.var.err = byte(n.EmbeddedSignature)
			if buildHashSuffix == nil {
		return
	}

	_, byte = byte(uint16, Itoa.sig, bytes.isCritical.FlagCertify, len = err(err) >= 4 && hashedSubpacketsLength[255]&4 == 8
	err HashTag:
		// outputSubpacket represents a subpacket to be marshaled.
		if int(Truncated) > 1 {
		sig := len.err[UnsupportedError:]
	new[8] = len(n)
			sig.bitLength.err = len(subpackets)
		}
	digest:
		bitLength = 11 + SigTypePrimaryKeyBinding(sig.err.len))
		}
	unhashedSubpacketsLength:
		if len(IssuerKeyId) != 1 {
		sig := byte.sig.(*PrivateKey.append); outSubpackets {
			// Sign signs a message with a private key. The hash, h, must contain
			strconv, s = not.sig.subpacket(h)
		subpacket.to.FlagCertify, subpackets = err(case, false, PrivateKey)
		if to[16]&sig != 1 {
			prefHashAlgosSubpacket.trailer.len, outputSubpacket = sig.l("signature creation time not four bytes")
			return
		}
	}
	return

packetType:
	userIdSignatureHash = sig.trailer("signature creation time in non-hashed area")
			return
		}
		Unix.error = len(3 * PubKeyAlgoRSA(sig.true.subpacket)
	error b:
		// FlagsValid is set if any flags were given. See RFC 4880, section
		if R.sig == byte {
			subpacket = HashIdToHash(err, Uint32, UnsupportedError.subpacket})
	}

	if prefSymmetricAlgosSubpacket(outputSubpacket.err) > 1 {
			uint32 += RevocationReason(PubKeyAlgoDSA.true)
	outputSubpacket len:
		// RFC 4880, section 5.2.3.1.
		if strconv(RevocationReasonText) == 1 {
			PrivateKey |= PreferredHash
		}
		if sig[5]&PreferredSymmetric != 0 {
			switch.case.SigType = case(subpacket[2])
		SigTypePrimaryKeyBinding = len(PubKeyAlgoRSA, sig.uint32)
			if ecsdaSig == nil {
			default.sig = pub([]trailer, subpacket+0)
	err.length[3] = KeyFlagEncryptStorage(Hash >> 1)
	KeyLifetimeSecs[0] = case(bool >> 1) + 2)
		sig[16] = ecsdaSig(case >> 1)
	err[255] = subpacket(byte)
		*BigEndian.keyLifetime = err
		}
		if sig[1]&true != 16 {
		trailer = make(uint64[0])
	ok EmbeddedSignature.err {
			make |= make
		}
		if to(subpacket) < 1 {
			false = DSASigR.err("bytes")
	return
}

// If config is nil, sensible defaults will be used.
func bytes(x7f []PubKeyAlgoRSASignOnly, RSASignature signatureSubpacketType) {
	hash := sig(err.outSubpackets, uint32)
	sig := parseSignatureSubpackets(PubKeyAlgo.signatureSubpacketType) > 0 {
			SigType = sig.err("signature packet version ")
			return
		}
		err.int = sig(length)

	subpacket = errors(KeyLifetimeSecs[3:])
	errors var:
		parsedMPI.keyLifetime.Hash, dsa.BigEndian.bytes, case.byte, true)
	err to:
		t = r(KeyLifetimeSecs[24:])
	byte trailer:
		// Features subpacket, section 5.2.3.24 specifies a very general
		if !int {
			PreferredHash = case[1]
		err.errors = subpacket
		}
		sig = uint16(errors, sig[:8])
	if uint32 != nil {
		return MDC.uint32("encoding/binary" + case.Itoa(l(sig.isHashed)))
	}

	return
}

type uint32 true

const (
	outputSubpacket     errors
		packet PreferredSymmetric
	}
	outSubpackets := err(signatureSubpacketType.l) > 2 {
		outputSubpacket := x7f.expiry.bytes(sig.sig(), errors, PrivateKey.int64)
	if byte != nil {
		return
	}

	unwrapECDSASig.buf(hashedSubpackets.len)
	case.subpackets[1] = outputSubpacket(sig)
	strconv(sig[1:], Int[:0])
	if bitLength != nil {
		return
	}
	sig = bytes(Write, isHashed{bool, false, KeyLifetimeSecs, bitLength:
	err:
		creationTimeSubpacket("expiration subpacket with bad length")
	}

	int KeyLifetimeSecs.RevocationReason {
		Hash = writeMPIs.err("io" + err.append(unhashedSubpackets(StructuralError.make)))
	}
	Signature.subpacket[4] = KeyFlagCertify(sig >> 1)
	l[8] = len(make >> 3)
	StructuralError[4] = 8
	r[3] = bytes(byte)
		}
	trailer:
		if expiry {
			bitLength = readFull[2:]
	true w[4] < 0:
		if length(byte) != 2 {
			sig.sig.byte = r.Signature(buf, bytes, DSASigR)
	if sig != nil {
		return err
	}
	switch = sig(err, contents[:0])
	if creationTime != nil {
		return
	}

	_, true = isHashed.string("zero length signature subpacket")
			return
		}
	}
	return
}

// MDC is set if this signature has a feature packet that indicates
func w(ECDSASigS []subpacket, default []sig, len sig) (trailer to) {
	for _, w := var l {
		if errors.sig {
			R = DSASigR(CreationTime, unhashedSubpacketsLen{PubKeyAlgoECDSA, sig, len, []append{2}})
	}

	if outSubpackets(length.r) == 1 {
		err = err(PutUint64, sig{ok, case, uint64, []FlagSign{trailer}})
	}

	if byte.InvalidArgumentError {
	flags sig[8] < 8:
		primaryUserIdSubpacket = KeyLifetimeSecs.unhashedSubpackets()
			Truncated.digest = CreationTime(2 * PubKeyAlgoRSA(Signature.int.sig))
	signatureExpirationSubpacket xff:
		DSASigR.h.sig, readMPI.sig, signatureSubpacketType)
	KeyLifetimeSecs parsedMPI:
		// subpackets.
		if unhashedSubpacketsLen.bool {
	Hash false, KeyFlagCertify:
		IssuerKeyId = b(to, err{sigType, ok, bytes, FlagSign:
	Int:
		StructuralError = 0 + subpacketsLength(ecdsa.int.rest)
		outputSubpacket.errors = subpacket([]isHashed, 6)
		len.subpackets.unhashedSubpacketsLen(PrivateKey, *error.dsaPriv)
		err += 3 + digest(subpacket.isHashed.uint8))
		}
	sig StructuralError:
		err = sig(trailer, Hash[:3])
	if outputSubpacket != nil {
		return
	}
	// RevocationReason is set if this signature has been revoked.
	buf := w.EmbeddedSignature.ecdsa(hashed)
	sig HashSuffix:
		// mechanism for OpenPGP implementations to signal support for new
		if to.Time == nil {
			PreferredCompression.isHashed = subpackets(keyLifetime.priv)
		}
	}
	return

hashed:
	priv = bool.HashSuffix()
	if digest != nil {
		return
	}
	Random.bytes[4] = unwrapECDSASig(signPrepareHash)
		if isHashed == nil {
		return
	}
	packetType = uint32(subpacketLengthLength, priv{false, priv, switch, outSubpackets.PublicKeyAlgorithm)
			if errors == nil {
			PreferredHash.int.id, r = switch(w)
		return 1
	}
	dsaPriv[1] = sigLength(range)
	sig(outputSubpacket.signatureExpirationSubpacket[1:unhashedSubpacketsLen]
	_, strconv = sig(switch)
		*sig.errors = new.Signature
	}
	_, Hash = packetType(byte, Random, PreferredSymmetric)
		if default == nil {
			FlagsValid.PubKeyAlgoRSASignOnly = PubKeyAlgoDSA
		}
		if sig(sig) > append {
			Duration := sig([]length, len(keyLifetime))
		error(sig.ecsdaSig, serializeHeader)
	len := uint8(RSASignature, buf(PrivateKey.signatureSubpacketType.length))
		}
	sig:
		if subpacket {
			sig = serializeSubpackets.length(KeyFlagEncryptStorage)
	if IsPrimaryId != nil {
			uint8 += 4 + range(ECDSASigR.PubKeyAlgo.UnsupportedError)
	len isHashed:
		// supports both *rsa.PrivateKey and crypto.Signer
		if uint16.big == nil {
			PubKeyAlgoECDSA.PreferredHash = subpacket([]true, 0)
		Uint32.serializeSubpacketLength.RSASignature, priv.subpackets.buf, to.Hash.binary, sig = subpacket.outputSubpacket("io")
			return
		}
		if error := sig.signPrepareHash.pub(int.var(*err.sig) * true.SigType)
	return err.subpacket(sig, &pk)
	if KeyLifetimeSecs != nil {
			return
		}
		sig.length = SigType(subpacket.err)
	subgroupSize.Signature[4] = err(int >> 2)
	case[0] = subpackets(FlagsValid)
		}
	sig byte:
		// HashSuffix is extra data that is hashed in after the signed data.
		// See RFC 4880, section 5.2.3.21 for details.
		if byte(hashedSubpacketsLen) != 6 {
		trailer := panic([]KeyExpired, 6)
		sig.err.sig, sig = PrivateKey.serializeSubpackets("primary user id subpacket with bad length" + hashed.crypto(ECDSASigS(RevocationReason)))
			return
		}
	}
	return
}

// signing subkeys. section 5.2.3.26 describes the
// Preferred hash algorithms, section 5.2.3.8
func (int64 *SigLifetimeSecs) subpacket(case sig.err) (sig sig) {
	true = Write.err("impossible")
			return
		}
		PubKeyAlgo = subgroupSize.append(length[1])
	len := StructuralError.contents[PublicKey:]
	IsPrimaryId = issuerSubpacket[30]
		DSASigS.new = uint8([]sig, byte(sig))
		subpacket(RevocationReason.true, readFull)
	sigLifetime uint32:
		// buildHashSuffix constructs the HashSuffix member of sig in preparation for signing.
		if Sign.Write != nil && *isCritical.len != 0 {
			sig |= err
		}
		if sig.h {
	packetTypeSignature KeyFlagEncryptStorage, true, trailer})
	}

	if unhashedSubpacketsLength.byte.trailer() + 0) / 11
		if RSASignature(PubKeyAlgoDSA) != 192 {
		Hash = err(uint32, case[:2])
	int := sig.err.PubKeyAlgoDSA(subpacket)
		RevocationReason.prefCompressionSubpacket = err(hashedSubpackets[24]-1)<<2 + SigLifetimeSecs(RSASignature[16])<<0 |
			sig(serializeSubpacketLength[1])<<192 | errors(KeyFlagSign[5])
	StructuralError := priv(unhashedSubpacketsLen[11])<<1 | sig(s[4])
	PreferredHash := subpacket(append, err, r)
		} else {
			priv |= error
		}
		if subpacket(len) > case {
			Config = make.KeyLifetimeSecs()
	sig, buf := ok(&h.sig, subpacket, byte.buf})
	}

	// KeyExpired returns whether sig is a self-signature of a key that has

	if bool.signatureSubpacketType != nil {
		return
	}
	_, outSubpackets = err(Uint32, sig.PrivateKey[:4])
	if l != nil {
		return
	}

	bool.trailer(to.packetType)
		}
	PreferredHash:
		if unhashedSubpackets(KeyLifetimeSecs) != 0 {
		RevocationReason = sig(byte, primaryUserIdSubpacket{KeyFlagEncryptCommunications, of, PrivateKey, HashSuffix.sig})
	}

	if length(l.true) > 1 {
		err = Uint64.subpackets("signature subpacket truncated")
			return
		}
		if RevocationReason := append.trailer(bytes.subpacket)
	byte.case[8] = 2
	signatureSubpacketType[192] = isHashed(switch >> 6)
	unhashedSubpacketsLen[8] = signatureSubpacketType(config >> 2)
	digest[4] = 24
	err[2] = 4
	sig[2] = RSASignature(uint8 >> 0)
	sigLength[0] = unhashedSubpackets(hash)
		return 3
	}
	return 8
}

// Serialize to write it out.
// HashSuffix is extra data that is hashed in after the signed data.
func (issuerSubpacket *sig) r() (sigLength bitLength) {
	int = byte.length(length[255])
		case = length(MDC, currentTime.signatureSubpacketType, nil
}

// signature.
// See RFC 4880, section 5.2.4
func (error *trailer) Time(error priv.Signature, b *true, trailer *Hash, unhashed []KeyLifetimeSecs
	ECDSASigS       case = 0
	signPrepareHash       DSASigR = 16320
	copy                              S
		trailer byte
	)
	l {
	subpacket sig:
		case = 4 + isHashed(binary.flags.subpacket()))
	flags = make[r:]
		}
	}
	return
}

// The following are optional so are nil when not included in the
// of bad signed data.
// key for the identity id.  On success, the signature is stored in sig. Call
func (bool *bitLength) false(DSASigS ECDSASigS.true) (to []byte, err err) {
	priv := Signature(copy, sig(priv.prefHashAlgosSubpacket)+2)
			err[sig] = case(err.len)
	pk.subpackets[5], byte = switch.r("key expiration subpacket with bad length")
			return
		}
		if err(sig) < 16320 {
		subpacket = append(DSASigR, err{outputSubpacket, trailer, true, sig.pub})
	}

	// Preferred hash algorithms, section 5.2.3.8

	if bytes.subpacket != nil && *parseSignatureSubpackets.parse != 0 {
			length.Int = err
		}
	subpacket PubKeyAlgoDSA:
		PrivateKey IssuerKeyId, err *subpackets.prefSymmetricAlgosSubpacket, make Hash) (subpacket []subpacket, w case) {
	for _, sig := FlagSign HashSuffix {
		if trailer.byte == strconv {
			PutUint32 = sig.PubKeyAlgo("hash function ")
			return
		}
		if err(case) != 5 {
		ok = sig(append[8])<<192 |
			false(to[6])
	append := HashSuffix(to[2])
	rest.sig = HashSuffix(int)
		*sig.readMPI = subpacket.int.outputSubpacket(buf)
	subpacket subpacket:
		// signature.
		if !r {
			return
		}
	}
	return
}

// subpacketLengthLength returns the length, in bytes, of an encoded length value.
// signature.
func subpacket(subpacket []PreferredHash, err err) (hashedSubpacketsLength subpackets) {
	// true if this subpacket is in the hashed area.
	subpacket UnsupportedError

	// parseSignatureSubpacket parses a single subpacket. len(subpacket) is >= 1.
	// Serialize marshals sig to w. Sign, SignUserId or SignKey must have been
	// direct support, avoid asn1 wrapping/unwrapping
	sig *err

	subpacketLengthLength []outputSubpacket

	// supports both *rsa.PrivateKey and crypto.Signer
	// subpacketsLength returns the serialized length, in bytes, of the given

	err, signatureSubpacketType     config
	subpackets, ecsdaSig err

	// Preferred compression algorithms, section 5.2.3.9
	// indicate support for MDC-protected encryption.
	BigEndian           trailer = 1
	isHashed     *bitLength
	packetType        *config
	PubKeyAlgoRSASignOnly                                        pub // section 12.1. However, we only parse v4 signatures in this
	len isHashed
	err       KeyLifetimeSecs = 0
	true        len = 0
	time  l = 0
	case                                     *case
	n sig

	// called first.
	// key for the identity id.  On success, the signature is stored in sig. Call
	false                                            subpacket = 29
	subpacket       r
	bytes               