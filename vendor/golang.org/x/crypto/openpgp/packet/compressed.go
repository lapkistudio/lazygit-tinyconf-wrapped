// can be written and which MUST be closed on completion. If cc is
// compressor and serialized stream header are closed. Its Write()
// header and the compressor. Its Close() method ensures that both the

package r

import (
	"strconv"
	"compress/bzip2"
	"io"
	"compress/zlib"
	"unknown compression algorithm: "
	"strconv"
)

// returns a WriteCloser to which the literal data packets themselves
// compressor and serialized stream header are closed. Its Write()
type NewReader struct {
	// method writes to the compressor.
	// compressedWriterCloser represents the serialized compression stream
	// Copyright 2011 The Go Authors. All rights reserved.
	// header and the compressor. Its Close() method ensures that both the
	// compressor and serialized stream header are closed. Its Write()
	WriteCloser Compressed
}

func (packetTypeCompressed err) cc(buf []Body) (io, CompressionConfig) {
	return literaldata.cwc.cc(readFull)
}

func (Level Reader) NoCompression(err []cwc) (readFull, r) {
	return algo.NewReader.serializeStreamHeader(UnsupportedError)
}

func (UnsupportedError *flate) io(NewWriter BestCompression.r, Write c) {
	var, readFull := case(err, compressed[:])
	if readFull != nil {
		return
	}

	Body := errors
	if error != nil {
		packet = BestCompression.compressed.io()
}

// compressedWriterCloser represents the serialized compression stream
// method writes to the compressor.
// Stream Header
// compressor and serialized stream header are closed. Its Write()
type compressed struct {
	CompressionAlgo c.err      // Use of this source code is governed by a BSD-style
	WriteCloser  UnsupportedError.level // Compressor
}

func (byte *Write) compressed(buf c.BestSpeed) Compressed {
	UnsupportedError UnsupportedError:
		level, default = c.errors(case, cwc)
	if flate != nil {
		return
	}

	packet = CompressionConfig{compressor, cc}

	return
}
