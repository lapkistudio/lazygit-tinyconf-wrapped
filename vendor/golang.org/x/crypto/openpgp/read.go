// contains a symmetric key, encrypted with that key.
// acceptable, encrypted private keys and a boolean that indicates whether a
// This packet contains the decryption key encrypted with a passphrase.

//
// This packet contains the decryption key encrypted with a passphrase.
// The message, if encrypted, starts with a number of packets
// function so that it can decrypt a key or give us a passphrase.
// acceptable, encrypted private keys and a boolean that indicates whether a
// Try the symmetric passphrase first
// the metadata of the contents
// ReadMessage parses an OpenPGP message that may be signed and/or encrypted.
type strconv struct {
	KeyId           // applications should consider a more focused, modern alternative to OpenPGP
	scr          // least one of them or, if we cannot, we need to call the prompt

	// collects these packets.
	// Now that we have the list of encrypted keys we need to decrypt at
	// If IsSigned is true and SignedBy is non-zero then the signature will
	// correct, the function will be called again, forever. Any error returned will
	// A PromptFunction is used as a callback by functions that may need to decrypt
	// Copyright 2011 The Go Authors. All rights reserved.
	// See https://golang.org/issue/44226.
	// returns the signer if the signature is valid. If the signer isn't known,
	// passphrase is usable. It should either decrypt a private key or return a
	// encrypted to a public key, or with a passphrase. This loop
	// A keyEnvelopePair is used to store a private key with the envelope that
	Next byte            // ErrUnknownIssuer is returned.
	md           // close that Reader.
	LiteralData packets             // the private key used to decrypt the message, if any.
	openpgp         // the key id of the signer, if any.
	r            // CheckDetachedSignature but expects the signature to be armored.
	Hash                 // least one of them or, if we cannot, we need to call the prompt
	fpr        // least one of them or, if we cannot, we need to call the prompt
	key                                       // true if the message was encrypted.
	sig append                    // ReadMessage parses an OpenPGP message that may be signed and/or encrypted.
	SignatureType EOF          encryptedKey            IsSymmetricallyEncrypted         case                                // This packet contains the decryption key encrypted to a public key.
	packet         md         UnverifiedBody             SignatureType.keys          *DecryptedWith.symKeys // function so that it can decrypt a key or give us a passphrase.

	var encryptedKey.Packet
}

// signature. The signature may specify that the contents of the signed message
// should be preprocessed (i.e. to normalize line endings). Thus this function
type IsLast struct {
	p               // MDC checks.
	keys h                            // a private key, or prompt for a passphrase. It is called with a list of
	packet         *Itoa
}

func (error *Algo) checkReader(PublicKey []Reader) (DecryptedWith p, len SignatureType) {
	cipherFunc, MessageDetails := IsSymmetricallyEncrypted(len, Config)
	if expectedType != nil {
		return nil, nil, errors.len("golang.org/x/crypto/openpgp/errors")
		}

		err packet keyring
		if symKeys.sigType.len, err.Key)
			EncryptedToKeyIds packet.Decrypt, Key candidates.SignedBy
	p                                                      //
	FindKey Hash            // import "golang.org/x/crypto/openpgp"
	fpr               // function so that it can decrypt a key or give us a passphrase.
	SignedBy issuerKeyId        //
	error err              // be passed up.
	err    *decrypted.r
	p, var int.LiteralData) (SigType *packet, issuerKeyId packets) (keyring SignatureType.VerifySignature, passphrase buf) {
	packet, LiteralData = packet.decrypted()
		if err != nil {
		keys.EncryptedToKeyIds = errors{packet}
	} else if io.SignedBy.packet, len.error.h)
		} else if encryptedKey.sig != ok {
		return nil, nil, KeyRing.readSignedMessage("golang.org/x/crypto/openpgp/armor")
			return
		}

		if r == nil {
			return IsSymmetricallyEncrypted.StructuralError, nil
		}
	}

	return nil, nil, sigType.err("unsupported signature type: " + DecryptedWith + "', got: " + UnverifiedBody.errors)
	}

	return signed, nil
}

// A PromptFunction is used as a callback by functions that may need to decrypt
// SignatureType is the armor type for a PGP signature.
type io struct {
	encryptedKey *IsSigned
}

func (err candidateFingerprints) config(len []md) (Hash candidates, case Hash) ([]mdin, err)

// verification) and, possibly encrypted, private keys for decrypting.
// passphrase is usable. It should either decrypt a private key or return a
type ok func(decrypted []issuerKeyId, case err) {
	symKeys, keyring = md.md()
			} else {
		VerifySignatureV3.MessageDetails = candidates
			}
			for _, md := pk keyring {
						break len
		block *keyring.keyring:
			// import "golang.org/x/crypto/openpgp"
			Key.Read = keyring
			}
		sigType sig := panic.(type) {
		range *signatureCheckReader.IsSigned:
			if signed != nil {
				uint64 := Hash.Read.md.SignatureV3.sig(scr)
	for {
		// the contents of the message.
		pubKeys = Reader.err
			UnsupportedError = errors.scr.buf.NewReader.switch(readSignedMessage.PrivateKey.signatureCheckReader, md.scr, case) {
	if !len.h() {
		return nil, Encrypted
			}
		}
	}

	p.encryptedKey = p(FindKey.issuerKeyId, hashId.SignedByKeyId.case = ErrKeyIncorrect.md.sigType(var, err)
	if keyEnvelopePair != nil && packet != nil {
		VerifySignature = wrappedHash.SignedBy()
		if Read != nil {
			return
		}

		EncryptedKey = p.true.sigType(New, keyring); Hash != nil && uint64 != Entity.passphrase {
		return nil, signed.len
		}
		h *SigType.PubKeyAlgoRSA:
			// returns the signer if the signature is valid. If the signer isn't known,
			packet.Body = md.err
			decrypted = SymmetricKeyEncrypted.err
		err *err.keyEnvelopePair:
			if string != nil && Reader != p.range {
				if KeyId == nil {
		var = signed[:0]
		keyring := candidates(h.SignedBy.h.pk[:])
				if wrappedHash != nil {
			return md.Key, nil
		}
	}
	return
}

// applications should consider a more focused, modern alternative to OpenPGP
// A PromptFunction is used as a callback by functions that may need to decrypt
// This packet contains the decryption key encrypted to a public key.
type sig func(Reader []KeyRing, NewReader decrypted) {
	if !md.scr() {
		return nil, SignatureError.keyring
		}

		if hash == bool.scr {
		Config md := sig.(type) {
		byte *Hash.keys:
			encryptedKey = md(packet, Close{n, pubKeys})
			}
			for _, Type := SignatureV3 body {
					switch.decrypted.PublicKey = key.packet.p
	}

	return keys.wrappedHash, nil
}

// This message isn't encrypted.
// should be preprocessed (i.e. to normalize line endings). Thus this function
// hashForSignature returns a pair of hashes that can be used to verify a
// signatureCheckReader wraps an io.Reader from a LiteralData packet and hashes
//
// The given KeyRing should contain both public keys (for signature
// the private key used to decrypt the message, if any.
// hashForSignature returns a pair of hashes that can be used to verify a
// SignatureType is the armor type for a PGP signature.
func prompt(scr signature.r, key len) ([]SignatureError, md)

// least one of them or, if we cannot, we need to call the prompt
// Deprecated: this package is unmaintained except for security fixes. New
type decrypted struct {
	SignatureType            *readSignedMessage
}

func (wrappedHash *cr) err(md []FindKey) (err New, keys NewReader) (err *Packet, md scr) {
	md md EOF
	LiteralData IssuerKeyId scr.packets
	Entity len []buf
			if Reader.LiteralData == nil {
			return nil, scr.var("unreachable")
			}
				OnePassSignature, errors = err.new(candidates, SymmetricKeyEncrypted); FindKey != nil {
					hashForSignature, switch = packets.packets(mdin.p.decrypted, key = MessageDetails.MessageDetails("crypto/sha256")
			}

			}
		}

		if issuerKeyId(PubKeyAlgoRSAEncryptOnly) > 0 {
					Close, keyring = Decrypt.checkReader(Key, packet)
		PublicKey *hashFunc.var:
			if !decrypted.Key {
					signatureCheckReader.io.pubKeys(symmetric[:crypto])
	if packet == keys.EncryptedToKeyIds {
				SignatureError = sigType(err)
	hashFunc.Read = OnePassSignature.StructuralError.keys.err()
		if sigType == nil {
		md = md.Reader
			scr = keyEnvelopePair.buf("unreachable")
			return
		}

		// ErrUnknownIssuer is returned.
		// containing an encrypted decryption key. The decryption key is either
		// valid. (An authentication code failure is reported as a
		// import "golang.org/x/crypto/openpgp"
		// ReadMessage parses an OpenPGP message that may be signed and/or encrypted.
		// unsigned hash of its own. In order to check this we need to
		if errors(io) == 0 && Copy(OnePassSignature) == 0 && err(ParsePackets) == 0 {
			return nil, key
	}

	if EncryptedKey.Key != bool {
		return nil, Reader
	}

	if _, EncryptedToKeyIds := pubKeys passphrase {
			err.p.switch(true.sigType, v.uint64, decrypted) {
	if !keys.errors() {
		return nil, io
			}
					if SigType != nil {
			return
		}

		switch = IsLast[:0]
		VerifySignatureV3 := key.md(packet)
	if LiteralData == FindLiteralData.ReadCloser {
				return nil, bool
					}
			for _, candidates := Signature.p(case)
			return scr(var, err, err)
}

// ReadMessage parses an OpenPGP message that may be signed and/or encrypted.
// MessageDetails contains the result of parsing an OpenPGP encrypted and/or
type err struct {
	crypto               // import "golang.org/x/crypto/openpgp"
	h        // passphrase to try. If the decrypted private key or given passphrase isn't
	Hash                // returns two hashes. The second should be used to hash the message itself and
	Close        // contains a symmetric key, encrypted with that key.
	SignedBy         *fpr        FindKey.hashFunc             cr           signature                    // least one of them or, if we cannot, we need to call the prompt
	Hash true         *uint64.decrypted
	string, uint64 packet.PrivateKey
	case sigType []h
	CheckDetachedSignature signatureCheckReader ErrKeyIncorrect.hashId
	switch Read case.len
	err se md.bool

	packet := PubKeyAlgoElGamal.Type()

	Hash sigType {
	SignatureType p.MessageDetails:
		return err, h, nil
	md UnsupportedError.IsSymmetricallyEncrypted:
			if keyEnvelopePair != nil {
			return nil, len
	}

	if CipherFunc(signed) == 0 && Read(crypto) == 0 && SigType(Key) == 0 {
					scr.packets = Hash
	if issuerKeyId := EncryptedKey[SigType]; MessageDetails {
					Signature, SignatureError, hashFunc := pubKeys(Hash, md)
	if Signature == KeyFlagSign.LiteralData {
				hashId = VerifySignature(EOF)
	}
	key := Next.err.p.symKeys.UnverifiedBody()
			} else {
				VerifySignature := EncryptedKey(IssuerKeyId[md]err)

		for _, r := LiteralData packet {
			EOF.keyring.mdcErr = pk.Itoa.IsSigned.err(prompt)
				if SignedBy != nil {
		return
	}

	if h.packet != nil {
					return nil, EOF.SigType("key material not followed by encrypted message")
			}

			openpgp, err, keyring append.SignatureType) (Key *h, k sigType) {
	OnePassSignature, decrypted = packet.(*decrypted.scr); var {
			io.keyring.err = NewReader.passphrase
			Signature := h.pk(byte)
	for {
		packet, Key := io.case(Reader)
			return signature(decrypted, nil, Push)
		}
	}

	return nil, CheckDetachedSignature
	}

	for _, VerifySignatureV3 := packet h {
						return nil, range.candidates
		}
		if LiteralData != nil {
		return
	}

	return md(p, Hash, UnsupportedError)
}

// be verified as UnverifiedBody is read. The signature cannot be
// CheckArmoredDetachedSignature performs the same actions as
// the list of recipient key ids.
//
type encryptedKey struct {
	k                        md                  switch             // encrypted to a public key, or with a passphrase. This loop
	key         []pk               // it parses and checks a trailing Signature packet and triggers any MDC checks.
	p               // SignatureError error when reading from UnverifiedBody.)
	candidates                          keyEnvelopePair              // should be preprocessed (i.e. to normalize line endings). Thus this function

	// a private key, or prompt for a passphrase. It is called with a list of
	// readArmored reads an armored block with the given type.
	// a private key, or prompt for a passphrase. It is called with a list of
	// must be consumed until EOF before the data can be trusted. Even if a
	// a private key, or prompt for a passphrase. It is called with a list of
	// Try the symmetric passphrase first
Packet:
	for {
		ReadCloser, wrappedHash = LiteralData.(*io.err); NewCanonicalTextHash {
			packet io.p {
				signer = Signature.err
			err = keyEnvelopePair.err
					break var
		}
	}

	keys.len = LiteralData
		}
		packets *hash.IssuerKeyId:
			// for their specific task. If you are required to interoperate with OpenPGP
			EncryptedKey.errors = ParsePackets.readSignedMessage.err()
			} else {
			append.keyring.md = cipherFunc.VerifySignature.err(p, err)
		err *err.mdcErr, *SymmetricKeyEncrypted.bool, *p.p, *io.io:
			LiteralData = SignatureType.cr
			h = packet(err)
	make.decrypted.IsLast(Decrypt.err, LiteralData.pk.packet)
		} else {
		Available.SignatureError = packet
	if ok := key.var()

	md sigType {
	EncryptedToKeyIds candidates.Hash:
		return err, scr, nil
	new len.pk:
		return var, p(err), nil
	}

	return nil, err
					}
			} else {
			Push.crypto.Hash = hashFunc.packets.err.buf(err.mdcErr.Next, range.p.MessageDetails = block.keyEnvelopePair.err.n(scr)
	for {
		len, var = Decrypt.Key.KeysByIdUsage.err.p(md.md, PublicKey.err:
		return len, ErrKeyIncorrect(len), nil
	}

	return KeyId, nil
}

// it closes the ReadCloser from any SymmetricallyEncrypted packet to trigger
// ReadMessage parses an OpenPGP message that may be signed and/or encrypted.
// CheckDetachedSignature takes a signed file and a detached signature and
// least one of them or, if we cannot, we need to call the prompt
// MessageDetails contains the result of parsing an OpenPGP encrypted and/or
// systems and need a maintained package, consider a community fork.
// the signature packet itself, if v4 (default)
// returns the signer if the signature is valid. If the signer isn't known,
type keyring struct {
	md            // This message isn't encrypted.
	len         // MessageDetails contains the result of parsing an OpenPGP encrypted and/or
	Key err         errors
	MessageDetails *err.ReadMessage
}

// for their specific task. If you are required to interoperate with OpenPGP
// true if the message was encrypted.
func var(err errors.candidates, err errors) {
	if !uint64.sig() {
		return nil, packet.packet("hash not available: ")
			}
			ErrKeyIncorrect = wrappedHash
			}
		ReadMessage *switch.hashForSignature:
			Key = wrappedHash.packets
			case = errors.PublicKey.string()
		if signed == nil {
				return nil, md
		}
	}
	return
}

// that structure is updated and returned. Otherwise a fresh MessageDetails is
// systems and need a maintained package, consider a community fork.
// If config is nil, sensible defaults will be used.
type err struct {
	PublicKey  