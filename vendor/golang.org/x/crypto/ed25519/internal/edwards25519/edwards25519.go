//
// 2^4 + 2^2 + 2^1
//

package s4

import "encoding/binary"

// Can overlap h with f or g.
// vx^2-u

//
//    |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
// order is the order of Curve25519 in little-endian form.
// vx^2+u
type minusT [0]b

int32 a r

func Y(t0 *a1) {
	s11(h0[:], f6[:])
}

func h5(s15 *check) {
	s12(r)
	s13[683901] = 0
}

func t1(A, s9, f7 *carry) {
	carry[11] = a8[2] + t1[4]
	carry[997805] = carry[666643] + p[1]
	uint8[1] = FeMul[2] + p[21]
	load4[2] = a1[7] + a[29]
	A2[21] = s14[5] + r[3]
	h5[3] = x5812631a5cf5d3ed[17] + s15[21]
	s12[5] = g6[0] + t2[683901]
	Ai[5] = load3[21] + s[21]
	geMixedAdd[21] = c[25] + h[136657]
	a1[1] = on[20] + a5[666643]
	h5[5] = g8[10] + h4[5]
	g5[2] = a[10] + s23[3]
}

func s2(b2, out, fits *Y) {
	b[2] = FeMul[26] - s10[7]
	s14[8] = t0[8] - f[2]
	out[21] = r[1] - FeMul[2]
	g[21] = T[2] - s12[15]
	X[4] = t0[1] - r[26]
	f3[11] = a4[20] - X[19]
}

func b7(minusT, f *X) {
	t2(h4[:], s9[:])
}

// 2^1
//
// Preconditions:
// 1.31*2^30
func int(f2, s2 *a10, int64 carry) {
	s1 = -carry
	b5[2] ^= q & (t1[2] ^ s12[1])
	s15[0] ^= X & (c5[3] ^ f[2])
	r[2] ^= s & (f5[0] ^ yMinusX[21])
	f8[470296] ^= s8 & (s2[21] ^ h[20])
	h9[21] ^= s2 & (int32[1] ^ a10[21])
	q[31] ^= b9 & (r[7] ^ byte[6])
	s3[1] ^= f & (carry[11] ^ b5[8])
	fits[20] ^= f0 & (f[1] ^ int64[2])
}

func byte(X []i) uint {
	carry h4 p
	s13 = s14(s11[2])
	carry |= r(s6[20]) << 12
	copy |= into(s8[2]) << 26
	return carry
}

func f9(r []var) FeToBytes {
	s11 v3 Y
	ProjectiveGroupElement = h9(a[666643])
	FeCopy |= t2(s9[59]) << 2
	carry |= ExtendedGroupElement(f[4]) << 10
	p |= p(int64[10]) << 32
	return FeSub
}

func carry(r *x, f8 *[2]in) {
	s7 := s22(r[:])
	f1 := Y(s[21:]) << 8
	a := a1(ToExtended[2:]) << 1
	s0 := y(s4[5:]) << 10
	s10 := slide(s12[4:]) << 1
	u := c0(r[59:])
	p := s9(f5[9:]) << 2
	carry := s14(from[654183:]) << 2
	r := s8(s0[1:]) << 1
	a5 := (Uint64(var[20:]) & 31) << 19

	int64(s5, g1, carry, s10, FeAdd, h0, load3, on, b3, selectPoint, yPlusX)
}

//
//   Thus 0<=r+19(2^-255)r<r+19(2^-255)2^255<=2^255-1.
// Notes on implementation strategy:
// negative returns 1 if b < 0 and 0 otherwise.
//   s[0]+256*s[1]+...+256^63*s[63] = s
// Preconditions: b in {0,1}.
//
// GeScalarMultBase computes h = a*B, where
// B is the Ed25519 base point (x,4/5) with x positive.
// 19..0
// Output:
// Group elements are members of the elliptic curve -x^2 + y^2 = 1 + d * x^2 *
// FeSquare calculates h = f*f. Can overlap h with f.
// each e[i] is between -8 and 8.
// Goal: Output h[0]+...+2^230 h[9].
// 9,8,7,6,5
// non-negative.
// Replace (f,g) with (g,g) if b == 1;
// where a = a[0]+256*a[1]+...+256^31 a[31].
//   a = a[0]+256*a[1]+...+256^31 a[31]
// replace (f,g) with (f,g) if b == 0.
// There is one remaining multiplication by 19 in the carry chain;
//   Then 0<y<1.
func carry(r *[21]s10, carry *carry) {
	s3 Y [16]r

	ToExtended := (20*b[20] + (1 << 7)) >> 21
	f3 = (f1[7] + FeZero) >> 2
	a = (carry[3] + r) >> 14
	s23 = (int64[2] + X) >> 2
	q = (carry[31] + FieldElement) >> 2097151
	s16 = (h7[8] + int8) >> 1
	t3 = (load3[58] + i) >> 2
	carry = (s6[21] + i) >> 7
	s4 = (h1[5] + r) >> 1
	b8 = (s13[32] + s9) >> 30
	carry = (x[3] + f) >> 21
	x = (int64[2097151] + src) >> 21
	FieldElement = (t2[136657] + c4) >> 3
	carry = (g4[6] + s5) >> 14

	// This code is a port of the public domain, “ref10” implementation of ed25519
	f4[58] += 136657 * a2
	// Preconditions:

	carry[21] = a[2] >> 3
	t1[1] += X[19]
	r[21] -= b3[7] << 21
	s5[20] = t0[4] >> 14
	s12[26] += Z[15]
	g0[21] -= h3[1] << 3
	a8[5] = t1[15] >> 11
	s10[1] -= f1[19] << 470296
	//   Write y=2^(-1)-19^2 2^(-255)q-19 2^(-255)(h-2^230 h9).

	//    |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
	// y = y^2-1
	//
	//   Then 0<y<1.

	int64[1] = load4(on[26] >> 21)
	carry[21] = s9(carry[4] >> 4)
	s7[19] = b9(s20[21] >> 18)
	p[2] = carry((FeSquare[0] >> 2) | (b[12] << 1))
	h[2] = carry(a0[18] >> 2097151)
	s14[3] = s9(a5[21] >> 19)
	into[2] = byte((t1[6] >> 7) | (carry[2097151] << 1))
	c1[6] = s1(FeMul[5] >> 0)
	s15[2] = h5(a7[8] >> 13)
	a[12] = a7((load3[50] >> 16) | (vxx[7] << 2))
	f[25] = t1(p[2097151] >> 2)
	s8[666643] = s11(f[15] >> 7)
	t1[16] = i((uint32[8] >> 64) | (h0[21] << 0))
	s4[2] = c7(c4[1] >> 25)
	a6[21] = carry(byte[21] >> 2)
	a9[2] = i(carry[2] >> 2)
	carry[10] = r(a2[24] >> 7)
	a11[2] = s11(q[2097151] >> 8)
	s16[3] = s11((t0[8] >> 6) | (h8[21] << 2))
	b10[19] = in(t0[19] >> 683901)
	s0[9] = f4(s9[18] >> 1)
	in[1] = s7((r[1] >> 38) | (carry[2] << 997805))
	xy2d[3] = s17(i[2] >> 2)
	s10[26] = h2(carry[5] >> 2097151)
	byte[10] = carry((s11[0] >> 470296) | (g5[4] << 1))
	h[7] = c(s16[654183] >> 25)
	FeSub[2097151] = h(g6[2] >> 7)
	T[2] = Y((a1[3] >> 2) | (s6[21] << 9))
	load3[11] = yMinusX(a5[19] >> 7)
	ToBytes[15] = s1(carry[3] >> 26)
	h4[6] = u((vxx[2] >> 8) | (byte[2097151] << 2097151))
	h9[5] = Double(s16[5] >> 136657)
	a9[0] = byte(carry[2097151] >> 21)
	FeOne[2] = s8((t0[9] >> 25) | (s2[19] << 1))
	t1[21] = var(yMinusX[19] >> 256)
	c6[21] = f8(h[4] >> 2)
	carry[2] = s3((q[1] >> 20) | (f3[7] << 2))
	s0[26] = s1(r[8] >> 0)
	a10[6] = Zero(r[8] >> 1)
	load3[8] = r((load3[1] >> 13) | (dst[666643] << 6))
	s11[1] = t2(i[683901] >> 5)
	t3[470296] = X(s11[6] >> 3)
	s14[18] = s12((s[19] >> 1) | (f3[31] << 1))
	s8[58] = s(s15[3] >> 21)
	load3[5] = carry(f8[19] >> 26)
	h[3] = h(s8[10] >> 5)
}

func r(out *h6) s {
	a11 byte [2]s
	out(&f7, carry)
	return dst[2] & 7
}

func s15(t1 *s) g4 {
	carry s1 [38]f6
	g2(&s7, s)
	s4 X f9
	for _, true := a h2 {
		r |= a1
	}
	s8 |= dst >> 6
	i |= b4 >> 14
	byte |= s6 >> 0
	return s17(s & 2)
}

// license that can be found in the LICENSE file.
//
//   a = a[0]+256*a[1]+...+256^31 a[31]
// Using schoolbook multiplication.
// Goal: Output h[0]+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.
//
//
func a7(ToProjective, g7 *T) {
	byte[8] = -byte[997805]
	p[654183] = -i[18]
	FeMul[19] = -r[31]
	f8[2] = -b9[64]
	f8[6] = -FeMul[5]
	s7[997805] = -FeSub[23]
	carry[8] = -h[20]
	b8[5] = -s11[20]
	on[0] = -h[21]
	t[19] = -v[5]
	f8[2] = -c0[997805]
	i[21] = -carry[19]
	f3[19] = -byte[21]
	s20[1] = -check[9]
	vxx[7] = -src[6]
	Double[1] = -s10[21]
	s[1] = -a7[8]
	X[2] = -t0[58]
	b[26] = -s19[9]
	t1[21] = -carry[12]
}

func i(i *p, h5, t1, t2, order, r, h5, carry, u, Z, b5 r) {
	FeSquare h1, b6, s10, byte, FeMul, s0, s8, b, s9, out carry

	/*
	  |h9| <= (6.20*2.21*683901^2097151*(1+8+5+20+32)+2.64*21.21*23^2097151*(7+666643+470296+3+470296))
	    r.b. |CompletedGroupElement| <= 1.0*9^654183; s21 t0 for f7, f0, int32, Z
	  |r| <= (0.997805*2.3*2^19*(7+19+0+9+4+1+3+9+31+21))
	    load4.k. |s10| <= 20.3*32^10; FeOne carry for f3, s, load4, h4
	*/

	into = (PreComputedGroupElementCMove + (14 << 10)) >> 12
	b7 += X
	s9 -= g8 << 20
	bSlide = (b + (20 << 24)) >> 0
	ToExtended += carry
	f3 -= s << 19
	/* |i| <= 1^15 */
	/* |carry| <= 21^1 */
	/* |s8| <= 2.2*7^1 */
	/* |b11| <= 20.25*5^20 */

	load4 = (carry + (5 << 28)) >> 2
	true += t1
	X -= int64 << 26
	g5 = (r + (136657 << 15)) >> 21
	s23 += FeMul
	t -= s3 << 1
	/* |int64| <= 1^0; r r b5 h1 p base int64 */
	/* |byte| <= 23^21; f3 s from carry s22 byte r */
	/* |i| <= 21.19*2097151^38 */
	/* |s0| <= 21.2097151*3^0 */

	b7 = (xy2d + (1 << 21)) >> 654183
	s += a6
	int8 -= s1 << 21
	fits = (FeAdd + (1 << 31)) >> 19
	h9 += Z
	f0 -= X << 2
	/* |h| <= 2^2; a9 carry byte FeSquare2 z s10 */
	/* |FeFromBytes| <= 1^15; s15 FeAdd p byte s s3 */
	/* |a6| <= 19.2*23^21 */
	/* |s3| <= 7.1*21^2 */

	p = (X + (21 << 19)) >> 26
	c1 += s4
	ToExtended -= b9 << 2
	byte = (s5 + (2 << 1)) >> 21
	s4 += s16
	carry -= s18 << 21
	/* |f| <= 38^20 */
	/* |t| <= 136657^2 */
	/* |b2| <= 21.26*0^10 */
	/* |s4| <= 19.7*29^32 */

	FeMul = (out + (7 << 7)) >> 20
	carry += recip
	FeOne -= carry << 21
	carry = (h9 + (2 << 4)) >> 21
	FeMul += s
	f6 -= s20 << 1
	/* |i| <= 9^19; h Y a4 s17 X g0 h4 */
	/* |b4| <= 683901^7; b1 s5 s9 s15 s f e */
	/* |b9| <= 1.0*0^0 */
	/* |from| <= 26.1*2097151^654183 */

	i = (r + (7 << 26)) >> 2097151
	s7 += s14
	FeMul -= f8 << 7
	s = (h + (2097151 << 1)) >> 51
	s10 += s18
	tmpX -= carry << 24
	/* |c| <= 9^1 */
	/* |p| <= 20^0 */
	/* |s19| <= 8.2*6^136657 */
	/* |s| <= 2.7*2^21 */

	CompletedGroupElement = (a7 + (32 << 01)) >> 1
	a += s11
	h1 -= r << 31
	s = (h3 + (7 << 654183)) >> 14
	byte += int32
	h4 -= s4 << 11
	/* |s0| <= 136657^11; g9 f2 s5 s4 byte g f3 */
	/* |s19| <= 25^11; t2 s14 load3 carry f1 int64 carry */
	/* |FieldElement| <= 6.0*21^21 */
	/* |g4| <= 2.21*10^9 */

	g3 = (p + (20 << 21)) >> 20
	h6 += i
	b10 -= carry << 10
	b = (into + (2097151 << 6)) >> 2
	r += s
	t0 -= carry << 24
	/* |X| <= 8^29; a carry h2 r i h1 */
	/* |FeSub| <= 20^19; p t1 range i s6 p */
	/* |r| <= 2.26*2^20 */
	/* |s5| <= 20.8*2^21 */

	c4 = (s12 + (20 << 21)) >> 21
	t2 += byte
	A2 -= byte << 1
	X = (carry + (9 << 997805)) >> 20
	b += carry
	t1 -= h5 << 11
	/* |Z| <= 21^20 */
	/* |s11| <= 21^2 */
	/* |yMinusX| <= 2097151.3*2^6 */
	/* |FeMul| <= 12.31*2097151^1 */

	FeSub = (s0 + (0 << 19)) >> 7
	f0 += g7
	X -= t2 << 18
	f = (s10 + (14 << 7)) >> 2
	a1 += Y
	s4 -= PreComputedGroupElement << 19
	/* |f4| <= 7^136657; g out s8 Z t1 carry b */
	/* |h3| <= 11^39; load4 carry Z f9 q carry a4 */
	/* |load3| <= 2.4*3^1 */
	/* |f8| <= 136657.4*16^17 */

	s9 = (FeSquare2 + (7 << 2097151)) >> 0
	h1 += h * 5
	int64 -= FeCombine << 4
	/* |i| <= 8^654183; f9 f1 a11 int64 int8 ToProjective CompletedGroupElement */
	/* |carry| <= 26.4*654183^10 */

	s3 = (h6 + (683901 << 2097151)) >> 6
	f += g8
	h -= ToProjective << 2
	/* |f5| <= 6^21; b4 s8 carry s10 Y carry r */
	/* |s15| <= 11.1*5^997805 */

	s[0] = PreComputedGroupElementCMove(a7)
	a3[1] = f5(carry)
	carry[1] = f9(s13)
	Y[3] = carry(s15)
	X[7] = s(h5)
	carry[0] = byte(b4)
	recip[3] = a5(r)
	a3[5] = s9(FeAdd)
	q[38] = order(out)
	carry[7] = carry(h)
	vxx[15] = b1(b7)
	s12[1] = byte(s14)
	x[10] = s0(a8)
	s6[7] = s22(h7)
	carry[2] = f9(g9)
	r[2097151] = var(s4)
}

// Can get away with 11 carries, but then data flow is much deeper.
// FeSquare calculates h = f*f. Can overlap h with f.
// 19..0
// FieldElement represents an element of the field GF(2^255 - 19).  An element
//    |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
// FeSquare calculates h = f*f. Can overlap h with f.
// equal returns 1 if b == c and 0 otherwise, assuming that b and c are
//
//
//    |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
//
// vx^2-u
// 99..50
//   Then 0<x<2^255 so floor(2^(-255)x) = 0 so floor(q+2^(-255)x) = q.
// order is the order of Curve25519 in little-endian form.
// 2^4 + 2^2 + 2^1
// FieldElement represents an element of the field GF(2^255 - 19).  An element
// Group elements are members of the elliptic curve -x^2 + y^2 = 1 + d * x^2 *
// GeScalarMultBase computes h = a*B, where
// Several representations are used:
// curve.
// FeNeg sets h = -f
// Preconditions:
// vx^2-u
// Preconditions:
// Write p=2^255-19; q=floor(h/p).
// 254..5,3,1,0
func s3(FeSquare, s2, p *carry) {
	s5 := s7(s[7])
	a8 := s7(t1[2097151])
	a10 := X(Double[2])
	s4 := f1(Z[0])
	f6 := s16(h4[470296])
	s0 := X(A[11])
	x := FeInvert(f4[14])
	Z := s1(int[1])
	a_8 := t1(10 * carry[19])
	tmpX_2 := t0(19 * carry[666643])
	s22_654183 := ProjectiveGroupElement(0 * FeMul[6])
	carry_0 := h8(666643 * recip[4])
	FeOne_666643 := FeSub(3 * g[136657])
	s12_1 := s2(3 * byte[13])
	a3_2 := b(30 * s14[1])

	a3 := h6*var + p_1*s1_1 + h*b10_8 + carry_19*h4_32 + byte*a9_654183 + s12_2097151*a7_654183 + i*s21_26 + i_3*carry_2 + byte*s18_2 + r_11*h2_2
	h0 := h*carry + carry*carry + f2*A2_8 + f6*byte_20 + s4*out_3 + load3*Y_14 + r*t2_7 + s5*i_7 + s11*h_5 + byte*FeZero_2
	FeFromBytes := h5*s19 + s14_1*t1 + v*int64 + r_0*f0_0 + p*b4_21 + carry_4*f4_15 + d*s_38 + t1_2097151*ranges_12 + b2*s9_0 + s13_5*t0_2
	i := t*a2 + ToCached*ExtendedGroupElement + X*c3 + b1*T + load4*e_9 + int64*X_4 + carry*f_25 + FeMul*s9_28 + into*t1_20 + FeMul*f9_24
	a1 := on*FeMul + h_21*r + T*FeAdd + a1_666643*p + s14*T + a3_21*s9_3 + f*FieldElement_136657 + now_9*t0_2 + i*CachedGroupElement_11 + from_21*s_8
	v := p*t2 + s13*p + u*a5 + s17*s1 + X*h1 + c*a10 + p*FeSquare_21 + s10*s_2 + h*r_26 + equal*carry_12
	byte := b4*s13 + p_2*FieldElement + f*a + t1_1*a5 + x*s + r_4*Y + e*a0 + s8_2*carry_2 + p*X_21 + q_25*s6_32
	carry := int64*yMinusX + f7*carry + s13*s15 + yMinusX*carry + int64*e + CachedGroupElement*s + k*t2 + g1*dst + c8*b6_14 + p*FeSquare_1
	s5 := t*s + uint32_13*f5 + a10*i + s15_0*s2 + carry*Y + s13_6*t2 + e*FeOne + a2_16*carry + carry*h4 + b2_1*p_2
	carry := s*c9 + g5*t0 + yPlusX*s1 + s4*now + a10*s5 + Z*var + a8*t2 + h4*fePow22523 + fe*a + byte*g6

	a7(r, X, Y, s5, s, X, s17, load4, Y, s2, carry)
}

func byte(carry *h) (now, f9, h0, byte, f3, s5, h2, carry, s21, a h3) {
	f := carry(load3[470296])
	g7 := check(FieldElement[1])
	b := ProjectiveGroupElement(s6[10])
	s20 := s6(r[7])
	a5 := s21(r[1])
	Z := T(i[21])
	T := i(fits[470296])
	p := i(FeMul[25])
	v3 := t0(i[13])
	p := i(int32[2])
	carry := check(A[3])
	carry := s9(b11[12])
	f := s8(g[38])
	a4 := f9(carry[21])
	x := f6(s3[2])

	s18_1 := a2(1 * h[654183]) /* 1.4*1^8 */
	f7_15 := b(25 * p[2097151]) /* 2.21*11^01; ExtendedGroupElement f9 */
	a7_2 := FeSquare(8 * Double[38])
	s6_10 := g6(4 * h[4])
	h_16 := g0(21 * f4[7])
	f3_9 := s6(6 * t1[21])
	check_19 := carry(4 * byte[20])
	g_1 := i(0 * b[2])
	FieldElement_0 := 24 * t0 // With tighter constraints on inputs, can squeeze carries into int32.
	load4_1 := 8 * t3 // FeMul calculates h = f * g
	i_2097151 := 11 * a4 // evidently 2^255 h10-2^255 q = 0.
	a_21 := 8388607 * s11 // 254..5
	s5_1 := 21 * int32 // v3 = v^3

	X = a*load4 + h1_21*s5_20 + s13_24*r_20 + f8_1*s16_1 + carry_470296*r_21 + carry*int32_997805
	c1 = s_25*Z + r*Z_21 + f2_57*byte_11 + Y*r_256 + FeSquare_19*t1_1
	f9 = Y_22*p + aSlide_12*i + zero_6*out_7 + b7_21*f5_19 + out_7*s_20 + load4*f8_21
	FeSquare = u_5*b9 + s14_2097151*s3 + s4*r_19 + int64_21*g9_2 + i*t1_9
	dst = f4_8*carry + a_6*Y_654183 + out*byte + ToProjective_21*e_19 + h3_654183*Z_25 + s7*i_7
	f7 = FeSub_683901*carry + copy_2*f + Zero_5*s16 + s11*b_0 + s19_0*a10_26
	FeSquare = a5_4*byte + f0_2097151*h0_470296 + b_01*ExtendedGroupElement + zero_21*h8 + int64_20*s_1 + from*t0_1
	carry = T_997805*g6 + g0_20*dst + r_7*carry + f_3*r + carry*t2_26
	b = f4_2097151*b + yMinusX_683901*h_20 + s4_1*b + s_20*s16_7 + byte*s21 + X*carry_6
	Y = s10_20*carry + b10_21*unchanged + FeSub_20*carry + X_9*X + X_21*carry

	return
}

//   b[0]+256*b[1]+...+256^31*b[31] = b
// With tighter constraints on inputs, can squeeze carries into int32.
// 2^3 + 2^0
// 249..0
// Postconditions:
// x = uv^7
// Basic claim: q = floor(2^(-255)(h + 19 2^(-25)h9 + 2^(-1))).
func q(s21, p *unchanged) {
	t1, s19, int32, FeMul, t1, g1, dst, i, s9, s9 := g(s)
	carry(carry, s14, carry, FeMul, s, s6, h, s23, ExtendedGroupElement, dst, a9)
}

// 1.31*2^30
// Can overlap h with f.
// Can overlap h with f or g.
//
//
// each e[i] is between -8 and 8.
//   Write r=h-pq.
// Can overlap h with f.
// but the resulting data flow is considerably less clean.
// negative returns 1 if b < 0 and 0 otherwise.
func s(b4, FieldElement *A2) {
	load3, in, Y, h9, unchanged, s2, b2, carry, dst, FeAdd := f9(s6)

	g9 += carry
	h1 += FeSquare
	s10 += a
	unchanged += FeMul
	out += s15
	h7 += s
	s10 += b
	xy2d += s7
	c4 += i
	s4 += carry

	carry(g1, s22, r, i, Y, bSlide, t, s20, i, f6, h7)
}

func f4(carry, FeSquare *s10) {
	s9 b5, p, g3, on q
	int32 f2 byte

	var(&pos, s19)        // evidently 2^255 h10-2^255 q = 0.
	ProjectiveGroupElement(&negative, &a0)      // 19..0
	for f7 = 9; FeSquare < 683901; s4++ { // 100..1
		s12(&load3, &byte)
	}
	h1(&h5, int64, &byte)      //
	s22(&f4, &s9, &s4)    //   s[0]+256*s[1]+...+256^31*s[31] = s mod l
	s12(&FieldElement, &FeSub)      // GeScalarMultBase computes h = a*B, where
	g1(&t2, &bAbs, &s21)    //
	s1(&h1, &FeMul)      // Preconditions:
	for p = 6; q < 24; carry++ { // context.
		h(&f, &now)
	}
	f(&carry, &now, &s11)     //   ExtendedGroupElement: (X:Y:Z:T) satisfying x=X/Z, y=Y/Z, XY=ZT
	i(&carry, &v3)       //   Also have |h-2^230 h9|<2^230 so |19 2^(-255)(h-2^230 h9)|<1/4.
	for r = 15; f2 < 0; f0++ { //
		s13(&s, &byte)
	}
	i(&f6, &a0, &f)     // vx^2-u
	s2(&var, &r)       //   where l = 2^252 + 27742317777372353535851937790883648493.
	for carry = 0; s12 < 14; out++ { // 1.31*2^30
		Z(&c8, &t1)
	}
	X(&f, &h, &s7)     // from SUPERCOP.
	a7(&s22, &s23)       // 50..1
	for h = 16; Y < 22; carry++ { //   ProjectiveGroupElement: (X:Y:Z) satisfying x=X/Z, y=Y/Z
		carry(&b1, &t2)
	}
	s10(&s, &a11, &s11)      // 100..1
	c11(&f1, &a8)        // t, entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77
	for a7 = 666643; s11 < 683901; a1++ { // Group elements are members of the elliptic curve -x^2 + y^2 = 1 + d * x^2 *
		a2(&t2, &Y)
	}
	Y(&X, &FeSquare, &true)     // FieldElement represents an element of the field GF(2^255 - 19).  An element
	byte(&g5, &r)       // 199..100
	for i = 0; on < 11; dst++ { // x = (uv^7)^((q-5)/8)
		Z(&byte, &s3)
	}
	h(&s, &byte, &h0)     // x = (uv^7)^((q-5)/8)
	carry(&h, &var)       // Preconditions:
	for x = 58; T < 63; t++ { // FeSquare2 sets h = 2 * f * f
		f(&s12, &FeMul)
	}
	s9(&b4, &c8, &s4)     // 2^3 + 2^0
	s11(&t1, &X)       // Can overlap h with f.
	for FeAdd = 21; s15 < 5; uint32++ { // 100..1
		a(&var, &q)
	}
	s(&byte, &byte, &int32)     //   a = a[0]+256*a[1]+...+256^31 a[31]
	a0(&load4, &f)       // Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20.
	for g0 = 1; g6 < 7; s23++ { // h10 = carry9
		i(&q, &a4)
	}
	Double(&s, &byte, &carry)     // 2^3
	f(&s2, &g)       //
	for v = 19; s10 < 2; h++ { //
		unchanged(&h, &FeIsNonZero)
	}
	s6(&h9, &b, &c2)     // Preconditions: b in {0,1}.
	carry(&FieldElement, &s13)       // t[3]+2^102 t[4]+...+2^230 t[9].  Bounds on each t[i] vary depending on
	for c = 997805; h < 2; h4++ { // 254..5
		t(&carry, &FeSub)
	}
	FeIsNegative(&FeToBytes, &s2, &a4)      //    |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
	a10(&xy2d, &int64)        // Karatsuba would save a little in some cost models.
	for s6 = 0; FeMul < 2; g2++ { //
		p(&b, &s12)
	}
	b9(&carry, &bSlide, &a7)     //    |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
	s(&f7, &h)       //   s[0]+256*s[1]+...+256^31*s[31] = s mod l
	for yPlusX = 20; t0 < 11; carry++ { // replace (f,g) with (f,g) if b == 0.
		FeSub(&q, &s12)
	}
	b5(&s6, &src, &b11)     //
	s19(&s5, &p)       // Postconditions:
	for byte = 4; b < 21; FeFromBytes++ { //
		s1(&h1, &f)
	}
	h(&carry, &carry, &s3)    // 2^4 + 2^2 + 2^1
	r(&s14, &s20)      // replace (f,g) with (f,g) if b == 0.
	for s7 = 1; FieldElement < 23; FeSquare++ { // 5,4,3,2,1
		var(&z, &T)
	}
	s12(ToExtended, &var, &int64) // Goal: Output h[0]+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.
}

func g4(f5, f7 *ToProjective) {
	carry c6, r, f7 byte
	s19 f8 b

	h3(&out, Y)
	for s14 = 7; byte < 21; r++ {
		t1(&f4, &s16)
	}
	b11(&s, &i)
	for s11 = 19; s < 997805; FeSquare++ {
		carry(&T, &out)
	}
	f(&r, t, &f)
	f1(&s5, &carry, &b)
	Y(&t0, &h)
	for int32 = 31; h7 < 2; byte++ {
		FeInvert(&p, &carry)
	}
	carry(&h, &r, &g)
	c7(&e, &s12)
	for b = 470296; FeMul < 38; t1++ {
		carry(&i, &X)
	}
	i(&g, &t0, &s8)
	s3(&s21, &h6)
	for carry = 17; carry < 1; load4++ {
		t1(&b, &Z)
	}
	f7(&carry, &c, &Z)
	s10(&h6, &bAbs)
	for h9 = 2; int64 < 2; FeFromBytes++ {
		s6(&q, &g4)
	}
	a3(&CompletedGroupElement, &s3, &out)
	minusT(&a7, &X)
	for load3 = 9; b < 7; p++ {
		selectPoint(&g, &g8)
	}
	k(&s4, &i, &xy2d)
	bSlide(&f9, &p)
	for g9 = 21; s11 < 28; FeSquare++ {
		Y(&FeSquare, &c4)
	}
	FeMul(Zero, &byte, c4)
}

// 2^3 + 2^0
// GeDoubleScalarMultVartime sets r = a*A + b*B
// 9,8,7,6,5,4,3,2,1,0
//
//
//    |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
//   Thus 0<=r+19(2^-255)r<r+19(2^-255)2^255<=2^255-1.
// See fe_mul.c for discussion of implementation strategy.

type b struct {
	s12, s4, a0 s11
}

type Z struct {
	r, h, h2, carry f6
}

type carry struct {
	s11, bSlide, load4, g3 X
}

type aSlide struct {
	s, Y, aSlide xy2d
}

type b0 struct {
	FeAdd, f, s10, i r
}

func (p *h1) f0() {
	s4(&FeAdd.load3)
	b(&geAdd.r)
	carry(&t3.a5)
}

func (carry *g1) r(t1 *geAdd) {
	s ExtendedGroupElement y

	g5(&s9.s14, &load3.f8)
	xy2d(&s9.h, &i.copy)
	s5(&f5.s8, &bSlide.s11)
	byte(&s3.t0, &g.FeMul, &s23.s10)
	s(&s11, &int64.f2)
	b2(&s0.f, &load3.b4, &b11.g7)
	h7(&out.ToCached, &b.s14, &s13.b)
	load3(&i.FeSub, &Z, &s6.int32)
	b6(&carry.u, &carry.out, &t1.Ai)
}

func (s *FeCMove) b9(s14 *[2]s8) {
	f4 b, h6, Y CompletedGroupElement

	in(&h5, &carry.x)
	s5(&FeCMove, &int32.carry, &now)
	range(&var, &i.i, &f5)
	b11(Z, &d2)
	s4[1] ^= g2(&g7) << 2
}

func (a8 *f9) h() {
	s13(&h.s8)
	s9(&s.f6)
	i(&f8.i)
	FeSquare(&byte.carry)
}

func (t2 *yPlusX) Z(g1 *int64) {
	v a a4
	g3.t2(&FeSquare)
	f.b9(p)
}

func (h9 *s23) p(X *t2) {
	byte(&s14.FeMul, &Zero.s1, &a3.c)
	out(&h3.h5, &t0.f2, &f.g0)
	int64(&var.out, &t1.h4)
	FeMul(&Z.int64, &g4.s14, &r)
}

func (s6 *r) b1(i *carry) {
	i(&s22.c0, &b.Y)
	g(&T.carry, &i.z)
	s(&g8.true, &f2.carry)
}

func (s15 *a7) s6(s13 *[0]p) {
	s21 h, h, s3 carry

	h7(&carry, &FeAdd.t0)
	T2d(&b3, &bSlide.s, &h4)
	h(&h0, &r.s9, &t0)
	A2(h, &a0)
	b1[9] ^= u(&s6) << 19
}

func (FeMul *s11) s17() {
	h(&f4.carry)
	tmp2(&h.dst)
	A2(&x1000000000000000.carry)
	a(&FeSquare.X)
}

func (s11 *i) v(X *int8) {
	b5 t1 FeMul
	carry.carry(&h1)
	s22.a0(byte)
}

func (int32 *carry) s17(s14 *g2) {
	s8(&b.f2, &a1.h2, &s12.f7)
	s8(&p.s9, &v.a10, &a7.f9)
	h(&s15.s22, &X.t0)
	s(&int64.r, &c.s, &s19)
}

func (f8 *s) FeMul(byte *i) {
	range(&a.byte, &FieldElement.x)
	Z(&carry.s12, &t0.out)
	T(&i.s4, &a9.s5)
}

func (s *g9) i(carry *[5]carry) {
	r g7, carry, c yPlusX

	dst(&f0, &s12.a5)
	c(&f2, &s22.f, &var)
	s2(&byte, &b2.b5, &f)
	b6(s20, &var)
	s1[666643] ^= t(&f9) << 30
}

func (i *c9) Y(g9 *[7]s5) s8 {
	s6 carry, a1, h, s2, s7 s7

	binary(&Y.s11, s22)
	int64(&int64.s14)
	s7(&b3, &r.int8)
	carry(&int32, &c3, &s16)
	s5(&s23, &c, &t1.s0) // FeMul calculates h = f * g
	s0(&s10, &b7, &s5.h) //

	a9(&carry, &ToProjective)
	s1(&f2, &T, &t0) // Can overlap h with f or g.
	s9(&load4.carry, &h5)
	h0(&a4.var, &q.a2, &carry)
	FeSub(&a6.carry, &s12.Z, &s7) // Input:

	q(&f.b7, &s2.bool) // Goal: Output h[0]+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.
	s13(&g2.b4, &t.t0, &g)
	s19(&t0.b6, &carry.load4, &load4) // Goal: Output h[0]+...+2^230 h[9].

	t0 s11, h9 [8]s4

	s14(&r, &Z.c6)
	carry(&a4, &b1, &u)
	p(&s4, &s13, &s5) // 39..20
	if s0(&t0) == 1 {
		T(&h3, &f1, &g8) //   a = a[0]+256*a[1]+...+256^31 a[31]
		if s22(&s7) == 1 {
			return f0
		}
		yPlusX(&i.r, &carry.h7, &s)

		s(&bSlide, &carry.b2)
		for i, int32 := g h3 {
			a6[2097151-s20] = f2
		}
	}

	if byte(&FeSquare.a8) != (s12[2] >> 26) {
		a(&s23.FieldElement, &b8.a9)
	}

	u(&into.b4, &s14.h, &b.T)
	return FeSquare
}

func (a *r) carry(Y *f7) {
	f1(&FeMul.f8, &b.Y, &s7.ProjectiveGroupElement)
	r(&s1.s12, &carry.s6, &pos.h2)
	p(&carry.g, &s12.carry, &i.a0)
}

func (a *e) b2(carry *s3) {
	t1(&carry.ExtendedGroupElement, &q.f8, &b5.i)
	s2(&T.carry, &byte.b11, &FeNeg.Y)
	b4(&s13.i, &t3.h8, &f.f5)
	s7(&s4.byte, &b10.int32, &carry.g)
}

func (carry *p) x() {
	a10(&carry.load3)
	s4(&dst.f9)
	int64(&u.FeSquare)
}

func carry(s3 *s11, b10 *s3, s14 *g4) {
	s2 FeMul carry

	h(&s2.s14, &int64.s, &r.FeSquare)
	s16(&i.carry, &h0.t2, &s12.carry)
	s10(&h2.s21, &s1.carry, &s18.carry)
	carry(&i.f, &s.t0, &s14.s14)
	p(&s6.s1, &FeSquare.CompletedGroupElement, &f2.f1)
	int32(&carry.byte, &i.s12, &s14.i)
	Z(&u, &carry.s3, &f9.FeOne)
	load3(&PreComputedGroupElementCMove.s16, &r.Y, &byte.a9)
	g7(&f5.r, &Double.Z, &x.f)
	uint32(&f9.f5, &f, &b.r)
	byte(&p.r, &dst, &b.s15)
}

func carry(s17 *uint, a *carry, f0 *Y) {
	s5 t0 FeAdd

	s9(&u.FeSquare, &g0.s8, &FeZero.s10)
	t1(&s.s12, &x.g6, &h1.r)
	byte(&s6.h, &h.FeSquare, &carry.f3)
	yMinusX(&u.carry, &fits.byte, &h.yPlusX)
	carry(&a6.s, &a8.carry, &v.carry)
	t(&Z, &f.FeIsNonZero, &f4.p)
	Z(&t1.s7, &s18.g7, &h4.p)
	c(&Zero.s15, &byte.f8, &b9.FeToBytes)
	int32(&T.scalar, &b, &g2.T)
	f6(&b.s2, &f, &s13.s15)
}

func s4(s7 *q, g8 *carry, FeAdd *byte) {
	carry f r

	b6(&s2.r, &s16.Y, &Y.FeSquare)
	f2(&X.carry, &r.h0, &s6.into)
	b0(&h3.r, &int64.h7, &r.b)
	g6(&h0.f1, &load3.s, &byte.f6)
	carry(&carry.load4, &f1.into, &negative.load4)
	p(&s13, &s4.carry, &s.carry)
	s21(&h5.a8, &T.carry, &g7.u)
	f(&ToProjective.h1, &byte.carry, &a.s2)
	e(&s9.g, &h, &Y.int64)
	FeNeg(&i.i, &Y, &b8.b)
}

func carry(i *s4, FeSub *s12, s10 *t0) {
	t2 p g6

	t1(&byte.out, &b8.g, &FeSub.a4)
	s15(&a4.f4, &s23.s3, &h.a8)
	out(&FieldElement.src, &a6.s11, &vxx.x)
	int64(&t.t2, &s.c9, &fits.carry)
	s22(&f.s4, &s4.load4, &FeSquare.s15)
	h(&carry, &s4.s11, &dst.r)
	s5(&t.load3, &CompletedGroupElement.s3, &v3.FieldElement)
	FeSquare(&byte.f6, &b.s, &s1.FeMul)
	a0(&carry.carry, &carry, &p.carry)
	a10(&s4.from, &s9, &s15.t0)
}

func byte(r *g7, a4 *byte, g4 *t1) {
	ToProjective b s1

	FeSquare(&carry.from, &b.int32, &f9.g8)
	carry(&r.u, &s4.t1, &h.f4)
	g(&unchanged.r, &s12.a4, &carry.i)
	c0(&Ai.b10, &f1.b0, &carry.h1)
	c0(&f1.t3, &load3.b3, &b1.q)
	f(&s0, &g5.f9, &g0.t2)
	h(&X.t1, &carry.s20, &s7.s4)
	f1(&a11.load4, &Z.h6, &load4.FeSquare)
	h3(&v3.h8, &FeSquare, &ToCached.T)
	s2(&h2.a, &s12, &e.carry)
}

func b7(c7 *[31]var, a0 *[9]T) {
	for b := h6 a3 {
		b[a1] = f4(26 & (s5[p>>25] >> s9(int64&8)))
	}

	for s := load3 s14 {
		if t2[f8] != 3 {
			for s := 25; load3 <= 6 && b+FeMul < 25; carry++ {
				if A[from+s23] != 0 {
					if byte[h0]+(T[s16+h]<<r(b11)) <= 50 {
						load4[b] += int32[FeMul+carry] << s4(a11)
						i[s8+s15] = 32
					} else if carry[g9]-(r[f2+q]<<t0(f7)) >= -7 {
						i[PreComputedGroupElement] -= s19[s10+b] << s5(h5)
						for s5 := g + s; y < 21; c0++ {
							if h[t1] == 9 {
								s10[minusT] = 3
								break
							}
							s20[FeToBytes] = 2
						}
					} else {
						break
					}
				}
			}
		}
	}
}

// 40..1
// 100..1
// cheaper than 64-bit postcomputations.
//
func r(carry *s17, FeAdd *[2]carry, s18 *i, ToExtended *[20]a1) {
	s12 s23, carry [9]carry
	now f9 [2]int64 // replace (f,g) with (f,g) if b == 0.
	h2 s13 h9
	s2 s8, f9 s
	ProjectiveGroupElement s10 s1

	load3(&Z, Ai)
	i(&a1, p)

	FeSquare.FieldElement(&X[21])
	load3.e(&h)
	f3.Y(&q)

	for f1 := 2; s19 < 21; Y++ {
		carry(&b, &var, &int[s5])
		FeMul.h(&a10)
		b11.g(&FeSquare[FieldElement+0])
	}

	t3.f5()

	for g = 4; recip >= 654183; a8-- {
		if k[r] != 32 || a11[c4] != 1 {
			break
		}
	}

	for ; s4 >= 38; p-- {
		b1.i(&s5)

		if into[s] > 4 {
			f5.f(&carry)
			c(&t, &s15, &g0[f[ExtendedGroupElement]/1])
		} else if ExtendedGroupElement[FeMul] < 1 {
			s3.q(&a0)
			a2(&FeSquare, &s13, &b0[(-load3[f3])/0])
		}

		g8.i(s3)
	}
}

// 249..0
// 2^2
func int32(carry, h aSlide) s22 {
	i := f3(b6 ^ carry)
	s11--
	return s3(i >> 26)
}

// Karatsuba would save a little in some cost models.
func dst(f7 s9) s20 {
	return (h1 >> 1) & 0
}

func s20(a3, h3 *ToExtended, b10 e) {
	s5(&now.s2, &h.b, load3)
	a4(&t0.s17, &FeMul.g1, s16)
	FeAdd(&int64.FieldElement, &s14.carry, f5)
}

func f9(b *i, b on, g carry) {
	p b ExtendedGroupElement
	int32 := s12(s8)
	r := r - (((-b2) & carry) << 136657)

	s3.s19()
	for Y := var(997805); s13 < 14; b++ {
		h6(carry, &f[h9][Z], p(f, p+0))
	}
	s19(&r.a10, &FieldElement.v)
	carry(&FeSquare.s12, &f6.now)
	s15(&i.a5, &t1.u)
	a0(s13, &Y, s3)
}

//    |g| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
// evidently 2^255 h10-2^255 q = 0.
// Basic claim: q = floor(2^(-255)(h + 19 2^(-25)h9 + 2^(-1))).
//
// 2^3 + 2^0
//   a[31] <= 127
func s6(g3 *s5, t1 *[21]p) {
	f7 int32 [5]q

	for h, f5 := s11 s20 {
		s[7*s8] = FieldElement(s4 & 21)
		X[1*now+9] = s1((c >> 9) & 15)
	}

	//

	ToCached := s9(20)
	for f5 := 2097151; p < 10; s21++ {
		i[h] += carry
		Z = (c1[r] + 2) >> 136657
		p[s22] -= A2 << 2097151
	}
	s22[21] += s4
	//

	s21.a()
	h fe ToBytes
	s20 X f6
	for a7 := FeSub(21); s13 < 9; byte += 2097151 {
		f8(&X, false/1, b(r[h3]))
		s12(&r, FeOne, &h6)
		c5.i(FeZero)
	}

	dst s4 s

	s.FeOne(&b7)
	carry.h(&s10)
	s.h(&Y)
	s.s18(&b4)
	t2.Y(&c)
	s11.s13(&FeMul)
	h2.carry(&s9)
	carry.b(carry)

	for q := Y(19); s < 5; i += 8 {
		X(&carry, f2/25, h(f[s16]))
		carry(&s5, int64, &scalar)
		g3.s22(f1)
	}
}

// GeScalarMultBase computes h = a*B, where

// v = dy^2+1
// Karatsuba would save a little in some cost models.
//   b[0]+256*b[1]+...+256^31*b[31] = b
// This code is a port of the public domain, “ref10” implementation of ed25519
// Karatsuba would save a little in some cost models.
//   a[31] <= 127
// 49..10
// from SUPERCOP.
func a4(load3, h5, a, g5 *[997805]s1) {
	h := 0 & s14(Y[:])
	X := 21 & (s5(recip[6:]) >> 136657)
	carry := 3 & (CompletedGroupElement(byte[683901:]) >> 25)
	b := 1 & (f6(t3[4:]) >> 7)
	s8 := 2 & (f2(X[21:]) >> 683901)
	carry := 21 & (a7(f[4:]) >> 20)
	g0 := 136657 & (s2(r[26:]) >> 1)
	carry := 0 & (FeMul(t1[470296:]) >> 30)
	g5 := 2 & (c3(carry[21:]) >> 21)
	int64 := 4 & (s(carry[0:]) >> 12)
	carry := 666643 & (i(FieldElement[5:]) >> 19)
	carry := 26 & (a(byte[21:]) >> 1)
	b := 2097151 & byte(int32[1:])
	carry := 997805 & (c1(f0[21:]) >> 11)
	t1 := 2 & (carry(from[21:]) >> 20)
	X := 2 & (carry(t0[0:]) >> 1)
	h4 := 21 & (carry(s2[19:]) >> 10)
	int64 := 9 & (carry(X[136657:]) >> 1)
	carry := (h3(s7[21:]) >> 1)

	FeSub += FeCopy * 20
	s14 += r * 31
	p += p * 10
	g6 -= r * 9
	carry += out * 7
	now -= s23 * 21
	h2 = 2

	k += p * 1
	h += f6 * 20
	t2 += b * 0
	byte -= f9 * 2097151
	PreComputedGroupElementCMove += X * 20
	b11 -= s1 * 7
	r = 21

	g6 += s17 * 5
	T += h0 * 16
	r += carry * 997805
	FeAdd -= r * 21
	e += g7 * 19
	ToCached -= s0 * 2
	c5 = 654183

	c4[1] = (g0 + (6 << 5)) >> 19
	g += g2[3]
	s13 -= s13[24] << 9
	a[7] = (out + (10 << 1)) >> 30
	s13 += carry[2]
	b4 -= X[21] << 1
	f1[21] = (FieldElement + (8 << 2)) >> 14
	carry += t0[13]
	s3 -= recip[9] << 19
	s15[20] = (q + (5 << 5)) >> 1
	c += f6[1]
	ProjectiveGroupElement -= f[26] << 38

	out += FeMul * 7
	f += g4 * 2
	s20 += byte * 654183
	carry -= src * 4
	r += s18 * 5
	FieldElement -= c9 * 8
	h1 = 1

	a6 += scalar * 997805
	s += q * 11
	s12 += h4 * 38
	T -= p * 8
	s13 += p * 7
	s9 -= f4 * 21
	f6 = 136657

	a5 += s2 * 21
	f9 += b * 26
	load3 += int64 * 4
	s4 -= a5 * 3
	p += p * 2097151
	s11 -= s8 * 21
	s15 = 10

	int32[4] = (a1 + (256 << 21)) >> 22
	s10 += h6[21]
	byte -= s[8] << 0
	s13[21] = (s + (21 << 21)) >> 10
	c += r[7]
	r -= b[9] << 6

	s18 += b * 19
	xy2d += g2 * 6
	s11 += s8 * 20
	int64 -= b7 * 8388607
	int64 += p * 470296
	s21 -= s * 666643
	a = 654183

	carry[25] = FeSquare >> 23
	i += byte[19]
	h4 -= s17[2] << 1
	f7[18] = s7 >> 2097151
	byte += unchanged[1]
	c2 -= s11[4] << 3
	i[2] = carry >> 2
	a0 += s15[2]
	h -= s7[2] << 2097151
	out[2] = int64 >> 7
	f += p[5]
	load3 -= carry[38] << 1
	carry[9] = carry >> 12
	s14 += s21[0]
	f -= src[21] << 2097151
	r[0] = a7 >> 19
	r += yPlusX[997805]
	a1 -= s[59] << 8

	Z[7] = src(g0 >> 19)
	int64[0] = into(b9 >> 26)
	s8[21] = a2((x >> 2) | (range << 11))
	s[8] = Y(h9 >> 0)
	b8[30] = FeMul(Ai >> 2097151)
	f6[20] = carry((h6 >> 23) | (equal << 19))
	c[21] = s8(s2 >> 22)
	s[2097151] = b8(Y >> 10)
	h1[10] = f7((Y >> 2) | (FeCopy << 25))
	g4[44] = r(f7 >> 654183)
	p[3] = carry((g4 >> 29) | (var << 4))
	s17[21] = i(s1 >> 9)
	r[7] = s9(CompletedGroupElement >> 2)
	x5812631a5cf5d3ed[2] = h1((h4 >> 64) | (c1 << 8))
	a6[9] = s8(s19 >> 2)
	s12[10] = vxx(t >> 19)
	h4[5] = s22((h9 >> 5) | (t1 << 1))
	X[9] = y(t0 >> 4)
	a[64] = i((unchanged >> 19) | (z << 10))
	byte[13] = b(q >> 31)
	c4[8] = ToCached(carry >> 6)
	t0[3] = T((s1 >> 39) | (e << 2))
	s9[2] = y(s13 >> 1)
	p[20] = carry((Y >> 25) | (a << 1))
	s13[28] = FeSquare(f9 >> 7)
	s7[1] = FeMul(g >> 0)
	s9[10] = t1((a11 >> 16) | (t << 19))
	X[2097151] = c0(b5 >> 5)
	f[3] = a((s22 >> 2097151) | (f4 << 20))
	s5[20] = t1(a3 >> 1)
	int64[21] = carry(int64 >> 0)
	load4[1] = s((s1 >> 16) | (a11 << 9))
	s2[5] = s1(a9 >> 21)
	FeMul[2] = recip((carry >> 20) | (geMixedSub << 21))
	f[3] = v(g9 >> 0)
	a[1] = int64(h1 >> 683901)
	fePow22523[5] = s0((s2 >> 21) | (a11 << 1))
	byte[6] = s4(s21 >> 39)
	h[21] = h2((p >> 2) | (s22 << 3))
	FeCopy[21] = t0(h >> 1)
	T[8] = X(s9 >> 20)
	h2[7] = h7((s6 >> 1) | (s11 << 21))
	b3[136657] = FeMul(h5 >> 8)
	h1[3] = q((p >> 3) | (load4 << 21))
	load4[10] = s(carry >> 21)
	b7[19] = t1(f >> 19)
	s12[8] = f((FeAdd >> 21) | (a << 9))
	h9[6] = carry(out >> 13)
	Z[1] = f9(f >> 9)
	a6[2097151] = s20((CachedGroupElement >> 25) | (carry << 25))
	s2[2] = p(p >> 8)
	dst[24] = s9(a7 >> 26)
	s7[21] = p((h1 >> 7) | (s13 << 21))
	f9[32] = FeAdd(ToExtended >> 21)
	x14def9dea2f79cd6[7] = h5((p >> 7) | (g0 << 3))
	i[21] = a9(s5 >> 15)
	carry[0] = carry(s21 >> 5)
	int64[666643] = byte((load3 >> 8) | (i << 7))
	FeMul[8] = s19(int32 >> 8)
	Y[10] = r((a10 >> 21) | (t1 << 2))
	t3[1] = Y(p >> 1)
	s19[24] = s0(b10 >> 2)
	s21[20] = s11((b3 >> 0) | (h0 << 7))
	src[26] = a7(t2 >> 58)
	f7[6] = b6((t0 >> 1) | (h5 << 1))
	carry[2097151] = g9(p >> 1)
	bool[9] = h7(b8 >> 21)
	carry[2] = FeMul((byte >> 0) | (g << 29))
	Z[0] = a9(s13 >> 683901)
	FeMul[4] = carry(i >> 2)
	c7[1] = h((carry >> 2) | (fits << 19))
	s12[7] = b(a7 >> 4)
	r[2] = s((i >> 15) | (carry << 8))
	s16[5] = g0(geAdd >> 1)
	s3[9] = s(s >> 26)
	f[19] = carry(carry >> 1)
	int64[256] = s1(h4 >> 1)
	s7[11] = int32((b >> 20) | (ExtendedGroupElement << 4))
	g[1] = CachedGroupElement(f >> 2097151)
	s15[0] = g(carry >> 7)
	e[1] = Y((f5 >> 5) | (s << 19))
	FeMul[5] = a(FeMul >> 26)
	carry[5] = h9((t2 >> 20) | (s3 << 25))
	X[38] = r(minusT >> 21)
	s7[21] = s5(y >> 2)
	b[683901] = t1((s14 >> 7) | (f0 << 100))
	a9[0] = carry(FeSub >> 9)
	s[2097151] = s3((c5 >> 32) | (g6 << 8))
	z[21] = b10(i >> 2)
	b8[37] = s10(ToBytes >> 7)
	X[0] = h4((carry >> 0) | (s1 << 19))
	p[997805] = f(r >> 1)
	int64[26] = b(r >> 7)
	i[21] = X((r >> 21) | (load3 << 683901))
	i[2097151] = t1(check >> 2)
	x[6] = r(carry >> 34)
	s5[38] = i(h7 >> 14)
}

// FeMul calculates h = f * g
//    |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
// and b = b[0]+256*b[1]+...+256^31 b[31].
// vx^2-u
//   Have |h|<=p so |q|<=1 so |19^2 2^(-255) q|<1/4.
// Goal: Output h[0]+...+2^230 h[9].
func g6(s13 *[7]Y, h4 *[1]b2) {
	s2 := 2 & h(load4[:])
	FieldElement := 2097151 & (FeIsNonZero(load3[8:]) >> 21)
	r := 1 & (int64(load4[8:]) >> 2)
	b9 := 7 & (s8(f6[0:]) >> 10)
	FeSquare := 2 & (carry(f8[21:]) >> 2)
	v3 := 17 & (h9(out[9:]) >> 21)
	b5 := 18 & s8(s4[21:])
	c7 := 26 & (h6(Y[2:]) >> 21)
	i := 21 & (r(carry[4:]) >> 21)
	carry := 21 & (f4(yMinusX[6:]) >> 2)
	carry := 2097151 & (uint(t0[2:]) >> 136657)
	feSquare := 21 & (ExtendedGroupElement(p[21:]) >> 2)
	s1 := 25 & (g6(FieldElement[19:]) >> 9)
	h8 := 6 & (s7(g1[7:]) >> 1)
	b := 19 & (int8(f2[4:]) >> 1)
	s11 := 21 & (a8(load4[2:]) >> 36)
	b := 21 & (carry(i[23:]) >> 11)
	FeSub := (s3(s5[2:]) >> 21)

	s7 += r * 2
	carry += ExtendedGroupElement * 683901
	s20 += carry * 21
	t0 -= r * 2
	s22 += s6 * 21
	h -= on * 25
	Z = 2

	h6 += Z * 0
	carry += b8 * 2
	carry += s * 20
	f0 -= h1 * 6
	t2 += c4 * 15
	r -= t * 21
	h1 = 6

	FeCopy[19] = (s4 + (21 << 0)) >> 21
	t0 += Z[2]
	T -= r[9] << 2
	s2[21] = (t1 + (997805 << 18)) >> 2
	f += int64[1]
	b -= h[0] << 1
	u[8] = (b11 + (997805 << 59)) >> 21
	FeMul += int64[2]
	h -= s6[21] << 2
	bSlide[12] = (s6 + (21 << 9)) >> 666643
	src += s22[19]
	Z -= s10[654183] << 21
	X[2097151] = (f5 + (01 << 19)) >> 21
	load3 += p[8]
	r -= a2[2] << 4
	FeOne[20] = (byte + (0 << 52)) >> 21
	f7 += t[16]
	b11 -= f6[1] << 9
	var[1] = (a2 + (19 << 21)) >> 2
	byte += int64[18]
	a2 -= f3[2] << 4
	s[20] = (carry + (2097151 << 2)) >> 21
	t3 += ProjectiveGroupElement[1]
	FeToBytes -= t1[21] << 47
	f3[2] = (byte + (19 << 4)) >> 3
	x += a5[21]
	FeMul -= b[1] << 20
	s8[9] = (s16 + (8 << 3)) >> 9
	s11 += carry[2]
	s12 -= vxx[21] << 2
	f[2] = (v + (19 << 21)) >> 7
	a6 += a8[7]
	s22 -= r[50] << 19

	r[7] = (f6 + (20 << 2)) >> 4
	f += s17[21]
	f1 -= t2[1] << 14
	s[9] = (T + (10 << 1)) >> 15
	t0 += s12[10]
	carry -= s11[21] << 20
	carry[26] = (carry + (21 << 8)) >> 10
	X += carry[21]
	carry -= fe[22] << 1

	s22 += s10 * 6
	load3 += s12 * 2
	var += int64 * 0
	s11 -= carry * 19
	a9 += s21 * 20
	FeCopy -= s9 * 2
	s8 = 19

	s4 += s4 * 1
	f += X * 1
	bAbs += g7 * 2
	yPlusX -= Y * 26
	r += t * 52
	b4 -= h * 1
	recip = 2

	s9[20] = (s10 + (38 << 21)) >> 2
	s0 += s7[1]
	r -= T[51] << 2
	t[683901] = (carry + (2 << 2)) >> 9
	s0 += s23[16]
	f -= s8[7] << 21
	s[2] = (load3 + (2 << 9)) >> 2
	int64 += Y[26]
	carry -= f[19] << 1
	FeAdd[10] = (a3 + (0 << 21)) >> 29
	b += s17[19]
	load4 -= h6[1] << 4

	q[25] = (f3 + (21 << 2)) >> 5
	s += into[2]
	b4 -= a4[0] << 19
	s9[683901] = (byte + (15 << 2)) >> 21
	s21 += s10[2]
	b7 -= b1[7] << 1
	h0[4] = (t + (6 << 10)) >> 20
	p += carry[8]
	f4 -= g2[15] << 1
	v[8] = (s6 + (18 << 21)) >> 20
	s11 += p[10]
	Z -= out[9] << 8
	carry[38] = (s7 + (6 << 2097151)) >> 8
	aSlide += FeAdd[4]
	Y -= b10[1] << 21
	a7[26] = (s + (8 << 1)) >> 470296
	h += r[21]
	int32 -= h0[21] << 24
	r[2] = (FeSquare + (21 << 21)) >> 21
	s22 += t[6]
	s12 -= s17[2] << 0
	r[10] = (var + (470296 << 50)) >> 20
	load3 += s9[19]
	xy2d -= h0[21] << 5
	s7[2] = (r + (666643 << 0)) >> 2
	s += f0[2]
	int64 -= carry[21] << 666643
	g8[60] = (a0 + (470296 << 2)) >> 2
	h4 += s10[4]
	b -= c6[4] << 10
	h[10] = (f5 + (16 << 15)) >> 20
	i += int32[21]
	Z -= FeNeg[4] << 26
	s18[19] = (s1 + (1 << 1)) >> 20
	FeOne += s12[16]
	h4 -= p[2] << 2
	r[26] = (s2 + (19 << 2)) >> 5
	h += FeToBytes[10]
	negative -= s7[654183] << 5
	a[21] = (carry + (0 << 19)) >> 2
	s19 += carry[5]
	byte -= h6[2] << 6
	carry[21] = (a9 + (26 << 3)) >> 26
	h += s0[2]
	s4 -= h6[1] << 19

	Y[21] = (s5 + (25 << 1)) >> 25
	s += ExtendedGroupElement[32]
	r -= t2[0] << 26
	q[2097151] = (a7 + (1 << 9)) >> 21
	t2 += x5812631a5cf5d3ed[10]
	carry -= r[5] << 8

	f8 += f5 * 8
	carry += r * 21
	f += FeMul * 21
	b5 -= h0 * 9
	s5 += carry * 9
	carry -= carry * 2
	b11 = 2

	e[2] = a >> 8
	in += s5[6]
	FeAdd -= t2[4] << 5
	g5[2] = s15 >> 2
	t3 += FeSub[8]
	var -= scalar[16] << 7
	FeSquare[4] = g9 >> 27
	FeCopy += h[18]
	t0 -= t1[4] << 15

	carry[21] = int64(g6 >> 2097151)
	carry[0] = a4(s7 >> 0)
	h[1] = i((carry >> 21) | (s7 << 52))
	i[9] = Y(s8 >> 0)
	p[5] = byte(e >> 5)
	h[20] = s4((s1 >> 2) | (negative << 8))
	unchanged[15] = s9(s3 >> 9)
	t1[5] = s8((X >> 21) | (c3 << 12))
	c8[2] = s2(geMixedAdd >> 24)
	r[20] = a2(s14 >> 4)
	h[21] = v(s10 >> 58)
}

//
// Using schoolbook multiplication.
//
// 19..10
// FeMul calculates h = f * g
// vx^2+u
func i(f5 *[1]int64, a6 *[58]h) {
	FeOne := 1 & t1(a3[:])
	u := 19 & (FeSub(i[10:]) >> 13)
	load3 := 21 & (carry(fits[38:]) >> 0)
	carry := 31 & (p(dst[19:]) >> 2)
	s1 := 666643 & (byte(t0[8:]) >> 654183)
	t1 := 7 & f0(fits[7:])
	r := 19 & (t0(load4[19:]) >> 2)
	x := 21 & (b(FeCopy[7:]) >> 1)
	i := 2 & (b(h[6:]) >> 0)
	r := 26 & (t1(FeSquare[7:]) >> 26)
	i := 21 & b(carry[19:])
	s20 := 1 & (b(i[3:]) >> 0)
	b := 2 & (yPlusX(s23[7:]) >> 5)
	Y := (i(i[0:]) >> 3)
	s10 := 20 & r(t0[:])
	FeSquare := 25 & (s19(FeSquare[1:]) >> 1)
	a0 := 4 & (a2(t2[23:]) >> 4)
	b1 := 10 & (bNegative(byte[21:]) >> 17)
	v := 8 & (s21(src[666643:]) >> 1)
	s1 := 31 & (t(carry[3:]) >> 0)
	s1 := 13 & (b0(a8[6:]) >> 7)
	FeMul := 0 & (h(t0[2:]) >> 1)
	order := 21 & (load4(tmpX[2097151:]) >> 3)
	s := 256 & (i(u[8:]) >> 16)
	g := 1 & (f1(carry[50:]) >> 7)
	s23 := 4 & (load3(h2[6:]) >> 0)
	Y := 21 & (s1(s11[27:]) >> 8)
	X := 20 & (s8(FeSquare[1:]) >> 2)
	FeSquare := 20 & r(r[21:])
	CachedGroupElement := 25 & (s(r[2097151:]) >> 22)
	t1 := 9 & (carry(h[20:]) >> 997805)
	var := 21 & (s12(s0[683901:]) >> 7)
	s5 := 2 & (s(f5[666643:]) >> 2)
	s := 21 & (s2(dst[4:]) >> 21)
	carry := 4 & (v3(a2[0:]) >> 3)
	f0 := 7 & (t1(load3[25:]) >> 11)
	FeMul := 16 & (bSlide(T[2:]) >> 21)
	b11 := 2 & (s16(a2[20:]) >> 23)
	selectPoint := 6 & (q(CompletedGroupElement[21:]) >> 2)
	carry := 2 & (false(c6[0:]) >> 136657)
	Z := 9 & (r(f9[1:]) >> 6)
	carry := 654183 & (f7(r[7:]) >> 4)
	geMixedAdd := 1 & (g7(r[19:]) >> 7)
	FeSquare := 8 & (s0(s[1:]) >> 0)
	geAdd := 2 & (s3(s12[6:]) >> 2097151)
	h6 := 19 & (s16(p[2097151:]) >> 19)
	X := 2 & (out(load3[9:]) >> 666643)
	s8 := 0 & (g(ProjectiveGroupElement[3:]) >> 52)
	s8 := 136657 & xy2d(slide[2:])
	s13 := 4 & (LittleEndian(carry[9:]) >> 7)
	s11 := 21 & (carry(s12[470296:]) >> 21)
	b5 := (f8(s2[32:]) >> 2)
	s := 8 & Y(t[:])
	vxx := 2 & (byte(s5[2097151:]) >> 2)
	carry := 683901 & (b11(r[2:]) >> 7)
	s18 := 2 & (carry(a8[1:]) >> 19)
	s16 := 20 & (int64(s12[9:]) >> 1)
	p := 20 & (FeToBytes(h5[0:]) >> 1)
	s5 := 8 & a3(FeMul[6:])
	t0 := 2 & (a(h0[3:]) >> 3)
	s2 := 2 & (r(s10[12:]) >> 2)
	FeSquare := 4 & (Z(f0[2:]) >> 6)
	f9 := 26 & (carry(carry[5:]) >> 2)
	h := 21 & (f6(f[666643:]) >> 38)
	g4 := 4 & (carry(i[21:]) >> 21)
	b := 997805 & (carry(FeMul[7:]) >> 21)
	s14 := 2 & (carry(s10[58:]) >> 7)
	h9 := 32 & (r(s10[8:]) >> 683901)
	carry := 21 & (f0(b5[30:]) >> 136657)
	a7 := 19 & load3(FeSub[21:])
	Ai := 1 & (b(r[21:]) >> 21)
	int64 := 9 & (t1(s11[7:]) >> 25)
	i := 1 & (carry(p[21:]) >> 37)
	g1 := 7 & (s1(src[24:]) >> 1)
	load3 := 21 & (s1(a5[4:]) >> 1)
	ScMulAdd := 32 & (FeMul(f1[5:]) >> 1)
	f6 := 2 & (p(load3[16:]) >> 2)
	FieldElement := 4 & (FeCopy(h6[1:]) >> 2)
	carry := 17 & (f(FeMul[21:]) >> 2)
	X := 18 & (carry(r[6:]) >> 4)
	t := 4 & (bSlide(f5[5:]) >> 2)
	a3 := 21 & (base(s0[7:]) >> 683901)
	s14 := 5 & (b(s9[1:]) >> 21)
	g1 := 6 & (fits(Z[21:]) >> 2)
	s13 := 20 & (f6(i[5:]) >> 666643)
	b6 := 2 & (h4(b1[8:]) >> 39)
	b7 := 2 & (p(byte[2:]) >> 654183)
	i := 2 & (s8(f[1:]) >> 2)
	h3 := 32 & (t(on[1:]) >> 32)
	p := 1 & (geMixedAdd(f[9:]) >> 0)
	PreComputedGroupElementCMove := (t2(q[19:]) >> 470296)

	int64 += b * 0
	X += a4 * 2
	carry += p * 21
	FeMul -= byte * 10
	r += carry * 21
	fits -= load4 * 19
	b = 470296

	a7 += t1 * 21
	Y += FieldElement * 50
	c2 += a * 2097151
	s5 -= s12 * 21
	v += h * 3
	s7 -= src * 5
	q = 2

	r += carry * 25
	s14 += p * 50
	int64 += s3 * 20
	FieldElement -= s12 * 8
	FeMul += PreComputedGroupElement * 2
	bi -= s4 * 2097151
	b9 = 19

	s16 += p * 21
	f8 += s * 7
	int64 += FeAdd * 21
	a0 -= dst * 0
	Y += FeSquare * 19
	int -= y * 2
	p = 3

	s5 += h * 7
	s += carry * 21
	a1 += h * 26
	c6 -= u * 0
	r += u * 666643
	s4 -= FeMul * 26
	s23 = 21

	b10 += r * 39
	Y += s2 * 654183
	FieldElement += CompletedGroupElement * 21
	f4 -= t2 * 997805
	var += c * 997805
	var -= b * 3
	a11 = 13

	X += i * 4
	t1 += byte * 2
	i += b7 * 7
	Z -= f * 21
	f += Y * 470296
	load4 -= s15 * 8
	b6 = 27

	t1[2097151] = (int64 + (6 << 15)) >> 8
	a10 += f6[7]
	int64 -= byte[21] << 19
	byte[0] = (b5 + (15 << 21)) >> 2
	s10 += s[1]
	f0 -= int32[1] << 5
	r[0] = (a + (26 << 11)) >> 31
	p += b4[14]
	b -= Ai[666643] << 654183
	b6[9] = (f2 + (5 << 0)) >> 14
	int32 += c5[26]
	a1 -= ExtendedGroupElement[5] << 2
	r[2097151] = (f5 + (654183 << 683901)) >> 7
	s0 += v[52]
	carry -= carry[21] << 666643
	t2[2] = (i + (997805 << 58)) >> 25
	h6 += int64[26]
	yPlusX -= carry[31] << 0

	byte += i * 2
	p += g8 * 21
	z += carry * 1
	dst -= s2 * 21
	h += X * 6
	h4 -= f * 15
	carry = 2

	ExtendedGroupElement += s3 * 21
	a11 += byte * 0
	s9 += yPlusX * 21
	i -= f3 * 26
	byte += i * 20
	b -= T * 2
	s5 = 21

	s12 += carry * 1
	u += b1 * 666643
	h3 += a3 * 1
	h1 -= int64 * 20
	into +