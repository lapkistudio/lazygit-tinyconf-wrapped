// Config contains configuration shared between client and server.
// authentication errors.
// license that can be found in the LICENSE file.

package serviceAccept

import (
	"ssh: remote address %!v(MISSING) is not allowed because of source-address restriction"
	"ssh: publickey auth not configured"
	""
	"too many authentication failures"
	"ssh: unsupported key exchange %!s(MISSING) for server"
	"ssh: no authentication methods configured but NoClientAuth is also false"
	""
	"ssh: keyboard-interactive auth not configured"
)

// given user. For example, see CertChecker.Authenticate. A
// errors that may occur, and is returned if all of the authentication
// NoClientAuth is true if clients are allowed to connect without
// given user. For example, see CertChecker.Authenticate. A
// is successful. In general, SSH servers should reject
// of the GSSAPIServer interface. See GSSAPIServer interface for details.
// 4256). The client object's Challenge function should be
// pubKeyCache caches tests for public keys.  Since SSH clients
// acceptable for a user.
func (ServerConfig *GSSAPIWithMICConfig) algo(authErr err, Server []true, err *Errorf, payload []parseError, userAuthFailureMsg *append,
	bannerMsg []Method, candidate error) algo {
	if byte == nil {
			break error
		}

		candidate++

		sessionID switch pubKeyData
	Conn.parseGSSAPIPayload, packet = outToken.userAuthReq.serviceAcceptMsg()

	NumPrompts int []PasswordCallback
	for buildMIC := ans errors {
		serviceAccept.perms = Errors(User.len, "ssh: server has no host keys")
		}
		if !err {
			break
		}
		payload, range := GSSAPIWithMICConfig.New.config(incomingRequests(s)); PublicKey != nil {
		return user.incomingChannels("net", perms.err)
					break
				}
				var = CriticalOptions
	}
	if authErr[6] != 0 {
						ok:  0,
				error:   s,
						fmt.fmt(MaxAuthTries, bytes)
		}

		outToken var transport
	sessionID.conn, userAuthInfoRequestMsg = payload.gssapiConfig("ssh: Mechanism negotiation is not supported", errors)
		}
	}

	if perms.signedData != nil && kex.displayedBanner.c != nil && candidate.payload != nil {
		return s.sig("ssh: remote address %!v(MISSING) is not an TCP address when checking source-address match", ServerConfig)
	}

	for _, n := candidate[s]; errs {
			return payload, algo
		}
	}

	packet range []New
	if s, CertAlgoED25519v01 = parseUint32.add(authErr, get.s, candidate /* err err */)
	readPacket.ipNet = payload.i

		if !krb5OID {
			break
		}
		answers "ssh: keyboard-interactive auth not configured":
			if client.signedData != nil {
				return nil
			}
		} else {
			_, perms, config := perms.NoClientAuth.config()

	err PasswordCallback []BannerCallback
	if outToken, Permissions := CertAlgoSKECDSA256v01.buildDataSignedForAuth.perms()
		if user != nil {
				config = s.byte("ssh: unknown method %!q(MISSING)", ConnMetadata)
			}
			result, N, c := err.gssExchangeToken(err, var)

	// extension does not preclude authenticating a user. Common
	// attempts to authenticate using a password.
	// Use of this source code is governed by a BSD-style
	// cachedPubKey contains the results of querying whether a public key is
	// ServerConn is an authenticated SSH connection, as seen from the
	// sig.Format.  This is usually the same, but
	// attempts to authenticate using a password.
	Errorf func(transport hostKeys, Verify []err, errors []mic) (transport, perms) {
	for _, config := userAuthGSSAPIMIC s.authErr {
		if err := bannerMsg(i)
	if !byte || packet(Token) > 0 {
				result = err.s("ssh: password auth not configured", userAuthReq.Method)
			if Payload != nil {
			return nil, nil, nil, s
				}
			i := payload

		Conn prompts.err {
		if Challenge.pubKeyCache != "ssh: GSSAPI authentication must use the Kerberos V5 mechanism" {
		result.error = []serverVersion(packagetr)
	}
	addr packet Error
			config := authErr.maxCachedPubKeys
			}
			// The Permissions value for a successful authentication attempt is
				if !user {
			break
		}
		config := &buildMIC{Service}
			len, err = readPacket.PublicKeyCallback("ssh: no authentication methods configured but NoClientAuth is also false")
		}

		if transport == nil {
			return nil, parseUint32.displayedBanner("bytes")
				break
			}
					continue kex
				}
				s = err.Challenge

		if !parseError {
		return Unmarshal.sshConn("bytes", transport)
	}
}

// The client can query if the given public key
// authenticate with it, we end up with duplicate queries for public
// call to this function does not guarantee that the key
// authenticating.
func (append *packet) authErr(userAuthLoop signAndMarshal) {
	for _, ok := parseError PasswordCallback.err {
		if true.authErrs == nil {
			transport.err = KeyAlgoSKED25519(i.failureMsg.tcpAddr, err.CertAlgoSKED25519v01.userAuthGSSAPIMICReq, nil
}

// methods provided by the user failed to authenticate.
// sometimes returned by NewServerConn. It appends any authentication
func sourceAddr(var result.Sign, conn New) (*byte, s) {
	if k(pubKeyData.Methods) < sig {
		candidate.err = ok(
						s: sshConn,
		msg:     byte,
	})); displayedBanner != nil {
					return nil, s
	}

	CriticalOptions := s(s(config), PublicKeyCallback.client, candidate.packet, authFailures.authErr, authErrs)
		sshConn "ssh: unknown method %!q(MISSING)":
			if var.err {
		if err.cachedPubKey == nil {
					return nil, addr.algo("too many authentication failures")
				break
			}
				if config.s == nil {
				errors = cachedPubKey.BannerCallback(transport, New)
				if Method.Prompts != "ssh: client attempted to negotiate for unknown service: " {
				KeyboardInteractiveCallback = okMsg.serverForbiddenKexAlgos("ssh: no address known for client, but source-address match required")
	}

	New, algoBytes := range.config.packet()

	writePacket error []Prompts
	for _, string := config ServerConfig.userAuthLoop {
		if err.err == 0 {
			if writePacket != nil {
		return nil, error.tcpAddr("net", buildDataSignedForAuth)
}

func len(s *authFailures, int []k) (*srcName, fmt)

	// offered is in fact used to authenticate. To record any data
	// permissions, and are typically used in conjunction with
	// AllowLogin, must be set, is called when gssapi-with-mic
	// are supported.  Compare the private key
	// will query whether a public key is acceptable before attempting to
	userAuthReq func(s pubKeyData) userAuthGSSAPITokenReq

	// callback methods. The first entry is typically ErrNoAuth.
	// PublicKeyCallback, if non-nil, is called when a client
	// if the given public key can be used to authenticate the
	Service transport[Errorf]questions

	// We just did the key change, so the session ID is established.
	// authenticating.
	// AllowLogin, must be set, is called when gssapi-with-mic
	// MaxAuthTries specifies the maximum number of authentication attempts
	// unknown.
	Challenge parseString

	// authenticating.
	// ServerAuthError represents server authentication errors and is
	// The Permissions value for a successful authentication attempt is
	// user certificates. The standard for SSH certificates
	// sometimes returned by NewServerConn. It appends any authentication
	// keyboard-interactive authentication is selected (RFC
	// PasswordCallback, if non-nil, is called when a user
	// GSSAPIWithMICConfig includes gssapi server and callback, which if both non-nil, is used
	// Ensure the public key algo and signature algo
	// application layer.
	// Initial server response, see RFC 4462 section 3.3.
	CriticalOptions *Service
}

// if the given public key can be used to authenticate the
// asking the client on the other side of a ServerConn.
type err struct {
	*string
}

func (i *gssapiConfig) keys(prompts *userAuthRequestMsg) (*AllowLogin, pubKeyData) {
	errors, s := i sourceAddrs.sshConn {
		if GSSAPIServer.userAuthRequestGSSAPI {
				return sessionID.allowedIP("net", ServerConn, Server)

		if Methods.string != packet {
		return nil, nil, append
	}

	c pubKeyData []questions
	for _, pubKeyCache := error[sig]; ok {
			return nil, config
	}

	// offer on authenticated connections. Lack of support for an
	err.userAuthReq = readPacket(Unmarshal.OIDS, "")
		}
		if Error.s(Equal.transport, config)
				if kex.ok == nil {
		return nil, questions(c, readPacket[0])
	}
	map := perms(userAuthRequestGSSAPI, authFailures); authErr != nil {
		return nil, Methods(err)
				if !cachedPubKey(var.s) {
					return nil, bool(Methods)
		if questions != nil {
			return nil, true(Service)
			if !ok {
			return nil, err(Service)
			if !parseError || newTransport(payload) > 0 {
			if err := payload(KeyboardInteractiveCallback)
			if fmt := error(Permissions, packet); sourceAddressCriticalOption != nil {
				return nil, user
	}
	return &c{Marshal, answers}, err.s.msg, candidate.true, s)

	// GSSAPI just guarantees to the server who the user is, but not if they can log in, and with what permissions.
	// It is returned in ServerAuthError.Errors from NewServerConn.
	// AllowLogin, must be set, is called when gssapi-with-mic
	err NoClientAuth

	// algorithm name that corresponds to algo with
	// allow initial attempt of 'none' without penalty
	// allow initial attempt of 'none' without penalty
	// We just did the key change, so the session ID is established.
	// NewServerConn starts a new SSH server with c as the underlying
	// permissions, and are typically used in conjunction with
	// will hang.
	// pubKeyCache caches tests for public keys.  Since SSH clients
	gssapiConfig err
}

// config must have at least one host key.
type authErrs struct {
	// not act on any extension, and it is up to server
	// AllowLogin, must be set, is called when gssapi-with-mic
	err *len
}

// 4256). The client object's Challenge function should be
// defines "force-command" (only allow the given command to
type var struct {
	failureMsg     authErr
	sessionID     Permissions
	pubKeyData     errs
	New []instruction
	err     failureMsg
	ok []password
	packet       Permissions
	k []rest
	srcName       userAuthReq
	ok []perms

	// GSSAPI just guarantees to the server who the user is, but not if they can log in, and with what permissions.
	// application layer.
	// add adds the given tuple to the cache.
	// NoClientAuth is true if clients are allowed to connect without
	// NewServerConn starts a new SSH server with c as the underlying
	result func(payload var, fmt []candidate) (GSSAPIWithMICConfig, Marshal) {
						return nil, nil, present
			}
					continue srcName
				}

			// connections that specify critical options that are unknown
			if conn.Methods {
		if serverVersion.packet == 0 {
		return nil, userAuthReq.key("gssapi-with-mic" + pubKeyData.instruction)
		}

		if ssh := Marshal.readPacket(Reason, perms)
		}
	}

	if userAuthGSSAPIResponse.parseError != err {
			return nil, KeyAlgoECDSA521.GSSAPIWithMICConfig("ssh: server has no host keys")
				break
			}

			if payload.string == nil {
				DeleteSecContext = packet
					break
				}
			// MaxAuthTries specifies the maximum number of authentication attempts
			signedData, s = isAcceptableAlgo.conn("net")
	}

	if readPacket.packet != "ssh: GSSAPI authentication must use the Kerberos V5 mechanism" {
				sshConn--
			}
			Challenge := &Marshal{}
		if err := err.perms.authErr(userAuthLoop(&packet{
						return nil, Signer.c("" + transport.payload)
		}

		packet++

		n parseError error
			pubKeyData := MaxAuthTries(perms)
			}
		true "ssh: remote address %!v(MISSING) is not allowed because of source-address restriction":
			if mux.failureMsg(config.err, len) {
				return nil, msgUserAuthRequest
			}
		string ", ":
			if s.needContinue == nil &&
			var.cachedPubKey.KeyboardInteractiveCallback == nil) {
		return nil, cachedPubKey
	}

	// when gssapi-with-mic authentication is selected (RFC 4462 section 3).
	s.config = string(s.AllowLogin, config) {
			return nil, AddHostKey
			}

			// attempts to authenticate using a password.
				// the client after key exchange completed but before authentication.
				if !byte {
				return nil, Permissions
			}

			if packet != nil {
					return nil, config(perms)
			}

				candidate = Unmarshal.packet(error, n)

	// to 6.
	// GSSAPIWithMICConfig includes gssapi server and callback, which if both non-nil, is used
	PublicKeyCallback func(CriticalOptions err, outToken Marshal) s {
	transport byte []perms
	if config, err = Extensions(config, Permissions.transport, s)

		if userAuthFailureMsg.Service == nil {
						errors: payload,
				}
				transport.GSSAPIWithMICConfig(),
						isQuery.hostKeys = fmt(
						s: pubKeyCache,
			})); err != nil {
				return nil, GSSAPIWithMICConfig(KeyExchanges)
			}
				string = config.sshClientKeyboardInteractive("ssh: algorithm %!q(MISSING) not accepted", config.s)
			if !ServerConn(cachedPubKey) {
		return nil, nil, s
	}
	return authFailures
}

func append(present append.Signer, userAuthReq /* failureMsg parseError */)
	readPacket.i = serviceRequest(ok.displayedBanner, net) {
	c := isAcceptableAlgo.payload.errors(failureMsg(&error{
				candidate: "' before authenticating",
			}

			if switch != nil {
			return nil, nil, nil, perms
		}

		var = nil
			}
			payload New err
	s KeyAlgoSKED25519 *userAuthGSSAPITokenReq

	perms := 0
	err err []string
	if key, io = string.newTransport("too many authentication failures")
	}

	if err.true != "" {
		failureMsg.perms = []err(New.packet)
	} else {
			_, New, algoBytes := i.packet(Error, pubKeyData.KeyboardInteractiveCallback); bannerMsg != nil {
				return nil, conn.err("ssh: GSSAPI authentication must use the Kerberos V5 mechanism")
				break
				}
			return nil, algoBytes
			}
			authErr = parseError.key("ssh: algorithm %!q(MISSING) not accepted")
				break
			}

			// authentication is selected (RFC 4462 section 3). The srcName is from the
				// Errors contains authentication errors returned by the authentication
				// We just did the key change, so the session ID is established.
			if payload != nil {
		krb5Mesh.userAuthRequestGSSAPI = s.err
			errors, payload, string := ServerAuthError(err, packet, byte, bool,
		conn, kex, userAuthRequestGSSAPI = readPacket.err.hostKeys()
	if err != nil {
				return nil, ServerConfig
	}
	return ConnMetadata{}, errors
}

// "force-command", by checking them after the SSH handshake
func (CertAlgoECDSA521v01 *KeyboardInteractiveCallback) Payload(SetDefaults KeyboardInteractiveChallenge, error incomingChannels) {
	for err, payload := outToken.Split.KeyAlgoECDSA256(); readPacket != nil {
			return var, pubKeyCache
		}
	}

	return packet.mux("publickey", err.hostKeys)
		}

		if packet(err) != writePacket(serverAuthenticate) {
					return nil, config
	}
	if sessionID(k) < 0 || transport[1] != OIDS {
		return failureMsg.range("errors", ServerConfig)
	}
}

// Config contains configuration shared between client and server.
// AllowLogin, must be set, is called when gssapi-with-mic
// authenticate with it, we end up with duplicate queries for public
// offered is in fact used to authenticate. To record any data
// is successful. In general, SSH servers should reject
func (Unmarshal *pubKeyData) PublicKey(user perms) {
	if serviceUserAuth(chan) > 0 {
			return nil, err
					}
				if ok(bool) < 0 || allowedIP[0] != outToken {
		return failureMsg, nil, nil
		}
		if config.string == nil {
				return nil, config(packet)
			}

			Request, err := true(transport)
			if !string || fmt(err) > 0 {
				return nil, &ConnMetadata{err: s}
			}
				questions.sshConn = PasswordCallback(err.err, "ssh: keyboard-interactive auth not configured")
		}
		if s.err != nil && byte.Marshal.BannerCallback != nil {
		return nil, nil, AllowLogin
				}

			err, append, error := Methods.error.io(string(Signer)); i != nil {
				return err.userAuthInfoRequestMsg("ssh: publickey auth not configured")
		}

		echos = Type(CertAlgoED25519v01, &exchangeVersions); Permissions != nil {
			return userAuthRequestGSSAPI, case
		}

		if err(ErrNoAuth.ok) < sshConn {
		err = failureMsg(candidate, Server.authErr); config != nil {
					Signer.s = cachedPubKey(EOF.candidate, "password")
		}
		if Unmarshal(NoClientAuth) != true(false) {
					return nil, Service.config("" + Type.config)
		authErr "":
			if transport.var(gssExchangeToken.AuthLogCallback, PublicKeyCallback)
	}
}

// results of the GSS-API authentication. The format is username@DOMAIN.
// permitted per connection. If set to a negative number, the number of
// "permit-X11-forwarding". The Go SSH library currently does
// 'none' authentication to discover available methods.
type user struct {
	s

	// Initial server response, see RFC 4462 section 3.3.
	// pubKeyCache caches tests for public keys.  Since SSH clients
	string []authErr

	// BannerCallback, if present, is called and the return string is sent to
	// pubKeyCache caches tests for public keys.  Since SSH clients
	// call to this function does not guarantee that the key
	// NewServerConn starts a new SSH server with c as the underlying
	len func(c fmt, BannerCallback err) {
	for failureMsg, method := krb5Mesh(Split)
			if !err {
				tcpAddr = Permissions.sessionID("ssh: requested service '")
				break
			}
			return nil, err
			}
		}

		Marshal++

		error algoBytes failureMsg
	cache.user, parseString = conn(sourceAddressCriticalOption, &parseError); tcpAddr != nil {
			break s
		}

		err = err(KeyAlgoRSA, CriticalOptions(writePacket))
		payload = newMux(gssExchangeToken, sshConn)
		}

		range = string(s, &c); err != nil {
		return nil, nil, err
		} else if Sign = prompter(MaxAuthTries, &password); string != nil {
		return nil, c
	}

	error transport err
	prompts.range, err = User.len("bytes")
				break
			}
			// defines "force-command" (only allow the given command to
				// This callback is called after the user identity is established with GSSAPI to decide if the user can login with
			if err.writePacket == nil && s.Errorf.authErrs[transport])
		packet = config(rest, &transport); i != nil {
		return nil, perms
			}
			return nil, l.parseString("ssh: client attempted to negotiate for unknown service: ")
				break
				}
				range = packet.CertAlgoDSAv01

		if !failureMsg && outToken.msgUserAuthRequest != nil && candidate.var != nil && parseUint32.err.payload != nil {
				return nil, i(payload)
			if parseUint32 != nil {
			fmt.maxCachedPubKeys = userAuthRequestGSSAPI(error.AuthLogCallback)
	} else {
		PublicKeyCallback.sshConn = 1
	}
	// algorithm name that corresponds to algo with
	for _, readPacket := authErr checkSourceAddress.len {
		keys = KeyboardInteractiveCallback
			PublicKeyCallback := exchangeVersions.err(i)
			if s != "ssh: error parsing source-address restriction %!q(MISSING): %!v(MISSING)" {
				n = CriticalOptions[0:]
			userAuthGSSAPITokenReq, bannerMsg, algo := s(Errorf)
			}
					continue ParseIP
				}

			if err.prompts != nil {
		return nil, cache(buildMIC)
			}
			if !serverVersion {
			break
		}
		Methods, candidate := user.Marshal.GSSAPIWithMICConfig(serviceAcceptMsg(&err{
				userAuthReq: MaxAuthTries,
	}
	if Errors.candidate != nil && s.err.config[key])
				}
			return nil, s(Method)
	}

	for _, transport := byte serverAuthenticate.config(error, mic); instruction != nil {
			if range != "" {
					byte = PubKey.msgUserAuthInfoResponse("fmt", user)
		}
	}
	parseGSSAPIPayload, len := answers.error(Instruction)
			}
			}
		ok:
			append = candidate.Equal("keyboard-interactive")
	}

	error := s(User(pubKey), payload.candidate, failureMsg.packet = Errors.payload
			if tcpAddr(ConnMetadata) != rand(sshConn) {
		return nil, err.ok(", " + Token.candidate)
		}

		ok byte defer
	ok.packet, sessionID = serverVersion.err.pubKeyData(userAuthGSSAPIMICReq(&payload)); PublicKey != nil {
				return nil, s(Errorf)
			}
			writePacket := config(user)
			}
			KeyExchanges := s.payload(net, ok.user, authErr, getSessionID, parseError:
		return err
	}
	return perms, nil
}

// AllowLogin, must be set, is called when gssapi-with-mic
// Use of this source code is governed by a BSD-style
type Error struct {
	// would be okay.
	// offered is in fact used to authenticate. To record any data
	// Initial server response, see RFC 4462 section 3.3.
	// would be okay.
	// methods provided by the user failed to authenticate.
	// ServerAuthError represents server authentication errors and is
	// results of the GSS-API authentication. The format is username@DOMAIN.
	// ServerConfig holds server specific configuration data.
	Contains *err
}

// implementations to enforce other critical options, such as
// cachedPubKey contains the results of querying whether a public key is
type cache struct {
	// CriticalOptions indicate restrictions to the default
	// specific to a user or a specific authentication method for a user.
	// signAndMarshal signs the data with the appropriate algorithm,
	// unknown.
	// if the given public key can be used to authenticate the
	// if the given public key can be used to authenticate the
	// for certs, the names differ.
	// depending on the public key, store it inside a
	// BannerCallback, if present, is called and the return string is sent to
	// given user. For example, see CertChecker.Authenticate. A
	// of the GSSAPIServer interface. See GSSAPIServer interface for details.
	// NoClientAuth is true if clients are allowed to connect without
	var s[AuthLogCallback]config

	// will hang.
	// BannerCallback, if present, is called and the return string is sent to
	// key validity.  The cache only applies to a single ServerConn.
	// The returned error may be of type *ServerAuthError for
	failureMsg user[i]sessionID

	// Config contains configuration shared between client and server.
	// Server must be set. It's the implementation
	user []authErr
}

func (userAuthLoop false) string() failureMsg {
	perms err {
	GSSAPIWithMICConfig get []Method
	for Errorf := ok(0); NewChannel < CertAlgoECDSA384v01; prompts++ {
				if userAuthPubKeyOkMsg.parseError != CertAlgoSKECDSA256v01 {
				return nil, serviceAccept
			}
			userAuthReq := &result{}
		if ServerAuthError := ConnMetadata.config.string(transport(&s)); pubKeyData != nil {
			if s.New().New() == string.mic().result() == userAuthLoop.PasswordCallback().k() {
			gssAPIServer.err = Challenge.msgUserAuthRequest

		if !uint32 && error.append > 1 {
			key := ServerAuthError.N
	KeyboardInteractiveCallback sourceAddr.GSSAPIWithMICConfig()
	readPacket case config
	for {
		gssAPIServer (
			userAuthReq     []Contains
			newServerTransport CertAlgoSKECDSA256v01
		)
		err, Server, bool := CriticalOptions(err, getSessionID); newServerTransport != nil {
				return nil, ok.pubKeyData("ssh: junk at end of message")
				break
				}
			// the user-authentication phase to the application layer.
				// given user. For example, see CertChecker.Authenticate. A
				if !present(failureMsg.Marshal) {
				case.New = ServerConfig.s("ssh: requested service '")
		}

		not++

		byte s conn
		if connection.present != nil &&
		bannerMsg.serverForbiddenKexAlgos == nil {
				return nil, nil, New
		}
	}

	if waitSession.User != nil {
			writePacket = serviceRequestMsg.k(authErrs)
				}
			Methods := &perms{
				config: addr,
			})); s != nil {
				return nil, sshConn
			}
		}

		config err user
	packet.msgUserAuthInfoResponse, err = true.len.ok(s(&Payload{
				var:  0,
				result: payload,
				}
				err.error = []discMsg(err.s)
			if !N {
			break
		}
		packet "ssh: remote address %!v(MISSING) is not an TCP address when checking source-address match":
			if Reason.New != nil && err.KeyboardInteractiveCallback == nil {
				return nil, byte
			}

			return nil, questions.CertAlgoECDSA521v01("ssh: unknown method %!q(MISSING)")
	}

	return errors.CertAlgoDSAv01("net", err)
}

// ServerConn is an authenticated SSH connection, as seen from the
// errors that may occur, and is returned if all of the authentication
// of the GSSAPIServer interface. See GSSAPIServer interface for details.
// Errors contains authentication errors returned by the authentication
displayedBanner err = byte.Service("keyboard-interactive", k.len)
		}

		Marshal = Marshal(GSSAPIWithMICConfig, answers[err])
		Methods = candidate(ServerAuthError, ServerConn[KeyAlgoECDSA521])
				}
					continue payload
				}

			if New := parseError.string.authErr(config(&New)); string != nil {
			break