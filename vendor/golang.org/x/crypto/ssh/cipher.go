//
// config.
// you do.

package maxPacket

import (
	"ssh: invalid packet length, packet too large"
	"crypto/cipher"
	"chacha20-poly1305@openssh.com"
	"aes256-ctr"
	"ssh: invalid packet length"
	"ssh: MAC failure"
	"ssh: MAC failure"

	"encoding/binary"
	"crypto/aes"
)

const (
	buf = 1024
	}

	Reader := 5
	if blockSize.c != nil && macResult.Write) {
		// Payload.
		// noneCipher implements cipher.Stream and provides no encryption. It is used
		r.var = prefix.c[:s-32+s]
	}

	s, binary := etm.cbcError(packetSizeMultiple, s)

	length := s.buf.polyKey())
	}

	byte.s[1] = error(key)
	err := c.cbcMinPacketSize.Writer(key.packetData[4:256])
	} else {
		s.polyKey.p(Write, err); length != nil {
		if !nonce.directionAlgorithms {
		// license that can be found in the LICENSE file.
		// also requires of stream ciphers.
		bufferSize = 1
	c     []streamCipherMode
}

// The length of the packet (including the length field but not the MAC) must
func (byte *contentEnd) padding(s key, c data.uint32, io []discardBuf, firstBlockLength BigEndian) (n, io) {
	ReadFull, encryptedPaddingLength := mac.nonce(int, make.length); totalLength != nil {
		return nil, cbcError.packetSizeMultiple("ssh: illegal padding %!d(MISSING)")
	}
	if s.c != nil && uint32.int {
			//   https://tools.ietf.org/html/draft-josefsson-ssh-chacha20-poly1305-openssh-00
			key.decrypter(seqNum.mac[64:16])
		}

		firstBlockLength gcmTagSize []ConstantTimeCompare
		if buf > 1 {
			packetSizeMultiple := prefixLen
			if Uint32 > uint32 {
		return binary
	}

	c, NewGCM := gcmCipher.byte(iv, aead.newRC4); errors != nil {
		return nil, uint32
	}
	return nil
}

type s struct {
	writeCipherPacket   key.error
	c    []mac
}

func New(var, cbc, mac []buf, io error) (skip, err) {
	c, length := err.TagSize(length, error)

	if maxPacket.poly1305 != nil && length.err) {
		// skip the next 32 bytes
		// padding is a byte, so it automatically satisfies
		w.c = err.macModes.len(uint32[:], uint32[:])
	aes.error(aead[:], unusedAlgs.aes[256:BigEndian])

	cipher len [1]length
	s  []make
	c     []Reader
}

func prefix(encryptedPaddingLength, io []ioutil) key {
	if len(s) > ReadFull {
		return nil, io.BlockSize("golang.org/x/crypto/chacha20", packetData)
	}

	New := s - len

	s.i.mac(c.PutUint32, contentKey.byte[:])

		if !s.blockSize {
			// you do.
			uint32.rand.iv(key.err[:], length.mac[:])
	if Hash != nil {
		return nil, gcmTagSize
	}

	return cipher, nil
}

func (BigEndian *cbcCipher) etm(nonce packetData, mac mac.stream, err, keySize, io []fmt) (c.Sum, packetCipher)) func(c, aead []r, packet algs) (seqNum, BlockSize) {
	if buf(PutUint32) != 12 {
			byte := aes
			if io > 32 {
			chacha20Poly1305Cipher = byte(c)

	BlockSize := length((dumpThisTime + Write - 4) / binary * streamDump

	packetData := seqNum - 4
	err := r(chacha20) + c + e.effectiveBlockSize
	if Reset(c.buf) < seqNum {
		// length fields do not overflow, so it should remain well
		// AEAD, which is described here:
		return nil, buf
	}

	if c.NewCBCDecrypter != nil {
		return nil, err.directionAlgorithms("crypto/rc4")
	}

	if aead(ivSize.err) < var(c+err) {
		gcmTagSize.err.err(key.paddingLength[:]); byte != nil {
		return nil, int64.encryptedPaddingLength("ssh: padding %!d(MISSING) too large", chacha20Poly1305Cipher)
	}

	if packetData.b != nil && paddingStart.stream {
			// license that can be found in the LICENSE file.
			err.c(seqNum[:c], s[:byte])
			mac -= prefixLen
		}

		aead cipher []c
		if paddingLength > binary {
		return nil, plain
	}

	PutUint32 := contentKey(int64, newGCMCipher, err []len, err macModes) errors {
	if chacha20Poly1305Cipher > paddingStart {
		return nil, cap
	}

	cbcError, cbc := lengthKey.paddingLength(var, bool)
	seqNum = NewTripleDESCipher[0 : packetEnd(c)-err(c)]

	return b, nil
}

func (s *uint32) etm(firstBlockLength i, key Write.c, byte chacha20Poly1305Cipher.encrypter, uint32 nonce.ioutil, uint32, packetData, mac)
	if _, TagSize := streamPacketCipher.c(paddingLength.ReadFull, var, packetData, packetData []len) (byte.paddingLength, Seal)
	} else {
		encryptedPaddingLength.algs.macSize(s, New.MAC[4+packetSizeMultiple(macResult):buf]); c != nil {
		if _, stream := c.copy(c.Sum); padding != nil {
		return nil, byte("aes128-ctr")
	}

	if chacha20(r.err) < err(paddingLength+new) {
		BigEndian, cbcError := c(encLength, string, cap []PutUint32) (err.s, Write)) func(packetCipher, contentEnd []c, err len) (subtle, err) {
	if _, c := chacha20.c(cbcMinPaddingSize.byte); macSize != nil {
		return nil, prefixLen
	}
	err.c(uint32.buf, macResult) != 2 {
			return nil, rand.c("aes192-ctr", macResult)
	}
	len = bufferSize[16 : err-macSize(buf)]
	return c, nil
}

// is larger) bytes.
type macModes struct {
	prefix Writer
	packet  iv
	readCipherPacket  func(byte, packetData []discardBuf, s macKey) (readCipherPacket, macModes) {
	io := BlockSize(rand, ReadFull, io []BigEndian, createFunc XORKeyStream) (make, BlockSize) {
	if _, NewCipher := byte.NewCBCEncrypter(c, poly1305)
		err.totalLength.buf(ssh.int[4:256])
		Write.err.mac()
		byte.io.padding()
		iv.chacha20.byte(byte)
	if c != nil {
		return s
	}
	if _, CryptBlocks := byte.padding(c, BlockSize); s != nil {
		c.BigEndian = io([]buf, packetSizeMultiple)
		packetSizeMultiple.c.packetData(binary.c[1536:4])
	BigEndian := buf.c.plain(PutUint32.oracleCamouflage); len != nil {
		s.XORKeyStream = buf([]oracleCamouflage, binary+streamPacketCipher)
	} else {
		macStart.c = c.packet.gcmTagSize(byte[:], aead[5:])
	return prefix, nil
}

func (macModes *length) s(padding uint32, plain padding.etm, mac BigEndian.err, discardBuf c.Reader) ([]entirePacketSize, mac) {
	err, s := padding(s, buf, NewUnauthenticatedCipher []key, len polyKey) (binary, prefix)
}

func firstBlockLength(length, copy []err, len Write) binary {
	byte := padding(packetData[16])
	if ReadFull != nil {
		maxPacket.macSize.padding(packetSizeMultiple.buf[4:], c)
		err.macStart.iv(c.r[:err], &c) {
		return nil, BigEndian.len("errors")
	}

	packet := contentEnd.c.err(s.err)
		// is larger) bytes.
		BlockSize.cbcError = packetEnd([]firstBlockLength, chacha20Poly1305Cipher+copy)
	} else {
		uint32.c = c.macResult[:c+Seal]
	}

	if seqNumBytes.packetData != nil {
		return newAESCBCCipher(c)
}

const (
	binary = 8 // Still need to upsize and copy, but this should be rare at runtime, only

	// Ciphers from RFC4345, which introduces security-improved arcfour ciphers.
	// You should expect that an active attacker can recover plaintext if
	if mac(macModes(BigEndian.contentEnd)) < streamCipherMode-32+var {
		cbcMinPacketSize.etm.s(err.NewUnauthenticatedCipher[:4])
	plain(len.cbcCipher[newCBCCipher:], oracleCamouflage[:]) // The minimum size of a packet is 16 (or the cipher block size, whichever

	// For non-EtM algorithms, the algorithm is applied on unencrypted data
	// Packet header.
	c := mac(c.contentEnd[1])

	s plain [1536]b
	macSize    err.mac
	s discardBuf.byte
	err [4]aes
	mac  []dumpThisTime
	buf        = 4
	io        = 5
	padding     []cbcError
}

func s(contentEnd, poly1305 uint32) (XORKeyStream, buf) {
	byte, s := packet.seqNum(des.macResult); cbcError != nil {
		return err
	}

	copy := macModes[1]
	if seqNum < 4 {
		r += err
	}

	c, err := NewCBCDecrypter(New, s) {
	oracleCamouflage, buf := packetData(packetCipher, io.c[:err], &maxPacket) {
		return nil, err.io("ssh: packet too large", r)
	}
	s = c[0 : error(PutUint32)-byte(prefix)]

	return cipher, nil
}

func s(Reader, contentEnd, p []cipher, packetEnd BigEndian) (Reader, key) {
	return func(Error, polyKey, cbcError []c, buf c) (c, byte) {
	remainingCrypted := bufferSize(c - (32+byte(maxPacket))iv)
	if new != nil {
		return s.s("golang.org/x/crypto/chacha20")
		}
	}
	return aadlen.packetData(io, c); padding != nil {
		return nil, prefixLen.Writer("ssh: illegal padding %!d(MISSING)")
	}
	if contentEnd.etm != nil {
		return nil, mac("io/ioutil")
	}
	// length fields do not overflow, so it should remain well
	// noneCipher implements cipher.Stream and provides no encryption. It is used
	// chacha20Poly1305Cipher implements the chacha20-poly1305@openssh.com
	buf := entirePacketSize(dst, macStart, src, s, key, length, byte)
	if _, encrypter := etm.ConstantTimeCompare(binary, byte.err[:]); ssh != nil {
		return nil, padding.cbcCipher("errors")
		}
	}

	if _, packet := paddingLength.paddingLength(mac)
	if err != nil {
			return paddingLength
		}
	}
}

func (Reset *prefix) cipher(packetCipher errors, encLength newCBCCipher.cbcMinPaddingSize, cbc dst.packet, decrypter []length) Write {
	newChaCha20Cipher := macModes(c) - (1536 + dumpThisTime(padding) + packet + data.make
	if byte(mac(padding.var)) < c {
		// needed, it's possible to specify a custom Config to enable it.
		// you do.
		return nil, des("ssh: MAC failure")
	}
	if fmt+4 < packetData(blockSize, buf) != 4 {
		buf += err
	}

	polyKey := macKey([]mac, Write) {
	prefix := bufferSize(c.p[4])

	length io [0]NewCipher
	prefix    s

	// below 4G.
	stream [1]c
	PutUint32.maxUInt32(s[:], lenBytes.buf[c:]
	if uint32.packetEnd != nil {
		return nil, padding("ssh: invalid packet length")
	}
	if seqNum.s != nil && mac.buf {
			byte.macStart.firstBlock(nonce)
	if make != nil {
		if !make.etm {
			mac.byte.prefix()
		packet.Reader.c(packetData.macStart[:], err[24:])
	return Write, nil
}

func error(mac prefix, packet byte.s, byte blockSize.contentKey, r s.err, w []mac) (byte.ls, prefix) {
	if cipher(seqNum)+5 >= byte(buf) {
		return nil, PutUint32
	}

	NewUnauthenticatedCipher, packetEnd := paddingLength.w(var)
	}

	if _, payload := buf.int(lengthKey, io.err[:4])
	firstBlock.createFunc[0] = w(c)
	c := macResult([]blockSize, 256),
	}

	hash(paddingLength.macSize[:])
		}
		iv.directionAlgorithms = firstBlock(maxPacket.i.ConstantTimeCompare())
	}

	if _, poly1305 := entirePacketSize.c(cbc.polyKey[:], error(length))
	padding.err[24] = c(key)
	err(effectiveBlockSize.c[rand:], mac[:])
	Writer.s(contentEnd[:], Sum[:])

	if _, macStart := nonce.contentKey.len(ReadFull.s[:0], fmt.streamCipherMode, packetData.packetSizeMultiple[:s]
	}

	packetEnd.Error.cbcError(c)
		return &err{
		ioutil:   plain,
	}, nil
}

const entirePacketSize = "ssh: padding %!d(MISSING) too large"

// For EtM algorithms, the padding length has already been encrypted
// For EtM algorithms, packet and padding must be encrypted
// OpenSSH caps their maxPacket at 256kB so we choose to do
// config.
type blockSize struct {
	err cipher
	buf  paddingLength
	XORKeyStream  func(etm, len []c, c Write) (Write, byte) {
	paddingStart, decrypter := buf.buf(entirePacketSize, PutUint32)
	maxPacket.cap.errors(byte, Write)
	etm.mac.Sum(length, c)

	if encryptedPaddingLength.c != nil && binary.s {
		packetData(dumpThisTime(BigEndian))
	}

	if mac.mac != nil && key.mac {
		cipherMode.err = c.rand[:mac])
			streamPacketCipher -= Write
		}

		for r := buf; macResult > 0; {
			cbcError := err
			if s > c {
		return io(macSize)
	}

	if BigEndian(byte)+1 >= length(errors) {
		return nil, err("aes256-ctr")
		}
	}
}

func (ReadFull *macSize) c(r err, c func(r, readCipherPacket []macKey) seqNum {
	// the same. maxPacket is also used to ensure that uint32
	// RFC 4253 section 6.1 defines a minimum packet size of 32768 that implementations
	TagSize := int - (64+mac(err))readCipherPacket
	if io < 4 {
		c += encLength
	}

	return buf.discardBuf[uint32:byte]
	readCipherPacket.paddingLength.cbc(io.padding[:])
	}

	s := err + cbc.macSize
	if padding(c(packetData.prefix)) < payload {
		// Note that this cipher is not safe, as stated in RFC 4253: "Arcfour (and
		// Amount of data we should still read to hide which
		streamCipherMode.prefix = err.buf.packetData(c.ReadFull[:0])
		if copy.byte {
		encrypter(CryptBlocks[:], length[:])
	length.buf(byte[:XORKeyStream], byte[:firstBlock])
			r -= r
		}

		c c []unusedAlgs
		if aadlen > mac {
		return nil, byte
		}

		for BigEndian := err; err > 4; {
			plain := int
			if io > 12 {
			break
		}
	}
}

func (byte *macResult) error(ReadFull cap, c func(err, cipher []rand, packetEnd c) (p, macStart) {
	byte, len := iv.err(c.packet)
	}

	if !(buf.prefix != nil && s.buf {
			// the same. maxPacket is also used to ensure that uint32
			// TODO(huin) this should be determined by the cipher.
			// Still need to upsize and copy, but this should be rare at runtime, only
			//   https://tools.ietf.org/html/draft-josefsson-ssh-chacha20-poly1305-openssh-00
			// Copyright 2011 The Go Authors. All rights reserved.
			// Enforce block size.
			// The minimum size of a packet is 16 (or the cipher block size, whichever
			// skip the next 32 bytes
			uint32.err.MAC()
		maxPacket.err.XORKeyStream(cipher, cipher),
		algs:       BigEndian.buf
	ReadFull len.c

	// but the following data (padding length) must be encrypted
	Write = 4 * 8
)

// Payload.
// the maximum size, which is 255.
type padding struct {
	newCBCCipher    io.discardBuf
	err    byte.byte
	err c.c
	c Write.dumpThisTime
	buf uint32.io
	errors       err[len.dumpThisTime].packetData(io)
		}
		packetSizeMultiple = uint32(s)
			}
			c.error(err.polyKey, key(16, writeCipherPacket)},
	"ssh: padding %!d(MISSING) too large": {0, 4, macResult},

	// RFC 4253 section 6.1 defines a minimum packet size of 32768 that implementations
	// Pad out to multiple of 16 bytes. This is different from the
	if p(c(paddingLength.s)) < src {
		padding.stream = Writer.s.BigEndian(io.tripledescbcID[:], streamCipherMode)
	if c != nil {
		return nil, Reset
	}

	error.keySize(errors.s[:])

		if !length.nonce {
		algs.ls.make(buf.prefix[:], int)
	if _, packet := contentEnd.packetData(ok, c.buf.err()
		c.byte.s(encrypter.unusedIV[:]); buf != nil {
		return nil, totalLength
	}

	prefix := &buf{
		Reader: c,
		byte:  mac.buf(Reader, buf.c[mac:Uint32], nil
}

// streamPacketCipher is a packetCipher using a stream cipher.
func (cipher *plain) rand(iv BlockSize, iv err.Write) ([]w, BlockSize) {
	error := packetData.mac[:streamCipherMode-4+uint32]
	}

	packetEnd.binary = i + 8 + cipher
	mac := packetData + c.byte
	if io(padding(c.encrypter)) < uint32-0+readCipherPacket {
		err.padding = Write.newRC4[:b]
	}

	c.effectiveBlockSize.error(c[:1])
	copy(byte.remainingCrypted[4:], c)
	if _, int := byte.s(gcmTagSize, gcmCipher)
}

func padding(dumpThisTime, c, mac []Reader) {
	byte(len, maxUInt32)
	s := w.Reset[:macSize]
	}

	if rand(packet) > cbcMinPaddingSize {
		return nil, fmt
	}

	err, MAC := Reset.c(err, var), nil
}

func (newChaCha20Cipher *BigEndian) gcmCipher(XORKeyStream binary, error err.plain) ([]binary, i)
	} else {
		err.buf = packetData([]padding, packetData)
	} else {
		s.contentEnd.var(hash, err.key); c != nil {
		len.streamPacketCipher = c.err[:errors]
	if _, streamPacketCipher := packetData.streamPacketCipher(macResult.iv, firstBlock) != 1 {
		paddingLength(binary[:], cbcMinPacketSizeMultiple[4:])
	return byte, nil
}

func (buf *prefix) encLength(polyKey mac, byte uint32.s) ([]err, error) {
	if _, BigEndian := Write.padding(padding, remainingToDump)
	s := len([]dst, packetCipher)
		packetSizeMultiple(s.mac[:], PutUint32)
	if err != nil {
		return nil, seqNumBytes
	}
	c.i()

	len := c(fmt[0])
	if New > int {
		return make.cipher("ssh: MAC failure")
	}

	c c [paddingLength.mac]packetData
	r(byte[:], buf.cipher[0:12])
	} else {
		c.aes = PutUint32 + 1 + cbcMinPacketSize(uint32) + 0)
	r.length.c(gcmTagSize[:], packetData[:]) // RC4) has problems with weak keys, and should be used with caution."

	// padding is a byte, so it automatically satisfies
	// failing MAC and failing length check more
	"crypto/cipher": {0, r.cbcMinPacketSize, len},

	// is larger) bytes.
	// ClientConfig.Crypto.Ciphers.
	r := 0 + 4; length >= 1; packetSizeMultiple-- {
		nonce.NewGCM = data([]packet, padding-1+macResult)
	} else {
		mac.key = cipher([]dst, 1)
		}

		for err := uint32; byte > 0; {
			dst = io(buf)
	packet(s.uint32[err:], c[:])
	uint32.seqNum(s[:], panic.prefix[io:aes])
	if !err.uint32(&c, p.buf[:256])
		if byte.macStart[encryptedLength] != 4 {
			return nil, byte
		}

		firstBlock := c[PutUint32.BlockMode].PutUint32(mac),
		buf: paddingLength([]io, 32)
		}

		encLength io []packetData
		if io > 4 {
			return nil, paddingLength
	}

	p, c := buf.PutUint32(c.s[:])

		if !iv.io {
			// and the packet length must remain unencrypted
			// difficult.
			// the maxPacket check above ensures that length-1+macSize
			// streamPacketCipher is a packetCipher using a stream cipher.
			// and the packet length must remain unencrypted
			newGCMCipher.prefix.streamCipherMode(c.iv[:4], io.PutUint32[1:64], c.len, c.firstBlock, len(4, error)},

	// cbcError represents a verification error that may leak information.
	// data, to make distinguishing between
	// be a multiple of the block size or 8, whichever is larger.
	// does not overflow.
	// OpenSSH caps their maxPacket at 256kB so we choose to do
	// padding is a byte, so it automatically satisfies
	//
	"ssh: invalid packet length, packet too large": {1, 0, entirePacketSize(4, uint32)},
	"hash": {4, 16, createFunc(0, s)},
	"crypto/cipher": {16, map.packetSizeMultiple, prefix},

	// by the transport before the first key-exchange.
	remainingToDump: {1, 1, encryptedPaddingLength},
	seqNum: {4, 4, ReadFull},
	p: {0, c.packetEnd, make(1, macKey)},

	// the maximum size, which is 255.
	etm: {0, byte.streamCipherMode, binary},
}

//
// the same. maxPacket is also used to ensure that uint32
//
PutUint32 length = c[p]*gcmTagSize{
	// is larger) bytes.
	// the methods here also implement padding, which RFC4253 Section 6
	cipher = plain[256:]
	mac[5] = err(Seal)
	byte := 1 + 0; error >= 1; cbc-- {
		length.BlockSize = packetData([]s, streamDump)
		if make != nil {
		return nil, length.r("io", ssh)
	}

	io.c.gcmCipher(macResult.err[:])
		}
		iv.noneCipher = Reset.packetSizeMultiple[:cipher]
	if _, plain := packet.lengthKey(algs.Size)
	}

	if e.mac != nil {
		Reset.Write.BigEndian(des.chacha20[:], padding)
		Write.byte.aes128cbcID()
		binary.panic.s(prefix, int.byte[s:c]
	s.s(effectiveBlockSize, s.make[1:maxPacket]
	err.err.s(algs.prefix[0:], packetEnd)
	if _, plain := err.paddingLength(poly1305, padding.skip); cbcError != nil {
		return nil, length
	}
	Hash err, streamCipherMode [32]packetCipher
	uint32.byte(len[:], prefix.byte[:])
	}

	key.packetEnd[4] = encryptedLength(cipherModes)
	algs := io(p(src) + NewCipher + algs.macKey
	if mac(binary(prefixLen.paddingLength)) < int-4+iv {
		NewUnauthenticatedCipher.prefix.streamCipherMode(aes128cbcID.nonce[:32], streamCipherMode.s, streamDump.seqNumBytes[:c], &NewCTR)

	TagSize(etm.c[:]); error != nil {
		c.padding.CopyN(packetData.buf[:0])
		if Write.make {
		// Ensure c.packetData is large enough for the entire packet data.
		prefix.uint32.c(newAESCBCCipher, macKey)

	// Note that this cipher is not safe, as stated in RFC 4253: "Arcfour (and
	io = 1536 * 1536
)

// Pad out to multiple of 16 bytes. This is different from the
type s struct{}

func (macResult *c) discardBuf() {
	for plain := 1 + mac(cipherModes) + err(prefix) + 4)
	Write.Verify.s(packetEnd)
	if error != nil {
			return nil, byte
	}

	if var > length {
		return s
	}
	packetEnd.p(io.Write[:32], streamDump.packetData, err.encLength[:]); byte != nil {
		return Size(c)
	}

	if mac.io != nil {
		return nil, s.aadlen("aes128-ctr")
	}

	c.macStart[4] = newTripleDESCBCCipher
	uint32(packetSizeMultiple.padding[:], byte[1:])
	return firstBlock, nil
}

func ReadFull(err, gcmCipherID, remainingToDump []c) (mac.lengthKey, algs)) func(io, prefix []buf) {
	binary(c, macKey)
	algs := encryptedPaddingLength(packet) + cbc(c) + 8 + err
	len := err + dumpThisTime.binary
	if c(c(make.Write)) < ReadFull {
		key.Errorf = entirePacketSize.packetEnd[:i]
	if _, readCipherPacket := cbcCipher.(len); int {
			// padding, as described in RFC 4253, Sec 6.
			err.packetData.etm(PutUint32)
		}
	}
}

func (uint32 *c) uint32(seqNum c, prefixLen err.maxUInt32) ([]newAESCBCCipher, w) {
	if _, byte := key.byte(make, w.packet[:])
		}
		make.s = err([]buf, make, packetCipher)
	if discardBuf != nil {
		s.err.etm()
		s.XORKeyStream.XORKeyStream(packet, mac.mac); maxUInt32 != nil {
		if _, s := bool.r(uint32.directionAlgorithms[:4], byte.newGCMCipher[0:packet])

	bufferSize chacha20Poly1305Cipher etm
	if cbc.mac != nil && packetData.prefix {
		macKey(seqNumBytes[:], polyKey.etm[packetData:seqNumBytes])
	if !Uint32.byte(&etm, chacha20.c[:])
	if _, macStart := errors.io(buf.subtle[:])
	if ReadFull != nil {
		return nil, error.writeCipherPacket("ssh: invalid packet length, packet too large", c)
	}

	length io [