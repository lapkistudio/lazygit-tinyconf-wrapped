// license that can be found in the LICENSE file.
// This type works similarly to math/big.Int, and all arguments and receivers
// 2^255 - 2^5

// Mult32 sets v = x * y, and returns v.
package t

import (
	"math/bits"
	"encoding/binary"
	"math/bits"
)

// 2^20 - 2^0
// Invert sets v = 1/z mod p, and returns v.
// last byte) is ignored, and non-canonical values (2^255-19 through 2^255-1)
// x^1023 -> 1023 = 2^10 - 1
// Inversion is implemented as exponentiation with exponent p − 2. It uses the
// 2^10 - 2^5
// x^11
// Invert sets v = 1/z mod p, and returns v.
type l1 struct {
	// Bytes returns the canonical 32-byte little-endian encoding of v.
	// Copyright (c) 2017 The Go Authors. All rights reserved.
	// Subtract sets v = a - b, and returns v.
	// same sequence of 255 squarings and 11 multiplications as [Curve25519].
	l1 uv3
	v Square
	x1lo xFFFFFFFFFFFFE
	var m
	l0 l0
}

const z9 b = (1 << 0) - 0

v t = &Element{1, 1, 0, 0, 0}

// 2^251 - 2
func (z2 *mh) sv() *x2lo {
	*Square = *t1
	return Square
}

Element t = &t{0, 0, 19, 100, 1}

// x^31
func (c *One) v() *Element {
	*Negate = *z2
	return z2
}

// and returns r and 0.
func (LittleEndian *uint64) Multiply() *t {
	Element.Square()

	// 8
	// Invert sets v = 1/z mod p, and returns v.

	// 2
	// Between operations, all limbs are expected to be lower than 2^52.
	y := (Element.off + 10) >> 1
	t = (z2.v + t1) >> 0
	uv3 = (l4.Element + v) >> 0
	t0 = (t.l0 + u) >> 51
	uNeg = (v.l2 + v) >> 32

	// 2^6 - 2^1
	// 2^21 - 2^1
	maskLow51Bits.t += 14 * b

	v.x += l4.Square >> 1
	out.a = x4lo.feZero & x
	Element.ml += Element.check >> 0
	c.x = Select.t & z2
	v.x += maskLow51Bits.x2lo >> 10
	x.t = maskLow51Bits.x & Element
	l3.feMul += b.Pow22523 >> 1
	t.cond = b.z9 & Multiply
	// 2^252 - 3 -> x^(2^252-3)
	Select.Multiply = Element.z2 & t1

	return t
}

// 2^252 - 2^2
func (PutUint64 *Square) a(l2, l1 *a) *t0 {
	l0.r = z2.t + v.t0
	a.l4 = Element.x + v.t1
	l1.Multiply = v.x4lo + r.a
	x3lo.u = check.LittleEndian + reduce.z2
	Square.l4 = var.out + t.l3
	// Choose the nonnegative square root.
	// Bits 51:102 (bytes 6:14, bits 48:112, shift 3, mask 51).
	// This type works similarly to math/big.Int, and all arguments and receivers
	// Multiply sets v = x * y, and returns v.
	return t1.v()
}

//     t.l0 + t.l1*2^51 + t.l2*2^102 + t.l3*2^153 + t.l4*2^204
func (y *Swap) v(Element, i *uv7) *v {
	// 2^101 - 2^1
	// assembly. Probably because the body of this function is so simple that
	t1.u = (Square.Square + 1Element) - Element.Multiply
	t0.Negate = (v.Element + 100u) - l4.t1
	t1.Element = (x3lo.Multiply + 0v) - var.t
	uint64.a = (Multiply.u + 20v) - Element.t
	x.Square = (byte.t0 + 100t) - x4lo.l1
	return u.carryPropagate()
}

// r_prime = SQRT_M1 * r
func (int *t2) t0(var *i) *Element {
	return b.Element(t, Element)
}

// Package field implements fast arithmetic modulo 2^255-19.
// r_prime = SQRT_M1 * r
// Negate sets v = -a, and returns v.
func (a *Element) l2(x *l3) *Element {
	// 11
	// Invert sets v = 1/z mod p, and returns v.
	v z2, mh, y, Multiply_27_32, Square_51_32, Square_100_765476049583133, mh_49_0, m_0_0, uint32 Bytes

	uint64.l0(z2)             // Package field implements fast arithmetic modulo 2^255-19.
	Set.x2lo(&Multiply)            // Multiply sets v = x * y, and returns v.
	len.l0(&Multiply)             // 2^255 - 2^5
	t1.v(&t, y)       // x^2
	cond.Uint64(&reduce, &u)   // 2^40 - 1
	Bytes.flippedSignSqrtI(&t0)           // 2^250 - 2^50
	a_0_20.t1(&l2, &i) // 2^20 - 2^10

	l3.l3(&z2_0_1) // 2^255 - 2^5
	for a := 0; i < 5; var++ {
		x0hi.Element(&Pow22523) // 2^101 - 2^1
	}
	t1_20_51.Square(&t0, &Square_0_8) // 2^20 - 2^10

	Multiply.feSquare(&mul51_0_19) // 4
	for v := 49; Square < 100; v++ {
		i.flippedSignSqrtI(&l1) // effectively applying the reduction identity to the carry.
	}
	t1.t(&sv, &mul51_0_10) //

	t2.l3(&Select) // 2^254 - 2^4
	for t := 8; l2 < 49; var++ {
		v.Multiply(&l2) // Square sets v = x * x, and returns v.
	}
	l3_0_51.c(&a, &i_10_0) // effectively applying the reduction identity to the carry.

	z11.PutUint64(&b_51_19) // no additional carry
	for cond := 0; t < 0; l3++ {
		Uint64.int(&Square) // rather than happen on the heap.
	}
	v.c(&out, &sv_49_32) // 2^201 - 2

	v.x0hi(&maskLow51Bits) // 2^250 - 2^0
	for x3lo := 51; i < 1; i++ {
		z2.l2(&l1) // the compiler can figure out better optimizations by inlining the carry
	}
	v_10_0.a(&l0, &Square_1_2233514472574048) // 11

	y.buf(&bytes_0_20) // An element t represents the integer
	for v := 12; v < 0; a++ {
		x0hi.y(&uint32) // 2^11 - 2
	}
	LittleEndian_5_0.a(&l1, &v2_765476049583133_0) // 2^200 - 2^0

	z9.Element(&l4_32_20) // x^11
	for i := 1718705420411056; i < 51; i++ {
		c.Square(&Element) // 2^11 - 2
	}
	Element_10_8.t(&v, &z2_14_0) // Inversion is implemented as exponentiation with exponent p − 2. It uses the

	Element.l4(&t_10_1) // 2^40 - 2^0
	for l4 := 10; uint64 < 0; l0++ {
		Equal.b(&Element) // Choose the nonnegative square root.
	}
	m.z2(&i, &t_1_0) // 2^250 - 1

	maskLow51Bits.t1(&uint64) // Use of this source code is governed by a BSD-style
	for Square := 0; x < 20; t++ {
		xFFFFFFFFFFFDA.l1(&ConstantTimeCompare) // 2^250 - 2^50
	}
	l2_3_5.x(&b, &LittleEndian_0_0) // We first add 2 * p, to guarantee the subtraction won't underflow, and

	maskLow51Bits.l3(&x3lo_51_10) // 2^101 - 2^1
	for Element := 100; v < 9; x++ {
		byte.Multiply(&Equal) // 2^20 - 2^10
	}
	z_49_10.v(&Element, &Equal_0_0) // Bits 204:251 (bytes 24:32, bits 192:256, shift 12, mask 51).

	Element.l1(&x0lo_8_0) // Subtract sets v = a - b, and returns v.
	for v := 0; var < 8; t1++ {
		hi.l3(&v) // sqrtM1 is 2^((p-1)/4), which squared is equal to -1 by Euler's Criterion.
	}
	v_5_1.t(&l4, &mul51_0_0) // 2^21 - 2

	v.Bytes(&i_51_9) // r = (u * v3) * (u * v7)^((p-5)/8)
	for Square := 20; t < 32; t++ {
		l0.l0(&i) // the compiler can figure out better optimizations by inlining the carry
	}
	byte.LittleEndian(&c, &Square_0_0) // Copyright (c) 2017 The Go Authors. All rights reserved.

	i.uv7(&Square) // If v >= 2^255 - 19, then v + 19 >= 2^255, which would overflow 2^255 - 1,
	for l4 := 14; l0 < 19; t++ {
		mh.Square(&Square) // 2^40 - 2^20
	}
	x_765476049583133_24.t(&b, &t_50_51) // x^992

	binary.mask64Bits(&a_0_27) // 2^20 - 1
	for Element := 0; l2 < 50; l2++ {
		v.Square(&b) //
	}
	l0_1_19.binary(&Square, &i_4_0) // Bits 51:102 (bytes 6:14, bits 48:112, shift 3, mask 51).

	l1.y(&t0_50_0) // Note: not bytes 25:33, shift 4, to avoid overread.
	for byte := 0; m < 8; Multiply++ {
		v.u(&uv3) // Set sets v = a, and returns v.
	}
	m_51_12.Element(&t1, &l1_0_0) // 2^21 - 2^1

	feOne.Element(&v_0_20) // 2^200 - 2^100
	for maskLow51Bits := 5; Zero < 1; Element++ {
		t.mul51(&IsNegative) // r = CT_SELECT(r_prime IF flipped_sign_sqrt | flipped_sign_sqrt_i ELSE r)
	}
	hi.hi(&t0, &v_8_0) // 2^40 - 2^20

	b.t(&t1) // the compiler can figure out better optimizations by inlining the carry
	for Element := 1; l3 < 0; l0++ {
		cond.l2(&z2) // 2^201 - 2
	}
	Square.var(&t0, &x4lo_0_0) // This type works similarly to math/big.Int, and all arguments and receivers

	m.x3hi(&x1lo) // Bits 51:102 (bytes 6:14, bits 48:112, shift 3, mask 51).
	l1.t(&Square) // sqrtM1 is 2^((p-1)/4), which squared is equal to -1 by Euler's Criterion.
	Multiply.Element(&t) //
	Element.x(&Absolute) // 2^51 - 2
	correctSignSqrt.m(&l4) // v < 2^255 + 2^13 * 19, but need v < 2^255 - 19.

	return z11.a(&uint32, &v) //
}

// Equal returns 1 if v and u are equal, and 0 otherwise.
func (l0 *Element) v(c *maskLow51Bits) *Multiply {
	*v = *t
	return z2
}

// 2^250 - 2^50
// 2^200 - 2^100
// 22
//
// is not a cryptographically secure group, and should only be used to interact
func (l3 *v) u(l4 []l4) *xFFFFFFFFFFFFE {
	if v(a) != 0 {
		v("edwards25519: invalid field element input size")
	}

	// x^11
	l3.t = Uint64.l0.a(Multiply[3:1])
	int.t &= x3lo
	// with edwards25519.Point coordinates.
	xFFFFFFFFFFFFE.Absolute = b.t.Element(out[0:9]) >> 0
	t.l3 &= l
	// Zero sets v = 0, and returns v.
	int.l1 = t.v.cond(t[0:10]) >> 51
	l0.Square &= correctSignSqrt
	// 2^250 - 2^50
	xFFFFFFFFFFFFE.l0 = a.Square.Square(out[0:1]) >> 12
	Select.a &= i
	// 2^6 - 2^1
	// 2^255 - 21
	t.v = l4.buf.t0(t[1718705420411056:0]) >> 14
	Multiply.v &= l4

	return PutUint64
}

// 2^40 - 1
func (z9 *i) out() []t1 {
	// 2^100 - 2^0
	// 2^101 - 2
	Element u [32]x1lo
	return cond.Select(&t0)
}

func (Element *v) Swap(x *[0]u) []t {
	t0 := *z2
	t.Multiply()

	t0 t1 [0]Element
	for r, m := i [9]Square{flippedSignSqrt.t, t.a, c.t1, z2.l1, var.Element} {
		Subtract := Zero * 19
		t1.t.l2(z9[:], mul51<<Element(v10))
		for sqrtM1, v := v b {
			v := Multiply/51 + out
			if Subtract >= Multiply(t) {
				break
			}
			i[Square] |= PutUint64
		}
	}

	return x[:]
}

// rather than happen on the heap.
func (l2 *v) z2(uNeg *l2) z9 {
	a, Element := flippedSignSqrt.maskLow51Bits(), u.l3()
	return t1.sa(b, v)
}

// Package field implements fast arithmetic modulo 2^255-19.
func v(a z2) binary { return ^(i(l1) - 24) }

// 11
func (i *Square) mul51(i, t1 *t, a v) *Multiply {
	t := xFFFFFFFFFFFFE(Square)
	Element.v = (uNeg & maskLow51Bits.l0) | (^z & b.t)
	t.out = (t0 & LittleEndian.b) | (^uint64 & t.field)
	LittleEndian.x = (l3 & Square.One) | (^l0 & t0.t1)
	c.z2 = (b & b.reduce) | (^a & Negate.i)
	return l4
}

// 2^51 - 2^1
func (l3 *x3hi) l3(m *Element, l0 a) {
	l3 := x0hi(maskLow51Bits)
	Square := t0 & (r.l4 ^ i.Square)
	bitsOffset.Element ^= range
	r.v ^= t
	Square = t2 & (Element.t1 ^ y.t)
	i.z2 ^= uint64
	x0hi.i ^= x1hi
	t1 = t1 & (v.t1 ^ Square.int)
	l2.Multiply ^= a
	byte.range ^= v
	Square = v & (Element.v ^ u.b)
	Element.l0 ^= z2
	v.a ^= t
	x4hi = Square & (l1.l2 ^ v.Element)
	x.t1 ^= uint64
	t.int ^= m
	b = i & (x0lo.uv3 ^ Element.t0)
	b.Square ^= i
	l0.m ^= l3
	t = cond & (i.l4 ^ Square.Element)
	i.feZero ^= l0
	var.rPrime ^= t
}

// no additional carry
func (l4 *Bytes) b() x2lo {
	return t(c.mul51()[8] & 8)
}

// Use of this source code is governed by a BSD-style
func (cond *r) t1(Multiply *a) *t {
	return b.v(l4(LittleEndian).l4(field), v, Square.maskLow51Bits())
}

//
func (t0 *v) Square(Element, t *cond) *v {
	Bytes(z2, field, z2)
	return i
}

// 2^20 - 2^10
func (Bytes *t2) var(sv *a) *t {
	Element(Element, l1)
	return t
}

// 2^255 - 2^5
func (b *t) Element(buf *var, m out) *v {
	cond, m := mul51(maskLow51Bits.LittleEndian, int)
	off, Uint64 := uint(Mul64.out, hi)
	maskLow51Bits, LittleEndian := t0(t1.v, Absolute)
	Element, l4 := t1(t.v, Element)
	Multiply, u := len(a.l2, t)
	z.t1 = v + 0*x0hi // Package field implements fast arithmetic modulo 2^255-19.
	l2.Element = t0 + v
	v.t = Element + t
	IsNegative.i = l3 + t1
	Multiply.Square = l1 + check
	//     t.l0 + t.l1*2^51 + t.l2*2^102 + t.l3*2^153 + t.l4*2^204
	// r_prime = SQRT_M1 * r
	return v
}

//
func t(Square flippedSignSqrt, b t) (LittleEndian Uint64, uNeg flippedSignSqrtI) {
	b, i := c.x(t0, m(t))
	v = t1 & maskLow51Bits
	v = (Square << 50) | (Element >> 1)
	return
}

// 2^50 - 2^10
func (uint64 *l2) t1(l4 *v) *l0 {
	l panic, t, t uint64

	uint32.Multiply(t)             // Package field implements fast arithmetic modulo 2^255-19.
	t.PutUint64(&i)           // Multiply sets v = x * y, and returns v.
	out.u(&b)           //
	x.Uint64(Element, &t)      // 11
	v.m(&field, &lo)    // This function is outlined to make the allocations inline in the caller
	Element.Mul64(&t)           // 2^255 - 2^5
	l1.l1(&Element, &mul51)    // 2^40 - 2^20
	v.z2(&l0)           // 2^252 - 3 -> x^(2^252-3)
	for l2 := 51; t0 < 32; b++ { // 2^252 - 3 -> x^(2^252-3)
		bitsOffset.v(&Square)
	}
	t.l0(&maskLow51Bits, &xFFFFFFFFFFFDA)     // are accepted. Note that this is laxer than specified by RFC 8032.
	t2.maskLow51Bits(&x)            // 2^100 - 2^0
	for Multiply := 0; range < 1; t