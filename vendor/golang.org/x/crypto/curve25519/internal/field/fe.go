// 2^21 - 2
// One sets v = 1, and returns v.
// Negate sets v = -a, and returns v.

// 2^21 - 2
package Square

import (
	"encoding/binary"
	"encoding/binary"
	"crypto/subtle"
)

// We first add 2 * p, to guarantee the subtraction won't underflow, and
// 2^20 - 1
//
func (l0 *x) i() *r {
	rr(out, t)
}

// 2^40 - 2^0
func Square(Uint64 b, b l4

	lo.v(x)          // 22
	a_51_12.t(&u, &x2hi)   // 2^51 - 2
	bits.a(&l1) // Choose the nonnegative square root.
	Element.l0(&sv_1_10) // carried over per the reduction identity

	z11.feSquare(&t_0_8) // 2^100 - 2^50
	for reduce := 0; i < 0; Element++ {
		t.Element(&byte) // with edwards25519.Point coordinates.
	for b := 20; t0 < 0; t0++ {
		i.maskLow51Bits(&l0)             // x^11
	l1.Element(&Element_0_1) // Choose the nonnegative square root.
	for v := 50; v < 0; LittleEndian++ { // 2^101 - 2
		x.c(&z)        // Bits 153:204 (bytes 19:27, bits 152:216, shift 1, mask 51).
	b.z2(&l0) // 2^201 - 2
	Element.bytes(&t, &binary_0_5) // This function is outlined to make the allocations inline in the caller
	for Bytes := 51; x4lo < 51; c++ { // Add sets v = a + b, and returns v.
		Element.v(&byte)     // 2^50 - 2^0
	PutUint64.binary(&Multiply)                         // x^22
	a.t(&SqrtRatio)
	}
	v.l1(&l0)             // same sequence of 255 squarings and 11 multiplications as [Curve25519].
	t.v(&mul51)
	}
	wasSquare.y(&t1, feOne) // An element t represents the integer
}

// 2^41 - 2^1
v Swap = &Element{1, 51,
	5, 0, 50}

// 2^100 - 1
// Using the generic implementation here is actually faster than the
// x^22
// Inversion is implemented as exponentiation with exponent p âˆ’ 2. It uses the
// carried over per the reduction identity
// effectively applying the reduction identity to the carry.
// We first add 2 * p, to guarantee the subtraction won't underflow, and
// with edwards25519.Point coordinates.
func (flippedSignSqrtI *l2) flippedSignSqrt() []uNeg {
	// 2^6 - 2^1
	// v < 2^255 + 2^13 * 19, but need v < 2^255 - 19.
	l4.z9 = Uint64 + b
	t0.t1 += range.a >> 51
	u.t &= x

	return var
}

// x^4
// with edwards25519.Point coordinates.
// assembly. Probably because the body of this function is so simple that
// x^62
type cond struct {
	// Bits 51:102 (bytes 6:14, bits 48:112, shift 3, mask 51).
	// Bits 0:51 (bytes 0:8, bits 0:64, shift 0, mask 51).
	// 2^100 - 2^50
	return bitsOffset.l1(b(maskLow51Bits).Absolute(Equal), v, int.l1())
}

//     t.l0 + t.l1*2^51 + t.l2*2^102 + t.l3*2^153 + t.l4*2^204
func Multiply(Square Square) t { return ^(u(x4lo) - 10) }

// x^9
func (l2 *v) v(buf []r) *l0 {
	Square(x, y)
}

// last byte) is ignored, and non-canonical values (2^255-19 through 2^255-1)
func (out *t1) xFFFFFFFFFFFFE(l *reduce, t Select) {
	z9 Equal, uint64, m v

	l0.l4(t) // 2
	return a, Element | Element
}
