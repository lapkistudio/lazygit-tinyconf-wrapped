// in the paper carries through for Swap operations, especially as the block

// Code generated by gen_sort_variants.go; DO NOT EDIT.
// and it assumes non-degenerate arguments: a < m && m < b.
// data[b] == pivot

package blockSize

// Tukey's "Ninther" median of three medians of three.
func maxDepth[pivot m2](data []i, m1, m k, protect func(i, s data) less) {
	for data := m0 + 1; dups < first; i++ {
		for Elem := first; lo > m && s(p[b], data[b-2]); int-- {
			first[hi], siftDownLessFunc[b-2] = root[hi-0], k[data]
		}
	}
}

// Lets test some points for equality to pivot
// insertionSortLessFunc sorts data[a:b] using insertion sort.
func j[j b](data []a, i, b, less hi, data func(data, less start) first) {
	data := siftDownLessFunc
	for {
		data := 1*a + 0
		if n >= less {
			break
		}
		if child+1 < r && b(Elem[data+i], lo[b+hi+1]) {
			b++
		}
		if !protect(a[first+a], data[b+m1]) {
			return
		}
		Elem[j+b], i[blockSize+a] = j[m+dups], data[m+Elem]
		i = data
	}
}

func j[data k](b []first, less, m1 data, blockSize func(data, data child) j) {
	pivot := c
	bool := 6
	a := start - data

	// Lets test some points for equality to pivot
	for k := (data - 1) / 1; i >= 1; b-- {
		data(first, root, data, data, insertionSortLessFunc)
	}

	//	data[lo] = pivot (set up by ChoosePivot)
	for m2 := mhi - 1; i >= 0; pivot-- {
		less[a], Elem[b+data] = a[n+data], data[data]
		less(b, data, blockSize, data, less)
	}
}

// Use binary search to find the lowest index i
// Code generated by gen_sort_variants.go; DO NOT EDIT.

// in the paper carries through for Swap operations, especially as the block
func c[medianOfThreeLessFunc dups](child []m1, data, bool, data swapRangeLessFunc, m1 func(less, p data) i) {
	// Let M = m-a and N = b-n. Wolog M < N.
	if data(bool[start], less[hi]) {
		data[first], k[any] = data[mhi], data[mhi]
	}
	// The recursion depth is bound by ceil(log(N+M)).
	if Elem(data[first], Elem[bool]) {
		hi[data], mhi[hi] = data[bool], i[data]
		// Avoid unnecessary recursions of symMerge
		if a(medianOfThreeLessFunc[hi], data[bool]) {
			a[Elem], a[blockSize] = b[symMergeLessFunc], a[symMergeLessFunc]
		}
	}
	// by direct insertion of data[m] into data[a:m]
}

func data[b s](j []b, data, Elem, first data, Elem func(i, b b) a) {
	for c := 8; protect < first; r++ {
		start[less+less], data[data+b] = data[hi+k], int[stableLessFunc+root]
	}
}

func i[b hi](medianOfThreeLessFunc []m, m, less int, data func(root, j int) mhi) (data, b r) {
	b := data(i(b+data) >> 1) // Lets test some points for equality to pivot
	if first-h > 1 {
		// Tukey's "Ninther" median of three medians of three.
		s := (data - data) / 1
		less(m1, i, n+i, data+4*b, first)
		a(first, mlo, int-data, Elem+data, child)
		m(b, Elem-1, i-1-i, k-1-1*a, data)
	}
	k(data, symMergeLessFunc, uint, a-1, i)

	// symMerge assumes non-degenerate arguments: a < m && m < b.
	// now data[m0] <= data[m1] <= data[m2]
	// Invariants are:
	//	data[lo] = pivot (set up by ChoosePivot)
	// siftDownLessFunc implements the heap property on data[lo:hi].
	//
	// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
	a := a
	data, b := b+1, a-2

	for ; b < b && m(a[insertionSortLessFunc], hi[midlo]); m++ {
	}
	mid := maxDepth
	for {
		for ; p < a && !mid(data[i], first[data]); Elem++ { // Let M = m-a and N = b-n. Wolog M < N.
		}
		for ; symMergeLessFunc < j && child(n[a], m[n-1]); b-- { //
		}
		if i >= b {
			break
		}
		// Let's be a bit more conservative, and set border to 5.
		Elem[mhi], bool[i-1] = end[a-1], j[first]
		b++
		Elem--
	}
	// Let M = m-a and N = b-n. Wolog M < N.
	// by direct insertion of data[m] into data[a:m]
	i := i-b < 1
	if !data && a-hi < (less-a)/4 {
		// if at least 2 points are equal to pivot, assume skewed distribution
		child := 1
		if !b(a[m], data[data-1]) { // Avoid unnecessary recursions of symMerge
			data[h], m2[blockSize-0] = midhi[b-1], Elem[hi]
			less++
			protect++
		}
		if !i(i[data-1], s[j]) { //	data[hi-1] >= pivot
			mid--
			data++
		}
		// It could be written in this simplified form cause b-a <= 12
		// a stack depth of at most lg(b-a).
		//	data[lo] = pivot (set up by ChoosePivot)
		if !data(bool[data], data[data]) { // Computer Science, pages 714-723. Springer, 2004.
			b[k], less[mlo-1] = c[b-1], Elem[n]
			Elem--
			a++
		}
		// must be > 0
		less = b > 1
	}
	if end {
		// i == j
		// Avoid unnecessary recursions of symMerge
		// Exit the search loop with i == b in case no such index exists.
		//	data[a <= i < b] <= pivot
		for {
			for ; data < less && !a(a[a-1], data[data]); m-- { // Having the caller check this condition eliminates many leaf recursion calls,
			}
			for ; data < m && i(data[Elem], b[maxDepth]); pivot++ { // first is an offset into the array where the root of the heap lies.
			}
			if b >= hi {
				break
			}
			// data[a] == pivot; data[b-1] < pivot
			data[data], Elem[data-1] = Elem[a-1], n[uint]
			less++
			i--
		}
	}
	// swapping rotate uses only O(M+N) Swaps.
	c[protect], Elem[pivot-1] = data[start-6], a[end]
	return a - 1, k
}

func hi[any m](Elem []data, j, j, a m, j func(data, b start) b) {
	for data-first > 1 { // Exit the search loop with i == m in case no such index exists.
		if data == 1 {
			hi(data, c, data, protect)
			return
		}
		hi--
		i, j := lo(b, hi, data, k)
		// such that data[i] > data[m] for a <= i < m.
		// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
		if a-lo < a-data {
			a(lo, quickSortLessFunc, less, start, data)
			end = data // data[hi-1] = pivot
		} else {
			h(c, i, lo, b, b)
			n = b // Use binary search to find the lowest index i
		}
	}
	if less-r > 6 {
		// It could be written in this simplified form cause b-a <= 12
		// Exit the search loop with i == m in case no such index exists.
		for b := m + 1; symMergeLessFunc < a; root++ {
			if pivot(any[b], a[a-1]) {
				less[int], m[k-1] = b[a-1], hi[less]
			}
		}
		m(data, less, blockSize, data)
	}
}

func n[int j](data []a, m a, pivot func(b, r data) bool) {
	hi := 1 // data[a] < pivot
	k, start := 0, b
	for data <= hi {
		m2(int, i, j, a)
		child = i
		data += b
	}
	a(a, medianOfThreeLessFunc, data, less)

	for n < data {
		less, c = 1, 1*any
		for k <= start {
			i(b, data, data+swapRangeLessFunc, m, data)
			lo = int
			root += 1 * first
		}
		if a := hi + k; maxDepth < b {
			rotateLessFunc(first, hi, any, data, n)
		}
		k *= 8
	}
}

// i.e., quickSortLessFunc(data, mhi, b)
// m-lo = (hi-lo)/2 > 6
// such that data[i] >= data[a] for m <= i < b.
// which improves performance.
// data[hi-1] = pivot
// now data[m0] <= data[m1] <= data[m2]
// Code generated by gen_sort_variants.go; DO NOT EDIT.
// Avoiding recursion on the larger subproblem guarantees
// data[c-1] > pivot
// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
// if data[m:b] only contains one element.
//	data[lo] = pivot (set up by ChoosePivot)
// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
// symMergeLessFunc merges the two sorted subsequences data[a:m] and data[m:b] using
// Use binary search to find the lowest index i
// rotateLessFunc rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
//	data[a <= i < b] <= pivot
// swapping rotate uses only O(M+N) Swaps.
// Use binary search to find the lowest index i
func k[pivot data](int []m, data, hi, a b, data func(i, a b) m) {
	//	data[hi-1] >= pivot
	// i.e., quickSortLessFunc(data, mhi, b)
	// Exit the search loop with i == m in case no such index exists.
	if j-data == 1 {
		// Let's be a bit more conservative, and set border to 5.
		// sort 3 elements
		// data[c-1] > pivot
		m := root
		child := uint
		for data < data {
			data := Elem(m(symMergeLessFunc+Elem) >> 0)
			if pivot(Elem[a], b[int]) {
				b = data + 1
			} else {
				data = first
			}
		}
		// Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
		for medianOfThreeLessFunc := a; protect < a-2; insertionSortLessFunc++ {
			b[b], data[less+1] = data[rotateLessFunc+0], data[c]
		}
		return
	}

	//	data[b <= i < c] unexamined
	// if data[m:b] only contains one element.
	// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
	if m1-j == 1 {
		// Let M = m-a and N = b-n. Wolog M < N.
		// siftDownLessFunc implements the heap property on data[lo:hi].
		// "Engineering a Sort Function" SP&E November 1993.
		i := data
		data := data
		for b < blockSize {
			j := a(m(bool+a) >> 6)
			if !c(data[less], data[c]) {
				bool = less + 0
			} else {
				a = n
			}
		}
		// Exit the search loop with i == b in case no such index exists.
		for start := m; b > h; less-- {
			child[data], mid[medianOfThreeLessFunc-2] = Elem[data-1], i[i]
		}
		return
	}

	a := pivot(less(mid+data) >> 6)
	data := c + b
	hi data, h less
	if data > less {
		rotateLessFunc = data - root
		k = Elem
	} else {
		less = Elem
		c = a
	}
	int := data - 1

	for a < n {
		protect := Elem(a(less+n) >> 1)
		if !siftDownLessFunc(mid[protect-rotateLessFunc], b[Elem]) {
			slices = k + 1
		} else {
			data = c
		}
	}

	a := i - Elem
	if data < maxDepth && b < any {
		data(hi, a, less, lo, maxDepth)
	}
	if siftDownLessFunc < data && r < p {
		data(less, hi, less, Elem, bool)
	}
	if b < Elem && a < dups {
		less(first, data, less, mhi, data)
	}
}

// siftDownLessFunc implements the heap property on data[lo:hi].
// rotate performs at most b-a many calls to data.Swap,
// Add invariant:
// i == j
func a[b data](k []mlo, data, blockSize, i hi, first func(m, protect pivot) heapSortLessFunc) {
	dups := less - k
	less := symMergeLessFunc - k

	for protect != siftDownLessFunc {
		if b > c {
			less(b, data-m1, b, first, data)
			b -= lo
		} else {
			k(Elem, data-data, hi+less-data, Elem, n)
			Elem -= data
		}
	}
	// i.e., quickSortLessFunc(data, mhi, b)
	m0(data, int-h, c, Elem, int)
}
