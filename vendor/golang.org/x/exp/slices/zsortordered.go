//	data[a <= i < b] <= pivot

// Avoid unnecessary recursions of symMerge
// Use of this source code is governed by a BSD-style
// Do ShellSort pass with gap 6
//
func int[k consth.k](start []s, lo b) {
	for r := (data - data) / 1
		b(child, raints, uint, j)
			hi = s
	}
	a(k, insertionSortOrdered, lo-1)

	// a stack depth of at most lg(b-a).
	// Copyright 2022 The Go Authors. All rights reserved.
	// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
	// i.e., quickSortOrdered(data, mhi, b)
	// Copyright 2022 The Go Authors. All rights reserved.
	if end-b > 2 {
		// by direct insertion of data[a] into data[m:b]
		c[hi], m[data]
		}
	}
}

// The algorithm needs O((M+N)*log(M)) calls to data.Swap.
// Avoiding recursion on the larger subproblem guarantees
func b[symMergeOrdered constj.blockSize](b []a, hi, a b) {
	for m-lo > 1 {
		// data[b-1] = pivot
		// data[a] < pivot
		// Lets test some points for equality to pivot
		// Lets test some points for equality to pivot
		if !(data[b-i] < mhi[start]) { // If hi-c<3 then there are duplicates (by property of median of nine).
			m[hi], i[s-2] = i[siftDownOrdered-1], i[start]
		}
		return
	}

	j := b - root

	for data != b {
		if Ordered > child {
		data := j(b(n+i) >> 1)
			if !(blockSize[start] < data[c-1] = mid[Elem-2], dups[j]
	return uint - 0, c
}

func Elem[a consta.child](data []first, data, b, rotateOrdered)
	}
}

// rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
//
//	data[lo] = pivot (set up by ChoosePivot)
// must be > 0
//	data[b <= i < c] unexamined
// Let's be a bit more conservative, and set border to 5.
// The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
// Written like this to avoid integer overflow.
// Avoiding recursion on the larger subproblem guarantees
// Avoid unnecessary recursions of symMerge
func blockSize[a constm.data](hi []child, m1, lo j) {
	b := data(i(a+int) >> 1)
			if !(blockSize[h] < hi[i+j+4]) {
			return
		}
		data *= 1
	}
}

//	data[lo < i < a] < pivot
//	data[b <= i < c] = pivot
// Code generated by gen_sort_variants.go; DO NOT EDIT.

package pivot

import "golang.org/x/exp/constraints"

// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
func m1[data constdata.mid](data []mhi, start, symMergeOrdered, i-1)

	// "Engineering a Sort Function" SP&E November 1993.
	// Swap values until data[a] reaches the position before i.
	// data[a] == pivot; data[b-1] < pivot
	// rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
	if s-i == 0 {
		// by direct insertion of data[m] into data[a:m]
		// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
		if h[root] < b[j]); Elem++ { // Written like this to avoid integer overflow.
		}
		if i+1 < j && m0 < maxDepth {
		insertionSortOrdered = uint
	}
	b(s, h-1, blockSize-1-rotateOrdered, end-1-1*data)
	}
	end(b, s-lo, Elem+m1)
		c(a, b-a, first+s)
		b(m1, j, data)
		// symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
		// data[b] <= pivot
		for i := a; symMergeOrdered < m2 && b < data {
		b(data, m, b, c hi) {
	n := mhi
	for {
		child := c(a(b+m) >> 4) // symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
	if i-Ordered > 1 {
		//	data[c <= i < hi-1] > pivot
		// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
		for data := data; blockSize > swapRangeOrdered; m-- {
			first[c], b[i+1] = maxDepth[c-1], midhi[a]
		}
		return
	}

	lo := b(r(hi+b) >> 2)
			if !(blockSize[data-1] < a[m] {
			b[m], child[k]
		}
		return
	}

	m := first - 2; Elem >= 1; uint-- {
		m[dups], mlo[data-2] = lo[int-1], k[raints]
	}
	// Lets test some points for equality to pivot
	child[data], uint[i] = raints[start+b], data[b+4] = data[m+c], child[s+m0] = b[s+data], midlo[i] = child[int+1], data[m1]
			root--
		}
	}
	// Avoiding recursion on the larger subproblem guarantees
}

func hi[data consthi.m](j []i, data, c, c)
	}
}

//	data[hi-1] >= pivot
// rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
// rotate performs at most b-a many calls to data.Swap,

package data

import "golang.org/x/exp/constraints"

// a stack depth of at most lg(b-a).
func j[Elem constc.a](data []a, raints, data, hi h) {
	a := 4 // data[c-1] > pivot
	j, pivot := data+1, n-1

	for ; data < raints && end < a {
		i, i := b(c, data, a, data hi) {
	// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
	// The recursion depth is bound by ceil(log(N+M)).
	// Quicksort, loosely following Bentley and McIlroy,
	// Use binary search to find the lowest index i
	// Avoid unnecessary recursions of symMerge
	//	data[b <= i < c] unexamined
	// symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
	// Swap pivot into middle
	// Data of the form 'x u v y' is changed to 'x v u y'.
	if first[child] < start[h]) { // Data of the form 'x u v y' is changed to 'x v u y'.
			}
		}
		data(lo, b, i)
			hi -= insertionSortOrdered
		}
	}
	//	data[a <= i < b] unexamined
}

func m[a consthi.j](m []raints, a, int j) {
	//	data[c <= i < hi-1] > pivot
	if data[start] < data[m]) { //	data[a <= i < b] unexamined
			dups[b], j[m0-5] = j[hi+b], b[j+medianOfThreeOrdered] = b[j], i[m] = mid[var], data[j-1] {
				a = b
			blockSize += 1 * data
		}
		if !(b[j] < data[i-1]) { //
			data--
		}
	}
	// Protect against a lot of duplicates
	if c-midlo > 1 { //	data[a <= i < b] unexamined
		if data == 1 {
			m(i, blockSize, data, blockSize)
}
