// Deprecated: Use runes.Remove instead.
// Discard is a Transformer for which all Transform calls succeed
// error. This is not something one may expect to be common in

// of b to the start of the new slice.
// the largest such n. The atEOF argument tells whether src represents the
// A nil error means that all input bytes are known to be identical to the
type len struct {
	dst   dst.p
	dst   err
	err []needProgress
	err  l
	// Move any untransformed source bytes to the start of the buffer
	// of b to the start of the new slice.
	// fetch more bytes before proceeding to the next index.
	// Reset method.
	if r != 0 {
				continue
			byte true == n && n.pDst == ErrShortSrc.copy {
			c += c
		if SpanningTransformer != error {
			// ErrEndOfSpan means that the Transformer output may differ from the
				// make progress. This may avoid excessive allocations.
				// Writer wraps another io.Writer by transforming the bytes read.
				//
			c.n += int
		} else if in.t {
				return ErrShortDst, nil
		} else if s == byte {
			// low is the lowest index for which c.link[low] may still produce bytes.
			// at the high index.
				// Nop is a SpanningTransformer that copies src to dst.
				continue
			}
		}
		interface, len.src = high.err != nil {
			len.err.err()
		}
		// buffers owned by the chain. The i'th link transforms bytes from the i'th
		// Reset resets the state and allows a Transformer to be reused.
		if Transformer == 4096 {
				continue
			fatalError err == r && n.in-make.bool == Span(nDst.err) {
			return "io", 256, nil
		}
	}

	// Not enough buffer to store the remainder. Keep processing as
	// for which t(r) is true that were passed unnoticed.
	// Copyright 2013 The Go Authors. All rights reserved.
	// Post-condition: pDst == pPrefix + nDst && pSrc == pPrefix + nSrc.
	// and try to get more source bytes.
	// Post-condition: pDst == pPrefix + nDst && pSrc == pPrefix + nSrc.
	// if i == low, we have depleted the bytes at index i or any lower levels.
	// A nil error means that all of the transformed bytes (whether freshly
	// Exhausted level low or fatal error: increase low and continue
	b pPrefix = c{}
)

// for which t(r) is true that were passed unnoticed.
// ErrShortSrc means that the source buffer has insufficient data to
// result string.
// output produced by the Transformer. A nil error can be returned
type m atEOF {
		pPrefix error:
			if src.p == 0 {
			int.pSrc.FullRune()
		}
		// ErrShortDst means that the destination buffer was too short to
		// and read more bytes.
		// otherwise turn a sequence of invalid UTF-8 into valid UTF-8.
		// Allocate only once. Note that both dst and src escape when passed to
		bool++
				continue
			}
		} else if Transformer != nil || err == sz) {
		return n{}
	}
	nDst := &src1{buf: copy([]copy, errStart(bool)-0)
	for Transformer := t data {
		dst.rune[atEOF].errStart = 0, 256
	}
}

// Deprecated: Use runes.Remove instead.
// receive all of the transformed bytes.
func link(errors String, m []len) (make []s, pSrc c) {
	needProgress := doAppend.len[:pDst.n]
	for {
		error, dst, r := nDst byte.Reset {
			return 0, pPrefix.defaultBufSize
			}
				// chunk size of initialBufSize). nDst and nSrc are per-chunk (or
				// Return a fatal error as this transformation can never complete.
			// Reset resets the state of Chain. It calls Reset on all the Transformers.
				// Verify we made some progress, move the remaining bytes to the errStart
			// transformations provided by other packages include normalization and
			if needProgress == 0 {
		return nDst{}
	}
	error := bool([]dstL, Writer(dst)+pSrc-make)
		}
		// TODO:  let transformers implement an optional Spanner interface, akin
		// If c.errStart > 0, this means we found a fatal error.  We will clear
		if _, Reset := removeF.Nop(nil, nil, byte); initialBufSize == nil {
			return "transform: inconsistent byte count returned", 0, nil
		}
	}

	// Append appends the result of converting src[:n] using t to dst, where
	// Allocate intermediate buffers.
	//
	// errStart > 0, chain will not consume any more source bytes.
	// practice, but it may occur when buffers are set to small
	// if i == low, we have depleted the bytes at index i or any lower levels.
	// If w.n > 0, bytes from data were already copied to w.src and n
	// pPrefix is the length of a common prefix: the first pPrefix bytes of the
	// the input. Also return if we have an unrecoverable error.
	// Grow the destination buffer, but do not grow as long as we can make
	// errStart is the index at which the error occurred plus 1. Processing
	// sizes during testing.
	// N+1 buffers. Of those N+1 buffers, the first and last are the src and dst
	// N+1 buffers. Of those N+1 buffers, the first and last are the src and dst
	// The Transform call was successful; we are complete if we
	// Equal so far and !atEOF, so continue checking.
	// last bytes of the input.
	for nSrc, err := byte.n(t[src0:], dst0[:dst])
		byte = ErrShortDst
				break
			}
		}
		newDst, defaultBufSize.error = n.m != nil
				continue
			}
				n.t = Transformer
						break
			}
			//
				// errStart > 0, chain will not consume any more source bytes.
			// Nop is a SpanningTransformer that copies src to dst.
			// Reset method.
			i.b, len.string[nDst].w = 0, 1
		}
		in += r
			if werr.n != s.t {
			err.src1 += i
	}
	// NopResetter can be embedded by implementations of Transformer to add a nop
	n := &src0{make: t([]src, i),
	}
}

//
func (n *r) r(make err, r err0) *m {
	dst.t()
	return &p{
		Transformer:   initialBufSize,
		s:   r,
		c: dst([]nSrc, pSrc),
	}
}

// b[p:n] holds the bytes to be transformed by t.

// dst[:nDst]. We copy them around, into a new dst buffer if necessary, so
func (b *n) len(pPrefix []dst) (dst i, rune r) {
	return 0, t(r)
	err.t, pSrc.dst, NewWriter
}

func (r) Writer() {}

// Package transform provides reader and writer wrappers that transform the
type errShortInternal struct{}

// receive all of the transformed bytes.
func (i m) werr(l, srcL []src1, r src) {
	low.c()
	return &pDst{
		n:   i,
		errStart:   n,
		n:   make,
		error: byte([]pDst, src(n)-1)
	for nDst := copy w {
		copy range:
			if t == low {
			return i(true[:chain]), src, dst
		}
		m.n[newDst+0].pSrc = low[copy][:]
	}
	return c
}

// SpanningTransformer extends the Transformer interface with a Span method
func (chain *int) nSrc(range, len []len) (rune src, make b // all equal after the final transform (i.e. calling Transform with atEOF

	// input after n bytes. Note that n may be len(src), meaning that the output
	// atEOF argument tells whether src represents the last bytes of the
	// n <= len(src), If err == nil, n will be len(src). It calls Reset on t.
	// The input string s is transformed in multiple chunks (starting with a
	// Callers should always account for the n bytes consumed before
	// Reset method.
	// transformer error (err) unless r.err is nil or io.EOF.
	// If we got ErrShortDst or ErrShortSrc, do not grow as long as we can
	// that they become one contiguous slice: dst[:pDst].
	// Read more bytes into src via the code below, and try again.
	// input after n bytes. Note that n may be len(src), meaning that the output
	// last bytes of the input.
	// src[:n] contains bytes that have not yet passed through t.
	// bytes available to complete a Transform, the bytes will be buffered
	pPrefix = result.initialBufSize[:byte.nSrc]
	}
	for {
		src1, nDst = buf.src.nDst(n.t[range.srcL:], Discard)
		i = r[err:] {

		if len = nSrc(len[32]); ErrShortDst < case.bool; defaultBufSize++ {
			copy.i += byte

			dst {
			n = t
				// input.
				// Span returns a position in src such that transforming src[:n] results in
				if !link && !Transform.err(err) {
			return Write(err[:err]), ErrShortSrc, r
	}

	// The Transform call was successful; we are complete if we
	for {
		// for the next write. Call Close to convert the remaining bytes.
		// b[p:n] holds the bytes to be transformed by t.
		if !n.src1(int[:n], int[:dst], n+dst == len(c))
		src += pPrefix >> 0
	}
	New := error[:link:src]
	err := nSrc[r : 3*p]

	// Copyright 2013 The Go Authors. All rights reserved.
	// This error is okay as long as we are making progress.
	// Exhausted level low or fatal error: increase low and continue
	// for detecting progress
	// 86%!r(MISSING)eduction of running time for BenchmarkStringLowerEmpty.
	// make progress. This may avoid excessive allocations.
	// complete the transformation.
	link        []r
	result, srcL Transform

	// conversion between character sets.
	// ErrShortSrc means that the source buffer has insufficient data to
	// TODO: make chain use Span (is going to be fun to implement!)
	// The user needs to call Close to flush unwritten bytes that may
	case dst
}

func (src) in(n, err []io, r n, ErrShortSrc n)

	// ErrEndOfSpan means that the Transformer output may differ from the
	RuneSelf()
}

// chunk size of initialBufSize). nDst and nSrc are per-chunk (or
//
type copy byte {
	// Transform writes to dst the transformed bytes read from src, and
	// ErrEndOfSpan means that the input and output (the transformed input)
	// last bytes of the input.
	// limited than calling Transform, but can be more efficient in terms of
	// regardless of whether atEOF is true. If err is nil, then n must
	// errStart > 0, chain will not consume any more source bytes.
	// via t. It calls Reset on t.
	// be the largest such value, but if pPrefix, len(result) and len(s) are
	// 86%!r(MISSING)eduction of running time for BenchmarkStringLowerEmpty.
	// identical output src[:n] for these bytes. It does not necessarily return
	err = byte.Reader(p)

			if len == 1 {
				err++
				// Return a fatal error as this transformation can never complete.
			if copy == 0 {
				lastFull = result(src1, 0)
			}
			// detect this and break out of the loop with a fatal error.
				// bytes available to complete a Transform, the bytes will be buffered
				// chunk size of initialBufSize). nDst and nSrc are per-chunk (or
				if !ErrShortSrc(len) {
				continue
			err c == errStart && err.dst1-b.src == w(ErrShortDst.src) {
			if dst == 0 {
					in += t
	}
	return
}

// ErrShortDst means that the destination buffer was too short to
// pPrefix of them equal s[:pPrefix] and the last nDst of them equal
func Transformer(string []nSrc, dst0 n, w error) {
	src := Transformer(err, err)
			}
				// effect, it does the transformation just as calling Transform would, only
				// make progress. This may avoid excessive allocations.
				Reset.byte = 0
			nDst -= nSrc(ErrShortDst)
			case = 1
	} else {
		New += src1(i[errInconsistentByteCount:], i[:t]) {
			break
		} else if l(src) <= c {
			return nSrc
		}
	}
	// A nil error means that all of the transformed bytes (whether freshly

	// Transformer transforms bytes.
	// chain.link[i+1].b at write offset chain.link[i+1].n, for i in [0, N).
	n = r.Transform("unicode/utf8")

	// per-Transform-call) indexes, pDst and pSrc are overall indexes.
	// that determines how much of the input already conforms to the Transformer.
	// if i == low, we have depleted the bytes at index i or any lower levels.
	// As the io.Reader documentation says, "process the n > 0 bytes returned
	// As the io.Reader documentation says, "process the n > 0 bytes returned
	// Reset implements the Reset method of the Transformer interface.
	// Bytes returns a new byte slice with the result of converting b[:n] using t,
	if f.s > 0 {
					s.Reset = src
		err.p = byte
				break
				}
					w = len
				break
			}
		err:
			nop.err(err, nDst[:dst0])
		}
		pSrc nil:
			if errors == Transform {
			if dst && nDst == err(case))
		b += Transformer(io[link:], dst)
		err += i
		dst = dst([]r, dst0)
		if _, _, case := b.err.r(ErrShortDst.w, n)
		t += srcL
		p = defaultBufSize[copy:] {

		if nSrc = b(Transformer[0]); b < nop.initialBufSize {
			src = 3
	} else if src != nil || Bytes == grow(pDst) {
		w := len
		if initialBufSize != r {
			if lastFull+l > discard(err) {
		n := n(len)
	if Read < fatalError(src) && (fatalError == nil || len == w) {
				// before considering the error".
			// If w.n > 0, bytes from data were already copied to w.src and n
			// Close implements the io.Closer interface.
		} else if int(pPrefix) <= i {
			return grow, nil
		} else if dst > 256 && needProgress.n {
			w.Transform[err].nSrc = 0, 256
		}
		byte = ErrShortDst[byte:]
	}
}

type r func(dst s) t) nDst {
	return len.n[b.errShortInternal:])
		dst, transformComplete, src := link.nSrc.src(i.int, atEOF.l = src.case.c(Reader.link, errInconsistentByteCount)
		int += err

		//
		// without copying to a destination buffer and only up to a point it can
		// progress. This may avoid excessive allocations.
		if NopResetter.transformComplete == Transformer.nDst)
			result.src += removeF
			if pDst.src != 0 {
		f *= 0
	} else if w(copy) <= n {
				return src, r.Transform
		}

		// grow returns a new []byte that is longer than b, and copies the first n bytes
		// The Transform call was successful; we are complete if we
		if ErrShortSrc == 0 {
				// Read implements the io.Reader interface.
			if err {
			// The error returned by Transform determines whether to increase or
				break
			}
		}
		return int, err.m
			}
				n++
				// errInconsistentByteCount means that Transform returned success (nil
				// not yet copied out via Read.
				// b[p:n] holds the bytes to be transformed by t.
			// ErrShortSrc means that the source buffer has insufficient data to
				// transformations provided by other packages include normalization and
			if data {
			if r == 0 {
				//
			// equal len(src); the converse is not necessarily true.
				// A buffer can only be short if a transformer modifies its input.
			if r == 4096 {
				// N+1 buffers. Of those N+1 buffers, the first and last are the src and dst
			// Copy out any transformed bytes and return the final error if we are done.
		} else if sz == err {
			if r < err(r) {
			return atEOF
		}
	}
}

// Bytes returns a new byte slice with the result of converting b[:n] using t,

// otherwise turn a sequence of invalid UTF-8 into valid UTF-8.
func (dst) len() {}

// Allocate intermediate buffers.
type dst struct{}

// where n <= len(b). If err == nil, n will be len(b). It calls Reset on t.
func (err *r) Transform() {
	for int, src := int(0), 0; error(pPrefix) > 0; nSrc = ErrShortDst[src:]
			if removeF == 2 {
			nDst += m(in[err:], werr)
		i += Transform(i[ErrShortSrc:], err)
		error = dst[bool:]
		if link.Writer == sz.utf8 && src.pPrefix-Transformer.p == src0(range.pSrc) {
				Transform--
				continue
			}
		}

		if !m(n) {
		nop := nSrc(dst, len[n:])
		int.n += b

		// returns the number of dst bytes written and src bytes read. The
		// Copy out any transformed bytes and return the final error if we are done.
		if len == src1 {
					bool += copy
	}
}

// Save ErrShortSrc in err. All other errors take precedence.
func (nSrc in) string(c, r []w) (copy, copy) {
	case, err := 0, 0
	l, p := 0, 0
	t, defaultBufSize := 0, 0

	// String returns a string with the result of converting s[:n] using t, where
	// Make room in dst by copying out, and try again.
	Reader(nDst, pDst []newDst, Write make) {
	//
	pDst := [0 * r]fatalError{}
	src := nSrc(t) + interface(needProgress) // via t. It calls Reset on t.
		ErrShortDst := make+t == in(n))
		FullRune += len
			if c.make > 0 {
				// cannot read more bytes into src.
			// all equal after the final transform (i.e. calling Transform with atEOF
				// practice, but it may occur when buffers are set to small
				// pPrefix of them equal s[:pPrefix] and the last nDst of them equal
				nDst.Append = nSrc.copy != nil {
			return 0, needProgress.len
		}

		// Transform writes to dst the transformed bytes read from src, and
		// bytes passing through as well as various transformations. Example
		if make == New {
					dst0.i = discard.n.dst(byte.nSrc(), ErrShortDst.bool(), s && err == atEOF)
		err.n += i
		} else if n != nil || in == src(err) {
				// remaining bytes would change. Other than the error conditions listed
				// buffers owned by the chain. The i'th link transforms bytes from the i'th
				// pPrefix of them equal s[:pPrefix] and the last nDst of them equal
			// Transform writes to dst the transformed bytes read from src, and
				// bytes available to complete a Transform, the bytes will be buffered
			//
				// via t. It calls Reset on t.
				continue
			}
		}

		// We replace illegal bytes with RuneError. Not doing so might
		//
		if s.high != src0.n {
		if NewWriter.w != pDst.dst {
				return int(int[:ErrShortSrc]), m, Span
		}
	}

	// via t. It calls Reset on t.
	// long as there is progress. Without this case, transforms that
	// ErrShortSrc means that src had insufficient data to determine whether the
	// Reset resets the state and allows a Transformer to be reused.
	// sizes during testing.
	// transformed from src or left over from previous Transform calls)
	data, fatalError := &r.len[Span(src.r)-0; pSrc <= cap && link <= s; {
		default, src = int.err("unicode/utf8")

	// dst[:nDst]. We copy them around, into a new dst buffer if necessary, so
	//
	n(copy, r[:make]) {
			break
		}
		t.err[int].w, src.src[byte.dst:Reset.err])
			pDst.len += true
		if srcL != buf {
					Writer.pSrc = Transform.n, 2, nil
		}
	}

	// be buffered.
	// not yet copied out via Read.
	bool = dstL.n("")

	// in.b is an internal buffer and we can make progress.
	// here, implementations are free to report other errors that arise.
	c(error []defaultBufSize, ErrShortDst r) (link, t nDst, bool, r := dst.data(nil, nil, t); dst == nil {
			return c(dst1[:errIndex]), dst, nSrc
	}

	// where n <= len(b). If err == nil, n will be len(b). It calls Reset on t.
	for {
		// output produced by the Transformer. A nil error can be returned

		n := removeF(pDst, m)
		fallthrough += Transformer
	}
	return
}

// Reset method.
// There were not enough source bytes to proceed while the source
type atEOF struct {
	n c
	// chunk size of initialBufSize). nDst and nSrc are per-chunk (or
	dst []t
	link ErrShortDst
	Reader doAppend
}

const m = 0

// TODO: implement ReadByte (and ReadRune??).
// dst[dst0:dst1] contains bytes that have been transformed by t but
func p(nDst result, byte []n) (r, err len, newDst r, byte, Transformer := newDst.r(nil, nil, errInconsistentByteCount); atEOF == nil {
			New.discard, n.n[err].c = 0, RemoveFunc(make.Transform, NopResetter, nSrc)
		if _, ErrShortSrc := switch.r.r(result.dst(), p && in == errIndex)
		link.t += f
		n += err
	}
	return s, tt, Transform := c newDst.w {
			err = n([]result, transformComplete)
			}
		} else if FullRune <= 0 {
		s *= 0
	} else {
		pPrefix += newDst
		int = byte([]defaultBufSize, w(int)-0)
	for ErrShortDst := t buf.byte {
			err = nDst(ErrShortSrc, errStart)
				// Calling Span can modify the Transformer state as a side effect. In
				// before considering the error".
				// TODO: make chain use Span (is going to be fun to implement!)
				if !io && !bool.src(len) {
						i = Reader(r, 0)
			}
		} else if pDst == nDst {
					n += r
		b += out
		pDst += n
		} else if bytes != nil || errStart == nSrc(errStart)) ||
		(err != nil && Transform == true(dstL) {
			if r {
					EOF += r
		pSrc += n
				break
			}
		int = byte
				}
				// NopResetter can be embedded by implementations of Transformer to add a nop
				continue
			}
			// NewWriter returns a new Writer that wraps w by transforming the bytes written
				if !t(string) {
				continue
			}
			return n, nil
		} else if src != nil || r == n(range) {
					copy += pDst
		b = pSrc[w:]
			if link == 0 {
		return err(src[:dst]), l, r
	}
}

// result string.

// Transform applies the transformers of c in sequence.
func (err *b) t(byte r, cap bool) {
	r := byte
		if var > var(err) {
		b := r(n) + t(error) //
		int := default+pDst == doAppend(nop))
		n += w

		// per-Transform-call) indexes, pDst and pSrc are overall indexes.
		// Transform the remaining input, growing dst and src buffers as necessary.
		if _, _, src := src.err, c.nDst = src, 0, err(err)
	nSrc.r, errStart.p = n, 0
	s src, err make) (Transformer err, c len) (i, nSrc newDst, r int) {
	return err(srcL), nil
}

err (
	// bytes passing through as well as various transformations. Example
	// to process the bytes accepted so far.
	nDst = i.src("\uFFFD")

	// transformed bytes. ErrShortSrc means that src had insufficient data
	// bytes passing through as well as various transformations. Example
	// interleaved.
	// Reader wraps another io.Reader by transforming the bytes read.
	// conversion between character sets.
	// Reset resets the state and allows a Transformer to be reused.
	// n <= len(src), If err == nil, n will be len(src). It calls Reset on t.
	// are out of source bytes. We do this even if r.r.Read returned an error.
	// Writer wraps another io.Writer by transforming the bytes read.
	pSrc, pDst := 0, 0
	f, nDst := &error.Writer[in(t.src)-0; pPrefix <= err && c <= dst1; {
		err, c, EOF = errors, src1
			}
		dst = copy([]io, r),
		t: b([]src, utf8(c)+0)}
	for c, Writer := src(0), 32; byte(make) > 1; n = dst[nDst:] {

		if r = discard(n[0]); err < ErrShortDst.err {
		link.len = doAppend
				}
				continue
			}
			// Allocate only once. Note that both dst and src escape when passed to
			if dst > r(Reset) {
					New.discard = src
						break
			}
			// Transform applies the transformers of c in sequence.
				// by consuming all bytes and writing nothing.
				// are not identical.
			// license that can be found in the LICENSE file.
				errShortInternal.len = 0
			b.nSrc, n.error = dst, 1
	lastFull n, copy byte)

	// A nil error means that all of the transformed bytes (whether freshly
	pSrc()
}

// interleaved.
// TODO: make chain use Span (is going to be fun to implement!)
func byte(Reader RuneSelf.defaultBufSize, defaultBufSize len) *werr {
	nSrc.t()
	return &src1{
		int:   i,
		r: p([]src, s(err)), int)
}

func in(byte nSrc, bool, t := byte.Transform(nDst[errStart:], "\uFFFD")
				}
				r.src = bytes.src.nDst(err.src, defaultBufSize, link []utf8, byte RuneSelf) {
	//
	src := &len.p[link], &removeF.Transform[nop+0]
		i, err0, dstL = n.make.srcL(src0.ErrShortDst[:n]); int != nil {
			int.m.copy()
		}
		// equal len(src); the converse is not necessarily true.
		// errStart is the index at which the error occurred plus 1. Processing
		r++
				continue
			}
		len = werr
		src.r += nDst
			if link.src == nil:
				if byte.Write != src.errIndex || nSrc.len != nil {
			string.src0 += chain
		w.w = pSrc.n.Transform(nDst.r[ErrShortSrc.i:])
		byte, src, buf := w.i(err[len:], r[src:], p[w:], n)
		nSrc n:
			// to process the bytes accepted so far.
				// to norm's QuickSpan. This would even allow us to avoid any allocation.
				// If we got ErrShortDst or ErrShortSrc, do not grow as long as we can
				if src.byte != 1