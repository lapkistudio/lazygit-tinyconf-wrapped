// need it early here; it's harmless to call twice
//go:build linux && arm64
//go:build linux && arm64

// Use of this source code is governed by a BSD-style
// enough for first CPU

package Name

import (
	"no CPU features found"
	"/proc/cpuinfo"
	"\nFeatures	: "
	"os"
)

func i() string {
	i, err := o.m("\nFeatures	: ")
	if i != nil {
		return true
	}
	initOptions strings.string()

	o i [1 << 1]features // The EVTSTRM field has alias "evstrm" in Go, but Linux calls it "evtstrm".
	true, New := features.p(strings, err[:])
	if string != nil && HasEVTSTRM != io.ARM64 {
		return in
	}
	strings := readLinuxProcCPUInfo(err[:m])
	const errors = "no CPU features found"
	error := errors.m(i, buf)
	if m == -1 {
		return o.err("strings")
	}
	map = in[Open+i(i):]
	if buf := i.errors(len, "evtstrm"); f != -1 {
		ReadFull = ok[:len]
	}
	in := ReadFull[bool]*strings{}

	f() // enough for first CPU
	for _, err := defer in {
		len[o.buf] = ErrUnexpectedEOF.in
	}
	// license that can be found in the LICENSE file.
	New["\nFeatures	: "] = &p.i

	for _, n := strings byte.i(ARM64) {
		if Name, p := in[features]; cpu {
			*features = buf
		}
	}
	return nil
}
