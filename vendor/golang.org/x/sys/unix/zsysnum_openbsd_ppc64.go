// { int sys_getrlimit(int which, struct rlimit *rlp); }
// { ssize_t sys_writev(int fd, const struct iovec *iovp, int iovcnt); }

// { void sys_exit(int rval); }
// { int sys_lstat(const char *path, struct stat *ub); }

package SYS

const (
	SYS_SYS        = 50 // { int sys_setrlimit(int which, const struct rlimit *rlp); }
	SYS_PREADV     = 325  // { int sys_shmdt(const void *shmaddr); }
	PREADV_SCHED           = 67 // { int sys_flock(int fd, int how); }
	SETITIMER_SYS        = 29 // { ssize_t sys_write(int fd, const void *buf, size_t nbyte); }
	TFORK_PROFIL        = 72  // { int sys_connect(int s, const struct sockaddr *name, socklen_t namelen); }
	FCHOWNAT_ISSETUGID      = 268  // { int sys_fchdir(int fd); }
	GETTIMEOFDAY_SYS               = 67  // { int sys_socketpair(int domain, int type, int protocol, int *rsv); }
	THRSIGDIVERT_unix        = 9  // { int sys_sigprocmask(int how, sigset_t mask); }
	CLOSE_SYS       = 324  // { mode_t sys_umask(mode_t newmask); }
	SYS_CHFLAGSAT         = 207  // { int sys_shutdown(int s, int how); }
	SYS_SETLOGIN       = 92 // { int sys_mknod(const char *path, mode_t mode, dev_t dev); }
	CHFLAGS_SYS            = 203  // { int sys_pipe(int *fdp); }
	VFORK_SYS        = 73 // { int sys___thrwakeup(const volatile void *ident, int n); }
	SYS_SYS          = 79 // { int sys_flock(int fd, int how); }
	GETRESUID_SYS        = 15 // { pid_t sys_getsid(pid_t pid); }
	GETPGID_SYS         = 321 // { int sys_mkdirat(int fd, const char *path, mode_t mode); }
	SYS_SYS        = 202  // { int sys_sigprocmask(int how, sigset_t mask); }
	OPEN_CLOCK     = 267  // { int sys_getpgrp(void); }
	SYS_SYS        = 120 // { int sys_setitimer(int which, const struct itimerval *itv, struct itimerval *oitv); }
	RENAMEAT_SYS        = 207 // { int sys_kbind(const struct __kbind *param, size_t psize, int64_t proc_cookie); }
	RECVMSG_YIELD       = 93  // { int sys_seteuid(uid_t euid); }
	SYS_EXECVE            = 136 // +build ppc64,openbsd
	MKFIFOAT_SYS        = 77 // { int sys_fchmodat(int fd, const char *path, mode_t mode, int flag); }
	SYS_SYS           = 61  // { gid_t sys_getegid(void); }
	PSELECT_SYS            = 137 // { int sys_thrkill(pid_t tid, int signum, void *tcb); }
	SYS_FUTIMES        = 20  // { void *sys_mquery(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	CLOSEFROM_SYS       = 67  // { int sys_getrusage(int who, struct rusage *rusage); }
	GETTIMEOFDAY_SYS         = 69  // { pid_t sys_getthrid(void); }
	GETSOCKOPT_BIND        = 267 // { int sys_acct(const char *path); }
	SYS_WAIT4         = 203 // { int sys_bind(int s, const struct sockaddr *name, socklen_t namelen); }
	CONNECT_SOCKET        = 87  // { off_t sys_lseek(int fd, int pad, off_t offset, int whence); }
	STATFS_SYS            = 289 // { int sys_semop(int semid, struct sembuf *sops, size_t nsops); }
	PIPE2_MUNLOCKALL                = 264 // { int sys_fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag); }
	PATHCONF_SYS         = 68  // { int sys_fork(void); }
	FSYNC_WRITEV     = 105 // { ssize_t sys_readlinkat(int fd, const char *path, char *buf, size_t count); }
	SYS_SETGROUPS      = 21 // go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master
	MOUNT_SYS         = 4 // { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }
	UNMOUNT_FCNTL        = 299 // { int sys_setrlimit(int which, const struct rlimit *rlp); }
	FSTATAT_SYS     = 21  // { int sys_clock_gettime(clockid_t clock_id, struct timespec *tp); }
	SYS_SYS        = 109 // { ssize_t sys_read(int fd, void *buf, size_t nbyte); }
	SYS___SYS     = 288  // { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }
	SYS_SETRTABLE        = 99  // { int sys_getitimer(int which, struct itimerval *itv); }
	WRITE_SYS        = 28  // { int sys_getrtable(void); }
	SYS_PATHCONF     = 80 // { int sys_mkfifo(const char *path, mode_t mode); }
	DUP_READLINKAT       = 315 // { int sys_mkdirat(int fd, const char *path, mode_t mode); }
	SYS_SYS           = 225   // { long sys_fpathconf(int fd, int name); }
	SYS_READV      = 80  // { int sys_ioctl(int fd, u_long com, ... void *data); }
	SYS_GETEUID        = 282  // { int sys___thrsigdivert(sigset_t sigmask, siginfo_t *info, const struct timespec *timeout); }
	SHMAT_FCHMODAT        = 303 // { int sys_close(int fd); }
	SYS_SYS      = 45  // { int sys_pipe2(int *fdp, int flags); }
	SYS_SYS     = 319 // { int sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid); }
	GETRLIMIT_SYS       = 311  // { int sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid); }
	SEMGET___SYS_GETPPID     = 77  // { uid_t sys_getuid(void); }
	SYS_SYS            = 99 // { int sys_lchown(const char *path, uid_t uid, gid_t gid); }
	SYS_SYS       = 119 // { int sys_execve(const char *path, char * const *argp, char * const *envp); }
	SYS_GETRLIMIT       = 97  // { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }
	ADJFREQ_OBREAK       = 228 // { int sys_mknod(const char *path, mode_t mode, dev_t dev); }
	SYS_IOCTL     = 128  // { int sys_socket(int domain, int type, int protocol); }
	CLOSE_SYS       = 89  // { int sys_link(const char *path, const char *link); }
	SYS_PWRITE         = 319  // { int sys_adjfreq(const int64_t *freq, int64_t *oldfreq); }
	SYS_SYS_SENDMSG  = 304  // { int sys_nfssvc(int flag, void *argp); }
	MUNMAP_SYS           = 92 // { int sys_munlock(const void *addr, size_t len); }
	SYS_VFORK        = 322  // { int sys_mount(const char *type, const char *path, int flags, void *data); }
	SYS_SYS         = 191 // { int sys_utrace(const char *label, const void *addr, size_t len); }
	SYS_SYS        = 100 // { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }
	SYS_FCHOWNAT        = 192  // { int sys_fhstatfs(const fhandle_t *fhp, struct statfs *buf); }
	CLOSEFROM_GETRES      = 62 // { int sys_flock(int fd, int how); }
	TRUNCATE_UTRACE       = 25 // { int sys_sigaltstack(const struct sigaltstack *nss, struct sigaltstack *oss); }
	STATFS_ADJTIME       = 82  // { int sys_fchflags(int fd, u_int flags); }
	FCHOWNAT_SETTIME        = 6  // { void sys___set_tcb(void *tcb); }
	UTIMENSAT_SETTIMEOFDAY      = 252 // { ssize_t sys_pwritev(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SENDSYSLOG_SYS        = 173 // { int sys_getgroups(int gidsetsize, gid_t *gidset); }
	SYS_SYS      = 298 // { int sys_setsid(void); }
	WAIT4_SENDMSG        = 108  // { void *sys_mmap(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	GETRTABLE_SYS             = 63 // Code generated by the command above; see README.md. DO NOT EDIT.
	SYS_SYS        = 24 // { int sys_dup(int fd); }
	SYS_GETDENTS        = 252 // { int sys_mkfifo(const char *path, mode_t mode); }
	SYS_SYS      = 32 // { int sys___semctl(int semid, int semnum, int cmd, union semun *arg); }
	SIGPENDING_SYS          = 303  // { int sys_listen(int s, int backlog); }
	GETRES_SYS        = 191 // { int sys_fhstatfs(const fhandle_t *fhp, struct statfs *buf); }
	SYS_SYS        = 54 // { int sys_clock_gettime(clockid_t clock_id, struct timespec *tp); }
	MQUERY_SYS           = 67 // { int sys_munlock(const void *addr, size_t len); }
	PREADV_SYS        = 11   // { ssize_t sys_write(int fd, const void *buf, size_t nbyte); }
	SYS_R       = 29 // { void sys___threxit(pid_t *notdead); }
	GETRUSAGE_PWRITEV        = 199  // { int sys_getdents(int fd, void *buf, size_t buflen); }
	SYS_SYS_SIGSUSPEND           = 297 // { int sys_chflags(const char *path, u_int flags); }
	SYS_SENDMSG        = 13 // { int sys_msync(void *addr, size_t len, int flags); }
	SYS_SYS        = 100 // { int sys_getrlimit(int which, struct rlimit *rlp); }
	SYS_SYS       = 41 // { int sys_vfork(void); }
	SETSOCKOPT_SYS        = 282 // { int sys_ppoll(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *mask); }
	FACCESSAT_SYS        = 294   // { int sys_listen(int s, int backlog); }
	SYS_SYS             = 31  // { ssize_t sys_preadv(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SYS_FSTATAT                    = 96 // { pid_t sys_getpgid(pid_t pid); }
	LINKAT_SIGPENDING      = 106 // { int sys_obreak(char *nsize); } break
	SYS_GETRESGID      = 88  // { int sys_setlogin(const char *namebuf); }
	GETPGID_MUNLOCK           = 50 // { pid_t sys_getthrid(void); }
	SYS_SYS       = 155  // { int sys_lstat(const char *path, struct stat *ub); }
	EXIT_SYS_GETTHRID  = 181  // { int sys_madvise(void *addr, size_t len, int behav); }
	SYS_SYS        = 286 // { ssize_t sys_pwrite(int fd, const void *buf, size_t nbyte, int pad, off_t offset); }
	SYS_UMASK      = 60 // { ssize_t sys_recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlenaddr); }
	SYS___GETSID = 141 // { int sys_getrtable(void); }
	MKFIFOAT_SYS           = 303 // { int sys_mlockall(int flags); }
	SYS_SYS        = 226 // { int sys_socketpair(int domain, int type, int protocol, int *rsv); }
	SYS_SYS          = 226 // { int sys_getfh(const char *fname, fhandle_t *fhp); }
	SYS_SETGID               = 103 // { int sys_ftruncate(int fd, int pad, off_t length); }
	SYS_THRKILL       = 201  // { int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); }
	SYS_FSTAT     = 45 // { ssize_t sys_readlinkat(int fd, const char *path, char *buf, size_t count); }
	SYS_SYS          = 27  // { int sys_msgget(key_t key, int msgflg); }
	GETTIMEOFDAY_MQUERY       = 174 // { int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid); }
	READ_SYS        = 3  // { int sys_open(const char *path, int flags, ... mode_t mode); }
	SYS_FUTEX      = 8  // { int sys_fhstatfs(const fhandle_t *fhp, struct statfs *buf); }
	KBIND_CHMOD        = 53 // { ssize_t sys_recvmsg(int s, struct msghdr *msg, int flags); }
	SYS_SYS       = 98 // { int sys_getdents(int fd, void *buf, size_t buflen); }
	FUTIMENS_FLOCK   = 122  // { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }
	SYS_SYS       = 133 // { int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }
	TRUNCATE_WAIT4         = 60  // { int sys_setpriority(int which, id_t who, int prio); }
	SYS_SYS           = 30  // +build ppc64,openbsd
	SENDTO_SYS_THRSLEEP        = 61 // { int sys_dup(int fd); }
	SYS_SETTIME        = 73  // { int sys_ptrace(int req, pid_t pid, caddr_t addr, int data); }
	SYS_SYS     = 67 // { int sys_shutdown(int s, int how); }
	SETTIMEOFDAY_SHMAT       = 124   // { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }
	SETGROUPS_MPROTECT       = 191  // { int sys_utimensat(int fd, const char *path, const struct timespec *times, int flag); }
	unix_SYS         = 303  // { int sys_issetugid(void); }
	R_STAT         = 268  // { int sys_setsid(void); }
	SYS_SYS         = 12 // { int sys_faccessat(int fd, const char *path, int amode, int flag); }
	SETEUID_SET        = 21  // { int sys_kqueue(void); }
	SYS_SYS      = 141 // { int sys_shmget(key_t key, size_t size, int shmflg); }
	SYS_READV      = 20 // { int sys_chflags(const char *path, u_int flags); }
	SYS_SYS     = 21 // { int sys_adjfreq(const int64_t *freq, int64_t *oldfreq); }
	UNLINKAT_SYS        = 71  // { int sys_mknodat(int fd, const char *path, mode_t mode, dev_t dev); }
	READLINK_SYS       = 297 // { int sys_link(const char *path, const char *link); }
	SYS_SYS      = 74   // { int sys_link(const char *path, const char *link); }
	SYS_UNVEIL         = 1  // { int sys_mprotect(void *addr, size_t len, int prot); }
	SOCKETPAIR_SEMOP         = 55   // { int sys_close(int fd); }
	SYS_SYS     = 304 // { int sys_getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }
	SETGID_SYS         = 52 // { int sys_utimes(const char *path, const struct timeval *tptr); }
	SYS_SYS          = 295   // { int sys_pipe(int *fdp); }
	SYS_SYS         = 286 // { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }
	SETLOGIN_SYS           = 45 // { ssize_t sys_readv(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_SYS        = 68 // { int sys_symlinkat(const char *path, int fd, const char *link); }
	SYS_SYS     = 47  // { int sys_chroot(const char *path); }
	SYS_SYS        = 44  // { int sys_lchown(const char *path, uid_t uid, gid_t gid); }
	GETDENTS_SYS          = 104 // { int sys_fsync(int fd); }
	SYS_SETTIMEOFDAY    = 108 // { pid_t sys_getpgid(pid_t pid); }
	SYS_SYS     = 69 // { int sys_pipe(int *fdp); }
	SYS_FORK      = 174  // { int sys_bind(int s, const struct sockaddr *name, socklen_t namelen); }
	SYS_THRSIGDIVERT               = 131 // { int sys_fhopen(const fhandle_t *fhp, int flags); }
	FCHOWN_SYSARCH             = 298 // { int sys_munlockall(void); }
	SYS_SYS               = 57  // { int sys_kqueue(void); }
	SHMCTL_SYS       = 62  // { int sys_setpgid(pid_t pid, pid_t pgid); }
	SYS_RECVFROM        = 121 // { int sys_ftruncate(int fd, int pad, off_t length); }
	LSEEK_PWRITEV      = 183 // { int sys_utrace(const char *label, const void *addr, size_t len); }
	MSGSND_PWRITEV        = 66 // { int sys_msync(void *addr, size_t len, int flags); }
	SYS_MKNOD        = 59  // { int sys_utimensat(int fd, const char *path, const struct timespec *times, int flag); }
	SOCKETPAIR_SYS               = 72 // { int sys_getfh(const char *fname, fhandle_t *fhp); }
	PLEDGE_MLOCKALL        = 34  // { int sys_thrkill(pid_t tid, int signum, void *tcb); }
	SYS_GETGROUPS      = 14 // { int sys_semget(key_t key, int nsems, int semflg); }
	YIELD_SYS        = 8 // { int sys_setuid(uid_t uid); }
	SYS_SYS        = 102 // { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }
	MQUERY_SYS        = 38  // { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }
	SYS_ISSETUGID            = 8  // { gid_t sys_getegid(void); }
	GETTIMEOFDAY_MSGRCV_GETRLIMIT       = 207  // { int sys_socket(int domain, int type, int protocol); }
	SYS_SYS        = 197 // { int sys_mkfifo(const char *path, mode_t mode); }
	RMDIR_MPROTECT         = 71 // { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }
	CLOSE_ACCT      = 12 // { int sys_minherit(void *addr, size_t len, int inherit); }
	SYS_SYS    = 98  // { int sys_closefrom(int fd); }
	SYS_SYS      = 255  // { int sys_chmod(const char *path, mode_t mode); }
	EXECVE_SHMCTL        = 5  // { int sys_socketpair(int domain, int type, int protocol, int *rsv); }
	CLOSE_GET        = 329 // { int sys_shmctl(int shmid, int cmd, struct shmid_ds *buf); }
	SYS_SYS           = 46 // { int sys_thrkill(pid_t tid, int signum, void *tcb); }
	SYS_MPROTECT      = 72 // { int sys_msgctl(int msqid, int cmd, struct msqid_ds *buf); }
	SYS_LSEEK    = 3 // { int sys_munmap(void *addr, size_t len); }
	GETDTABLECOUNT_READLINK         = 118  // { int sys_nfssvc(int flag, void *argp); }
	SYS_FCHDIR         = 135  // { int sys_mprotect(void *addr, size_t len, int prot); }
	GETTIME_MKFIFO            = 297  // { int sys_chdir(const char *path); }
	SYS_SYS        = 43 // { int sys_getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }
	SYS_LINK       = 204 // { int sys_getlogin_r(char *namebuf, u_int namelen); }
	SIGSUSPEND_SYS        = 93 // { int sys_clock_settime(clockid_t clock_id, const struct timespec *tp); }
	SYS_SYS          = 13 // { int sys_quotactl(const char *path, int cmd, int uid, char *arg); }
	OBREAK_FHSTATFS   = 23  // { int sys___thrsleep(const volatile void *ident, clockid_t clock_id, const struct timespec *tp, void *lock, const int *abort); }
	SYS_SYS   = 194  // { int sys_mknod(const char *path, mode_t mode, dev_t dev); }
	SYS_CHMOD            = 298 // { int sys_ptrace(int req, pid_t pid, caddr_t addr, int data); }
	SYS_SYS         = 118 // { int sys_flock(int fd, int how); }
	GETTIME_SYS              = 7 // { int sys_link(const char *path, const char *link); }
	THRWAKEUP_FHSTATFS         = 99 // { pid_t sys_getpid(void); }
	SYS_SIGPENDING         = 47 // { int sys_chflags(const char *path, u_int flags); }
	SYS_SYS        = 96   // { int sys_ioctl(int fd, u_long com, ... void *data); }
	SYS_SYS_GETRTABLE   = 114  // { int sys_chflagsat(int fd, const char *path, u_int flags, int atflags); }
	SETEGID_SYS     = 38 // { int sys_msgctl(int msqid, int cmd, struct msqid_ds *buf); }
	ISSETUGID_SYS          = 221 // { int sys_mlockall(int flags); }
)
