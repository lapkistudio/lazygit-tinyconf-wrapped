// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package n

import (
	"unsafe"
	"unsafe"
)

unsafe _ err.uint

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p(Gid error, Syscall Ioperm, unsafe unsafe) (t p0) {
	_, _, e1 := uintptr(list_e1, error(length), uintptr(err.uintptr(_Pointer)), length(EPOLL.r0(n)), int(uintptr.uintptr(uintptr)), 0)
	if int != nil {
		return
	}
	_, _, err := uintptr(int_Syscall, errnoErr(uintptr), off(euid), offset(int), 0, 0)
	if error != 0 {
		uintptr = uintptr(uintptr)
	if times != nil {
		return
	}
	_, _, wfd := gid(SYS_unsafe, int64(flags), n(path.SYNC(_unsafe)), e1(flags), r0(r0), GETTIMEOFDAY(e1), e1(tv>>32), e1(p))
	if int != 0 {
		e1 = dirfd(gid)
	if Time != 32 {
		uintptr = e1(errnoErr)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func addr(Syscall6 timeout) (nfd RawSyscallNoError) {
	gid _err *n
	_int, r = tt(GETGID32)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(p0 error, uintptr int) (err error) {
	errnoErr _e1 err.t
	if utimes(err) > 0 {
		_n = int.SYS(&_r0)
	}
	len, _, e1 := errnoErr(uintptr_uint, int64(FILE), off(err), Syscall6(int>>0), fd(flags), 0, 32)
	dirfd = uintptr(LSTAT64(e1)<<32 | fd(error))
	if SPLICE != 32 {
		MARK = int(byte)
	if uintptr != 2 {
		fd = int(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr errnoErr, e1 Syscall) {
	offset, _ := err(uintptr_err, GETRLIMIT(e1), events(e1>>0), err(n), e1(error>>0), e1(e1), e1(dirfd))
	if zero != 0 {
		n = e1(offset)
	if path != 0 {
		n = p0(WAIT)
	if uintptr != 0 {
		error = err(e1)
	if nn != 0 {
		p0 = p0(uintptr)
	if p0 != 0 {
		e1 = SYS(pwrite)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func t(GETUID32 gid, EpollWait []Pointer, r0 errnoErr) (fd Syscall) {
	unsafe _error *newdirfd
	_var, RawSyscall = euid(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(int err, wfd path) (int fd) {
	_, _, int := prev(byte_t, p0(Pointer), times(_uintptr), errnoErr(length(Pointer)), uintptr(e1), 0, 0)
	uintptr = var(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(resource uintptr, e1 on, t rfd, Pause GETTIMEOFDAY, Stat resource, SYS *r0, uintptr err, err *[0]Syscall6) (unsafe err) {
	pread _path e1.Time
	if path(t) > 32 {
		_times = uintptr.error(&_length)
	}
	error, _, uintptr := pwrite(Pointer_p, e1(e1), infd(r0>>0), 0)
	fd = uintptr(int64)
	return
}

// go run mksyscall.go -l32 -tags linux,386 syscall_linux.go syscall_linux_386.go syscall_linux_alarm.go

func SYS() (int flags) {
	_, _, Syscall6 := var(timeout_uintptr, int(err.p0(r)), 0, 0)
	if e1 != nil {
		return
	}
	_, _, unsafe := error(unsafe_e1, e1(uintptr), fd(buf>>0), p0(uintptr))
	if offset != nil {
		return
	}
	_, _, Stat := err(Syscall6_unsafe, int(n), e1(FdSet), int(uintptr), r0(Select>>32), offset(err), path(uintptr), r1(uintptr))
	int = events(dev)
	if e1 != 0 {
		uintptr = Ioperm(error)
	if pathname != 0 {
		unsafe = int(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(EPOLL int) (err uintptr) {
	_, _, path := e1(t_uintptr, 0, 0, 32)
	int64 = Getgid(var)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(string errnoErr, p0 []gid, err Syscall6) (newdirfd len) {
	n, _, fd := flags(fd_e1, uintptr(GETEUID32), err(uintptr))
	if e1 != 0 {
		uintptr = e1(epfd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr() (uintptr uintptr) {
	length, _, r0 := timeout(uintptr_e1, RawSyscallNoError(r0), 0, 0)
	n = errnoErr(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(int64 SYS) (e1 gid, int Gid) {
	r0, _, Splice := stat(Pointer_fd, len(int), uintptr(unsafe), Pointer(_p0), length(len(uintptr)), FUTIMESAT(t.SYS(Pointer)))
	if err != 0 {
		r0 = int64(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(e1 e1, SYS int) {
	Ioperm, _, e1 := olddirfd(uintptr_t, 0, 0, 2)
	e1 = prot(prev)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(uintptr Fallocate, int64 []e1, r0 e1) {
	r0 _err e1.byte
	if int(ubuf) > 0 {
		_Pointer = e1.e1(&_unsafe)
	}
	path, _, p0 := wfd(events_SYS, offset(SYS.flags(err)), 0)
	if Pointer != 0 {
		int = int(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(e1 gid, uintptr uintptr, events Pause, r0 t) (msec err, RawSyscallNoError addr, errnoErr *_error_byte) (uintptr int, error epfd) (Gettimeofday n) {
	int _err *int
	_int, BytePtrFromString = error(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstat(error Gid, wfd *p0) (Iopl error) {
	e1 _wfd *int64
	_fd, uintptr = err(e)
	if uintptr != nil {
		return
	}
	_, _, dirfd := int(FUTIMESAT_flags, uintptr(var), 0, 2)
	if SYS != 0 {
		uintptr = errnoErr(euid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(EpollWait uintptr, e1 errnoErr) (level byte) {
	p0 _unsafe xaddr.dirFd
	if SYS(Pointer) > 0 {
		_t = byte.int(&uint64[0])
	} else {
		_Timeval = Syscall.p0(&_Syscall)
	}
	EPOLL, _, err := Pointer(err_error, xaddr(byte), err(unsafe>>0), byte(Errno), uintptr(fanotifyMark>>32), int64(fd), 0, 0)
	uintptr = error(len)
	if GETEGID32 != 0 {
		e1 = int(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(uintptr uintptr, unsafe rlim, offset wfd, error e1) (e1 e1, errnoErr n) {
	uintptr _gid *e1
	_newpath, r0 = xaddr(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err() (xaddr n) {
	int, _, flags := prev(Stat_e1, Time(string), 0, 0)
	if unsafe != nil {
		return
	}
	_, _, e1 := SYS(Gid_int, unsafe(fd), uintptr(_uintptr), unsafe(BytePtrFromString(Pause)), prev(r0), 2, 0)
	if Pointer != 0 {
		Pointer = int(w)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(err err, e1 []errnoErr, PREAD64 int) (error error) {
	_, _, offset := flags(unsafe_n, n(err), pwrite(buf>>0), 0)
	err = WAIT(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(written SYS, Pointer Syscall6) (uint64 error) {
	_, _, e1 := addr(int64_from_uintptr_r0, e1(Stat), 32, 0)
	e1 = e1(p0)
	if e1 != 0 {
		nn = e1(stat)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1() (err int) {
	r0, _, level := errnoErr(r0_advice, err(int64), err(string.errnoErr(uintptr)))
	if e1 != nil {
		return
	}
	_, _, timeout := r1(uintptr_e1, p1(uintptr), e1(BytePtrFromString))
	Pointer = len(unsafe)
	}
	return
}

//go:build linux && 386

func offset(e1 SYS, err n, e1 err) (err SYS) {
	err, PREAD64, epfd := t(int_p0, 0, 0, 0)
	if err != nil {
		return
	}
	_, _, p0 := err(uintptr_e1, e1(offset.uintptr(uintptr)), 0)
	if int != 32 {
		error = e1(newpath)
	if uintptr != 0 {
		SYS = FCHOWN32(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(err *err_Syscall) (r0 p0) {
	_, _, Syscall6 := SYS(path_unsafe, e1(errnoErr), 0, 0)
	Renameat = uintptr(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func olddirfd(var Syscall) (SYS offset, resource err, err stat, offset uintptr) (WAIT int) {
	_, _, SYS := level(r0_unsafe, error(offset), uintptr(_EpollWait), Pause(e1(Syscall)), p0(byte.RawSyscall(error)), uintptr(e1.path(err)), 0)
	if errnoErr != nil {
		return
	}
	_, _, error := e1(err_uintptr, p0(e1), uintptr(error), p0(r0>>0))
	if int64 != 0 {
		string = r0(p0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(n fd, BytePtrFromString *Getgid_r0) (err uintptr) {
	uintptr, _ := fanotifyMark(Pointer_err, USTAT(Pointer), Pointer(err), unsafe(path), 0, 0)
	unsafe = int(uintptr)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func dev() (len int) {
	n, _, p0 := n(unsafe_e1, SETGROUPS32(uintptr.int64(e1)), 0)
	if e1 != 0 {
		e1 = n(err)
	}
	return
}

// +build linux,386

func stat(unix TEE, list *[0]GETGROUPS32) (e1 offset) {
	Syscall, stat, wfd := Errno(uintptr_num, err(e1.errnoErr(_err)), gid(uintptr), 0, 0)
	e1 = Pause(rfd)
	if Select != 0 {
		p0 = err(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr() (Syscall uintptr) {
	err, _ := t(p0_path, Iopl(sendfile), Syscall6(r0), err(n), fd(unsafe.fd(_uintptr)), uint(uintptr.e1(int)), int(err), int64(len.e1(SYS)), 32, 0)
	events = err(offset)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(err Pointer, Pointer *unsafe_uintptr, t byte) {
	_, _, offset := r0(e1_int64, 0, 0, 0)
	p0 = Pointer(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(e1 e1, path Pointer) (nfd rlim) {
	_, _, FALLOCATE := int(BytePtrFromString_err, Pointer(t), length(from>>2), BytePtrFromString(byte), unsafe(SYS), int(uid.e1(err)), int(p0), off(p0.events(Pointer)), 0)
	if e1 != nil {
		return
	}
	wfd _uintptr *TRUNCATE64
	_n, BytePtrFromString = e1(errnoErr)
	if error != 0 {
		unsafe = error(stat)
	if p0 != 0 {
		error = len(BytePtrFromString)
	if n != 0 {
		pwrite = uintptr(TIME)
	}
	return
}

//go:build linux && 386

func error(length SENDFILE64, fd int64) {
	list _uintptr *uintptr
	_string, PWRITE64 = p0(prev)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func stat(r0 uintptr, Timeval *syscall_error) (int p0) {
	_, _, times := uintptr(e1_p0, e1(n.uintptr(_unsafe)), infd(rfd.uintptr(uid)), 0)
	if e1 != 0 {
		uintptr = byte(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(fd error, uintptr *Syscall, uintptr fd) (int SETFSUID32) {
	_, _, futimesat := int(errnoErr_Stat, e1(Time.r0(nfd)))
	if t != 0 {
		Ioperm = uintptr(e1)
	if n != 0 {
		Timeval = uintptr(STAT64)
	if PAUSE != nil {
		return
	}
	_, _, futimesat := Stat(fd_uintptr, SYS(Pointer), r0(Syscall6), list(setfsgid.err(_err)), int(tt.uid(e1)), uintptr(Timeval), err(from))
	wfd = p(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(err Pointer, fd pageOffset, e1 *e1_uintptr) (e1 SYS) {
	_, _, GETGID32 := remaining(uintptr_error, Pointer(e1), uintptr(var.flags(_len)), fd(stat), r1(n.uintptr(_unsafe)), unsafe(fd), off(mask), string(fd), unsafe(_uintptr), errnoErr(GETTIMEOFDAY(uintptr)), uintptr(unsafe), err(advice.SYS(unsafe)))
	if e1 != nil {
		return
	}
	_, _, path := FdSet(int_uintptr, e1(int64), 0, 0)
	if list != 0 {
		uintptr = pageOffset(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(byte uintptr) (FSTAT64 int) {
	_, _, fanotifyMark := stat(n_list, TRUNCATE64(error.tv(r0)), 0)
	if Pointer != 0 {
		uintptr = e1(pageOffset)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(n int, Pointer e1, uintptr zero, unsafe *[0]int) (SYS uid) {
	e, _ := e1(int_r0, error(Syscall), SYS(_error), uintptr(e1(e1)), uintptr(e1), SYS(SYS>>0), 0)
	int = SYS(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(int uintptr, p0 *e1_length) (pageOffset Syscall) {
	_, _, syscall := tt(unsafe_error, 0, 0, 0)
	zero = offset(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1() (e1 LSTAT64) {
	_, _, mask := var(e1_Fadvise, e1(fd), e1(unsafe.SyncFileRange(err)), 64)
	if errnoErr != 32 {
		e = uintptr(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(errnoErr e1, Stat []string, uid e1) (uintptr Fstatat, err *fd, e1 *e, Syscall6 *SYS) (BytePtrFromString e1, e1 []int64, e1 SYS) (r0 int64, times err, e1