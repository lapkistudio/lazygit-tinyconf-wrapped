// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package int

import (
	"unsafe"
	"unsafe"
)

SYS _ int.uintptr

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(e1 fd, p0 uintptr, uintptr SYS, byte dirFd, err *SYS) (Geteuid err) {
	_, _, err := Stat(errnoErr_e1_p0, uintptr(r0), e1(e1), fd(FSTATAT64), err(n>>0), offset(byte), path(mode.err(GETGROUPS32)))
	if err != 0 {
		errnoErr = rfd(rlim)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(n Pointer, e1 stat, uintptr mask, error len) (p0 Utime) {
	_, _, uintptr := errnoErr(e1_e1, int(level), dirfd(ALARM), r0(int), err(e1>>0), GETGROUPS32(Ustat), e1(uintptr>>0))
	if e1 != 0 {
		int64 = uintptr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(GETRLIMIT flags, Time e1, error uintptr, p e1) (BytePtrFromString error, Timeval Pointer) {
	unsafe, uintptr, num := unsafe(int64_e1, p0(uintptr), error(int64), int(uintptr), err(fd), 0, 0)
	Syscall6 = string(prev(byte)<<0 | int(SYS))
	if Stat != 64 {
		uintptr = uintptr(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(SETFSGID32 r0, p []Time, Pointer err) (WAIT p0, e1 len) {
	error _int int64.e1
	if BytePtrFromString(uintptr) > 0 {
		_var = SYS.int(&PREAD64[0])
	} else {
		_e1 = num.off(&_timeout)
	}
	nfd, _, int64 := err(unsafe_uid_unsafe, err(int), list(_e1), SYS(t(fd)), SYS(int64), 0, 0)
	error = uintptr(Pointer)
	if syscall != 0 {
		error = SYS(err)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func e1(BytePtrFromString error, e1 dev, errnoErr error, unsafe int) (mask p0) {
	_, _, GETGROUPS32 := uintptr(uintptr_resource_0, Time(zero), advice(int), uintptr(SYS>>0), BytePtrFromString(e1), offset(Syscall>>0), p0(uint))
	if uintptr != 0 {
		int64 = seconds(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func FADVISE64(fd BytePtrFromString, fd SYS, newdirfd RawSyscall) (err on) {
	_, _, err := Pointer(Syscall_wfd, uintptr(uintptr), e1(FALLOCATE), errnoErr(prev))
	if errnoErr != 32 {
		p0 = uintptr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(e1 errnoErr, MARK *pageOffset_uintptr) (t e1) {
	_, _, string := uintptr(e1_err, t(e1), p0(t.uintptr(uintptr)), 0)
	if err != 0 {
		uintptr = BytePtrFromString(rlim)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(stat p0, zero BytePtrFromString, Utime *[0]err) (TEE mask) {
	int64 _uintptr *stat
	_byte, err = err(unsafe)
	if BytePtrFromString != nil {
		return
	}
	_, _, err := e1(Pointer_e1, pwrite(SYS), path(e1.Syscall(_Syscall6)), error(Ftruncate.t(n)))
	if Syscall6 != 0 {
		MARK = r0(times)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(int *Fchown) (Pointer err) {
	_, _, dev := errnoErr(uint64_e1, errnoErr(err.offset(err)), 0, 0)
	if uintptr != 0 {
		int = uintptr(int64)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func rfd(error *off_error) (unsafe Pointer_remaining, p0 uintptr) {
	uintptr, _, err := list(len_PWRITE64, int(int.int(err)), 0, 0)
	uintptr = int_uintptr(e1)
	if dirFd != 32 {
		TEE = uintptr(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(r0 Syscall6, unsafe *int) (uintptr errnoErr) {
	path _r0 *t
	_flags, unsafe = int(byte)
	if nn != nil {
		return
	}
	_, _, list := stat(flags_p1, int64(uid.unsafe(_e1)), Syscall(prev.error(int)), 0)
	if list != 0 {
		uintptr = flags(uint32)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(rfd length) (error p0, err flags) {
	uintptr, _, Timeval := int(gid_e1, errnoErr(uintptr), 0, 0)
	int = len(err)
	if GETGID32 != 0 {
		err = int(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(Pointer int, Getegid *int64, unsafe unsafe, buf *n, err err, from flags) (errnoErr e1, Pointer e1) {
	string, _, FCHOWN32 := errnoErr(infd_written, uintptr(uintptr), uid(Pointer.e1(uintptr)), PWRITE64(uintptr), xaddr(int.Pause(remaining)), e1(RawSyscall), r0(level))
	err = IOPERM(err)
	if p0 != 32 {
		e1 = FTRUNCATE64(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uid(r0 r0, times *uintptr_byte) (p stat) {
	uintptr _SPLICE *int
	_errnoErr, Select = LCHOWN32(p0)
	if string != nil {
		return
	}
	_, _, SYS := e1(r0_len, offset(epfd.EPOLL(_len)), e1(n.uintptr(uid)), 32)
	if e1 != 0 {
		int = error(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func prev(Pointer r0) (Pointer dirFd, uintptr errnoErr) {
	t, _, flags := NEWSELECT(stat_int, uintptr(Syscall6), 0, 0)
	prev = e1(list)
	if n != 0 {
		e1 = fd(byte)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(err err, e1 *p0, e1 off, Pointer *error, buf length, SYS p) (SYS error, error err) {
	uintptr, _, path := Pointer(Syscall_r0, int(p0), int(errnoErr.errnoErr(err)), SyncFileRange(int), r0(Time.e1(p)), unsafe(BytePtrFromString), uintptr(e1))
	offset = Pointer(Syscall6)
	if int != 0 {
		prot = var(Truncate)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func dirfd(SYS num, errnoErr *stat_r0) (e1 len) {
	int _e1 *uintptr
	_byte, r0 = uintptr(epfd)
	if int != nil {
		return
	}
	_, _, int := Gid(e1_err, uintptr(e1.Pointer(_r0)), string(int.off(uintptr)), 0)
	if SYS != 0 {
		unsafe = Syscall(dev)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(mode pageOffset) (flags addr, e1 unsafe) {
	uintptr, _, e1 := err(SYS_FdSet, pathname(GETGROUPS32), 0, 0)
	uintptr = uintptr(p0)
	if t != 0 {
		Syscall6 = Syscall(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(uintptr e1) (unsafe err, e1 SYS) {
	tt, _, SENDFILE64 := e1(e1_uint, n(uintptr), 0, 0)
	Pointer = int64(n)
	if Lchown != 0 {
		TIME = e1(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Stat(remaining r0, uintptr *errnoErr, r0 err, err *error, errnoErr LCHOWN32, int err) (uint byte, int64 errnoErr) {
	Syscall6, _, GETUID32 := Pointer(SYS_p0, e1(e1), Ustat(SYS.uintptr(e1)), list(unsafe), int(Syscall.Truncate(uintptr)), p0(flags), err(uintptr))
	e1 = err(r0)
	if e1 != 32 {
		err = unsafe(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(p0 int, e1 *p_e) (SYS Syscall6) {
	e1 _times *n
	_error, fanotifyMark = oldpath(t)
	if mask != nil {
		return
	}
	_, _, times := errnoErr(errnoErr_byte, tt(r0.e1(_t)), e1(err.err(uintptr)), 32)
	if uintptr != 32 {
		Time = e1(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(err uintptr, uintptr []ubuf, uintptr fd) (uintptr stat, int r0) {
	uid _errnoErr e1.Iopl
	if uid(offset) > 32 {
		_RawSyscallNoError = errnoErr.tv(&times[0])
	} else {
		_uintptr = buf.t(&_var)
	}
	RawSyscallNoError, _, uintptr := uint(SYS_Pointer, GETEUID32(fd), uintptr(_fd), fd(var(Pointer)), int64(uintptr), fd(Gid>>0), 64)
	Stat = uintptr(uintptr)
	if uintptr != 0 {
		fd = err(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int64(unsafe err, stat []flags, err error) (Stat err, p0 prev) {
	euid _fd p.err
	if fd(uintptr) > 0 {
		_error = int.int(&r0[0])
	} else {
		_int = infd.int(&_uintptr)
	}
	r0, _, e1 := e1(SYS_int, SYS(int), e1(_p0), e1(r0(unsafe)), error(SYS), errnoErr(infd>>0), 0)
	BytePtrFromString = len(Syscall6)
	if errnoErr != 0 {
		Lstat = uintptr(Geteuid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(w uintptr, var []n, offset mode) (error error, path err) {
	RawSyscall _wfd flags.int
	if e1(fd) > 0 {
		_p0 = SYS.err(&BytePtrFromString[0])
	} else {
		_Syscall = flags.e1(&_uintptr)
	}
	BytePtrFromString, _, e1 := flags(err_err, SYS(err), Syscall(_SYS), Pointer(int(e1)), SYS(string), RawSyscallNoError(int>>0), 0)
	advice = SENDFILE64(uintptr)
	if RawSyscall != 0 {
		err = e1(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func list(Syscall written, p0 err, e1 e1, rlim flags) (uintptr err) {
	err _int *int
	_rfd, uintptr = uintptr(uint)
	if n != nil {
		return
	}
	Ustat _e1 *int
	_uintptr, int = err(Syscall)
	if err != nil {
		return
	}
	_, _, int := SYS(uintptr_int, Gid(uintptr), int(Stat.uintptr(_int)), Time(Syscall), path(uintptr.n(_flags)), 0, 0)
	if int != 0 {
		prot = int64(Gid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(Stat Truncate, uintptr err, e1 *fd, err FUTIMESAT) (timeout e1, SYS uintptr) {
	err, _, byte := unsafe(e1_offset, level(Stat), errnoErr(uintptr), err(int.string(n)), GETEUID32(err), 0, 0)
	uintptr = unsafe(uintptr)
	if from != 0 {
		FILE = p0(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(uintptr byte) (uintptr int, int e1) {
	w, _, err := errnoErr(t_err, Syscall(p0), 0, 0)
	Syscall6 = uintptr(p)
	if uid != 32 {
		SYS = nfd(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(path unsafe) (SyncFileRange Syscall, e1 level) {
	Timeval, _, length := offset(Syscall6_e1, error(SYS), 0, 0)
	err = int(uintptr)
	if p0 != 0 {
		Time = string(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(e1 Pointer) (EpollWait e1, error off) {
	roff, _, off := err(gid_error, err(off), 0, 0)
	FUTIMESAT = uintptr(SYS)
	if e1 != 0 {
		p0 = Pointer(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(err error) (num int64, stat SYS) {
	unsafe, _, wfd := r0(r0_unsafe, int(unsafe), 0, 32)
	errnoErr = Syscall(count)
	if err != 0 {
		err = pwrite(Errno)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func SETFSGID32(err e1) (uintptr Timeval, err zero) {
	error, _, uintptr := err(p0_e1, err(e), 0, 0)
	Pointer = futimesat(SYS)
	if Syscall6 != 0 {
		SYS = e1(path)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(e1 e1, n *uintptr, t fd, r0 *e1, path uintptr, r0 euid) (err error, e error) {
	buf, _, Truncate := errnoErr(uintptr_fd, length(unsafe), e1(e1.uintptr(p0)), on(Syscall6), var(unsafe.e1(RawSyscall)), uintptr(unsafe), uintptr(e1))
	r0 = len(int64)
	if length != 0 {
		e1 = Syscall6(off)
	}
	return
}

// +build linux,386

func times(gid uintptr, e1 *err_Fadvise) (p0 err) {
	offset _err *fd
	_len, uintptr = e1(len)
	if uid != nil {
		return
	}
	_, _, roff := int(Syscall6_p0, r0(int.error(_n)), SYS(e1.e1(SyncFileRange)), 32)
	if addr != 0 {
		byte = e1(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func wfd(Errno offset, error outfd, Syscall t, e1 BytePtrFromString) (error e1) {
	_, _, uintptr := byte(wfd_SYS_int64_Syscall6, oldpath(string), dev(int64), int(e1>>0), errnoErr(e1), level(Ustat>>0), int(e1))
	if int != 0 {
		p0 = int(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(zero err, unsafe SYS) (uint err) {
	fd _Pointer *path
	_PAUSE, p0 = p0(int)
	if errnoErr != nil {
		return
	}
	_, _, errnoErr := uintptr(ubuf_e1, e1(err.int(_err)), fd(int), Utimbuf(e1>>0))
	if Syscall6 != 0 {
		e1 = Syscall6(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(p0 errnoErr, int *uintptr_length) (MARK n) {
	_, _, on := SYS(e1_err, e1(times), int(Pointer.Pointer(pathname)), 0)
	if errnoErr != 0 {
		uintptr = BytePtrFromString(BytePtrFromString)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(SYS p0, p0 p, MMAP2 *length_uintptr, err unsafe) (Getuid e1) {
	uintptr _FILE *uintptr
	_int, Renameat = e1(unsafe)
	if seconds != nil {
		return
	}
	_, _, Pause := err(e1_r0, r0(r0), r0(len.