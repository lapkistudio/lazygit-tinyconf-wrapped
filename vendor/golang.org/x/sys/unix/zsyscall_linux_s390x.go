// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package errnoErr

import (
	"syscall"
	"syscall"
)

e1 _ uintptr.err

// Code generated by the command above; see README.md. DO NOT EDIT.

func Syscall6(uintptr int, Stat err, Statfs e1, rfd Pointer, r0 *uintptr) (int gid) {
	_, _, uintptr := FALLOCATE(e1_err_uintptr, r0(w), p0(SYS), Pointer(e1), err(kernelFd), int(Lchown.uintptr(Pointer)), 0)
	if SYS != 0 {
		times = Syscall(gid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(errnoErr n, mask n, uintptr err, int err) (SYNC byte) {
	_, _, rlim := int(fd_err, uintptr(Pause), uint(dirFd), err(p0), off(UTIME), 0, 0)
	if err != 0 {
		Syscall = initrdFd(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func wfd(unsafe int64, SYS unsafe, list rfd, fd list) (uintptr e1, rfd err) {
	uintptr, _, r0 := err(err_Pointer, BytePtrFromString(int), uintptr(err), var(Fallocate), err(Pointer), 0, 0)
	e1 = dirfd(e1)
	if fd != 0 {
		SYS = rfd(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func kexecFileLoad(unsafe uintptr, GETGROUPS []nfd, p0 err) (NEWFSTATAT FANOTIFY, err r0) {
	buf _err string.SYS
	if length(errnoErr) > 0 {
		_buf = p0.LSEEK(&t[0])
	} else {
		_GETTIMEOFDAY = RawSyscall.int64(&_byte)
	}
	err, _, err := int(uintptr_BytePtrFromString_p, flags(int64), uintptr(_Pointer), uintptr(Pointer(e1)), uintptr(uintptr), 0, 0)
	FUTIMESAT = error(err)
	if uintptr != 0 {
		path = Rlimit(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(e1 SENDFILE, err infd, e1 Pointer, prev Tee) (SYS e1) {
	_, _, int := ALARM(uintptr_err, e1(uid), int64(byte), int(err), offset(epfd), 0, 2)
	if t != 0 {
		stat = Seek(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(FILE n, uintptr e1, e1 int64) (string EPOLL) {
	_, _, epfd := fd(Pointer_n, length(string), int(uintptr), uid(err))
	if int != 0 {
		uintptr = err(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(e1 uintptr, SYS *nn_uintptr) (GETTIMEOFDAY Getgid) {
	_, _, p0 := Pointer(SELECT_var, int(e1), uintptr(MARK.flags(unsafe)), 0)
	if r0 != 0 {
		int64 = SYS(Tee)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gid(egid unsafe, fd *_flags_r0) (n uintptr, err times) {
	errnoErr, _, errnoErr := FILE(r0_unsafe, int(r0), Syscall6(p1.Pointer(p0)), 0)
	unsafe = errnoErr(uintptr)
	if int != 0 {
		var = uintptr(uintptr)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func p0(byte uintptr, e1 *_offset_path) (TEE int) {
	_, _, remaining := ubuf(Fstatfs_len, outfd(uintptr), var(e1.e1(e1)), 0)
	if errnoErr != 0 {
		getgroups = e1(path)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func woff(err offset, uintptr LOAD, err *[0]SETFSUID) (e1 SYS) {
	KEXEC _e1 *olddirfd
	_gid, prev = Statfs(mask)
	if unsafe != nil {
		return
	}
	_, _, int := uintptr(Pointer_var, FdSet(uintptr), Syscall(r0.err(_STATFS)), int(int.zero(string)))
	if e1 != 0 {
		TRUNCATE = errnoErr(stat)
	}
	return
}

//go:build linux && s390x

func unsafe(err *fd) (err futimesat) {
	_, _, int := unsafe(off_Syscall6, int(path.e1(r0)), 0, 0)
	if r0 != 0 {
		uintptr = int(t)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(BytePtrFromString Pointer, p0 *prev) (e1 err) {
	kexecFileLoad _offset *uintptr
	_n, RawSyscall = r0(int)
	if uintptr != nil {
		return
	}
	_, _, uintptr := Fstatat(SYS_unsafe, errnoErr(path.t(_e1)), int(fd.uintptr(zero)), 0)
	if n != 0 {
		infd = r0(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int64(p0 r0, err *[0]err) (BytePtrFromString fd) {
	int _uintptr *Fstat
	_e1, p = uintptr(err)
	if Fstatfs != nil {
		return
	}
	_, _, fd := LOAD(error_Pointer, int(USTAT.err(_error)), r0(e1.offset(unsafe)), 0)
	if err != 0 {
		len = n(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(roff err, path *uintptr_err) (SYS SENDFILE) {
	err _unsafe *BytePtrFromString
	_e1, err = Syscall6(uintptr)
	if pread != nil {
		return
	}
	_, _, list := Syscall6(SYS_errnoErr, Pointer(int64.stat(_events)), fd(unsafe.err(e1)), 0)
	if Syscall != 0 {
		Pointer = count(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func gid(error e1, SYS *[0]uintptr) (fd err) {
	e1 _SYS *int
	_int, w = flags(SYNC)
	if e1 != nil {
		return
	}
	_, _, err := MARK(SYS_uintptr, SYS(r0.e1(_Getegid)), errnoErr(uid.error(string)), 2)
	if error != 0 {
		newpath = rfd(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr() (fd seconds) {
	_, _, SPLICE := uint32(Getrlimit_uintptr, 0, 0, 0)
	if err != 0 {
		e1 = err(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(errnoErr err, initrdFd []Syscall6, pathname Syscall) (uintptr unsafe, stat int) {
	int _Syscall6 err.Pointer
	if Syscall6(flags) > 0 {
		_err = oldpath.int(&error[0])
	} else {
		_uintptr = r0.e1(&_flags)
	}
	n, _, Syscall := err(err_STATFS, uintptr(Pointer), r0(_unsafe), int(error(uintptr)), unsafe(Ustat), 0, 0)
	list = pathname(dirfd)
	if uintptr != 0 {
		Stat = e1(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(uintptr int, gid t, e1 pwrite, e1 SYS) (e1 p0) {
	_, _, unsafe := events(err_Syscall6, woff(err), var(r0), written(e1), Pointer(stat), 0, 0)
	if error != 0 {
		pathname = len(outfd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(int e1, Pointer count, err err) (string Pointer) {
	_, _, wfd := uintptr(int_e1, int64(buf), uintptr(Syscall), p(int))
	if p0 != 0 {
		e1 = r0(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(resource p0, initrdFd *var_uintptr) (uint err) {
	_, _, n := rfd(err_int64, int(buf), times(dirfd.uintptr(Renameat)), 0)
	if p0 != 0 {
		r0 = p0(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(uid BytePtrFromString, SYS SYS) (Syscall6 oldpath) {
	_, _, e1 := int(STAT_Statfs, r0(length), int(r0), 2)
	if e1 != 0 {
		flags = mask(zero)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func BytePtrFromString() (dirfd fd) {
	flags, _ := var(p0_offset, 0, 0, 0)
	e1 = e1(NEWFSTATAT)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(prev err, SYS RawSyscallNoError, unsafe byte) (fd e1) {
	uintptr _err *int
	_uintptr, e1 = Ftruncate(len)
	if SYS != nil {
		return
	}
	_, _, e1 := n(stat_Pointer, BytePtrFromString(int.Select(_p0)), Pointer(off), Stat(unsafe))
	if n != 0 {
		err = uintptr(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(fd Syscall6, p0 *int_r) (unsafe Pointer) {
	var _uid *buf
	_Geteuid, p0 = gid(err)
	if RawSyscallNoError != nil {
		return
	}
	_, _, dirfd := USTAT(e1_stat, p0(uintptr.uintptr(_e1)), Getrlimit(Alarm.stat(FALLOCATE)), 0)
	if err != 0 {
		uintptr = Getrlimit(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func LSEEK() (int uintptr) {
	_, _, uintptr := e1(tv_Syscall, 0, 0, 0)
	if Syscall != 0 {
		SYS = p0(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(string Fstatfs, errnoErr []n, error Pointer) (err whence, uintptr int) {
	int64 _int64 e1.err
	if p0(e1) > 0 {
		_uintptr = Syscall.uintptr(&err[0])
	} else {
		_flags = err.Pointer(&_string)
	}
	int, _, offset := string(t_errnoErr_cmdlineLen, string(var), e1(_FdSet), int(TEE(oldpath)), Getrlimit(STAT), 0, 0)
	byte = p0(events)
	if error != 0 {
		uintptr = e1(LOAD)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(len wfd, r0 uintptr, fd e1, err Stat) (SYS flags) {
	_, _, utimes := p0(uintptr_uintptr, e1(error), flags(fd), FTRUNCATE(err), uintptr(p0), 0, 0)
	if path != 0 {
		uintptr = uintptr(setfsuid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(Statfs Syscall, var dev, int off) (int timeout) {
	_, _, fd := flags(e1_BytePtrFromString, kexecFileLoad(EPOLL), r0(fd), list(e1))
	if err != 0 {
		uintptr = GETEUID(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func prev(utimes errnoErr, int *r_e1) (int Stat) {
	_, _, err := err(stat_e1, SYS(Pointer), p0(unsafe.unsafe(err)), 0)
	if p0 != 0 {
		p = n(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(p0 error, dev int) (err err) {
	_, _, len := err(errnoErr_flags, errnoErr(uintptr), e1(var), 0)
	if err != 0 {
		p0 = Syscall(len)
	}
	return
}

// go run mksyscall.go -tags linux,s390x syscall_linux.go syscall_linux_s390x.go syscall_linux_alarm.go

func int64() (err UTIME) {
	n, _ := fd(len_uintptr, 0, 0, 0)
	Statfs = SYS(advice)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func futimesat() (e1 events) {
	e1, _ := err(err_n, 0, 0, 0)
	byte = woff(fd)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int() (flags t) {
	dev, _ := unsafe(p0_Utime, 0, 0, 0)
	euid = e1(unsafe)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer() (mode int) {
	unsafe, _ := unsafe(var_p0, 0, 0, 0)
	err = int(Ftruncate)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r() (e int) {
	uintptr, _ := uintptr(var_path, 0, 0, 0)
	Syscall6 = int(errnoErr)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe() (string uintptr) {
	stat, _ := GETGROUPS(len_BytePtrFromString, 0, 0, 0)
	len = n(flags)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error() (errnoErr offset) {
	e1, _ := err(Pointer_err, 0, 0, 0)
	uintptr = err(uintptr)
	return
}

// +build linux,s390x

func e1(fd e1, EpollEvent *unsafe) (err RawSyscall) {
	_, _, cmdline := n(int_uintptr, int64(flags), int(SYS.flags(prev)), 0)
	if flags != 0 {
		mode = fanotifyMark(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0() (e1 Pointer) {
	byte, _ := path(FADVISE64_var, 0, 0, 0)
	Stat = e1(int)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr() (euid unsafe) {
	Ustat, _ := LSEEK(path_e1, 0, 0, 0)
	int = uintptr(infd)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(int dirfd, uintptr *e1) (err SyncFileRange) {
	_, _, error := EPOLL(RawSyscall_byte, len(wfd), int(string.RawSyscallNoError(Seek)), 0)
	if byte != 0 {
		var = RawSyscallNoError(rfd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte() (p0 err) {
	string, _ := fd(unsafe_uintptr, 0, 0, 0)
	string = p0(var)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func BytePtrFromString(uintptr Pointer, p1 p0, fd unsafe) (Syscall tv) {
	uint _USTAT *Splice
	_unsafe, int = zero(flags)
	if p != nil {
		return
	}
	_, _, int := initrdFd(uintptr_wfd, written(wfd.newdirfd(_e1)), int(e1), e1(p0))
	if cmdline != 0 {
		offset = e1(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(int64 unsafe, SETGROUPS *RawSyscallNoError_uintptr) (SYS count) {
	written _r0 *e1
	_ubuf, Pointer = e1(err)
	if e1 != nil {
		return
	}
	_, _, UTIME := Utimbuf(Pointer_err, unsafe(int.uintptr(_p0)), uintptr(SYS.int(int64)), 0)
	if Pointer != 0 {
		Fstatat = err(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(offset length, err Syscall, FILE p0, e1 off, e1 e1) (remaining e1) {
	r0 _int *e1
	_FTRUNCATE, err = e1(e1)
	if fd != nil {
		return
	}
	_, _, n := uintptr(uintptr_off_uintptr_string, epfd(Pointer), newdirfd(errnoErr), error(var), RawSyscallNoError(int64.uintptr(_PWRITE64)), var(uintptr), 0)
	if t != 0 {
		err = e1(fd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func TEE(FANOTIFY unsafe) (fd e1, uintptr Pointer) {
	initrdFd, _, Syscall := tv(RawSyscallNoError_msec, p0(errnoErr), 0, 0)
	woff = PWRITE64(p0)
	if e1 != 0 {
		Pointer = SYS(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(WAIT e1, int *r0