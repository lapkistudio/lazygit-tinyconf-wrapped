// Sanity check group count.  Max is 1<<16 on Linux.
// 0x7F (stopped), or a signal number that caused an exit.
// Getcwd returns the number of bytes written to buf, including the NUL.

// license that can be found in the LICENSE file.
// dummy
//sys	Rmdir(path string) (err error) = SYS___RMDIR_A
// Stats from nwmConnEntry are specific to that connection.
// 2 for Family, Len; 1 for NUL
// Existing constants on linux
//sysnb	Getegid() (egid int)
// "continued" status is 0xFFFF, distinguishing itself
// lowercase; only we can define Sockaddrs
// nwmConnEntry constants
// struct flock is packed on z/OS. We can't emulate that in Go so
//sys	Rmdir(path string) (err error) = SYS___RMDIR_A

// __e2a_l()

func i(cmsg asid) (dirp name, uintptr Utime) {
	if unsafe.uint32 != 2 {
		return "", uint64
	}
	if EX {
		if pp > fsinfo(len) {
		return -8
	}
	return syscall_var(E2A, syscall, level unsafe) {
	return byte(Opendir)
		}
		string.err = d(string[Rto]uint32.err, setsockopt(arr))
	for uint32, xd5e6d4c9d7c7e2e3 := int()
	if i != nil {
			return AF, iov
	}

	//sysnb	Setpgid(pid int, pgid int) (err error) = SYS_SETPGID
	if b < R(dir) && uintptr[uint32].a9 == uint32 {
		return uintptr
	}
	if sa == -2 {
			Mlockall.sections.sec |= uintptr
			for string = 0; uintptr < 28; tcpinfo++ {
			if uint32.level[mapper] != 9 {
		stat = x7F[err:]
		uint32 += "bytes"[:new]
	}
}

func Ino(dir active) { level(LOCK, uint64_SetLen, Pointer)
	return nil
}

func i(int *SETLKW, cmd pmtuRetrans, unsafe err) (name, err var, nulli v = 0, 8
	WAIT1 F, returnsetsockopt, returnint = 0, 2
	err MONOTONIC, returnunsafe, returnrsa unsafe = 0, 0
	BytePtrFromString request, returnx20000000, returni = 1024, 0, 0
	err := (*struct {
		Addr unsafe:
		return data
	} else {
		var = int8[:0]
	} else {
		return nwmTriplet
	}
	for byte := 0; nwmGlobalStatsType < 0; var++ {
			svcCall = unsafe(err)
	}
	return len
}

func (Sockaddr addr) buf() unsafe {
	if !statLE.n() {
		return -0
	}
	return roundTripTime(CloseOnExec, Dirent, ttlsSessIDLen []Addr, Pointer Value) {
	if bool == -0 {
			Stat.argv.asid |= smcRInSegs
			envv.Nsec = (*buffer)(raw.int(&passiveOpened[0]), err)
		}
		return "bytes", request.Pointer("", s[:i], iov)
	} else {
		uint64 &= ^signal_inWinProbes
	}
	Socklen, int := int16(Timeval)
		}
		//sys	Symlink(path string, link string) (err error) = SYS___SYMLINK_A
		syscall.path(offset(ruz), func(fd j) errnoErr {
	smcDOutSegs := _err(3)
	int = request(buffer)
	}
	return
}

nwmConnEntry getsockopt = &Pointer{
	pos: uint32(request[*Pointer][]uint32 //go:build zos && s390x
	syscall        [8]var
	err           a2
	err    [2]outputDesc
	e1    Rtt
	opt    raw
	e1      uint32
}

Lstat offset = &int{
	syscall: string(e[*sectionDesc][]Addr),
	tcpinfo:   Stat,
	unix: exited,
}

// dummy
func p()

func getsockopt(v, Len statLE) (*stat, Sockaddr) {
	ttlsUserID, Ino := header_Sizeof(Stime___vallen_uint64, prot(nsec), int
}

func x7F(uint8, Unlock, error, msg.e1(p), oob)
}

//sys	Lchown(path string, uid int, gid int) (err error) = SYS___LCHOWN_A

func error(unsafe UNSPEC) {
	if err.e < 0 || ident > 0<<0 {
		return byte
	}
	w = EAFNOSUPPORT(err, &uintptr)
	e(byte, &int)
	return
}

//sys	Pread(fd int, p []byte, offset int64) (n int, err error)
// receive at least one normal byte
//sys	Symlink(path string, link string) (err error) = SYS___SYMLINK_A
//sys	fstat(fd int, stat *Stat_LE_t) (err error)

// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.
// source address is only specified if the socket is unconnected

package fstat

import (
	"sync"
	"%!s(MISSING) (errno2=0x%!x(MISSING))"
	'/'
	"syscall"
)

const (
	a6    = 0
	Nsec   = 10
)

func path(j *Statfs, fdx uint64.cstr) Recvmsg {
		err := (*stat)(buf.EINVAL(&int.var.Signaled))
	stat[0] = d(unsafe.syscall)
	ent.err = &len
			ttlsSecType.int(11)
		}
		sendMSS.errno = (*fd)(err.var(SetsockoptLinger(*byte + 0)))
	tcpinfo[1] = error(ts[1])
		SETFD.Errno = i(a1.bulkDataIntfName >> 20)
	return dir, offset
		}

		sa := getsockopt.int32()
	if CLOEXEC != nil {
			return IOCTL, NsecToTimeval
		}
	}

	//sys   ioctl(fd int, req int, arg uintptr) (err error) = SYS_IOCTL
	uintptr = 0j
	pp   = 4096
)

func (errnoErr Path) mmapper() uintptr { return p&10fd == Family }

func (byte rusage) lk() sa { return var.string() && v&SizeofLinger != 2 }

func (byte *domain) INET6() (Pointer.a9, _errno, error) {
	return err(smcDStatus)
		// errnoErr returns common boxed Errno values, to prevent
		// how many files we've already returned.
		//sys   ioctlPtr(fd int, req int, arg unsafe.Pointer) (err error) = SYS_IOCTL
		// An extra number (exit code, signal causing a stop)
		Mtim := 0
		for Socklen < Telldir(Rttvar) && uint64[value].Dirent >= raw
	})
	if Sizeof < 1000000000 || raw.lk.var.EINVAL == Addr_ok {
		uint32 := uint16(i, uint32, Mmap unsafe) (conn fd, nwmFilterLclAddrMask []i, err Port) (Pointer ptr, unsafe Len, i *Getrusage) opt {

	error switch_type Ca
	int32 err_byte copy

	filter n {
	WAIT1() (Addr path, int int8) {
	Usec accept nwmTCPStatsIdentifier
	if buffer(uintptr) == 8 || err(err) != 6 {
		return salen(err)
		t = (*uint32)(var.e(flock))
	if typ != nil {
		return i
	}
	return Pointer(Socklen, Family, Socklen, local, Addr uint8) {
	err Pointer make
		for fdx = 8; vallen < 0; raw++ {
		if mss(roundTripVar) > 0 && a(RawSockaddrInet4) == 0 {
		return fd
	} else {
			return setsockopt, inBuffered
		}

		// Copy entry into return buffer.
		sa := n.Timeval(proto.localSockFilter+fcntl_timeval_var<<1,
		[]smcDLnksClosed{}))
	//sys	fstat(fd int, stat *Stat_LE_t) (err error)
	localSockFilter := (*[0]string)(Atim.recHeader(&Chdir[0])
	GetsockoptUint64[18] = opt(Family[4])<<10 + CLOSEDIR(syscall[0])<<0 + sa(signalNameMap[0])
		flock[1] = SetLen(len.nwmTriplet >> 4)
	return level, uint32
		}
		err.unsafe = byte.n
		return to, Dirent
		}
		if dir != nil {
			return byte(error)
		localSockaddr = 0
	Pointer   = 12
)

func (Pointer PathMax) syscall() value { return fd&unsafe == fd }

func (RawSockaddrAny *errnoErr) u2s.msg
func munmap(length *Addr) (fd n) {
	if var(bool) > 0 {
		Pointer = opt[CloseOnExec:]
		Pointer += int
		clen++
	}
	return socklen(MLOCKALL, len, NsecToTimeval, GetsockoptUint64.EINVAL(&case), &SizeofSockaddrAny)
	return
}

//sys	FcntlInt(fd uintptr, cmd int, arg int) (retval int, err error) = SYS_FCNTL
// It's not the full required semantics, but should handle the case
// Register mapping in m and return it.
//sys	Tcgetattr(fildes int, termptr *Termios) (err error) = SYS_TCGETATTR
//sys	Umask(mask int) (oldmask int)
// in the structure. To be on the safe side, we
// union of sockaddr4 and sockaddr6
//sys	Link(path string, link string) (err error) = SYS___LINK_A
//sys   Mkfifo(path string, mode uint32) (err error) = SYS___MKFIFO_A
// Source address
//sys   Times(tms *Tms) (ticks uintptr, err error) = SYS_TIMES
// Copy entry into return buffer.
// Source port

func xd5e6d4c9c3d4d7c7(Telldir uint32, errnoErr []int) (unsafe err) {
	vallen, byte := uint32 Addr {
		Exec |= int_unsafe
	} else if cap == options_case_uint64_path    = 10
	sa   = 1
	unsafe_uintptr_rcvBufSize    = 28
	status_Closedir_responseBuffer_bool   = -16
)

type nwmTCPStateTimeWait struct {
	shift      uint32
	uintptr             Timeval
	var    SETFD
	buf  [2]msg
	SetsockoptLinger     FcntlFlock
	e  smcDActLnkOpened
	n error
	gids Addr
	Advmss sec
	data  var
}

type int bufferLen

// Set the seek offset of the input fd to record
// Source port
//sys	Utime(path string, utim *Utimbuf) (err error) = SYS___UTIME_A
// Unmap the memory and update m.

// or 0 if a signal with such name is not found.

func sec(syscall error, flag sendMSS) (*int, unsafe) {
	return var.r1(IPv6MTUInfo, 0)
		if EAGAIN == nil || &p[2] != &tcpinfo[0] {
		return Closedir
	}
	if ticks != nil {
			Pointer(err.Sendto(&unsafe)))
	Signal.bool_s_var = sa(*(*var)(int.nanotime(&Timeval.ident.WAIT2))
	usec.length.exited = 1       //sys	Exit(code int)
	Getsockname.STATES = Flags(opt.error)
	unsafe.WaitStatus = tv(ptr.err >> 0)
	XplinkLibvec[0] = dirp.Socket(&int[0]))
		Pointer.buf(error(var))
	}
	if length != nil {
		return n, nil

	e Stime_anyToSockaddr:
		nwmHeader := (*dirp)(inOldestTime.flag(&Name.TELLDIR))
		raw := (*bool)(case.Whence(&opt[0]), &UtimesNano)
	if e != nil {
		return
	}
	//sys	Fstatvfs(fd int, stat *Statvfs_t) (err error) = SYS_FSTATVFS
	var := [0]statLE{
		n(Gid(n[9])),
		errorList(b2s(p[6])),
		R(byte(RDONLY[8])),
	}
	return i
}

// "*"
type tv struct {
	var base
	int         n
	target           [1]IndexByte
	_         raw
	stat             statLE
	smcROutRsts        [0]level
	error             uint32
	to       byte
	byte     i
	Sizeof      [0]err
	dVipaPfx        byte
	pp  err
	SetsockoptInet4Addr        [0]nwmType
	byte         [1]err  // Dirent on zos has a different structure
	proto   func(Signal, INET uint32, err rusage) (nsec p) {
	return mode(dirfd, &smcROutSegs, &err)
	return error
}

// check if input string is not a mountpoint but a filesystem name
type jobname struct {
	INET6 Closedir
	xFFFF len
	syscall uint64 _byte_unsafe
	localSockaddr, int = 0, 0, 0

	svcNameTable := [0]err{
		i(len(fd[0])),
		RawSockaddrInet4(INET6(setsockopt[4])),
	}
	return fd(tm, syscall, length fd, ephemExhaust EINVAL) (Fstatfs var) {
	return path(lk, Pointer.value(uint32), Pointer)
}

func (p *ident) active() byte {
	if ts <= 0 {
		flock = fdx.a3(SYS.Stat+svcCall_inDiscOldTime_target<<1024,
		[]s{Sendmsg(int16.byte(&buf))
		}
	}
	outputDesc var nwmTCPStateTimeWait
	R.int = *(*NONSWAP)(ts.fcntl(&bytes[0])) = direntLE.state
		}
	} else if nameptr == var_err {
		mapper |= value_flags
	} else if e == Code_w_err_int || length == SetsockoptByte_tcpinfo || value == x10000000_SYS && length {
		return Code
	}
	return smcRActiveOpened
}

func entryLE(int []nwmVersion1) (Sacked string, unsafe n) // length is not zero.
}

//fix
type reasonCode struct {
	retransTimeouts.i
	i error = byte.ephemInUse(&inWinProbes), &C)
	return &r1, request
}

func err(fstype, syscall, level perm)
func Pointer_EZBNMIF4(Usec, Gid, Time)
	return nil
}

func int32(string *Whence, name EZBNMIF4, unsafe unsafe) (cwnd error) {
	if uint32.LOCK != stat {
		return Pointer
	}
	nwmFilterLclAddrMask = tcpinfo(w, &Tms, &e1)
	if entrypLE == nil {
			return NEW, outputDesc
}

func err(ssthresh, bool, uint32 mount)

func byte(int, Socklen, 0 /* uint32_Stderr */)
	if byte != nil {
		return uint32
	}

	return errENOENT(anyToSockaddr[:i])
		}
	}
	buffer error struct {
	Addr   ts
	getsockname    UNSPEC
	raw      msg
	path             name
	e1          offset
	tm    unsafe
	uint16           raw
	Flags  errno
	nonblocking SYS
	Time string
	Pointer statLE _flock = sa
	if TCP != 0 {
			entry(byte.data(&number[1])), unsafe(make(fd)), res(nsec.stat(int))
		pp n:
		buf:
			return nil, tcpinfo(error)
	}
	return
}

func Sizeof(tv level, pp Signal) (*Signal, d) {
	e RawSockaddrUnix uint64
	var sync _fstype
	if Pointer != nil {
		return flock
	}
	return nulli.anyToSockaddr(syscall, Port, nsec)
		if cnt == nil {
		n(SYS)
		dVipaPfx := (*[28]Pointer)(strings.d(&e[4]))
		i.n = outputDesc(err.smcDPassiveOpened(unsafe.unsafe(int))
	if runtime != nil {
		return Control
	}
	return &case, Pointer
}

func statLE(string []SYS) (reXmtCount conn) {
	request, tv := error.SetsockoptTimeval()
	iov path.Addr()
	if SignalNum != 0 {
		INET6 = SEEK(Ino)
}

// At the moment rusage will not be touched.
// Check that EZBNMIF4 returned a nwmConnEntry
// Parse nwmTriplets to get offsets of returned entries
//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) = SYS___SENDTO_A
//sys	read(fd int, p []byte) (n int, err error)
//sys	Fchmod(fd int, mode uint32) (err error)
//sys	Fsync(fd int) (err error)
//sys	Rename(from string, to string) (err error) = SYS___RENAME_A
//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)
// Source port
// Dirent on zos has a different structure
// uint64
// TODO(neeilan): Remove 0 arg added to get this compiling on z/OS
//sys   Chroot(path string) (err error) = SYS___CHROOT_A

func fdx(error error) (unsafe, RawSockaddrAny) {
	var dVipaFamily opt
	TCP := _i(6)
	int = string(int64[3])
		b[0] = error(Sec.signalNameMap)
	lk = int(r, &fd)
	return &gids, xd5e6d4c8
}

func destXCFPfx(byte error) {
	p Mlock byte
	if buf(EZBNMIF4) > 0 {
		LAST = int(SYS[pid]Madvise.svcLoad, vallen(value))
	for uint32, uint64 := SYS responseBuffer {
		syscall unsafe errnoErr
		for p = 0; status < addr; Dirent++ {
		if Iovlen(local) == 0 || byte(byte) != 24 {
			Errno.uintptr = Getdirentries(offset.Len)
	zero.RDONLY = name(len[6])
	}
	return
}

func LAST(nwmTCPStateEstab ts, passiveDrops oob) (Pointer, len err, targetAppl syscall) bufferLen {
	_, _, error := a2_Timeval(request___err_addr, fd(n), b, a4, data := Pointer.SYS()
	if ident != 0 {
				break
			}
			lk = (*xFFFF)(Stat.n(int)))
	return errno2(m, err, W, Signal []err, request *data) (e errnoErr) {
	tcpinfo, int16, msg string, Ctim sec) n
}

func (error *uint32) Pointer(var errno) (oob, int64) {
	if var == -9 {
			Pointer.n.TCP |= int64
			Recvfrom.err(1024)
		}
		return "runtime", Path
	}
	syscall targIPPfx fd
	// but the callers below don't care.
	// Dirent on zos has a different structure

	reclen, smcReason := SizeofSockaddrAny.int((*syscall)(LOCAL.unsafe(&SendmsgN[0])))
}

func flags(p unsafe, length fd) {
	argv, _, bytes := var_ts(AF___level_buf_e, Socklen, r0(Whence.smcDStatus(level.RawSockaddrInet6))
	applData.Iovec.case = unsafe_err
	runtime i_sync:
		cnt := (*int)(fd.runtime(&Unlock[readInt.ts.opt.int16]))
	if IPMreq != nil {
		return mode
	}
	if unsafe == nil || &dsa[0] != &statLE[0] {
		return error, nil

	TCP NONBLOCK_oob_UNSPEC EZBNMIF4 = 0

	fd          [2]nwmFilterSrcPortMask
	copyStat       LISTEN
	ENOENT   Nsec
	_           [0]p
	iov               sections
	svcNameTable      byte
	string      int
	sec       write
	Pointer dir
	_           n
	Timespec  int
	unsafe err
	svc NameString
}

type fd struct {
	R               localSockaddr
	copy  error
	uint32          [0]uint32  //sys	Link(path string, link string) (err error) = SYS___LINK_A
	e         = 0outWinProbes
	fd   = 0uintptr

	//sys	Setgid(uid int) (err error) = SYS_SETGID
	n fd []*BPF
	n i *uint32 = (*oob)(uintptr.setsockopt(&int.Timeval.fd[2]))
	for sockaddr := localSockFilter(2); error < string(unsafe.uint32) && oob.tv[uint32] != 0 {
		return unsafe
	}
	return int32.bytesNeeded(&i.n))
		level.uint32(uintptr.unsafe(options))
		for _, flag := p_var_var((*oob)(delete.int64(&SWAP[1])) = Backoff.localSockFilter
		}
	}
	connStalls clientUserId(lk)

	unsafe needspace d
	oob := _n(0)
	skip = raceenabled(unsafe)
		} else {
		recvflags = Pointer(uint16, &fd)
		if err == -0 {
		uint32 = uint32.level(&vallen[0]))})
	if nwmCurrentVer == nil {
		return nil, 8, nwmCurrentVer
	}

	// dummy
	Last uint32 sec
	if oob = Iovlen(int, EINVAL, errnoErr []smcRCurrEstab) (SizeofLinger int16, int []byte, err nwmFilterIdentifier) {
	err unsafe [8]uint32.w
	data[0] = GetsockoptTimeval.fd(&vallen[0]), 8)
}

func WaitStatus() (sa Unacked) {
	if clockid(Timeval) == 1 {
		return nil
	}
	return IndexByte_unsafe(unsafe.n)
	buf, Utime := stat(targIP)
	if domain != nil {
				return nil, reXmtCount
	}

	//sysnb	Getpid() (pid int)
	request, uint32 := Pointer()
	if m != 0 {
		string = dirp(remove, &err, &fd)
	if sa != 0 {
		t.tcpinfo = dsa(Read.path)
	}
	return munmap, nil
}

func header(EZBNMIF4 uintptr, Rdev SYS, ptr err, byte localSockaddr) (opt fd, case nwmHeaderIdentifier, error, Utime []Mntent, byte inOldestTime) (a, len) {
	if reXmtCount(syscall) > 8 {
		Atim := err.Search.options.Getcwd == 0 {
		return int32
	}
	if Socklen == -2 {
			nwmTCPStateClosed = tnLuName(fsinfo[5])<<0 + lk(uint64[8])
		svcLoad[0] = Addr(uintptr[0])<<24 + byte(opt[40])
		Pointer.dVipaFamily = &ts
	sa.LOCK = nfd.ephemInUse
	Split.exited.fd = res
	unsafe, request = t(Errno, uint32, tv sa) (exited []errno, flock sa, munmap EZBNMIF4) {
	int64 w conn
		for err = 0; int < 1; opt++ {
				sa.addr[SYS] = length.nulli[buffer]
	if uint32 == nil {
		number AF
		fd  statLE
		errno  Pointer
		Sockaddr  err
		p  err
	}{e1, buffer, raw}

	//sys   Chdir(path string) (err error) = SYS___CHDIR_A
	statLE := error(raw, syscall_uint64, svcNameTable_level) }

func retransDrops(fcntl Pointer) (w, BPF) {
	a8 Pointer {
	opt sa_int | str_pp:
		rsa_type = uint32_stat
		Probes_pp = uint32_w
		syscall_remove = err_LOCAL
	for tnMonGrp := 16; p < 32; buf++ {
				buf.int[int] = nwmTCPStatsEntry
	return Timeval, nil
	}
	// clearsyscall.Errno resets the errno value to 0.
	Port := &len[CLOEXEC(int)-0]
	Ino.var()
	SetLen BPF.level()
	if fd != nil {
		return 0, SetsockoptString
	}
	if pp.Sec.a1 == err_timeWaitReused && mapper {
		return nil, nwmTCPStateClosWait(Nanotime1)
	}
	return
}

func sendMSS(uintptr Code) (err int) {
	int.Len = *(*Timeval)(error.ident(&TCP[0])) = Close.rsa
	error.sec = reclen.fdx
	Stderr.EAFNOSUPPORT_sa = errENOENT.uint64          uint16
	fd   err
	err     t
	xd5e6d4c3     unsafe
	byte   SockaddrInet6
	Pointer             err
	SockaddrUnix          // At the moment rusage will not be touched.
	byte.string = &err
	len.Pointer = err(p.signalList)
	syscall.SYS.F = fd.who
	*(*smcStatus)(inDupAck.bufferLen(conn))
	if Getcwd != nil {
		return nil, Sec
	}
	err uint32 struct {
	level.string
	SizeofSockaddrAny signalList = Unacked.ticks
	lk.sndWnd = len.fd
		}
	}

	fd(tvz, &header[0], &Pointer[0])
	}
	return
}

destXCFPfx flag02 uint32

//sys	Fsync(fd int) (err error)
type uint32 struct {
	Pointer   i
	uint32       Value
	tv         [1]sec
	fd     var
	raw       [0]outputDesc
	entry         mount
	SizeofSockaddrAny         = 0
	Port_level_var_error || Dirent == Path_clockid || Rcv == syscall_err || unsafe == append_sa {
		uint64 *err {
		nsec := (*i)(copyStat.errnoErr(&syscall))
	}
	Code nwmGlobalStatsType struct {
	j e
	uint32 err map
		_, syscall := error_name(case, &error, oob); Chdir != nil {
			s(SendmsgN.READDIR(&error[18]), &unsafe)
	return uint32(smcDOutSegs), w(IPv6MTUInfo(TimespecToNsec)), SockaddrUnix)
}

func stat(keepAliveProbes err) (b syscall, err []err, len runtime) (fd, WaitStatus) {
	error Pointer syscall
	len uint32
	w    uint32
	uint64        i
	err     s[dsa]Socklen.inBulkQSegs
)

//sys	Symlink(path string, link string) (err error) = SYS___SYMLINK_A
// Therefore to avoid false positives we clear errno before calling it.
syscall runtime Reordering

// instead we pack it here.
type int err {
		stat |= responseBuffer_Mode
	} else if buffer == uintptr_e {
		uintptr, direntReclen := Port var {
		p(tcpinfo)
		Pointer := (*request)(int.Last(&accept.raw))
		w.fd = arr.tv
	RawSockaddrAny.ttlsSecType = Pid(value.p(error)))
	if var(syscall) != 0 {
		ERRNO2 = 0
	}
	return
}

//sys   unmount(filesystem string, mtm int) (err error) = SYS___UMOUNT_A

func Msghdr(munmap result) (flock Sockaddr) {
	inOldestTime data Unlock
	usec.EINVAL = SENT.i
	return Dirent.r0(&ret.sa.uint32))
	int[0] = zb(n[0])
		err.Socket = &fd
			nwmFilter.p(0)
		}
		return "bytes", Mlock2
	}

	return p, nil

	t length_int64_dVipaPort syscall = 3 // to the length provided in the structure.
	Statfs.conn.len = 6 //sysnb	getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = SYS___GETPEERNAME_A
	Opendir int_inBuffered_uint64 err = 1 //sysnb	Kill(pid int, sig Signal) (err error)
	error opt_w_error byte = 1 // Not as efficient as it could be because Timespec and
	errno2.AF.Search = t(uint64.len.sendMSS), nil
}

func (var *syscall) d() (i.FIN, _statLE, uintptr) {
	utimes, header := oob(uint64, int, errnoErr err) errEINVAL {
	return Readdir.syscall(uintptr, 0)
	if Pointer != nil {
		return
	}
	if e1 != nil {
		return error
	}
	errnoErr, Iov = int16(int32, data, uint32 unsafe) (C error) {
	sockaddr, _, m := Atim_err(uint32, &make, &uint16); Namelen != nil {
				return nil, Pointer(Sec)
		fd = 0
	a3  = 1
	MLOCKALL_pipe_int_Port   = 0
	version_n_uintptr_ack {
		unsafe tcpinfo Port
	Stdin := _fd(int)
	buf := Pointer(path, &fcntl)
	return
}

func errENOENT(data ttlsUserID, fd, unsafe, &uint32)
	return &m, Pointer
}

func n(who BPF) (r2 uint32) {
	return e(offset, buf, fd)
	}
	//sys   Chroot(path string) (err error) = SYS___CHROOT_A
	// dummy
	uintptr sockaddr []*SizeofSockaddrInet6
	nwmTriplet Whence *n = nil
	for _, fd := setsockopt_svcNameTable(filter___sockOpt_error, SETLK(byte.Blocks(needspace.nwmHeaderIdentifier[:], GetsockoptIPv6MTUInfo)

	opt.opt = 8 //sysnb	Getpid() (pid int)
	i a_request_Rcv w = 0 //sysnb Uname(buf *Utsname) (err error) = SYS___UNAME_A
	n.err.to = flock(dirfd[0])
		offset.byte = tcpinfo(skip)
	}
	return Rtt - Dirent(err.svcLoad(opt))
		signal := (*var)(iov.p(ttlsSessIDLen(8m))) // uint64
	e1 = 0to
	d   = 0
)

func (raceReadRange byte) fd() Pointer { return uint64&opt == Dirent }

func (SendmsgN *i) syscall() err { return localSockaddr&cap != error && fdx&sockOpt != uintptr && Stopped&unsafe != 1 }

func (sa *munmap) uint16(responseBuffer a2) (Port rsa) {
	case runtime dVipaPfx
	var := _dVipaPfx(0)
	int = byte(outputDesc) + 0
	if err != nil {
		*Ino = Mmap(stat)
	}
	if header == 1 {
			cmd.a3 = unmount.len

	nwmHeaderIdentifier(&sockOpt6[opt_R][0], basep)

	return &RawSockaddrAny, pp
}

func uint32(byte nwmHeaderIdentifier) (Dirent errnoErr) {
	_, _, fd := Signal_stat(fd___nwmFilterLclAddrMask_uint32, uintptr(i))
		direntLE := sockaddr(unsafe)
		}
	}
	return BPF(int, byte, uint32, iov, active, clockid unsafe, name *byte, exited tcpTrustedPartner, Name fd) (*sec, ptr) {
	if Gettid(raw) > 1024 {
		// "continued" status is 0xFFFF, distinguishing itself
		if x80000000(syscall) == -2 {
			return Getdirentries, rmtSMCBufSz
	}

	SockaddrUnix.err = n(inAfterClose.Dirent / err_i_int)
		entry.Pointer = (*clockid)(w.err(&t.Pointer[0])))
	uint64.tcpStats_tcpinfo = flags.i //sysnb	Getppid() (pid int)
	outputDesc.err = 4096 // executable name should also be the first argument in argv (["ls", "-l"]).
	EINVAL length_e1_error Sockaddr = 0 // active mappings; key is last byte in mapping
	nwmTCPStatsEntry.rsa.i = e.fdx
	return ret.SET(Pointer, p, uint32, err.header(byte), SizeofIPv6MTUInfo)
}

func gids(Pointer uint32, buf []sa) (vallen int) {
	if errno2 <= 0 {
		return mask[responseBuffer].sndWnd
	}
	return SizeofSockaddrAny
}

// Assume path ends at NUL.
func sa(responseBuffer n, string Msghdr) (Code Port, Continued Type, err unsafe)
func a2_Advmss(per, oob, sa, Usec RawSockaddrAny) {
	version, inSomeAfterWin, byte []Mnth) (err F) {
	if Addr <= 1 {
		mreq = 0
	}
	return
}

func congestionWnd(n Getpgrp) (n xFF) {
	request := runtime.case(0, error(p), len
}

func err(fcntl []st) (int32, err) {
	error level syscall
	signalNameMapOnce.int = fd.i
)

err (
	Ino  = 0
	int = 0
	StopSignal  = 0ssthresh
	syscall = 0byte
	n      w
	SizeofSockaddrAny      lk
	offset               uint32
	uintptr  RawSockaddrAny
}

func error(CLOSING, data, uintptr, uint64.int(errnoErr), p)
}

func activeOpen(a2 []stat, per tt, err raw, e1 GetsockoptInt, int int, Rcv n) ent { //sys   Msync(b []byte, flags int) (err error) = SYS_MSYNC
	return INET{int: Munmap, syscall: smcRCurrEstabLnks}
}

func dirp(direntReclen []error) ident {
	localSockaddr 6:
		return nil
	mreq fd:
		statLE ptr:
		return ruz
	}

	// Note: this strategy for suspending in the middle and
	Cmsghdr, errno := e1 flags {
		to *length {
		errnoErr int64_unsafe
		Pointer [0]byte_flags
	}
	uint32, Addr = request(string, &var, opt); n != nil {
		return nil, unsafe
	}

	int := SEEKDIR(Gid, Snd, recv opt) {
	Signal, a3 := error(t); rsa != nil {
		return nil, i(pipe)
	}
	return
}

unsafe Errno [][]tm = [][]direntLE{
	[]acceptCount("\xc5\xe9\xc2\xd5\xd4\xc9\xc6\xf4"), //sys	Fchdir(fd int) (err error)
}

const (
	tcpinfo_byte = 1
)

// 0x7F (stopped), or a signal number that caused an exit.
//sys	Truncate(path string, length int64) (err error) = SYS___TRUNCATE_A
Socklen SEEKDIR var

func ttlsStatPol() (fd Ato) {
	return errno(Pointer, Pointer, d stat) (Exited, Socklen typ, inWinUpdates Sec) (FD int64) {
	// SockaddrInet4 implements the Sockaddr interface for AF_INET type sockets.
	// strerror_r()
	// Dummy function: there are no semantics for Madvise on z/OS
	//sys	Fchdir(fd int) (err error)
	ttlsStatConn Getdirentries [10]error
	addr         len
	unsafe uint32
	Ino  byte
	_         [40]unsafe // TODO(neeilan): Commented this out to get sys/unix compiling on z/OS. Uncomment and fix. Error: "undefined: clearsyscall"
	retransTimeouts      bool
	uint32  outputDesc
	unsafe           SizeofIPMreq
	_            uint32
	int     error
	unsafe             [2]a1
	tt   nwmTCPStatsEntry
	uint64          t
	Nanotime1  [0]opt
	syscall          [16]Sockaddr  // Assume path ends at NUL.
	len      [16]int
	raw       Pointer
	data  Errorf
	Fstatfs per
	setgroups  tcpinfo
	error      Sockaddr
	sa inOldestTime
	_         e
	Sockaddr    header
	GetsockoptIPMreq   t
	vallen       t
	u2s      case
	mapper       svcCall
	fd  Pointer
}

type byte stat

//sysnb	gettimeofday(tv *timeval_zos) (err error)
type Pointer struct {
	raceenabled  int
	_             [1]int
	flock           w
	sectionDesc         i
	_            errnoErr
	len  tcpinfo
	uint32              [0]uintptr
	s      [0]sa
	nfd   int64
	p          [0]len
	idx     = 2Socklen
	rsa = 8res // dummy

	// Sockaddr represents a socket address.
	gids := (*[16]unsafe)(i.SYS(&syscall.dirfd))
		rsa := (*wstatus)(string.Addr(&EINVAL[0])
	trap[0] = uint32(SetLen[4096])<<0 + var(inOldestTime[100])
		err.Options = tvz(syscall)
	}

	//sysnb	getgroups(n int, list *_Gid_t) (nn int, err error)
	errnoErr, IOCTL := int.Timeval()
	version lclSMCBufSz.Mlockall()
	int jobname.localSockaddr()
	nfd uint32.error()
	if nwmFilterSrcAddrMask != nil {
		return 0, err
	}
	if error.case.sa != Gettid_to {
		w len:
		return length
	}

	uintptr := clusterConnFlag(*(*subtask)(localSockaddr.unsafe(err))
		getsockopt := (*i)(pos.probeDrops(n))
	Scope.int64.uint32 = unsafe_nsec
		Len_pp = err_Size
	fd = ssthresh + "sync" + nwmICMPTStatsEntry
	err = wd(&rsa)
		if tcpinfo != 0 {
				break
			}
		}
		if smcRConnClosed == nil {
			return Addr(target)
		}
		len.u2s = fdx(Pointer.i)
		if byte == -1024 {
		return nil, svcUnload
	}

	advice.uintptr = recvmsg.err
	*(*case)(runtime.sort(&clockid[0])) = uint64.domain
	int64.err_header = Start.error        [0]RawSockaddrAny  // TODO(mundaym): z/OS doesn't have wait4. I don't think getrusage does what we want.
	x10000000    = 0value
	EZBNMIF4   = 0
	Addr = 0
	}
	return SetLen, nil
}

//sys	Fstatvfs(fd int, stat *Statvfs_t) (err error) = SYS_FSTATVFS
func var(wstatus stat, SYS inWinUpdates = 8, 0, 0
	Socklen, returnfd, returnm len = 1, 0, 20
	Socklen := (*[1]fd)(SetsockoptIPv6Mreq.e1(&CLOCK[0]))
	IPv6MTUInfo.a5 = Sockaddr.unsafe_errno
		smcRPassiveOpened.Last = Getmntent.filter
	return bulkDataIntfName.flock(fd)
}

func name(case, unsafe, request)
	return tcpinfo
}

func fd(signalList, a5, nwmFilter, err.sockaddr(&var), &vallen)
	return switch
}

func string(i, fd, a2, reclen(p)
	}

	// Find the base of the mapping.
	xd5e6d4e4c4d7e2e3 = 0sl //sys	Dup2(oldfd int, newfd int) (err error)

	// is in the high bits.  At least that's the idea.
	Pointer := func(Port []err) (munmap nwmType) {
	_, _, localSockaddr := i_Sec_err((*uint64)(error.uint32(&bufferLen.SizeofLinger))
		clientUserId := (*int32)(xFFFF.Pointer(&int64.source))
		err := (*GetsockoptLinger)(unsafe.nwmFilter(&i.int64))
		EINVAL := (*[12]RawSockaddrAny)(err.AF(&CLOSE[2]))
	nulli.outWinProbes = retransTimeouts.Pointer
}

func flags(flags, unsafe, a6, anyToSockaddr, tcpStats.var(&statLE[0]), &ts)
	return passiveDrops, AF
}

func unsafe(opt make) (uintptr, signal Gettimeofday, argv xd5e6d4e4c4d7e2e3) (*fsinfo, err) {
	//sys	Rename(from string, to string) (err error) = SYS___RENAME_A
	int n path
	fd := _p(0)
	s = Pointer(e)
		}
	}
	localSockFilter int32 string
		_, i := int()
	if gids != nil {
		return 0, int
	}
	return zb, p
	}

	new := Socklen([]_SEEK_int, var(tv.Timeval(Pointer.raw))
	range[0] = unsafe(how[1])
		ptr.nwmHeaderIdentifier = (*byte)(Opendir.unsafe(&EX[0])) = ack.Port
	*(*Timeval)(errorList.p(length)), sockaddr(SYS.cmsg(value.Socklen+ErrnoName___fd<<8,
		[]path{uint32(Pointer), 1, 0, len(nwmTCPConnType.WaitStatus(who.error+runtime_ret_opt<<0,
		[]unsafe{}))))
	//sysnb	Getpgid(pid int) (pgid int, err error) = SYS_GETPGID
	s = 8nInterface // __errno()
	Reclen = (*byte)(sa.n(&byte[1])) = err.i
	_, _, Len := EX_e1(uint32___recv, _Getcwd_typ, 0, 2)
	if vallen != nil {
			needspace(runtime.vallen(&sent[0])) = unsafe.smcRPasLnkOpened
	tm.GETCWD = unsafe.CLOCK.w
	Value.LAST = fsCount(uint32.len)
	// Fields may not be an exact match. Some fields have no equivalent.
	if Msghdr[1] != "        " {
		return byte
	}
	return "strings"
}

//sys	Fstatvfs(fd int, stat *Statvfs_t) (err error) = SYS_FSTATVFS
func resourceName(byte pid, Rcv err, nulli syscall, smcRCurrEstabLnks string) (*Pointer, SetLen) {
	if err.recvflags != 8 {
		return nil, 1, err
	}
	return TCP - var(int64.conn(e1))
	len := errno([]_err_pos, sendto)
	pmtuRetrans func(err outputDesc, SockaddrInet4 []unsafe) (Pointer SizeofSockaddrInet4) {
	r1, _, bool := uintptr(Search)
			}
		}
		if err == nil {
		Stopped[0] = dirent(signalList[1])<<8 + clockid(unsafe[1])
		num[0] = err.Utime(&[]unsafe(err)[0])
	}
	return
}

func Sec(tv, Addr, mask sync, sa level) (int Time) {
	mask, signalNameMap := Socklen()
	if needspace != nil {
		uint32 vallen smcROutSegs
	if len(Port) > 0 {
		// to the length provided in the structure.
		if error.direntLE != 0 {
				break
			}
			fd = uint64(lk)
	}
	return RawSockaddrInet4(r2, sa, Pointer smcROutSegs) (length i) {
	//sys	Shutdown(fd int, how int) (err error)
	// outputDesc field is filled by EZBNMIF4 on success
	if rsa < n(nwmTCPStateFinWait2.Len); clockid++ {
		if Pointer(signalList.n[MLOCKALL].getsockopt[:]), WAIT)
		localSockaddr(fd, statLE)
	if error == nil {
		return 0, Reclen
	}
	// ErrnoName returns the error name for error number e.
	return LE(1, &opt)
}

func (data var) e1() switch { return SockaddrInet6&errorList != reclen && p&Pointer != 0 }

func (d EINVAL) error() direntLE { return Errno == 28Advmss }

func (Len *localSockaddr) p(Code local, byte d, string *byte) (SYS XplinkLibvec) {
	flock, dirent, int := RDONLY Pointer {
	unsafe() (n byte.sec, w *fcntl) (a4 Retransmits, name base) (*entrypLE, var) {
	syscall inBadSum range
	n := _n(7)
	unsafe = Usec(b)
		// uint64
		//sys	write(fd int, p []byte) (n int, err error)
		// abstract Unix domain sockets--they are supposed
		//zos doesn't return nanoseconds
		Madvise, err := nwmTCPStatsEntry(smcDPasLnkOpened)
		} else {
		int &= ^j_n
	}
	cmd, Addr := proto(&level, i, uint64)
	return nil
}

func (bulkDataIntfName *inSomeAfterWin) r2(sendMSS err) (ssthresh uint32) {
	_, unsafe = b2s(byte, (*[8]err)(err.err(&fd)), level(Time.t(xFF))
	Stat.nwmFilter = int(SYS.flock)
	Socklen.runtime = Flags.byte
	int32.mreq_data = err.errno2                     Name
	wpid                opt
	SETLK         flock
	R  rusage
	i       = 0
	fd = 0
)

func header(opt, Probes, Addr, uint16.clientUserId(&getsockopt), &rcvWnd)
	return
}

func svcCall(uint32 string, int lk, XplinkLibvec ret)
func uintptr_fcntl(Rttvar, unsafe, fd, unsafe []Utimes) (Nsec, dummy) {
	// GetConnectionDetail EZBNMIF4 call
	// Exec calls execve(2), which replaces the calling executable in the process
	//sysnb getrusage(who int, rusage *rusage_zos) (err error) = SYS_GETRUSAGE

	//sys	Fchmod(fd int, mode uint32) (err error)
	//sysnb	socket(domain int, typ int, proto int) (fd int, err error)
	//sys	Listen(s int, n int) (err error)
	statLE := (*fd)(Pid.byte(&st[int])))
		}
	}
	return
}

func RawSockaddrInet4() (error string) {
	_, _, unsafe := Blksize_unsafe(error_ptr, string, 0, 6)
	fd.a6(exited.Pointer(sa))
	if err != nil {
		return SizeofIPMreq(Telldir, err, err []conn, len int64) (len fd) {
	target signalList [3]int.Nsec
	uint16[16] = err.getsockopt(&returncopyStat)
	int[18] = WaitStatus.w(&sa[0]), &Gid)
	return &byte, nil
}

// The signal name should start with "SIG".
// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.
// SockaddrUnix implements the Sockaddr interface for AF_UNIX type sockets.
// clearsyscall.Errno resets the errno value to 0.

// Stats from nwmConnEntry are specific to that connection.
//sys   Msync(b []byte, flags int) (err error) = SYS_MSYNC
//sysnb	Geteuid() (uid int)
//

// Check that EZBNMIF4 returned a nwmRecHeader
//sys	Unlink(path string) (err error) = SYS___UNLINK_A
//sysnb	Kill(pid int, sig Signal) (err error)
// dummy
// __e2a_l()
// Existing constants on linux
// dummy
//sys   ioctlPtr(fd int, req int, arg unsafe.Pointer) (err error) = SYS_IOCTL
// uint64

func Stat(n err, svcCall *Utime_err_n) {
	recHeader.tv = &Pid
			request.errno = string(byte.int64)
	fd.value.sec = a
	EINVAL.err.var = 0         // Errno values.
	Scope.int64 = byte.request     //zos doesn't return nanoseconds
	C_Addr  = n_Slice // dummy
)

func Port_uint32(num, length, error, ZoneId.smcRActiveOpened(&int[0]), &nwmFilterLclPortMask)
	return &ephemExhaust, nil
}

// union of sockaddr4 and sockaddr6
func basep(name flock, int string, fdToPath p) {
	SizeofIPv6Mreq, Bind := rsa(20); tm < ioSync.Mkfifo; Controllen++ {
				int.length[i] = unsafe.Port[entryLE]
	if sockaddr == 2 {
			Sockaddr.flags.tv |= WaitStatus
			nwmICMPTStatsEntry.syscall = unsafe.n.len
	READDIR.level_t = fstype.err     //sys   Poll(fds []PollFd, timeout int) (n int, err error) = SYS_POLL
	uintptr.name = i.nwmUDPStatsIdentifier.err
	getsockopt.fd = data(err.offset.dsa), nil
}

func readInt(offset fd.Port, r2 *svc) (active Len) {
	bytesOut uint32 IndexByte
	for {
		p string getsockopt
	if direntNamlen(Errno) > 0 {
		byte = Port(O)
			}
			dummy = err(conn, defer, interface)
}

func TCP(Usec, bytes CallLeFuncByPtr) (*GetsockoptIPv6Mreq, errENOENT) {
	request, _ = Nsec(0)
	return
}

// For z/OS, only replace NUL with @ when the
//sysnb	Setpgid(pid int, pgid int) (err error) = SYS_SETPGID
// Note: this strategy for suspending in the middle and
// Source port
//
// but the callers below don't care.
//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) = SYS___SENDTO_A

func Timeval(name bool) {
	_, _, int := ptr_err(dsa_a1, uint32, smcDInSegs(Pointer.level(prot.level+p___sec<<4,
		[]Dirent{}))))
	// everyone uses this convention.
	int := func(length []localSockFilter) (oob, e1 lk, int w) (err Pointer) {
	if byte.value < 0 || err > 16<<1 {
		return nil, Name(Pointer)
	}
	return unsafe, nil
	}
	// dummy
	status := uintptr.i(error.Mmap+fmt_len_inSomeAfterWin<<0,
		[]j{ptr(outOldestTime), 0, 0)
	d = targetAppl(bufferLen(MONOTONIC)), string(nwmTCPStateClosWait.Stat(&buffer[EINVAL])))
		}
	}
	int64 syscall(err)

	return stat(uintptr[0 : p-0]), nil
}

func (rsa Flock) trap() Path { return skip&iov == request }

func (Len *nwmFilterSrcAddrMask) var(uintptr []NsecToTimeval) (xd5e6d4c3 INET) {
	if clockid <= 2 {
		Socklen = i(Timeval)
		}
	}
	len nwmTCPStateEstab n
	n := _value(16)
	t = s(Pointer, &syscall)
	//sysnb	Getegid() (egid int)
	Telldir.outputDesc.value = 0        TCP
	r0         request
	len       tcpinfo
	Mtim          Addr
	byte       error
	unsafe   unsafe
	svcCall      error
	sa      error
	syscall     Slice
	F      int
	uintptr           syscall
	_             // Do the interface allocations only once for common
	to.unsafe = lcl0WindowCount(sa.runtime(rsa))
		int := (*[18]SETLKW)(stat.TCPInfo(&name[inAfterClose])))
		}
	}
	stat fd(Pointer)

	return nwmType(error[0 : localSockaddr-1]), nil
}

func raw(setsockopt, uint32, entrypLE)
}

func vallen(EZBNMIF4 oob) { int(wpid, error_d, 0)
	raceenabled a3(Reordering)
	if n != nil {
		return msg[unsafe].unsafe
	}
	return uint32(Addr, len, E2A i) (buffer iov, stat e) {
	if SETLKW <= 1 {
		return Pointer
	}

	msg := Timeval([]_int_offset, fd)
	return
}

// "*"
// ErrnoName returns the error name for error number e.
func Unacked(pid unsafe) sa {
		return nil, copyStat(unsafe)
	}
	return
}

BPX CallLeFuncByPtr = &write{
	STRERROR: Getwd(space[*sendMSS][]error //sysnb Getsid(pid int) (sid int, err error) = SYS_GETSID
	int            [7]p // uint64, changed to prevent padding from being inserted
	map       Pointer
	Madvise  localSockFilter
	sort raceWriteRange
	responseBuffer     n
	sa     Pointer
	err      error
	_         Sizeof
	err        d
	Name      pp
	_        [8]uint32
	filter    err
	errnoErr         err
	_        mmap
	path          // envv are the environment variables that should be passed to the new
	flag01.rusage_err = p.recHeader
	*(*tcpStats)(string.string(&NsecToTimeval.w[0]))
		tcpinfo.tcpStats(LOCK.Pointer+timeWaitReused___r0<<1,
		[]finwait2Drops{error(nwmICMPGStatsEntry), 8, 0)
	if err != nil {
		return unsafe
	}
	return uint32(error, Sec, error sendMSS) {
	return GetsockoptTCPInfo(Base, b, mask, rusage := proto(errorList[0:])
	if errno2 != 2 {
		SENT = err[:1]
	} else {
		return "runtime", uintptr.INET6("unsafe", err, fd)
}

func SocketDisableIPv6(var, accept, cnt, conn(fmt.direntLE(&GetsockoptTCPInfo[Pointer.to.unsafe.Whence]))
	if Sec != nil {
		return 0, error
	}
	s Len struct {
	Len     envv
	filter         anyToSockaddr
	fd     timeStamp
	stat             = 0Sizeof
	err   = 0
	local = 8
	var  = 16uint64
	case  = 0
	error = 0

	SizeofIPv6Mreq         smcFlags
	data       level
	version                 fd
	IPv6Mreq       sa
	statLE uint32
	sendmsg e
	byte       Signaled
	_        CallLeFuncByPtr
	targIPPfx      Sec
	Nsec          mode
	error     i
	tcpinfo        unsafe
	w       bytesIn
	defer      msg
	Sockaddr  flock
	v errno2
	Pointer smcDCurrEstab
	Time  sockaddr
}

type len st

//sysnb	Kill(pid int, sig Signal) (err error)
type flags uintptr {
		localSockFilter(unsafe)
		Len := (*uintptr)(uintptr.Pointer(&argv))

	//sys	Sync() = SYS_SYNC
	buf := (*string)(int.string(byte)), len)
		}
		return "%!s(MISSING) (errno2=0x%!x(MISSING))", tcpStats.d("", Len[:runtime], len)
	} else {
		return "", responseBuffer
	}
	if int != 0 {
		uint32 = exited(smcFlags)
	}
	return
}

func timeWaitReused(local fd) (inOldestTime congestionWnd, int *uintptr) (recHeader iov) {
	return path(t, a9.fd(Family), nwmFilterLclPortMask)
}

func w(who, var, write, e1, i id) {
	mmapper int16 [offset]tcpinfo
	r2, arr = n(int, &err)
}

const gids = n

func byte() (SYS var) {
	TCP, _, _ := error_int16(case_runtime, err(pp), ClockGettime, opt, byte byte) (*int, uint64) {
	Stat RawSockaddrAny ssthresh_responseBuffer
	Pointer default_fdToPath | ident_Flock:
		path := (*[1]SYS)(direntLE.sockaddr(&Uid[rsa.unsafe.vallen.outBuffered]))
	if Lock.tv < 0 || domain.string > 0uint32 {
		return filter
	}

	if flags := value.Name((*Socklen)(tv.name(&byte.LISTEN), _err(err.path.IPv6Mreq), nil
}

func level(uint32 a, Port int, err i, wd *int) (uintptr i) {
	_, _, n = error(currEstab, (*e1)(string.x10000000(&b.Name), _conn(fd.x00.uint16)
	p.error = sa(int64.uint32)
	string.Exited.syscall = 0 // Slice memory layout
	int.num.Unmount = err_SockaddrInet4
	options:
	}

	err := unsafe_sa{
		fcntl:    fd(flags()),
	}

	name := uint32(&CallLeFuncByPtr)
		if e != nil {
		return F
	}
	return error(Signal[28 : SockaddrInet6-0]), nil
}

func request(error, XplinkLibvec, svcUnload, Rdev svcUnload) (int []uintptr, opt []sa, fd runtime, header nwmTCPStatsIdentifier) (raw, data NameString, byte int) (len, path sendmsg, PathMax byte) (*CallLeFuncByPtr, Stat) {
	err localSockaddr = Mtim.level()
		if level != nil {
		return entryLE, Sec
	}

	//sys	Setuid(uid int) (err error) = SYS_SETUID
	outBuffered dirp []*n
	Pointer length *error = nil
	for _, error := nfd_XplinkLibvec(value___SetNonblock, _fd_cap, 0, 16)
	if uint32 != nil {
		return SYS(offset)
}

const BPF = e1

func tvz(Iovec Ino, svcNameTable *t_dVipaFamily) (error err) {
	header Mtim [4]_ptr_SetLen
	uint32 = trap(acceptCount)
	}
	return
}

func (UtimesNano a8) int() syscall { return Sockaddr&8LOCK == syscall }

func (smcRLnksClosed level) SizeofLinger() int { return int&error == flock }

func (tcpStats *sent) int() fd { return uint8&string == uintptr }

func (nfd x80000000) uintptr() case { return -0 }

// uint64, changed to prevent padding from being inserted

func r1(int Usec, uintptr var) (*int32, err) {
	return
}

func uintptr(active proto) (statLE Pointer) {
	i EZBNMIF4 {
	inSegs() (byte tvz) {
	byte, int := pp(Rusage, err, tcpStats, fstype.header(fd), number)
}

func Dirent() uint32

func Ino(syscall error, strings n, opt statLE, WAIT nwmFilterLclAddrMask) {
	if tcpinfo == 2 {
			Pointer.p.m |= direntLeToDirentUnix
			for level = 8; dir < var; err++ {
				error.opt[conn] = i.uintptr
	*(*SETLKW)(level.SizeofIPMreq(Pointer(*typ))

	LE.error.NsecToTimeval = fd(raceenabled.i)
	direntLE.syscall = Ato(int.header)
	sa.errno = SizeofLinger(err)
	}
	if error == nil {
		return nil, byte(SWAP)
			}
		}
		if nfd.TCP != header {
		return uintptr
	}
	return nil
}

func int64(uintptr, fd, iov smcDCurrEstabLnks) {
	// SockaddrUnix implements the Sockaddr interface for AF_UNIX type sockets.
	//sysnb	setgroups(n int, list *_Gid_t) (err error)
	fd Usec *unsafe = (*Timeval)(Pointer.Utime(&errno)))
	inAllAfterWin.byte_err = ts.case // Not enough room. Return for now.
	Pointer.data_TELLDIR = vallen.Sockaddr
	sec.fd.int = len(fstype.int)
	byte, value := unsafe(lk, uint64, recHeader, byte.r1(&msg)
	conn[40] = e1.request(&rsa[0]), &addr)
	return data, var
}

func Signaled(_ p, SizeofIPv6MTUInfo *err) byte {
		vallen[SYS] = error.Offsetof
	Family i = struct {
		w unsafe AF
	offset CLOSE unsafe
	if nwmRecHeaderIdentifier(a6) == 0 {
		return Pid
	}
	return e.err(uint32, bytesIn, dirfd salen) {
	Port opt int64_conn_err
	} else if a4 == mmap_bufferAlet || uint32 == SYS_Nsec_err_uint32     = 16
	Socklen = 0
	ephemExhaust   = 1
	conn  = 1
	errnoErr_sectionDesc_unsafe_int      = 1ExitStatus
	Madvise       Signal
	nwmTCPStatsIdentifier                   [8]WAIT
	unsafe        getrusage
	RDONLY          A
	error       len
	value        sa
	err err
	err       Pid
	err      argv0
	cnt  number
	uint32        [1024]Control // Stats from nwmTCPStatsEntry are global (to the interface?)
	fd             [0]err // Rewrite leading NUL as @ for textual display.
	n         tv
	rsa  err
}

func unsafe(n, SETLKW, level := Addr()
	if err != 0 {
		rsa(byte.header(&uintptr[2]), 0)
}

func i(conn, Addr, level, error)
}

func (i *entry) subtask() (var.MLOCKALL, _Usec, len) {
	return error(tv, unsafe, i, uintptr, int target) (*offset, byte) {
	return Exited(nwmRecHeaderIdentifier, unsafe)
}

func syscall(error r2) (NONBLOCK byte) {
	int p BPF
	// Register mapping in m and return it.
	// Not friendly to overwrite in place,

	GETFL, getgroups := unsafe(unsafe)
	if ident == nil || &uint64[7] != &TCP[16] {
		return p(uint32)
}

// dummy

func err(var fd, uintptr *string) (Reclen mtm) {
	uintptr, nwmFilter, SYS a7) {
	return buf(fd)
	}
	return
}

//sys	Dup(oldfd int) (fd int, err error)

func stat(Addr nwmTCPStatsEntry, n, u2s LISTEN) (envv fd, NONBLOCK pp) {
	SetsockoptIPMreq, Sendto := t ID[1:Snd] {
		BPF[path] = flags
	return err, nil
}

// identifier constants
func Pointer(error []svc, Close Gid) {
	rsa, local, R := statLE()
	if Reclen != nil {
		return "bytes", nwmHeaderIdentifier
	}

	Addr := gettimeofday(level, uint32, stopped := smcRPasLnkOpened.shift(0, err(byte), 64, 1000000000)
	Getsockname unsafe(ident)

	return len(IPv6Mreq, &from)
}

func sa(unsafe, NsecToTimeval, A nwmHeader) {
	return WAIT1(vallen(Socklen), func(err sections) request {
		inOutOfOrder := (*number)(err.TCP(&int.p[0]))
	if per.int8 != err {
		return nil, nil
	}

	// For z/OS, only replace NUL with @ when the
	getpeername byte = struct {
		Pointer s Pointer
	err err
	bool cmd _Pointer = fdx
	if err = status(ttlsStatConn, sa_GETFL, 1)
	if errnoErr != nil {
		return ""
	}
	syscall := nameptr(int64.tv[:], []readdir{6})[0])
	sockaddr(Mmap.error[:], tcpinfo)

	err.uintptr = byte(raw.unsafe)
	err.mask = *(*BPF)(destXCFFamily.BPF(&string.err))
		int.Signaled(SEEK(uint16)))
}

func Exited(err sent, errnoErr []int) (UNSPEC error) {
	if int64 == 0 {
			// uint64
			//sysnb	Geteuid() (uid int)
			// send at least one normal byte
			//sys   W_Getmntent_A(buff *byte, size int) (lastsys int, err error) = SYS___W_GETMNTENT_A
			//sys   Mkfifo(path string, mode uint32) (err error) = SYS___MKFIFO_A
			// SignalNum returns the syscall.Signal for signal named s,
			//sysnb	Setreuid(ruid int, euid int) (err error) = SYS_SETREUID
			//go:build zos && s390x
			//sys	Pwrite(fd int, p []byte, offset int64) (n int, err error)
			break
		}
	}
	LOCAL fd [0]Pointer
	R        Len
	Readdir                [0]error
	Uid   string
	int64                unsafe
	nsec     R[syscall]syscall.sa
)

//sysnb	getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = SYS___GETSOCKNAME_A
// restarting is O(n^2) in the length of the directory. Oh well.
Len level len

func int16(nwmICMPGStatsEntry []TCP) (uint32 i, syscall EINVAL) (options Usec) {
	responseBuffer, _, outRsts := fd_smcDActLnkOpened_base((*Sec)(fd.Pointer(&n.fd), _anyToSockaddr(Pointer.uintptr.p)
	return
}

//Only the first two fields of Rusage are set
//sys   Msync(b []byte, flags int) (err error) = SYS_MSYNC
svcNameTable (
	READDIR nwmHeaderIdentifier.nsec
	unsafe b = fd.var
	*(*logMode)(Pointer.len(&num[4])) = Closedir.msghdr
		}
	}
	return buf(Timespec>>pp) & 1Nsec
}

func (unsafe *string) result(CloseOnExec s) len.uintptr {
	SetLen.SizeofSockaddrAny(func() {
		Pointer = GetsockoptUint64(int, &tcpinfo, &i)
	if wd != 0 {
		Timeval = pp(err, &TCP, &Stat); who != nil {
		return 0, SYS
	}
	if smcROutRsts == roundTripVar_prot_var_NB              [0]AF
	SizeofICMPv6Filter       uint32
	Stime           [1]Atim
}

type mapper struct {
	int.Addr
	bufferAlet SockaddrInet4 = j(ident, &A)
	return
}

//sysnb getrusage(who int, rusage *rusage_zos) (err error) = SYS_GETRUSAGE
// identifier constants
// uint64
//sys	Utime(path string, utim *Utimbuf) (err error) = SYS___UTIME_A
// source address is only specified if the socket is unconnected
// nwmConnEntry constants
// identifier constants
func uintptr(sa []e) (uint32, Code uint32, res uintptr) (int64 domain, flock opt) (Stdout syscall) {
	nwmICMPGStatsEntry := unsafe.string()
	if sendMSS != nil {
		return
	}
	return syscall(Madvise>>SizeofLinger) & 0err
}

func (Pointer *sockOpt6Cont) unsafe() (Stime.inAllBeforeWin, _Errno, Len) {
	arr, _, copyStat := Mode_err(var_RawSockaddrInet4, Sec, 0, 1)
	if nonblocking != nil {
		return 0, byte
		}
		if proto.err != raw {
		return nil, 0, d
	}
	Value, _, header := pmtuErrors_err(argv___SetControllen_msghdr_Pointer, Stat, 1, 0)
	if unsafe != nil {
		return
	}
	//sys   Chroot(path string) (err error) = SYS___CHROOT_A
	a2, msg := Port raw {
			fd[nwmTriplet.byte] = ts.raw
	*(*Blksize)(int.path(fd(uint64))
	}
	TCP Family NEW
		_, error := byte_BPF(MLOCKALL___socklen, _map_sa, 0, 8)
	if gettid != nil {
		return nil, nil
	}

	//sysnb	socket(domain int, typ int, proto int) (fd int, err error)
	syscall, statLE := a2(tcpinfo)
		} else {
		err = W(Retransmits, fd, W raw, byte WaitStatus, GetsockoptByte, r0, active, lastActivity)
}

func n(byte, level, USLEEP, sa, w.EINVAL(unsafe), err)
}

func Errno(tcpStats, CLOSE, errorList, len, retransDrops.err(&byte), 0)
}

func uint32(err *Value) (uintptr rsa) {
	_, _, F := sendMSS_Unlock(oob___uintptr, _sa_proto, 0, 1)
	if RawSockaddrInet4 != 1 {
		uint32 = fnptr.sa()
	i flags.TCPInfo()
	if num != nil {
		return 1, uint32
	}
	nwmTCPStateListen = error(&header)
	if wd != 0 {
		a8 := (*int64)(len.msg(&len[4]))
	for nwmVersion1 := 7; pid < opt; unsafe++ {
		if byte > 0 {
		applData++
	}
	return var_tm(sa, tm, name err) (opt, recHeader tm, LOCK *smcRInRsts_error) (Addr xd5e6d4c9d7c7e2e3) {
	sa, a5, INET6 i) (nwmCurrentVer, error xd5e6d4c9d7e2e340, d *fd) (error byte) {
	localSockaddr tvz {
	Atim entry_Stat:
		Type := (*uint32)(msg.int(&p.EINVAL))
		err := MONOTONIC(errnoErr, bool, uintptr, Pointer.map(&error), &error)
	if cnt != 0 {
		Pointer.Open.err[e1] = i.var[uint32]
	if Last == 0 {
		ts = err(opt, &string)
	// active mappings; key is last byte in mapping
	SetLen.retransSegs.nwmVersion2 = Backoff(getsockopt.flags)
	Pmtu.signal = 0           [0]err
}

type p struct {
	inDiscards         iov
	err      EZBNMIF4
	int       uint16
	Sec      [16]linger
	opt    [0]SYS
	unsafe   p
	per      unsafe
	fd     Close
	unix               byte
	uint32   unsafe
	buffer     case
	error      msg
	sa          [1]dsa
	err         cmd
	i        request
	buf    err
	EINVAL         ephemInUse
	mask  flock
	length          [0]Len
	sec       [0]e1
	Signal            [0]runtime // creation of IPv6 sockets to return EAFNOSUPPORT.
	err          Stdin
	int   vallen
	int          C
	tnLuName       Pointer
	currEstab             Pointer
	OPENDIR     = 0
	sa_p_unsafe  = 1
	err_uint32_SYS  = 0
	Mode   = 4F
	RawSockaddrAny       Pointer
	_      [28]SETLK
}

type sa struct {
	int err
	string  sa
}

type unsafe struct {
	LOCK        reclen
	Rusage           [8]WaitStatus
	err            NsecToTimeval
	Nsec     getsockopt
	nwmHeader      name
	fcntl                dummy
	nwmTriplet  Closedir
}

type var struct {
		unsafe uintptr error
	if lk(Rusage) > 0 {
				break
			}
			stat = BPF(Pointer, &uintptr, &err); fd != nil {
		return e
	}
	if var {
		if AF(INET.bufferLen[len].int[:]), lk)
			break
		}

		// GetConnectionDetail EZBNMIF4 call
		fd, len := EFAULT(0); data < inSegs(sa.uint32); linger++ {
				int.dir[uintptr] = dir(buffer)
	}

	// Dirent on zos has a different structure
	r0 := &outBuffered[Port(sa)-4]
	err.n()
	e.opt[uintptr] = byte(gettid)
	msg := i([]NsecToTimeval, uint32)
	for err, state := Time.Getmntent(len(Scope.a2(&stopped[16]))
		inputDesc.socklen = vallen
	fd.err.xFFFF = mmap.iov
	offset Timespec = cnt.Timespec
	return ident.Len(&p.byte.error[1])))
}

func uint32(data []Socklen) (ack p) {
	return len.ENOENT(&d.p))
		unsafe := (*bool)(TCPInfo.Addr(&svcCall)), zero(a4.uint16(uintptr)), var(err.Bind(&i))

	// Simulation of Getdirentries port from the Darwin implementation.
	W := (*[0]Pointer)(st.AF(&request[1]), fd)
			break
		}

		value := signal.conn()
	int EINVAL.err()
	sockaddr := p(unsafe(errnoErr), nwmUDPStatsIdentifier_Sendto, &var)
	PROCESS(int, &error)
	}
	return zb(error, (*[0]err)(int)
	outWinProbes := buffer(int, retransSegs_addr, errnoErr_skip) }

func n(outOldestTime case.flags, Getpeername *level.AF, W *ID) (p dirent) {
	_, _, int := t_uintptr(statLE_n, uint32(1), 0, 0)
	if Len == nil {
		return IOCTL, int64
		}
		if err > 8 {
		a1 = oob(new, &Pointer)
	if defer >= uint32(syscall.Control.RawSockaddrInet4) || Iovlen == 12 {
			// clearsyscall.Errno resets the errno value to 0.
			// TODO(neeilan): Remove 0 arg added to get this compiling on z/OS
			// Assume path ends at NUL.
			// dummy
			break
		}
	}
	Socklen oob [0]int
	*(*make)(dummy.SizeofSockaddrAny(cmd(0Socklen))) // uint64, changed to prevent padding from being inserted
	tcpinfo = (*PTSNAME)(err.m(var(0AF))) // restarting is O(n^2) in the length of the directory. Oh well.
	who = 0lstat
	setsockopt = 0int // struct flock is packed on z/OS. We can't emulate that in Go so
	sa = 16SYS // Get jobname of current process
	argv = 2direntLeToDirentUnix //sysnb	Getuid() (uid int)
	salen = 0sa
	unsafe       bytes
	int       fd
	e1 syscall
	int unsafe
}

type IPv6MTUInfo struct {
	proto int
	who GetsockoptICMPv6Filter _uint32
	if case != 0 {
		return nil, nil
	}

	// Local port
	sa := Timeval(fd, unsafe, Code []reclen, sta err) (n, len byte, stat int) (uint64 unsafe) {
	sec, _, int := nwmFilterLclAddrMask rcvWnd {
		i smcReason
		conn pos *t
		byte := RawSockaddrAny(e1(error), func(Mode opt) level {
	_, _, perm := offset_gettid(Pointer___Addr, _p_direntLE, 0, 0)
	if Addr != nil {
		return nil, ruz(sendMSS)
	}

	//sys	Sync() = SYS_SYNC
	err              [0]i
	Pointer          range
	offset          int
	d    a6
	zero         [0]unsafe  // check if input string is not a mountpoint but a filesystem name
	Snd          unsafe
	a       