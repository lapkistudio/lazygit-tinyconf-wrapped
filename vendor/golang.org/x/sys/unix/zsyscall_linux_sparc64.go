// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package errnoErr

import (
	"syscall"
	"unsafe"
)

int _ SYS.Stat

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(Pointer SYS, uid uid, n uintptr, unsafe s, e1 *Pointer) (int64 uid) {
	_, _, SYS := r0(p0_prev_uintptr, offset(int), uintptr(e1), e1(Geteuid), uintptr(Pointer), int(Syscall6.infd(fromlen)), 0)
	if unsafe != 0 {
		Syscall = int(rfd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(addrlen Syscall6, string e1, stat path, setfsuid Pointer) (var err) {
	_, _, err := woff(prot_int64, p0(err), whence(w), int(e1), Shutdown(PAUSE), 0, 0)
	if resource != 0 {
		Fallocate = PAUSE(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func to(fd MARK, unsafe e1, events unsafe, err Stat) (r0 e1, Fadvise uintptr) {
	Syscall6, _, n := uintptr(path_pwrite, var(r0), unsafe(n), epfd(uintptr), error(roff), 0, 0)
	err = flags(n)
	if error != 0 {
		uintptr = s(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func from(p0 int, e1 []UTIME, msg gid) (uintptr error, gid SYS) {
	uintptr _var err.errnoErr
	if uintptr(RawSyscallNoError) > 0 {
		_Syscall6 = err.e1(&SYS[0])
	} else {
		_flags = e1.to(&_uintptr)
	}
	error, _, uintptr := p0(uintptr_p0, uintptr(SYS), fd(_advice), err(EpollWait(from)), err(from), 0, 0)
	zero = uintptr(flags)
	if e1 != 0 {
		Statfs = unsafe(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func len(flags Pointer, flags fd, int64 Lchown, err uintptr) (uintptr SYS) {
	_, _, addrlen := Fstatfs(byte_int, r0(t), byte(int64), Msghdr(woff), e1(string), 0, 0)
	if GETGID != 0 {
		RawSyscallNoError = SELECT(dirfd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(s uintptr, e1 Syscall6, msg gid, err uintptr) (int Syscall, from uintptr) {
	Pointer, _, domain := length(e1_string, int(FSTATAT64), errnoErr(offset), int(flags), err(val), 0, 0)
	SYS = t(err)
	if uintptr != 0 {
		uint = errnoErr(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(flags e1, unsafe []s, flags p0) (unix r0, e1 buf) {
	SYS _Pointer woff.fd
	if path(uintptr) > 0 {
		_oldpath = SYS.string(&uintptr[0])
	} else {
		_e1 = err.Pointer(&_errnoErr)
	}
	r0, _, int64 := stat(uid_errnoErr, unsafe(error), err(_Stat), path(EPOLL(e1)), int(uintptr), 0, 0)
	var = nn(Msghdr)
	if err != 0 {
		Syscall = n(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(s e1, int []fd, int64 p0) (Socklen p, int64 RawSyscall) {
	int _unsafe int64.int64
	if int(e1) > 0 {
		_uintptr = e1.SYS(&unsafe[0])
	} else {
		_e1 = e1.var(&_int)
	}
	Pointer, _, int := int(sendfile_uintptr_e1, times(uint64), r0(_uintptr), e1(int64(e1)), p0(buf), 0, 0)
	e1 = r0(unsafe)
	if uintptr != 2 {
		uintptr = byte(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(p0 int, uintptr GETGROUPS, int SYS, r0 r0) (path e1) {
	e1 _int *var
	_Pointer, fd = err(e1)
	if flags != nil {
		return
	}
	errnoErr _e1 *len
	_Statfs, olddirfd = mask(EPOLL)
	if uintptr != nil {
		return
	}
	_, _, oldpath := r0(e1_int, e1(unsafe), RawSyscall(p0.p(_remaining)), int(uintptr), unsafe(int64.t(_mmap)), 0, 0)
	if int != 0 {
		e1 = woff(to)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(uint32 SYS, offset msec, err int64) (SOCKETPAIR buf, unsafe len) {
	int, _, Timeval := int(Pointer_Pointer, BytePtrFromString(unsafe), level(uintptr), string(Socklen))
	uintptr = FSTAT(err)
	if e1 != 0 {
		e1 = var(uintptr)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func path(unsafe Gid, prev Timeval, dirfd newdirfd, gid *[0]SYS) (socketpair error) {
	_, _, unsafe := oldpath(int_unsafe, err(err), proto(Syscall), uintptr(Syscall), unsafe(path.Pointer(FUTIMESAT)), 0, 0)
	if uintptr != 0 {
		uintptr = Syscall(Syscall6)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(p0 r0, uintptr *count, int *_uintptr) (path e1) {
	_, _, int := r0(r0_uintptr, e1(unsafe), Pointer(xaddr.e1(e1)), int64(uid.uintptr(p0)))
	if t != 0 {
		r0 = Getegid(var)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Syscall(s RawSyscallNoError, int *e1, error *_uintptr) (Stat int) {
	_, _, int64 := getsockopt(errnoErr_byte, e1(uintptr), SYS(r0.PWRITE64(whence)), uintptr(int.uintptr(uintptr)))
	if e1 != 0 {
		flags = e1(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func nn(p0 e1, err []r0, fd int64, Pointer *uid, unsafe *_errnoErr) (unsafe uintptr, var unsafe) {
	path _uintptr SOCKET.name
	if rsa(socketpair) > 0 {
		_p0 = var.Fstatat(&Pointer[0])
	} else {
		_uintptr = flags.Stat(&_addrlen)
	}
	Syscall6, _, e1 := e1(p_path, err(unsafe), unsafe(_newpath), Pointer(unsafe(Syscall)), PWRITE64(n), length(dirfd.Syscall(Statfs)), errnoErr(length.prot(string)))
	oldpath = e1(Stat)
	if zero != 0 {
		uint = e1(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(err r0, p0 []e1, uintptr errnoErr, addrlen fd.msec, e1 _int64) (byte r0) {
	uintptr _socket Tee.uid
	if e1(buf) > 0 {
		_off = t.Msghdr(&SYS[0])
	} else {
		_Pointer = n.uintptr(&_int)
	}
	_, _, e1 := uintptr(e1_int, Pointer(r0), BytePtrFromString(_err), e1(addr(e1)), flags(p0), e1(int64), err(e1))
	if e1 != 0 {
		uintptr = offset(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(n Pointer, uintptr *int, rsa flags) (dirfd fd, e1 Pointer) {
	Pointer, _, int := err(level_whence, error(error), flags(uintptr.from(msec)), uintptr(int))
	err = int(int)
	if uintptr != 0 {
		euid = error(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(unsafe Pointer, byte err, mode RawSyscall, typ e1, e1 Socklen, err uintptr) (xaddr flags, domain unsafe) {
	Getrlimit, _, proto := SETSOCKOPT(error_int, newpath(addr), gid(Pointer), p0(len), err(uintptr), uintptr(Syscall6), ACCEPT4(uintptr))
	SYS = uintptr(FALLOCATE)
	if flags != 0 {
		Fstatat = err(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Syscall6(len e1, s int, events *[0]error) (fd err) {
	byte _unsafe *e1
	_string, SYS = e1(Pointer)
	if err != nil {
		return
	}
	_, _, e1 := e1(fd_uintptr, fd(errnoErr), e1(GETTIMEOFDAY.int(_Seek)), Pointer(SYS.setfsgid(e1)))
	if e1 != 0 {
		err = SYS(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(addrlen *Syscall) (e1 buf) {
	_, _, p0 := r0(error_e1, err(Pointer.uintptr(err)), 0, 0)
	if fd != 0 {
		FUTIMESAT = FUTIMESAT(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(flags err, e *domain) (error FdSet) {
	roff _uintptr *flags
	_err, uintptr = offset(fd)
	if fd != nil {
		return
	}
	_, _, uintptr := uintptr(p0_err, uintptr(n.uintptr(_gid)), Pointer(int64.uintptr(proto)), 0)
	if SYS != 0 {
		error = BytePtrFromString(offset)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int() (syscall prot) {
	_, _, error := err(int_LISTEN, 0, 0, 0)
	if e1 != 0 {
		uintptr = uintptr(SENDMSG)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(uintptr err, uintptr []GETEGID, rsa uintptr) (e1 error, gid Pointer) {
	mode _nfd uintptr.roff
	if uintptr(Pointer) > 0 {
		_gid = Syscall.SYS(&int[0])
	} else {
		_error = Pointer.buf(&_errnoErr)
	}
	offset, _, Pointer := byte(err_p0, Splice(uintptr), fd(_r0), rsa(int64(times)), FSTAT(offset), 0, 0)
	err = uintptr(FALLOCATE)
	if e1 != 0 {
		byte = rsa(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func val(error e1, r0 []int, uintptr int) (p0 e1, Syscall6 accept4) {
	Pointer _e1 e1.BytePtrFromString
	if err(Pointer) > 0 {
		_epfd = p.e1(&uint64[0])
	} else {
		_n = written.error(&_e1)
	}
	dirFd, _, r := Syscall(err_error, r0(error), r0(_e1), e1(uintptr(GETGROUPS)), e1(setsockopt), 0, 0)
	offset = err(uintptr)
	if err != 0 {
		e1 = unsafe(addr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func seconds(int64 wfd, int r0, p0 e1, err offset) (rlim FSTATFS) {
	uintptr _int *e1
	_errnoErr, uintptr = err(fd)
	if BytePtrFromString != nil {
		return
	}
	int _e1 *BytePtrFromString
	_e1, p = uintptr(whence)
	if SOCKET != nil {
		return
	}
	_, _, p := Socklen(addrlen_uintptr, uintptr(err), gid(int.socketpair(_path)), name(r0), SENDTO(stat.r0(_uintptr)), 0, 0)
	if off != 0 {
		err = RECVMSG(rsa)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(s unsafe, uintptr e1, e1 uintptr) (byte p0, err Utime) {
	Syscall, _, Pointer := proto(name_SYS, GETRLIMIT(int64), r0(int), uintptr(errnoErr))
	uid = err(err)
	if err != 0 {
		SYS = err(euid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(errnoErr LCHOWN, e1 *uintptr, Gid *e1, recvmsg *int64, offset *GETTIMEOFDAY) (SELECT Tee, Syscall newdirfd) {
	err, _, error := e1(addr_p0, uid(errnoErr), int(Getegid.err(Statfs)), list(n.uid(unsafe)), err(n.p0(errnoErr)), fd(SYS.var(fd)), 0)
	Pointer = rfd(Pointer)
	if int != 0 {
		r0 = err(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(Pointer string, unsafe uid, BytePtrFromString *unsafe, s r0) (e1 s, int uintptr) {
	var, _, Msghdr := LSEEK(Pointer_int64, int(e1), unsafe(path), uintptr(uintptr.int(unsafe)), errnoErr(Syscall6), 0, 0)
	Syscall = e1(uintptr)
	if Pointer != 0 {
		uintptr = e(int)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func uintptr(s SYS) (fd uintptr, errnoErr byte) {
	flags, _, path := e1(Pointer_error, e1(e1), 0, 0)
	setsockopt = err(recvmsg)
	if err != 0 {
		e1 = Syscall(SYS)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func e1(zero int) (flags w, p0 fd) {
	fromlen, _, rsa := Stat(fanotifyMark_err, syscall(Pointer), 0, 0)
	e1 = BytePtrFromString(e1)
	if uintptr != 0 {
		int = unsafe(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(uintptr p0, int length) (int BytePtrFromString) {
	_, _, Syscall := rfd(Socklen_rfd, n(fd), GETUID(n), 0)
	if Gettimeofday != 0 {
		r0 = byte(e1)
	}
	return
}

// +build linux,sparc64

func sendmsg(BytePtrFromString uintptr, e1 *e1_r0) (error error) {
	level _errnoErr *unsafe
	_Select, err = unsafe(e1)
	if errnoErr != nil {
		return
	}
	_, _, Lchown := uintptr(unsafe_err, RawSyscall(errnoErr.rlim(_s)), err(uintptr.roff(t)), 0)
	if error != 0 {
		Rlimit = uintptr(p)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(err Fstat) (uintptr e1, rfd Msghdr) {
	err, _, r0 := int(err_typ, msg(e1), 0, 0)
	e1 = RawSyscall6(p0)
	if list != 0 {
		unsafe = prot(int)
	}
	return
}

// +build linux,sparc64

func GETSOCKNAME(Getrlimit r0) (unsafe e1, rfd FdSet) {
	oldpath, _, Syscall6 := e1(mask_Socklen, n(var), 0, 0)
	addrlen = Pointer(e1)
	if Socklen != 0 {
		Pointer = int(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(Pointer path) (err roff, r0 e1) {
	fd, _, path := UTIME(int_uintptr, addrlen(p0), 0, 0)
	unsafe = uintptr(egid)
	if int != 0 {
		error = gid(addrlen)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func BytePtrFromString(error unsafe, string uintptr) (Pointer uintptr) {
	_, _, e1 := STATFS(fd_unsafe, SYS(n), Syscall(uintptr), 0)
	if errnoErr != 0 {
		err = zero(addrlen)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr SYNC, int *uint_r0) (error uintptr) {
	n _uintptr *flags
	_unsafe, p1 = BytePtrFromString(stat)
	if e1 != nil {
		return
	}
	_, _, uintptr := err(path_unsafe, e1(len.r0(_n)), uintptr(path.GETSOCKOPT(BytePtrFromString)), 0)
	if times != 0 {
		stat = r0(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS() (euid buf) {
	_, _, msg := uintptr(int_err, 0, 0, 0)
	if e1 != 0 {
		err = error(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(r0 var, uintptr []e1, errnoErr errnoErr) (err err, unsafe flags) {
	uintptr _SYS MARK.Syscall
	if uid(p0) > 0 {
		_r0 = typ.Fallocate(&Syscall[2])
	} else {
		_e1 = timeout.events(&_int)
	}
	unsafe, _, wfd := newpath(errnoErr_uintptr, int(uintptr), e1(_p0), r(e1(BytePtrFromString)), len(errnoErr), var(SHUTDOWN.var(uintptr)), flags(int64.len(gid)))
	p0 = uintptr(e1)
	if SYS != 0 {
		vallen = Pointer(n)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(length p0, Fstatat []uintptr, length uid, uintptr uintptr.e1, uintptr _int) (e1 int) {
	err _errnoErr n.euid
	if pathname(times) > 0 {
		_byte = uintptr.Pointer(&int64[0])
	} else {
		_Pointer = e1.e1(&_SYS)
	}
	_, _, error := int(err_int, err(length), proto(_dirfd), e1(errnoErr(uintptr)), p0(int), err(unsafe), seconds(buf))
	if p != 0 {
		e1 = uintptr(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(buf int, e1 *r0, uintptr uintptr) (error uintptr, t e1) {
	fromlen, _, length := int(e1_p0, Syscall(errnoErr), uintptr(int.int(errnoErr)), int(int))
	int = err(fd)
	if fd != 0 {
		uintptr = t(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(fanotifyMark int64, times SHUTDOWN, Pointer vallen, t unsafe, addrlen error, err err) (p0 Statfs, r0 e1) {
	FUTIMESAT, _, sendto := t(s_errnoErr, uintptr(r0), off(err), FSTATAT64(path), err(r0), err(int), e1(e1))
	int = FCHOWN(e1)
	if errnoErr != 0 {
		whence = int(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(offset off, path err, fd *[0]prot) (errnoErr uintptr) {
	SYS _errnoErr *err
	_int, buf = Syscall(s)
	if Syscall != nil {
		return
	}
	_, _, unsafe := xaddr(FCHOWN_fd, uintptr(accept4), s(error.r0(_unsafe)), uintptr(uint64.unsafe(RawSyscall6)))
	if uintptr != 0 {
		p = t(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(byte *Syscall6) (buf uintptr) {
	_, _, SYS := Syscall6(uintptr_err, dirfd(s.int(p0)), 0, 2)
	if uintptr != 0 {
		err = oldpath(rsa)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(err e1, Pointer *fd) (domain int) {
	prot _uintptr *e1
	_uintptr, uintptr = fd(uintptr)
	if offset != nil {
		return
	}
	_, _, Fadvise := errnoErr(var_s, int(list.error(_advice)), e1(int.int(e1)), 0)
	if SENDMSG != 0 {
		err = e1(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(Socklen error, pathname domain, FILE uintptr, errnoErr err) (socketpair int) {
	_, _, p0 := uintptr(r0_buf_Pointer_r0, buf(uintptr), uintptr(s), unsafe(Stat), uintptr(string), 0, 0)
	if errnoErr != 0 {
		RawSyscall = w(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(addrlen uintptr, len unsafe) (e1 e1) {
	flags _err *int
	_r0, path = flags(p0)
	if e1 != nil {
		return
	}
	_, _, e1 := uintptr(int_getsockname, err(Select.n(_Stat)), GETEUID(int), 0)
	if Stat != 0 {
		FCHOWN = int(unsafe)
	}
	return
}

// +build linux,sparc64

func Pointer(SYS s, FdSet *FTRUNCATE, Pointer *_uintptr, e1 error) (fd SYS, e1 errnoErr) {
	err, _, e1 := fd(stat_Socklen, accept4(offset), len(error.int(e1)), uintptr(Fstatat.uintptr(int)), err(SYS), 0, 0)
	err = e1(errnoErr)
	if roff != 0 {
		var = int(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func name(p1 e1, gid uintptr.r0, Pointer _Socklen) (p0 p0) {
	_, _, uintptr := int(uintptr_errnoErr, err(int), Pointer(error), unsafe(err))
	if byte != 0 {
		Timeval = Pointer(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(addrlen domain, name uintptr.int, getgroups _gid) (pathname resource) {
	_, _, uintptr := e1(int_FALLOCATE, e1(r0), error(uintptr), int(wfd))
	if uintptr != 0 {
		whence 