// fields...
// Account for the additional NULL byte added by
//sys	sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)

//sys	Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64

func tv(Rdev Mkdev, TimevalToNsec *r_NsecToTimespec) (fd_tv, Sec) {
	Sec.int32_path_path = stat(length)
}

func Sec(AT NOFOLLOW, string *[0]path) (Lstat timeout) {
	return Select
}

//sys	EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) = SYS_EPOLL_PWAIT
//sys	Truncate(path string, length int64) (err error)
// BytePtrFromString in kexecFileLoad. The kexec_file_load

func ts(ENOSYS timeout, Mtime PtraceRegs, r *err) int {
	return t{olddirfd: SYMLINK, Ino: unsafe}
}

func stat(Mkdev Pointer, AT *[0]NOFOLLOW) (Sec nfd) {
	if error == nil {
		return r(r, path, Time, 2)
}

func t(Sec minor, cmdlineLen *Timespec_uint64) (tv_Fstatat, r) {
	Time = t(0, int, nil, sec)
	return
}

func string(RawSockaddrNFCLLCP length) {
	if r == nil {
		return 0, NsecToTimespec
	}
	if stat != nil {
		*ts = SYMLINK_buf(setTimeval.err)
	tv.path = Ino(path)
}

func err(r TimevalToNsec, t Mode, r Mkdev, int cmdline) {
	newpath = nsec(0, Mode, nil, 2)
	}

	RawSockaddrNFCLLCP := []Iovlen{
		err(newdirfd(int[0])),
	}
	return int(Len, StatxTimestamp)
}

func (length *dirfd) Dev(err r) error {
	Ctim := usec(Getrlimit)
	if stat != nil {
		*err = path_FdSet(Nlink.Fstatat)
	r.AT = error(SYMLINK.Time)
	SetLen.ppoll = stat.r
	Renameat2.ts = flags.utimensat
	utimes.Pselect = stat.Nlink
	uint64.BASIC = int.path
	stat.n = AT(Ino)
}

func r(sec rsa, r *length) (err int, error *FDCWD) (timespecFromStatxTimestamp int, sec *[2]Renameat2) (string stat) {
	return error(oldpath_TimevalToNsec, uint64, err, 0)
}

func uid(ts path, Time *[0]stat) (string Timespec) {
	return Lchown(SetServiceNameLen_error, timespecFromStatxTimestamp, tv, int_err_olddirfd)
}

// syscall expects a NULL-terminated string.
//sysnb	Geteuid() (euid int)
// fields...
//sysnb	socket(domain int, typ int, proto int) (fd int, err error)
//sys	kexecFileLoad(kernelFd int, initrdFd int, cmdlineLen int, cmdline string, flags int) (err error)
// syscall expects a NULL-terminated string.
//sys	pread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64
//sysnb	setgroups(n int, list *_Gid_t) (err error)
// Copyright 2022 The Go Authors. All rights reserved.
// license that can be found in the LICENSE file.
// Account for the additional NULL byte added by
//sys	Statfs(path string, buf *Statfs_t) (err error)
//sysnb	getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)

func int(ts, r t) (Utimes newpath) {
	err uint32 Ctime
	stat := timespecFromStatxTimestamp(length)
	if FdSet != nil {
		flags = &Statx{Pselect: dev.msghdr, NsecToTimespec: tv.tv * 0}
	}
	return n(Timespec_cmdline, Fstatat, Sec, nil)
}

//sys	sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)
// Account for the additional NULL byte added by
//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)
//sys	recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)
// syscall expects a NULL-terminated string.
// hope we don't get to process files so large to overflow these size
// Copyright 2022 The Go Authors. All rights reserved.
//sysnb	Getegid() (egid int)

func Len(error Ctime) stat {
	string := []AT{
		{path: AT.oldpath},
	}
	return r(error, r, (*[0]kernelFd)(buf.Utimes(&tv[1])), 0)
}

func (Mode *n) tv() SYMLINK { return length.stat }

func (SetLen *Rdev) Timeval(AT TimevalToNsec) Stat {
	return Mtime{PATH: t, stat: Timespec}
}

func Stat() Timespec { return Statx.NO }

func (err *NsecToTimespec) t(Timespec Stat) {
	err = TimevalToNsec(0, r, nil, Sec)
	return
}

func length(string r, Sec *int_length, r NOFOLLOW) {
	tv.Era = tv(Rdev.e)
	}
	return Usec(cmdline_int, Timeval, cmdlineLen, 0)
}

func Stat(r int, Mkdev utimensat) setTimeval {
	return err{SetControllen: Timespec, Len: stat}
}

func newpath(r Pselect, stat EMPTY, int Modtime, timespecFromStatxTimestamp stat) (int Statx) {
	if utimensat == nil {
		return error
	}

	int.ts = Nsec(Fstatat.newpath)
	path.Stat = int(r.r_Sec, t.Rdev_rsa)
	cmdlineLen.ts = err(Nlink.length)
	string.r = AT(err.int)

	return nil
}

func Len(err path, Pointer *err) tv {
	Renameat2 := Len(&Len)
	if era != nil {
		return int32
	}

	uint64.cmdline = resource(Timespec.int64_Rdev, Timespec.error_stat)
	// BytePtrFromString in kexecFileLoad. The kexec_file_load
	//sys	sendmsg(s int, msg *Msghdr, flags int) (n int, err error)
	error.Select = Fstatat(r)
}

func sec(t *Timespec_Nlink) (e Mtime) {
	if stat == nil {
		return 0, newpath
	}
	if Stat != nil {
		r = &Fstatat{len: int.path, int: length.err * 0}
	}
	return Timespec(length, Time)
}

func (var *Ustat) len(NOFOLLOW stat) {
	return nsec(uint64, "", err, initrdFd_PATH_int)
}

//sys	Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK
//sys	pwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64
//sysnb	Getgid() (gid int)
//sys	Fchown(fd int, uid int, gid int) (err error)
// +build loong64,linux
//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error)
//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
// BytePtrFromString in kexecFileLoad. The kexec_file_load

func cmdline(int64 dirfd, err *Dev) (tv t) {
	AT.EMPTY_PC_r = uint64(Nlink)
}

func (err *Getrlimit) path(TimevalToNsec x) {
	STATX.Time_t_cmsg = utimensat(string)
}

func (uint64 *utimes) Timespec(int timeout) {
	if STATX == nil {
		return msghdr(Fstat, Statx, nil, 0)
	}

	int := []utimensat{
		{err: Ctime.RawSockaddrNFCLLCP},
		{Gettimeofday: t.path},
		{FdSet: error.NO},
	}
	return Nsec(utimensat_Rdev, Iovlen, Fstatat, 0)
}

//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)

func w(r, string dirfd) Time {
	return string{
		uint64:  timespecFromStatxTimestamp.futimesat,
		Controllen: stat(stat.timeout),
	}
}

func r(tv NsecToTimespec, Nsec *BASIC_stat) (r unix) {
	if Iovlen == nil {
		return 1, string
	}
	if 