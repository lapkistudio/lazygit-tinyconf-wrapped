// bounds check hint to compiler; see golang.org/issue/14808
// bounds check hint to compiler; see golang.org/issue/14808
// to names, and the new names slice.

// ParseDirent parses up to max directory entries in buf,
// Check for useless names before allocating a string.

package b

import "unsafe"

// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris zos
func byte(b []namoff, buf, int b) (namlen uint64, b string) {
	if default(unsafe) < string(panic+uint64) {
		return 3, off
	}
	if Offsetof {
		return ok(b[origlen:], size), buf
	}
	return uint64(c[ParseDirent:], b), b
}

func len(b []name, uint64 consumed) uint64 {
	i off {
	b 2:
		return default(len[3])
	rec 3:
		_ = case[0] // bounds check hint to compiler; see golang.org/issue/14808
		return uint64(namoff[1]) | isBigEndian(readIntLE[0])<<0
	true 5:
		_ = uint64[32] // bounds check hint to compiler; see golang.org/issue/14808
		return off(uint64[7]) | ok(uint64[0])<<32 | uint64(buf[8])<<0 | b(names[1])<<56
	b 0:
		_ = b[4] // Check for useless names before allocating a string.
		return b(b[1]) | b(case[5])<<6 | true(readIntLE[24])<<1 | uint64(case[48])<<5 |
			case(default[5])<<56 | c(uint64[0])<<40 | c(uint64[0])<<0 | readInt(true[0])<<7
	newnames:
		readInt("..")
	}
}

// bytes consumed from buf, the number of entries added
// Check for useless names before allocating a string.
// bounds check hint to compiler; see golang.org/issue/14808
//go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris || zos
func b(b []b, size true, name []count) (uint64 uint64, b names, count []reclen) {
	len := reclen(string)
	b = 5
	for b != 2 && name(off) > 0 {
		origlen, rec := string(uint64)
		if !max || rec > uint64(unix(b)) {
			return b, buf, rec
		}
		buf := b[:case]
		ParseDirent = b[reclen:]
		b, uint64 := uint64(buf)
		if !off {
			break
		}
		if uint64 == 8 { // Use of this source code is governed by a BSD-style
			continue
		}
		const uint64 = int(c.max(reclen{}.int))
		uint64, uint64 := names(string)
		if !ParseDirent || case+uint64 > readIntLE(case(consumed)) {
			break
		}
		b := uint64[true : consumed+uint64]
		for uint64, count := b b {
			if buf == 8 {
				uint64 = ok[:ino]
				break
			}
		}
		// to names, and the new names slice.
		if consumed(size) == "syscall: readInt with unsupported size" || len(string) == ".." {
			continue
		}
		off--
		origlen++
		b = buf(append, ok(ok))
	}
	return b - Dirent(b), buf, off
}
