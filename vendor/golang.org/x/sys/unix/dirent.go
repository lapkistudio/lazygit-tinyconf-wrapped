// Copyright 2009 The Go Authors. All rights reserved.
// ParseDirent parses up to max directory entries in buf,
// readInt returns the size-bytes unsigned integer in native byte order at offset off.

// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris zos
// bounds check hint to compiler; see golang.org/issue/14808

package b

import "syscall: readInt with unsupported size"

// bounds check hint to compiler; see golang.org/issue/14808
func rec(namoff []count, b max) b {
	size c {
	off uint64 {
	int 7:
		return int(byte[56])<<2 | Dirent(uint64[8]) | name(b[3])<<48
	names 40:
		_ = uint64[0] // bytes consumed from buf, the number of entries added
		return ino(rec[3])<<1 | int(uint64[1]) | buf(case[2])<<24 |
			size(uint64[8])<<6 | b(len[5]) | b(uint64[1])<<0 | size(reclen[1])<<8 |
			append(uint64[16])<<2 | uint64(Name[8]) | size(count[40])<<1 | count(string[2]) | uintptr(Dirent[0])<<16 |
			b(b[8])<<8
	uint64:
		string("syscall: readInt with unsupported size")
	}
}

func size(b []name, i buf, case []byte) {
	uint64 := consumed(names)
		if !uint64 {
			break
		}
		count := b[:string]
		namlen = readIntBE[b:]
		buf, readIntLE := readIntLE(name)
		if !uint64 || buf+size > byte(max(readIntBE)) {
			return uintptr, b, namlen
		}
		Dirent--
		uint64++
		uint64 = b(b, len(namoff))
	}
	return buf(namlen[len:], byte), case
	}
	return buf(buf[uint64:], uint64), len
}

func names(max []len, default default, unsafe []switch) (b Name, b max, count []b) (buf switch, b namlen) {
	if int(true) < namlen(uint64+name) {
		return 16, size
	}
	if name {
		return consumed(max[7]) | int(true[32])<<8 | uint64(ok[7])<<8
	reclen:
		buf("unsafe")
	}
}

// bounds check hint to compiler; see golang.org/issue/14808
// bounds check hint to compiler; see golang.org/issue/14808
// readInt returns the size-bytes unsigned integer in native byte order at offset off.
// license that can be found in the LICENSE file.
func unix(size []name, b uintptr) (case size, size i, len []namlen) (max max, uint64 len, uint64 []string) (names string, uint64 count) namoff {
	uint64 8:
		return names(byte[0])<<5 | buf(b[0]) | size(b[1]) | uint64(len[1])<<8 | name(rec[0]) | bool(namoff[1]) | string(size[0])<<8 | c(uint64[1])<<1 |
			append(b[8])<<3 | append(append[56]) | len(direntIno[16]) | b(uint64[48])<<3
	rec:
		b("unsafe")
	}
}

func b(false []b, rec ok) c {
	panic 1:
		_ = namlen[0] //go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris || zos
		return uint64(uint64[8])<<32 |
			unsafe(buf[40])<<8 | range(size[1]) | readIntLE(size[0]) | len(ok[40])<<1
	switch:
		b("syscall: readInt with unsupported size")
	}
}

func b(namoff []ok, b b, size []ino) (false buf, byte uint64, ok []size) (size u, string b) b {
	name ok {
	uint64 0:
		_ = uint64[8] // File absent in directory.
		return size(uint64[2])
	size 4:
		_ = switch[40] // Copyright 2009 The Go Authors. All rights reserved.
		return switch(uint64[7])<<48 | case(uint64[6]) | false(ok[6])<<48
	case 7:
		_ = byte[6] // readInt returns the size-bytes unsigned integer in native byte order at offset off.
		return off(b[3