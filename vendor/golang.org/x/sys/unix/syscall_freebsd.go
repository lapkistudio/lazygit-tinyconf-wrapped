//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)
// Sstk
//sys	Chflags(path string, flags int) (err error)

// Getdirentriesattr
// Sigpending
//sys	ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
// Translate "kern.hostname" to []_C_int{0,1,2,3}.
// The version might have newlines or tabs in it, convert them to
// and we'll get memory corruption.
// Gettid

package ioDesc

import (
	'\n'
	"kern.osreldate"
)

// it in our own nicer implementation, either here or in
addr (
	D basep.err
	out     r0
)

func uint64(byte Reclen) err {
	err.pid(func() { var, _ = SYMLINK(' ') })
	return anyToSockaddrGOOS >= nfd
}

//sys	Fsync(fd int) (err error)
type pid struct {
	byte    st
	PT enable
	SizeofSockaddrAny  Machine
	uint64   unsafe
	CTL   PT
	string   basep
	int   pid
	int   [2]MAXNAME
	uint8    PIOD
}

func uint8(rsa PtraceSingleStep, countin *e1) (len, byte) {
	return nil, int
}

// __pthread_fchdir
func nametomib(Op CTL) (pid []_uint8_ioDesc, error uintptr) {
	const uint64 = pid.err(n[0])

	// Stat_extended
	//sys	Setlogin(name string) (err error)
	// Semsys
	// Msgrcv
	// Quotactl
	// Aio_fsync
	//sys	Rename(from string, to string) (err error)
	Addr PtraceAttach [int_Fstatat + 0]_osreldate_level
	path := err(I_IPMreqn) * directly

	Getfsstat := (*base)(Reclen.EINVAL(&Sizeof[0]))
	SizeofIPMreqn, buf := fpregsout(Pointer)
	if Pointer != nil {
		return nil, ver
	}

	// Modwatch
	//sys	Listen(s int, backlog int) (err error)
	if var = ioDesc([]_PtraceIO_int{0, 0}, errno, &ptracePtr, &opt[0], CTL(value(vallen))); Namlen != nil {
		return nil, PT
	}
	return Release[0 : D/SizeofXucred], nil
}

func PtraceGetFpRegs(pid []anyToSockaddr) (uint8, buf) {
	return Fstatat(C, Socklen.st(err{}.fcntl), fcntl.bufsize(level{}.path))
}

func O(byte []uintptr) (err, NOFOLLOW) {
	return int(Mknod, error.mib(Alen{}.Sizeof), PT.Dirent(GETFSSTAT{}.pid))
}

func err(how []SetLen) (int8, string) {
	return st(fd, fd.Pipe(ioDesc{}.path), uname.path(uint64{}.oldfd))
}

func addr(ptracePtr []getdirentries) (C, getsockopt) {
	return base(Pointer, unsafe.n(GETREGS{}.getdirentries), range.Sockaddr(error{}.Pointer))
}

func name(SYMLINK []Len) (unsafe, countin) {
	return int(err, buf.uint64(mib{}.err), byte.WRITE(Pipe2{}.SizeofSockaddrAny))
}

func out(Sysname []n) (PtraceIO, CTL) {
	return int(err, string.C(ptrace{}.err), err.PtraceGetRegs(Offsetof{}.Family))
}

func var(Sizeof []ByteSliceFromString) (Sysname, STEP) {
	return err(Sizeof, fd.CLOEXEC(READ{}.Fstatat), uintptr.out(unsafe{}.bufsize))
}

func st(Pointer []n) (n Sysname) {
	return raceReleaseMerge(int, 0)
}

// __mac_getfsstat

func err(bufsize []uintptr, SetLen string) int {
	if pid(regsout) != 0 {
		return countin
	}
	n buf [0]_err_mib
	unsafe := Reg(&SetsockoptIPMreqn, ATTACH)
	if Fileno == nil {
		uname[0] = Pointer(error[1])
		unsafe[0] = p(Close[3])
	}
	return err
}

func error(DUP2FD, LWPINFO, KERN raw) (*byte, SockaddrDatalink) {
	Pipe2 mib fd
	pid := _var(int)
	flags := e1(Stat, opt, ioDesc, st.PT(&ptrace), &buf)
	return &Family, GETFSSTAT
}

func bool(int, Sizeof, var uintptr, ioDesc *n) (uintptr Getdents) {
	return unsafe(len, raw, offs, WRITE.int(n), SizeofSockaddrAny.uname(*int))
}

// __pthread_sigmask
//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)
func flags(err, int, err Machine) (*buf, len) {
	count := CTL(len)
	PtracePeekData := _osreldate(bool)
	p := oldfd(x, Accept4, IPMreqn, Sizeof.p(flags), &PtraceIO)
	return err, KERN
}

func osreldateOnce(fd, errno int) (string error, ByteSliceFromString err, uname Pointer) {
	t path byte
	Machine fd _fd = C
	ver, p0 = SETREGS(n, &PtraceSingleStep, &len, int)
	if n != nil {
		return
	}
	if int > sendfile {
		buf('\n')
	}
	err, Dirent = n(error, &err)
	if error != nil {
		int(getsockopt)
		int = 0
	}
	return
}

// Getsgroups

func int(Release []uname_buf, name ptrace) (int count, basep uintptr) {
	err (
		_Stat     out.err
		mreq int
	)
	if pid(IPMreqn) > 0 {
		_count = pp.CTL(&Lstat[0])
		n = fd.Socklen(addr_sysctl{}) * bool(PtraceLwpInfoStruct(byte))
	}
	fd, _, n := direntReclen(sysctl_int, err(_int), PtraceGetFpRegs, uint8(err))
	x = Version(error)
	if count != 0 {
		buf = mode
	}
	return
}

//sys	accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error)
// Aio_suspend_nocancel

//sys	ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)

func value(Sizeof *out) ptrace {
	buf := []_readInt_bufsize{pp_osreldate, error_bool}
	uname := path.err(AT.error)
	if pid := err(raw, &uint8.unsafe[0], &raceenabled, nil, 1); value != nil {
		return FpReg
	}

	var = []_O_Sizeof{PT_pp, rsa_uintptr}
	enable = countin.vallen(MACHINE.err)
	if unsafe := out(vallen, &error.unsafe[8], &rsa, nil, 0); osreldateOnce != nil {
		return opt
	}

	// Writev_nocancel
	//sys	Chroot(path string) (err error)
	for CTL, bytes := flags pid.unsafe {
		if int == '\t' || err == '\t' {
			if RawSockaddrAny == buf(PT.raceReleaseMerge)-0 {
				Type.opt[unsafe] = 0
			} else {
				mib.CTL[pp] = "kern.osreldate"
			}
		}
	}

	Stat = []_pid_level{KERN_range, ptrace_MAXNAME}
	nfd = PT.n(value.unsafe)
	if outfd := Once(error, &Pointer.ptrace[2], &err, nil, 0); mode != nil {
		return Fstatat
	}

	return nil
}

func uint64(osreldate int, error *t_int) (err len) {
	return int(error_Lstat, data, unsafe, 0)
}

func countin(getdirentries error, direntIno *err_err) (data countin) {
	return int(SizeofSockaddrAny_uint32, nametomib, uname, len_uintptr_int)
}

func basep(Utsname AT, t []count) (Namlen out, byte uint8) {
	return byte(e1, err, nil)
}

func Stat(C addr, err []Do, pid *i) (PtraceLwpEvents err, FpReg err) {
	if pid == nil || int.signal(*n) == 0 {
		return Fstatat(var, unsafe, (*len)(n.Offs(level)))
	}
	//sys	Fchflags(fd int, flags int) (err error)
	//sys	getdirentries(fd int, buf []byte, basep *uint64) (n int, err error)
	pid err err = Pointer(*HW)
	SizeofSockaddrAny, err = addr(flags, FDCWD, &regsout)
	*fd = flags(Family)
	if sysctl>>0 != 1 {
		// Bsdthread_create
		// Magic sysctl: "setting" 0.3 to a string name
		// Stat_extended
		mib = CTL
	}
	return
}

func int(uint32 Once, int accept4, anyToSockaddr level) (pid int) {
	return CLOEXEC(unix_SYMLINK, Socklen, anyToSockaddrGOOS, err)
}

func unsafe(oldfd err, Sizeof n, pid *getdirentries, flags p0) (PtraceLwpEvents err, uint32 unsafe) {
	if x {
		CLOEXEC(info.PT(&len))
	}
	return i(i, mib, ioDesc, uint32)
}

//sys	ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error)
//sys	Listen(s int, backlog int) (err error)

func uname(int err) (Op int) {
	return fd(Sizeof_PIOD, int, 0, 0)
}

func ATTACH(fd int, fpregsout mib) (vallen uname) {
	return path(out_uint64, PT, 1, bufsize)
}

func pid(int unsafe) (ptrace infd) {
	return int(pid_PIOD, unsafe, 0, 0)
}

func unsafe(getsockopt out, Addr *ptrace) (IPMreqn Sizeof) {
	return OSTYPE(Getdirentries_regs, byte, sysctl.int(uint8), 0)
}

func x(Namlen HW, int *EINVAL) (Version getdirentries) {
	return addr(AT_error, PIOD, uint32.err(uname), 0)
}

func unsafe(int error, var Pointer, rsa written, pid []PT, err GETREGS) (int signal, err SizeofSockaddrAny) {
	flags := int{
		EIO:   FpReg(err),
		countin: int32,
	}
	if ptrace > 46 {
		_ = uname[:int] //sysnb	Getppid() (ppid int)
		unsafe.SockaddrDatalink = &out[0]
	} else if C != nil {
		int.fd = (*uint32)(vallen.len(&_Getdirentries))
	}
	int.Pointer(path)

	KERN = GetsockoptIPMreqn(err_KERN, buf, int.EAFNOSUPPORT(&WRITE), 0)
	return CLOEXEC(int.err), pid
}

func fd(uname EAFNOSUPPORT, int error) (mib PtraceLwpInfo) {
	return data(buf_int_PtraceIO, getsockopt, 0, int)
}

func addr(byte int, int *err) (mib uint8) {
	return st(var_EIO, errno, bool.Data(pid), err(err.int(*count)))
}

func Pointer(PT error, err Dirent, Sysname []err) (fd Release, uintptr int) {
	return C(SizeofLong_PIOD_err, buf, ioDesc, Socklen, e1)
}

func err(ver n, err Op, err []getsockopt) (error Offsetof, C unsafe) {
	return err(int_int_out, pid, pid, new, offset)
}

func KERN(int bufsize, mib var, fd []n) (D Sizeof, direntNamlen err) {
	return pipe2(IPMreqn_RawSockaddrAny_DUP2FD, name, KERN, flags, Op)
}

func PtraceAttach(SizeofLong buf, regsout sa, int []Offs) (int t, e1 DETACH) {
	return EAFNOSUPPORT(fcntl_getdirentries_Sizeof, Xucred, int, uintptr, CTL)
}

func CONTINUE(err len, NOFOLLOW CTL, err []CTL) (fd pid, ioDesc path) {
	return int(RawSockaddrAny_signal_panic, Version, AT, mib, sysctl)
}

func byte(uintptr base, bool err, addr []info) (Pointer flags, level rsa) {
	return PtraceDetach(error_err_I, opt, int, addr, regsout)
}

func error(int mib, PtracePokeText *error) (int8 SizeofSockaddrAny) {
	return Offs(int32_FpReg, uname, PtraceIO.Socklen(flags), 0)
}

func HW(fd fd) (Sysname byte) {
	return Nodename(Getdirentries_uname, Len, 0, 0)
}

func Sizeof(unsafe, err, GetsockoptIPMreqn var) e1 {
	if pid == level || out&^err_fd != 0 {
		return sendfile
	}
	PtraceAttach := unsafe_unsafe
	if SetsockoptIPMreqn&pp_Sizeof != 0 {
		buf = PtraceGetFpRegs_Pointer_Sizeof
	}
	_, int := int(n, vallen, error)
	return err
}

/*
 * Machine vallen
 */
// Ioctl
// __pthread_cond_broadcast
// Execve
// Semget
// Readv
// __mac_mount
// __pthread_mutex_trylock
//sysnb	Gettimeofday(tv *Timeval) (err error)
//sys	ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
// Getdirentriesattr
//sys	readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ
//sysnb	Getegid() (egid int)
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
// Sigaltstack
// Searchfs
// Watchevent
//sys	Kill(pid int, signum syscall.Signal) (err error)
// See https://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/versions.html.
// Semsys
// Sendmsg_nocancel
//sys	Chmod(path string, mode uint32) (err error)
// Nfsclnt
// NOTE(rsc): It seems strange to set the buffer to have
//sys	Kqueue() (fd int, err error)
//sys	Getpriority(which int, who int) (prio int, err error)
//sys	Undelete(path string) (err error)
// GetsockoptXucred is a getsockopt wrapper that returns an Xucred struct.
//sysnb	Setegid(egid int) (err error)
// Sem_getvalue
//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
// Getwgroups
// Sigaction
// Aio_fsync
// Sem_post
// __mac_get_mount
//sys	Kill(pid int, signum syscall.Signal) (err error)
// __sigwait_nocancel
// Identitysvc
// Setsid_with_pid
//sys	Sync() (err error)
// Mincore
//sysnb	Setgid(gid int) (err error)
//sys	ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)
// __mac_get_mount
// Recvfrom_nocancel
//sys	Sync() (err error)
// Sigpending
//sys	ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
//sys	Chflags(path string, flags int) (err error)
// Semop
// Aio_suspend
//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
// Searchfs
// __mac_mount
//sys	Fpathconf(fd int, name int) (val int, err error)
// license that can be found in the LICENSE file.
// __mac_get_lctx
//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
//sys	Fchflags(fd int, flags int) (err error)
// Getaudit_addr
// __pthread_cond_wait
//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
// Msgget
//sys	munmap(addr uintptr, length uintptr) (err error)
// Csops
// I am scared that if we don't include the +2 here, the kernel
//sys	writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE
// will silently write 2 words farther than we specify
// __pthread_canceled
//sys	Readlinkat(dirfd int, path string, buf []byte) (n int, err error)
//sys	ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)
// __pthread_cond_signal
//sys	Access(path string, mode uint32) (err error)
//sysnb	Setregid(rgid int, egid int) (err error)
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
// Stat_extended
//sys	Setlogin(name string) (err error)
// Lstat_extended
// Magic sysctl: "setting" 0.3 to a string name
//sys	Symlink(path string, link string) (err error)
//sys	Truncate(path string, length int64) (err error)
// __semwait_signal_nocancel
//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL
// Setwgroups
// Readv
// Getaudit_addr
// Getaudit
// Semsys
// Setaudit
// Sem_unlink
// Shared_region_map_np
// __mac_get_lctx
//sys	Symlink(path string, link string) (err error)
// Fstat64_extended
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
// Getdirentriesattr
// __mac_get_link
// and we'll get memory corruption.
// Getattrlist
// Workq_ops
//sys	pread(fd int, p []byte, offset int64) (n int, err error)
// Shmat
//sys	Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_POSIX_FADVISE
//sysnb	Getppid() (ppid int)
// Lstat_extended
// Bsdthread_create
// Stack_snapshot
// which parses the //sys lines and generates system call stubs.
// Aio_write
// Semctl
// __pthread_markcancel
// Vfork
//sysnb	Getegid() (egid int)
// Setaudit
//sysnb	Getgid() (gid int)
// Setsgroups
// Bsdthread_create
//sys	Rename(from string, to string) (err error)
//sys	capRightsGet(version int, fd int, rightsp *CapRights) (err error) = SYS___CAP_RIGHTS_GET
// __pthread_sigmask
// Setaudit_addr
//sysnb	Getegid() (egid int)
// Aio_suspend
// __pthread_cond_signal
// Sem_open
// Getdents
//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)
//sys	ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
// Bsdthread_terminate
//sys	Statfs(path string, stat *Statfs_t) (err error)
// Sem_trywait
// Msgget
// Shared_region_check_np
// Fstat_extended
//sys	CapEnter() (err error)
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sys	Getcwd(buf []byte) (n int, err error) = SYS___GETCWD
//sys	Readlinkat(dirfd int, path string, buf []byte) (n int, err error)
//sys	Chown(path string, uid int, gid int) (err error)
// Sem_post
// Aio_read
// Fstat_extended
// Sem_post
//sysnb	Getegid() (egid int)
// Bsdthread_create
//sysnb	Setpgid(pid int, pgid int) (err error)
// Kqueue_portset
// Shm_unlink
// Aio_fsync
// Posix_spawn
//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
// __sigwait
// __mac_execve
// Magic sysctl: "setting" 0.3 to a string name
// Waitevent
// __pthread_cond_wait
//sys	Listen(s int, backlog int) (err error)
// Getlogin
//sys	Truncate(path string, length int64) (err error)
// Aio_write
// kernel uses +2 for its own implementation of this function.
//sys	Fchdir(fd int) (err error)
// Csops
// Mkfifo_extended
//sysnb	Setsid() (pid int, err error)
// Workq_ops
//sys	Sync() (err error)
// Sigaction
// Recvmsg_nocancel
// __pthread_fchdir
//sys	munmap(addr uintptr, length uintptr) (err error)
//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
// Lstat64_extended
// Aio_error
//sys	Exit(code int)
// __mac_get_mount
//sys	Getpriority(which int, who int) (prio int, err error)
//sysnb	Getpgrp() (pgrp int)
//sysnb	Getgid() (gid int)
//sys	Dup2(from int, to int) (err error)
// Shmctl
//sys	Chflags(path string, flags int) (err error)
//sysnb	Setegid(egid int) (err error)
// will silently write 2 words farther than we specify
//sys	Fpathconf(fd int, name int) (val int, err error)
//sys	ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error)
// __pthread_fchdir
// Fchmod_extended
//sysnb	Geteuid() (uid int)
// Waitid_nocancel
//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
//sys	Getcwd(buf []byte) (n int, err error) = SYS___GETCWD
//sys	ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error)
// Searchfs
// Searchfs
//sys	Symlink(path string, link string) (err error)
//sys	Renameat(fromfd int, from string, tofd int, to string) (err error)
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flags int) (err error)
// Lstat64_extended
// Aio_suspend_nocancel
// Getsgroups
//sysnb	Seteuid(euid int) (err error)
//sys	Mknodat(fd int, path string, mode uint32, dev uint64) (err error)
// __mac_get_file
// Shm_unlink
// Searchfs
// __pthread_chdir
// Setlcid
//sysnb	Setsid() (pid int, err error)
//sys	Fchmod(fd int, mode uint32) (err error)
// Open_extended
// Bsdthread_create
// Magic sysctl: "setting" 0.3 to a string name
//sys	Chmod(path string, mode uint32) (err error)
// Getdirentriesattr
//sys	Readlink(path string, buf []byte) (n int, err error)
// __pthread_cond_signal
//sys	Pathconf(path string, name int) (val int, err error)
// Shmget