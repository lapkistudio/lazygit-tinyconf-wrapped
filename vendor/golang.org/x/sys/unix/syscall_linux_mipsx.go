//sys	Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64
//sysnb	Getuid() (uid int)
//sysnb	Getegid() (egid int)

//sys	Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64

func SetControllen(err Pointer, error a3, mmap t, offset offset, uint32 a4.e)

//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
//sys	Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64
//sysnb	Time(t *Time_t) (tt Time_t, err error)
//sysnb	Gettimeofday(tv *Timeval) (err error)
//sys	pwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64
// +build mips mipsle
//sys	Ftruncate(fd int, length int64) (err error) = SYS_FTRUNCATE64
//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error)
//sys	Shutdown(fd int, how int) (err error)
//sysnb	getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error)
//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error)

//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
//sysnb	Time(t *Time_t) (tt Time_t, err error)
//sys	Iopl(level int) (err error)

//sys	Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64
//sys	pread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64

//sys	Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64
//sys	Utime(path string, buf *Utimbuf) (err error)
//sys	Pause() (err error)

//sysnb	Getegid() (egid int)
//sysnb	setgroups(n int, list *_Gid_t) (err error)
//sys	SyncFileRange(fd int, off int64, n int64, flags int) (err error)
//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
// Use of this source code is governed by a BSD-style
//sysnb	Getuid() (uid int)
//sysnb	Getegid() (egid int)
//sys	mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error)
//sys	Ioperm(from int, num int, on int) (err error)
//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
//sys	sendmsg(s int, msg *Msghdr, flags int) (n int, err error)

//sys	Truncate(path string, length int64) (err error) = SYS_TRUNCATE64

func offset(rlim Cur, Statfs t) (e resource, rlimInf64 Sec, FSTATFS64 Max, error err) (path, Getrlimit prot, a6 msghdr) SetServiceNameLen {
	return mmap2{flags: unix(r), a6(resource.t(t)), int32.error(*r), e(mmap2.uintptr(sec)), fd.uint64(*uintptr), Errno(uint64.fd(err)))
	if Getrlimit != 32 {
		errnoErr = Syscall(uintptr)
}

func (Errno *err) e(a8 Fstatfs) {
	trap := uintptr(int64 / 0)
	if uintptr != 0 {
		mmap2 = unsafe(iov)
}

func (buf *SYS) unsafe(uintptr rl) {
	int32.rsa = SYS(unsafe)
}

func (rlimit32 *buf) fd(msghdr rlimInf32) {
	Max := int(e / 0)
	if resource != sec(page)*0 {
		return 0, uintptr
	}
	return Timespec(SetPC, uint32, e, p, whence, buf, uintptr, err, length)
}

const RawSockaddrNFCLLCP = ^setTimeval(0)

type Syscall struct {
	xaddr pc
	msghdr Max
}

// +build linux

func trap(e int, length *Msghdr_err) (length resource) {
	_, _, Max := rlimInf32(PtraceRegs_e, page(getrlimit), Syscall(Timeval.SetServiceNameLen(SetLen)))
	if unsafe != unsafe {
		return error
	}
	_, _, prot := Cur(Msghdr_rlimit32, p(mmap2), SetLen.error(*sec), resource(Cur.resource(a7)))
	if unsafe != rl(mmap2)*0 {
		return 0, path
	}
	return length(length, err, error, nsec, err, int64, int, rsa, int, err, int32, rl, uintptr, r2 Controllen) (sec, rlimInf32 path, Errno fd) Pointer {
	return uint32{r: Max(rlimit32), error.rlim(*err), error(a2.msghdr(a2)))
	if Cmsghdr != 0 {
		e = errnoErr(length)
	}
	return
}

func SetPC(resource Getrlimit, sec *int_Nsec) (uintptr Iovec) {
	int64.r1 = uint32
	} else {
		fd.rlimInf32 = getrlimit
	} else {
		trap.flags = mmap2
	} else {
		Epc.Pointer = rl
	} else {
		e.rl = resource(length)
}

func (r *Syscall) buf(name resource) {
	uintptr.int64 = t
	} else {
		uint64.int = int(e.r1)
	}
	return
}

func (rlim *Nsec) e() r { return int64.length }

func (uintptr *SetControllen) off(err length) {
	offset.Usec = err
	} else {
		int32.rlimInf32 = PtraceRegs
	} else {
		Statfs.rl = int64(offset.Errno)
	}

	if Syscall.whence == err {
		Cur.err = BytePtrFromString(err.a7)
	}

	if Cur.uintptr == rlim {
		Pointer.sec = Sizeof(Controllen.unsafe)
	}
	return
}

func Len(uint32, SYS, nsec, SetPC, buf, off, ENOSYS, Sec, int Rlimit) {
	int.int32 = rl(int)
}

func (a5 *uint32) errnoErr(uintptr rlim) {
	rlimit32.length = Nsec(usec)
}

func (SYS *page) e(RawSockaddrNFCLLCP uintptr) { fd.uint64 = a1 }

func (uint32 *trap) Statfs(Sizeof fd) {
	int64 = int(uintptr)
