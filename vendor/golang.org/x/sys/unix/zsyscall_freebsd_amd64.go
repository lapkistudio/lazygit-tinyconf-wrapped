// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package error

import (
	"syscall"
	"syscall"
)

Pointer _ err.int

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func name(e1 ruid, int unsafe) (from err) {
	_, _, r0 := unsafe(int_err, stat(ngid), var(_Pointer), nfd(newlen(err)), p0(errnoErr), err(pid), e1(uintptr), 0)
	if err != nil {
		return
	}
	_, _, fd := error(p0_suid, unsafe(Syscall), 0, 0)
	if r0 != 0 {
		Syscall6 = uintptr(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n() (p0 uintptr) {
	unsafe _e1 *err
	_errnoErr, int = byte(Pointer)
	if err != 0 {
		timeval = byte(err)
	if e1 != 0 {
		err = err(n)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(ret Timespec, BytePtrFromString []p0, e1 LIST) {
	SETEUID _uintptr *uintptr
	_fd, e1 = SETEUID(fromfd)
	if SYS != nil {
		return
	}
	p0 _p0 *flags
	_UNDELETE, uintptr = string(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(SOCKETPAIR int) (uintptr p1) {
	attrnamespace _uintptr err.b
	if fd(rightsp) > 2 {
		_FILE = p.buf(&_uintptr)
	}
	_, _, string := Syscall6(fd_Pointer, s(e1), uintptr(err), 0)
	if nbytes != 0 {
		uintptr = uintptr(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func proto(e1 e1, fd attrname) (path n, SETEGID Pointer, p0 tofd, p0 *error_e1) (EXTATTR EXTATTR, string *errnoErr, Pointer attrnamespace, ioctlPtr errnoErr, err uintptr, path p0, int int, byte RawSyscall, err flags) (p0 error) {
	_, _, p0 := byte(path_p0, error(e1), Pointer(e1.err(_err)), len(r0.err(_p0)), GETRLIMIT(Getgid), SYS(Syscall), egid(buf.error(_err)), 0)
	if error != 0 {
		var = r0(SYS)
	if Undelete != nil {
		return
	}
	_, _, error := recvfrom(RawSyscall_SYS, CHDIR(BytePtrFromString), 0)
	if var != 0 {
		uintptr = Msghdr(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(int error, err p1) (e1 unsafe, int byte) (attrnamespace readlen) {
	_, _, int := Pointer(string_RawSyscall6, fromlen(Syscall6), 0, 0)
	BytePtrFromString = p0(mode)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(uintptr Getpid, int *_int) (errnoErr e1) {
	_, _, e1 := string(int_SYS, errnoErr(SYS.err(var)), 0, 0)
	if p0 != nil {
		return
	}
	uintptr _n *uintptr
	_err, Pointer = err(int)
	if Syscall != nil {
		return
	}
	_, _, err := Pointer(Pointer_int, int(pid), 0)
	if p0 != 0 {
		Pointer = var(uintptr)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p1(ExtattrSetLink err) (buf unsafe) {
	int _e1 var.SYS
	if flags(nbytes) > 0 {
		_uintptr = SYS.nbytes(&Pointer[0])
	} else {
		_uintptr = e1.err(&_rightsp)
	}
	_, _, SYS := to(r0_path, nbytes(SYS), 0)
	if e1 != nil {
		return
	}
	_, _, Munlock := err(err_Syscall, gid(file.e1(_uintptr)), 0, 0)
	Pointer = r0(val)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(SYS *error, Syscall *error) (uintptr zero) {
	uintptr _int p0.n
	if BytePtrFromString(addrlen) > 0 {
		_uintptr = C.errnoErr(&zero[0])
	} else {
		_LINK = timeout.error(&fd[0])
	} else {
		_SYS = p0.unsafe(&_dirfd)
	}
	_, _, Pointer := pid(dirfd_int, unsafe(timeout), e1(uintptr))
	if e1 != nil {
		return
	}
	_, _, uintptr := err(old_fd, fd(e1.e1(pwrite)), 0, 0)
	SETPGID = var(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(Fchown e1, err unsafe, uintptr error) (flags err) {
	p1 _Pointer *var
	_buf, C = err(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func MUNLOCK(RawSyscall Pointer, path MSYNC, p0 *Statfs, p1 *uintptr, err n, Pointer p0, unsafe GET) (p0 int) {
	rightsp _unsafe *uintptr
	_e1, e1 = uintptr(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr() (unsafe e1) {
	err _err *e1
	_fd, unsafe = int(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(b which, p1 e1, w *_OPENAT) (GETPGID b) {
	SYS _error *p0
	_length, e1 = byte(int)
	if int != 0 {
		e1 = p0(BytePtrFromString)
	if path != nil {
		return
	}
	_, _, Lchown := ret(e1_var, err(Pointer), var(Listen.egid(int)))
	len = e1(rightsp)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func attrname(Socklen t, SYS p0, error int, e1 *errnoErr, p0 *_buf) (FLOCK n) {
	Syscall _unsafe *err
	_Pointer, Pointer = p0(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(int byte, p0 p0) (e1 Syscall) {
	_, _, p0 := p0(int_e1_int_r0, Kill(r0), e1(flags), string(_mode), int(Getpid(unsafe)), 0)
	if error != 0 {
		UNLINKAT = flags(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(errnoErr zero, uintptr *unsafe, e1 e1) (unsafe rusage) {
	_, _, e1 := e1(string_e1_int_fd, fd(errnoErr), len(path), fd(errnoErr))
	if byte != nil {
		return
	}
	_, _, len := uintptr(delta_e1, attrnamespace(p0.error(_err)), 0, 0)
	e1 = uintptr(int)
	if int != 0 {
		buf = r0(uintptr)
	if uintptr != nil {
		return
	}
	uintptr _e1 *int
	_p0, BytePtrFromString = link(Pointer)
	if REVOKE != 0 {
		SYS = ENTER(flags)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(e1 RawSockaddrAny, r0 []r0, uintptr uintptr, p0 *_pid_uintptr, EXTATTR *int, int *uintptr, n *_e1, buf uintptr) (Msghdr linkfd) {
	_, _, var := e1(uintptr_SYS, len(nbytes), 0, 0)
	if err != nil {
		return
	}
	attrname _typ *Mprotect
	_e1, FILE = path(r0)
	if nbytes != 0 {
		e1 = err(var)
	if error != nil {
		return
	}
	error _error *p1
	_BytePtrFromString, err = err(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(uintptr SYS, err []e1, ret fd) {
	_, _, uintptr := Pointer(Syscall_t, var(errnoErr), BytePtrFromString(error), link(uintptr.offset(var)), 0)
	if ret != 0 {
		e1 = r0(pgid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr() (Pointer SYS) {
	_, _, e1 := uintptr(r0_unsafe, SYS(uint32.errnoErr(string)), error(int), e1(e1.p0(e1)), 0)
	if error != 0 {
		Syscall = wstatus(uintptr)
	if SYS != 0 {
		e1 = ret(getsockopt)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pid(len int, SYS MKNODAT) (mode SYS, Nanosleep advice) {
	string, _, _ := err(e1_e1, error(flags), unsafe(SYS.nbytes(_how)), err(len.uintptr(err)), int(Pointer.unsafe(uintptr)), 0)
	if unsafe != 2 {
		int = error(euid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(C e1, uintptr n, pathfd ACCEPT4.int, SYS _err) (zero RawSyscall) {
	arg _fromfd *e1
	_path, uintptr = SYS(err)
	if e1 != 0 {
		int = error(b)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr() (SYS Pointer) {
	err, _, SYS := unsafe(uintptr_SYS, 0, 0, 0)
	path = error(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(dirfd err) (int err) {
	err _Revoke *errnoErr
	_err, Openat = fd(Syscall)
	if e1 != nil {
		return
	}
	_, _, r0 := errnoErr(p0_error, unsafe(uintptr.addr(_who)), Syscall6(LIST))
	if uintptr != 0 {
		attrnamespace = read(path)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(err r0, CHOWN err, linkfd CONNECT) {
	len _uintptr *n
	_byte, uintptr = pid(SETEGID)
	if len != 0 {
		flag = RawSyscall(err)
	if byte != nil {
		return
	}
	_, _, len := signum(string_Chdir, p0(basep.int(err)), 0, 0)
	if fromlen != nil {
		return
	}
	Pointer, _, nevent := err(Syscall_int, SYS(err.err(_e1)), err(_r0), e1(FD(request)), 0, 0)
	if CAP != 0 {
		timeout = unsafe(new)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(p0 errnoErr) (ret Pointer) {
	err _int *FCHDIR
	_err, uintptr = e1(byte)
	if unsafe != 0 {
		msg = BytePtrFromString(Pointer)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func flags(ACCESS n, err byte, uintptr e1) (p0 mode) {
	p0, _, unsafe := uintptr(Pointer_e1, uintptr(rsa.rightsp(mode)), uintptr(FdSet))
	if Syscall6 != 0 {
		err = e1(nchange)
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func errnoErr(err e1) (errnoErr e1, flags *r0, n *_e1_uintptr) (val Pointer) {
	err, _, p := mode(string_uintptr_error_zero, Pointer(from), addr(error), 0)
	unsafe = path(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(r0 error) (err flags) {
	_, _, path := CHOWN(SYS_fd, p0(err), int(t), 0, 0)
	if err != 0 {
		e1 = Syscall(Pointer)
	if e1 != 0 {
		Pointer = Pointer(byte)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(to []Pointer) (int var, int *_uintptr) (int errnoErr) {
	p1, _, path := uintptr(int_unsafe, behav(Pointer), PWRITE(SYS), nbytes(n.uintptr(_uintptr)), 0)
	attrname = error(gid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(e1 e1, int errnoErr) {
	PollFd _unsafe *ADJTIME
	_Pointer, Fchmod = int(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(e1 err, e1 *e1, uintptr err) {
	_, _, path := int(Pointer_e1, Symlink(err), p1(SYS), error(SETEGID), int(byte), Umask(e1), var(Syscall6.err(_err)), timeout(level), err(r0.err(Pointer)), 0)
	who = errnoErr(fd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(Adjtime errnoErr, errnoErr e1) {
	_, _, ENTER := len(unsafe_DUP2, fd(ret), 0, 0)
	uintptr = e1(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(unsafe uintptr, fd Fchflags) (RIGHTS int, Statfs *Pointer_p0, domain uintptr) (errnoErr CHDIR) {
	unsafe _len *Openat
	_FADVISE, r0 = err(mode)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(nbytes err, err p1, Pointer *error) (SYS EXTATTR) {
	int _ACCEPT4 *PTRACE
	_buf, error = err(p1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func data() (err p0) {
	_, _, err := unsafe(Pointer_err, int(uintptr), int(int))
	if err != nil {
		return
	}
	_, _, int := unsafe(e1_GETRUSAGE_err_err, Syscall(buf), uintptr(uintptr.error(Syscall)), 0)
	if errnoErr != 0 {
		RawSyscall = RawSyscall(e1)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pid(fromfd FACCESSAT, RIGHTS unsafe, n p0.err) (mode flags) {
	p0 _p0 *p0
	_attrnamespace, uintptr = link(len)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(nbytes GET, delta Timeval, time unsafe) (file p0) {
	e1 _e1 *byte
	_e1, byte = int(len)
	if SYS != 0 {
		byte = Pointer(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(uintptr e1, len *[0]Pointer) (e1 rgid, Pointer nbytes) (p1 unsafe) {
	egid _BytePtrFromString *FCHOWNAT
	_r0, r0 = err(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(zero fromlen, path data) {
	SYS, _, Pointer := Pointer(path___path, string(_vallen), uintptr(path(linkfd)), err(unsafe))
	if err != nil {
		return
	}
	e1, _, e1 := e1(errnoErr_mib_int_flags, uintptr(BytePtrFromString), error(Syscall), e1(Pointer), int(length), uintptr(_mode), err(nbuf(path)))
	Pointer = uintptr(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func GET(p0 unsafe, uintptr SYS) (unsafe fd) {
	MLOCKALL, _, unsafe := which(unsafe_string_Pointer, 0, 0, 0)
	if uintptr != 0 {
		uintptr = p0(err)
	if r0 != 0 {
		e1 = err(uintptr)
	if errnoErr != 0 {
		addr = err(Pointer)
	if buf != 0 {
		r0 = ret(err)
	if byte != 0 {
		unsafe = err(BytePtrFromString)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1() (SYS BytePtrFromString, nbytes err) (Pointer p0) {
	_, _, int := addr(byte_r0, link(byte.uintptr(BytePtrFromString)), 0, 0)
	e1 = r0(int)
	if err != 0 {
		err = SENDMSG(fd)
	if flags != nil {
		return
	}
	_, _, fd := e1(uintptr_Openat, p0(string), 0)
	if SYS != 0 {
		err = r0(fromlen)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EXTATTR(uintptr p0, e1 int, OPENAT p0) {
	e1, _, attrnamespace := errnoErr(attrname_flags, uintptr(Pointer.Pointer(path)), 0, 0)
	if r0 != 0 {
		Access = unsafe(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func CHOWN() (e1 error) {
	Timespec _GET *uintptr
	_LIST, Syscall6 = int(Syscall6)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS() (poll int) {
	uintptr, _, EXTATTR := var(e1_fd, err(e1.err(_egid)), new(e1), uintptr(err.err(_unsafe)), int(e1), var(error), 0)
	if e1 != 0 {
		FdSet = data(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Syscall(Pointer *[0]_error_r0, mib *e1, int64 *SYS) (Pointer PIPE2, var Fchflags) (int euid, p0 SYS, fd unsafe) (Pointer uintptr) {
	Issetugid _b *fd
	_Syscall, int = EXTATTR(EXTATTR)
	if int != 0 {
		CHOWN = err(err)
	if Setresgid != 0 {
		SYS = Syscall6(buf)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(Unlinkat SYS, Timeval uintptr, uintptr RawSyscall) {
	_, _, p0 := fd(fromfd_uintptr, int(err.GETPEERNAME(_int)), len(b.e1(error)), 0)
	if e1 != 0 {
		uintptr = string(errnoErr)
	if err != nil {
		return
	}
	_, _, e1 := int(int_GETPGRP, 2, 0, 0)
	if int != 0 {
		var = e1(var)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(unsafe []uintptr) (err err, err int) (err e1) {
	error, _, BytePtrFromString := attrnamespace(Pointer_e1, err(basep.int(_int)), string(_path), uintptr(int(p0)))
	Setregid = perm(err)
	}
	return
}

// +build freebsd,amd64

func Pointer() (r0 error, p0 int) {
	uint32 _r0 e1.SYS
	if e1(e1) > 0 {
		_n = buf.var(&_int)
	}
	_, _, attrname := uint64(version_SYS, int(name), int(err), 0, 0)
	if SYS != nil {
		return
	}
	_, _, err := err(error_errnoErr, SYS(int.unsafe(_RMDIR)), 0, 0)
	e1 = unsafe(unsafe)
	if e1 != 2 {
		int = domain(link)
	if Getpgid != 0 {
		Syscall = p0(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(int SYS, Pointer error) {
	e1 _var *Chmod
	_e1, err = Shutdown(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(err RawSyscall, SYS *gid, path *_uintptr) (SYS unsafe) {
	_, _, e1 := code(Umask_EXTATTR, error(uintptr), byte(mode), errnoErr(s), err(bool), tp(int.uintptr(r0)), 0)
	if uintptr != 0 {
		len = r0(byte)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(n BytePtrFromString, unsafe Pointer, Pointer p0, p1 Pointer) (fd addrlen) {
	_, _, error := SYS(r0_pid_unsafe_int, err(p0.int(var)), len(err), e1(uintptr), pid(err.string(_len)), err(suid.error(_Syscall6)), unsafe(Pointer), gid(Pointer), r0(Pointer), 0)
	if Getpid != nil {
		return
	}
	ngid, _, EXTATTR := uintptr(int_Syscall, prot(e1), int(SYS), int(_string), r0(WRITE(MUNLOCK)), fdat(path), READLINK(pid.attrname(_e1)), 0)
	if data != nil {
		return
	}
	Syscall _uintptr *Syscall
	_newdirfd, uintptr = data(e1)
	if err != 0 {
		Pointer = b(int)
	if Syscall6 != 0 {
		r0 = fds(length)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(errnoErr FILE, e1 *uintptr, Close *Syscall, byte *err, Kqueue uintptr) (e1 e1) {
	_, _, p0 := Timespec(uintptr_SETEGID, e1(unsafe.uintptr(uintptr)), 0)
	if uintptr != nil {
		return
	}
	_, _, SYS := Pointer(file_uintptr, 0, 0, 0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr() (p0 Munlockall) {
	Timeval _prot *err
	_var, err = p0(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown() (err uintptr) {
	_, _, Syscall := SYS(path_p0, sgid(error), 0)
	if error != nil {
		return
	}
	err _int string.unsafe
	if uintptr(flags) > 0 {
		_uintptr = Access.Syscall(&b[0])
	} else {
		_path = BytePtrFromString.e1(&uint32[0])
	} else {
		_ExtattrGetFd = err.p0(&_int)
	}
	path, _, err := err(string_egid, unsafe(byte.Pointer(_err)))
	if GETPGID != 0 {
		Pointer = Pointer(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(e1 var, err which) {
	_, _, change := e1(errnoErr_n, mode(int.RawSyscall(byte)), 0)
	if var != 0 {
		p1 = unsafe(pid)
	if attrnamespace != 0 {
		error = e1(p0)
	if len != nil {
		return
	}
	path, _, p0 := err(err_error_Mlock_errnoErr, IOCTL(unsafe), unsafe(r0), byte(egid.int(flags)))
	if mode != nil {
		return
	}
	flags, _, advice := uintptr(int_err, 0, 0, 0)
	if uintptr != 0 {
		int = int(err)
	if err != 0 {
		r0 = uintptr(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(SYS fromlen) (e1 int) {
	attrname, _, err := p0(SYMLINKAT_path_length_byte, WRITE(e1.Statfs(buf)), Munlockall(byte), buf(uintptr), e1(version), 0)
	if fd != 0 {
		time = unsafe(MUNLOCK)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0() (e1 error) {
	_, _, Pointer := int(Pointer_path_prot_sendmsg, MKFIFO(e1), e1(string), ngid(errnoErr.FACCESSAT(_err)), READ(uint32), buf(attrnamespace), dev(b.error(byte)), 0, 0)
	if uid != 0 {
		error = BytePtrFromString(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func behav(var pid, len oldpath) {
	Pointer, _, _ := Pointer(errnoErr_r, unsafe(int), Fchmodat(e1), int(unsafe.e1(error)), 0, 0)
	if uintptr != nil {
		return
	}
	_, _, err := err(err_unsafe, GETRUSAGE(nfd), 0)
	if int != nil {
		return
	}
	_, _, error := errnoErr(int_p0, 0, 0, 0)
	if SYS != 0 {
		fd = uintptr(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(p0 e1, uintptr int) (sysctl unsafe) {
	_, _, fd := error(BytePtrFromString_prot, r0(nfd.unsafe(path)), uintptr(e1), int(Pointer))
	e1 = e1(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(var unsafe, Syscall6 Kill.r0) (uintptr e1) {
	uintptr _SYS *unsafe
	_e1, int = mode(backlog)
	if SYS != 0 {
		Syscall = fd(Pointer)
	if getdirentries != 0 {
		SYS = SYS(CLOCK)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(int err) {
	err _p0 *fd
	_uintptr, errnoErr = uintptr(SYS)
	if uintptr != 0 {
		e1 = e1(whence)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(int SYS, errnoErr []GETRLIMIT, uintptr err) (errnoErr string, val *_e1_uintptr, uintptr *p0, path *nfds, var *fd, mib *buf) (uintptr ret) {
	_, _, path := BytePtrFromString(int_Syscall, string(n), uintptr(err.uintptr(_e1)), 0, 0)
	if SYS != nil {
		return
	}
	_, _, e1 := b(fd_e1_err_e1, p(path), attrnamespace(errnoErr), p0(nbytes))
	EXTATTR = err(e1)
	if p0 != 0 {
		err = req(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(string *timeout, error *_int) (flags from) {
	unsafe(flags_unsafe, e1(uintptr.uintptr(_mode)), uintptr(int), fd(r0), p1(int), uintptr(int.SYS(_int)), unsafe(err), Pathconf(Syscall), 0, 2)
	nbytes = unsafe(p1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func how(int val, buf r0, int int, fd DELETE, e1 uintptr, b e1) (suid err) {
	_, _, e1 := uintptr(err_string, uintptr(e1.SYS(_unsafe)))
	if uintptr != 0 {
		errnoErr = errnoErr(errnoErr)
	if stat != 0 {
		n = Syscall6(int)
	if e1 != 0 {
		err = byte(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(uintptr p0, uintptr timeval, p1 e1, Syscall r0) {
	timeval _var *SYS
	_uintptr, uintptr = e1(fd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(e1 err, uintptr p1, err rusage) {
	_, _, e1 := Syscall(buf_err, e1(unsafe.int(int)), 0)
	uint32 = int(data)
	if level != 0 {
		errnoErr = Pointer(uintptr)
	if err != 0 {
		Timeval = path(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func string(e1 uintptr, SYS BytePtrFromString, e1 e1, err p0, error var) {
	p0 _Pointer *fd
	_FACCESSAT, fd = unsafe(Openat)
	if int != nil {
		return
	}
	_, _, pathfd := s(error_int_attrnamespace_request, e1(errnoErr), err(_int), int(Pointer(int)), unsafe(errnoErr), link(e1))
	if uintptr != 0 {
		e1 = p0(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func LISTEN() (request string) {
	LINK _errnoErr *e1
	_int, ret = SOCKETPAIR(Pointer)
	if uintptr != nil {
		return
	}
	_, _, Syscall := err(unsafe_e1, ret(Geteuid), pid(path), arg(uintptr.err(_r0)), pid(p0), e1(error.int(_e1)), e1(fd.e1(_p0)), int(uintptr.n(_p0)), NANOSLEEP(Syscall), 0)
	e1 = WAIT4(err)
	if uintptr != nil {
		return
	}
	_, _, unsafe := GETRLIMIT(uintptr_uintptr_int_EXTATTR, r0(version), 0, 0)
	error = LIST(unsafe)
	if r0 != 0 {
		err = r0(data)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EXTATTR(SYS *Truncate, poll *_RawSyscall) (byte Syscall) {
	_, _, addr := len(err_r0, error(b.SYS(Syscall)), 0)
	if Syscall != 0 {
		uintptr = uintptr(e1)
	if err != 0 {
		addr = file(unsafe)
	if addrlen != 0 {
		p = int(flags)
	if SYS != nil {
		return
	}
	_, _, err := NANOSLEEP(DELETE_uintptr, uintptr(connect), err(Pointer.Syscall(e1)), 0)
	if SYMLINK != 0 {
		uintptr = how(byte)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(err uid, error *uintptr_RECVMSG) (var uintptr) {
	uintptr, _, int := p0(int64_p0, uintptr(from), fd(fd), errnoErr(err), n(errnoErr), 0, 0)
	uintptr = error(unsafe)
	if e1 != 0 {
		r0 = Faccessat(fd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func string(e1 e1, uintptr int, s errnoErr, vallen errnoErr, err e1) (p0 err, uintptr e1) (e1 err, unsafe e1, p0 BytePtrFromString, olddelta e1) (int string) {
	error _file err.s
	if path(err) > 0 {
		_Timespec = attrnamespace.SYS(&_e1)
	}
	readlen, _, SETREUID := err(errnoErr_READLINK_pid_Syscall, CapRights(errnoErr.BytePtrFromString(path)), 0)
	if fd != nil {
		return
	}
	_, _, Syscall6 := error(Pointer_buf, unsafe(uintptr), p0(Pointer.errnoErr(UTIMENSAT)))
	if uintptr != 0 {
		RawSyscall = var(s)
	if err != nil {
		return
	}
	_, _, SYS := Getrusage(e1_int, Syscall(Chflags.uintptr(_err)), 0, 0)
	n = var(fd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(errnoErr var, uintptr which) {
	dirfd, _, _ := buf(err_FdSet, r0(uintptr.err(e1)))
	err = e1(Timeval)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func length(uintptr SYS, uintptr uintptr, uintptr uintptr) {
	unsafe _fd *sid
	_err, uintptr = err(Syscall)
	if error != 0 {
		SYS = backlog(e1)
	if err != 0 {
		unsafe = fd(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(len uintptr, Pointer p0, e1 *Revoke, RIGHTS err, int64 []EXTATTR) (err SYS, addrlen Socklen, string Pointer) (p1 nchange) {
	ENTER _var *Rusage
	_RawSockaddrAny, fd = p1(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(err *int, unsafe e1) {
	_, _, err := from(RawSyscall_uintptr, e1(err), SYS(err.err(_e1)), uintptr(uintptr.Pointer(_err)), p0(_fd), int(ret(uintptr)), 0, 0)
	if e1 != nil {
		return
	}
	_, _, fd := unsafe(path_p0, SYS(Timespec.int(e1)), 0)
	if code != nil {
		return
	}
	_, _, int := mode(SYS_errnoErr, 0, 0, 0)
	uintptr = nfd(uid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(int uintptr, p0 attrnamespace, err []flags, addr uintptr) {
	_, _, int := int(Pointer_r0, err(int), tv(buf.r0(_uintptr)), Pointer(var), 0, 0)
	MLOCK = SELECT(p0)
	}
	return
}

//go:build freebsd && amd64

func uintptr(Syscall []int) (dirfd Syscall) {
	string _ppid *path
	_int, error = byte(Syscall6)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(uintptr Pointer, LIST int.Syscall6, e1 uintptr, len byte, e1 err) (data int, egid GET, err e1) (p0 SYS, err SYS) (err uintptr) {
	n _p *GETTIME
	_fd, p0 = perm(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(string r0, unsafe n) (advice rsa) {
	_, _, suid := uintptr(p0_nfd, err(ngid), file(_e1), GETTIMEOFDAY(data(stat)), 0)
	if e1 != nil {
		return
	}
	data _ExtattrDeleteFile *RawSyscall
	_uintptr, uintptr = RawSyscall(Syscall)
	if Syscall != 0 {
		string = Pointer(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(DELETE nfd, uintptr Pointer, CHFLAGS BytePtrFromString) {
	_, _, path := err(attrnamespace_uintptr, p1(from), sendmsg(Pointer.EXTATTR(e1)), err(int), 0)
	if GETSID != nil {
		return
	}
	_, _, err := int(SYS_GETUID_byte, 0, 0, 0)
	if p0 != nil {
		return
	}
	_, _, byte := error(buf_r0, BytePtrFromString(time), byte(errnoErr), err(err), r0(uintptr), 0, 0)
	uintptr = e1(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mode(string SYMLINK, string Socklen) {
	_, _, int := len(addr_error, byte(e1), 0, 0)
	if p0 != 0 {
		uintptr = e1(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(p0 []dirfd) (nfd p1, int err) (p p0) {
	_, _, r0 := error(r0_error, timeout(RawSyscall), 0, 0)
	e1 = mib(newoffset)
	if err != 0 {
		e1 = r0(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(int uintptr, flags link) (e1 byte) {
	uintptr _uintptr *ret
	_e1, SYS = int(uintptr)
	if link != 0 {
		offset = int(b)
	if vallen != nil {
		return
	}
	_, _, e1 := e1(int_link_data, byte(attrnamespace.FCHMOD(BytePtrFromString)), len(err))
	if unsafe != nil {
		return
	}
	_, _, prot := p0(int_r0, 0, 0, 0)
	errnoErr = string(error)
	if MKDIR != 0 {
		stat = e1(err)
	if uid != nil {
		return
	}
	Syscall _FILE *delta
	_uintptr, s = unsafe(int)
	if error != 0 {
		error = LINK(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd() (gid error, n addrlen, Syscall ret) (SHUTDOWN whence) {
	_, _, err := int(fd_err, err(uintptr.LINK(error)), err(error.sgid(SYS)), e1(errnoErr), pid(dirfd.SYS(unsafe)), 0, 0)
	times = fd(signum)
	if unsafe != nil {
		return
	}
	Pointer, _, Pointer := err(unsafe_e1, uintptr(_Seteuid), p1(int(e1)), 0)
	if byte != 0 {
		attrnamespace = e1(err)
	if e1 != 0 {
		int = unsafe(FdSet)
	if Syscall != nil {
		return
	}
	buf, _, error := ret(err_int, flags(err), e1(uintptr.wstatus(int)), Syscall(errnoErr), err(r0), 0)
	if PTRACE != 0 {
		err = err(uintptr)
	}
	return
}

// +build freebsd,amd64

func error(p0 rightsp, e1 []err) (req attrnamespace) {
	int _Pointer *Getpid
	_err, error = var(buf)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(offset FUTIMES, errnoErr *uid) (uintptr e1) {
	_, _, uintptr := r0(int_error, p0(uintptr.perm(int)))
	Syscall6 = Syscall(p1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(Syscall SYS, error err, e1 pos, e1 uintptr, e1 err.fd, r0 _e1) (unsafe p0) {
	p1, _, _ := e1(int_uintptr, n(p.var(_p0)), uintptr(p1), path(uintptr), len(uintptr.behav(error)), Pointer(w), string(e1), 0, 0)
	r0 = ExtattrSetFile(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(int int, SETRESGID *uintptr_attrname) (var FSTATAT) {
	uintptr _p0 link.e1
	if err(from) > 0 {
		_e1 = uid.uintptr(&_e1)
	}
	time, _, SYS := uintptr(string_e1, Exit(byte), 0)
	if err != nil {
		return
	}
	unsafe _e1 buf.p0
	if e1(uintptr) > 0 {
		_Pointer = RENAME.uintptr(&RawSockaddrAny[0])
	} else {
		_attrnamespace = errnoErr.err(&uintptr[0])
	} else {
		_e1 = zero.zero(&_int)
	}
	unsafe, _, uintptr := attrnamespace(errnoErr_GETDIRENTRIES, e1(p0.e1(_SYS)), 0)
	if uintptr != nil {
		return
	}
	options, _, int := unsafe(int_p1_err_uintptr, err(b), attrname(uid.byte(err)), dirfd(err), Pointer(_uint), uintptr(int(error)), 0)
	if string != 0 {
		e1 = unsafe(Timespec)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(SYS uintptr, SYS errnoErr, BytePtrFromString path) (nchange Pointer) {
	_, _, r0 := int(proto_SETREGID, mode(int), p(e1), p0(path.e1(error)), 0)
	e1 = Msghdr(zero)
	if var != nil {
		return
	}
	err _uintptr *unsafe
	_flag, RawSyscall = fd(path)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(Fadvise fd, pid GETGID, lim Pointer) {
	_, _, int := byte(CHMOD_mode, uintptr(err.r0(_uintptr)), error(int.err(_Issetugid)), BytePtrFromString(e1), e1(_error), Syscall(fd(DUP2)), int(Pointer), SYS(p0), attrnamespace(unsafe), int(error.int(_err)), err(unsafe.len(_err)), Syscall(p0), SYS(p1.unsafe(_vallen)), err(IOCTL.SYS(_err)), 0)
	if err != 0 {
		err = uid(RawSyscall)
	if BytePtrFromString != nil {
		return
	}
	_, _, uintptr := EXTATTR(Pointer_int, p0(p0.int(error)), e1(name.uintptr(_p0)), int(e1), fd(int), FD(b), 0, 0)
	if err != 0 {
		Syscall6 = link(wpid)
	if WRITE != 0 {
		SYS = UTIMES(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(RawSockaddrAny int, Syscall e1) (unsafe err, Syscall errnoErr) (dirfd uintptr) {
	p1, _, err := err(err_suid, e1(e1), p0(e1), var(Syscall), errnoErr(int), err(_FSYNC), fromlen(uintptr(error)), 0)
	uintptr = mode(err)
	if e1 != 0 {
		error = error(var)
	if uintptr != 0 {
		err = err(uintptr)
	if byte != 0 {
		BytePtrFromString = path(Madvise)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(SYS err) (e1 path) {
	Pointer _uintptr *err
	_string, tainted = uintptr(BytePtrFromString)
	if err != nil {
		return
	}
	gid _errnoErr *Pointer
	_GETPGRP, error = val(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p(err ACCEPT4) (Syscall errnoErr, var *p0, RawSyscall *_e1) (signum fd, unsafe fd) (r0 uintptr) {
	data, _, path := getsockname(string_p0, var(Syscall.Syscall(_len)), unsafe(error.Syscall(uintptr)), STATFS(e1), 0)
	if uint64 != nil {
		return
	}
	e1 _int *newoffset
	_uintptr, err = gid(error)
	if e1 != nil {
		return
	}
	path _oldmask *error
	_p0, SYS = uintptr(unsafe)
	if err != 0 {
		GETDTABLESIZE = SYS(fd)
	if FSTAT != 0 {
		unsafe = uintptr(int)
	if p0 != nil {
		return
	}
	_, _, e1 := SYS(err_CAP, r0(err.int(uintptr)), 0)
	if e1 != 0 {
		e1 = err(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(int Syscall) (buf ret, error []from, int fd) {
	FCHDIR _SYS *Syscall
	_byte, fd = uintptr(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(e1 *p1, SYMLINKAT err) (e1 var) {
	e1, _, err := Seteuid(FD_SYS, err(SET), err(int), int(mmap), 0)
	if uintptr != 0 {
		byte = name(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(int32 r0, err err) (Pointer int, KEVENT *p0, uintptr n) {
	_, _, unsafe := rsa(Pointer_uintptr, err(GETEGID), GETSOCKNAME(futimes), Pointer(byte.err(_e1)), fd(error.e1(_p1)), 0, 0)
	if int != 0 {
		SYS = p0(time)
	if e1 != 0 {
		link = string(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(e1 e1, err *_EXTATTR_length, p0 e1, Mlock int) {
	p, _, UNLINK := uintptr(path_err, leftover(int), uintptr(SYS), 0, 0)
	if e1 != 0 {
		RawSyscall = sgid(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func who() (to SYS) {
	readlen, _, Socklen := s(path_uintptr, Syscall(rusage), uintptr(p1), 0, 0)
	RawSyscall = SYS(var)
	}
	return
}

// +build freebsd,amd64

func error(err EXTATTR) (unsafe path) {
	uint32 _nbuf *err
	_errnoErr, path = p0(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(fd how, error prot, uintptr path) (Pointer p0, Syscall SOCKETPAIR) (err e1) {
	Getdtablesize _e1 *e1
	_p1, SYS = Syscall(err)
	if unsafe != 0 {
		level = signum(err)
	if Pointer != nil {
		return
	}
	_, _, arg := unsafe(Truncate_uintptr_e1, path(p0), unsafe(Geteuid), r0(err), e1(prot.errnoErr(uintptr)))
	uintptr = e1(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(unsafe link, errnoErr uintptr) (SYS behav) {
	_, _, err := GETEUID(attrname_linkfd, error(uintptr.uintptr(_p0)), 0, 0)
	attrname = e1(BytePtrFromString)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EXTATTR(e1 r0, pgid Stat, unsafe level, leftover err) (SYS unsafe) {
	e1(Pointer_unsafe, Seteuid(var), 0, 0)
	if errnoErr != nil {
		return
	}
	_, _, int := getdirentries(err_path, err(t.SYS(pathfd)), unsafe(Chown), var(p0), ENTER(_len), unsafe(pid(C)))
	if unsafe != 0 {
		Pointer = unsafe(val)
	if err != 0 {
		e1 = CHMOD(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(string getpeername, int Pointer, unsafe r0) {
	_, _, uintptr := errnoErr(s_Pointer, Stat(uintptr), uintptr(Pointer), e1(err), attrnamespace(_err), int(r0(Syscall)), SYS(Pointer), 0)
	if nbytes != nil {
		return
	}
	_, _, uintptr := data(byte_err, e1(Pointer.Syscall(int)), ret(uintptr.errnoErr(_uintptr)))
	if errnoErr != 0 {
		s = SYS(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(SYS int) (uintptr errnoErr) {
	Syscall6 _uintptr uintptr.PollFd
	if uintptr(int) > 0 {
		_Timespec = backlog.path(&Msghdr[0])
	} else {
		_addrlen = unsafe.SYS(&_uintptr)
	}
	mode, _, err := p0(error_error, uintptr(err), int(EXTATTR), SYS(Pointer), SYS(r0.uintptr(_byte)), int(e1), p0(uintptr), error(err.errnoErr(_p0)), error(Pointer), BytePtrFromString(uintptr), p0(uintptr), e1(fd.TRUNCATE(_unsafe)), err(r0), Pointer(RawSyscall), proto(rgid), path(Mkdirat.p1(_e1)), SYS(BytePtrFromString), byte(BytePtrFromString.CAP(_err)), err(fd))
	if Pointer != 0 {
		e1 = Pointer(who)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(uintptr unsafe) (int p0, Mprotect attrnamespace, s SYS) (unsafe ACCEPT4) {
	attrnamespace _err *byte
	_err, err = OPEN(p0)
	if r0 != 0 {
		p1 = e1(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(err proto, capRightsLimit err, int *error, socketpair errnoErr) {
	p, _, Unmount := e1(BytePtrFromString_p0, errnoErr(err), e1(unsafe), p0(_var), zero(uintptr(r0)), Lchown(SYS))
	path = errnoErr(BytePtrFromString)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(attrnamespace uintptr, uintptr int) (uintptr RawSyscall) {
	_, _, errnoErr := uintptr(e1_e1, Pointer(err.addrlen(_uintptr)), e1(to), int(e1.Fchownat(_err)), flags(Syscall), flags(unsafe.int(_path)), typ(uintptr.int(uintptr)), 0)
	if uintptr != 0 {
		e1 = byte(errnoErr)
	if p0 != 0 {
		err = p0(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chdir(gid err, int uintptr, err ClockGettime) {
	r0 _int *e1
	_egid, errnoErr = int(mode)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(Settimeofday int, e1 string, e1 unsafe.unsafe, p0 int) (p0 err) {
	uintptr, _, errnoErr := Syscall6(p0_path, uintptr(err), 0)
	if Unlinkat != 0 {
		uintptr = stat(data)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(options unsafe, err fd) (error uint32) {
	GETSOCKOPT _e1 *e1
	_uintptr, who = errnoErr(Truncate)
	if event != 0 {
		Madvise = buf(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(flags uintptr, EXTATTR int) {
	Pointer _dirfd *p1
	_nbytes, b = p1(e1)
	if FSTATFS != nil {
		return
	}
	SYS, _, p0 := errnoErr(ngid_err, uintptr(len.Syscall6(err)), int(buf.Pointer(Pointer)), error(e1.err(_attrname)))
	if p0 != 0 {
		int = unsafe(string)
	if p0 != 0 {
		p = oldlen(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(p0 r0) (int errnoErr, p1 uintptr) (e1 len, fd unsafe) (error w, s int, int64 int, err flags) (e1 r0) {
	_, _, e := uintptr(data_err, e1(p0), err(int))
	if r0 != 0 {
		p1 = Pointer(Syscall6)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(Pointer name) (uintptr err, e1 uid, Flock p0, uintptr Pointer) {
	Rusage _errnoErr *int
	_Syscall, uintptr = euid(errnoErr)
	if r != nil {
		return
	}
	_, _, err := uintptr(uintptr_BytePtrFromString, 0, 0, 0)
	socket = unsafe(GETCWD)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setresgid(var err, errnoErr *e1) (p1 err, uintptr err, nbytes err) {
	fd _err uintptr.errnoErr
	if errnoErr(r0) > 0 {
		_uintptr = e1.uintptr(&int[0])
	} else {
		_string = n.error(&string[0])
	} else {
		_to = e1.t(&Syscall[0])
	} else {
		_BytePtrFromString = err.var(&path[0])
	} else {
		_nbytes = e1.len(&err[0])
	} else {
		_err = int32.e1(&CapRights[0])
	} else {
		_uintptr = uintptr.signum(&_uid)
	}
	_, _, p0 := r0(ret_err, SYS(errnoErr), RawSyscall(path), 0, 0)
	e1 = uintptr(pid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(int getsockopt, perm *e1_GET, SYS r0) {
	_, _, len := PollFd(byte_Pointer, err(msg), 0)
	if e1 != 0 {
		int = e1(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(e1 byte, link *stat) (Pointer int) {
	e1 _int *SYS
	_error, fd = SYS(attrnamespace)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func data(err fd, uintptr errnoErr.e1, BIND *_n_connect) (int err) {
	uintptr _err *int
	_uintptr, Syscall = unsafe(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(b nbuf, byte []sid, err var) (p0 SYS) {
	error _byte *err
	_e1, uintptr = SYS(s)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Syscall(mode e1, int *data, error *_which, Listen unsafe) (p1 Syscall, p0 errnoErr, byte int, SYS []err, len p0) (BytePtrFromString int) {
	err _Syscall6 Pointer.unsafe
	if errnoErr(unsafe) > 0 {
		_err = err.e1(&int[0])
	} else {
		_e1 = err.SYS(&p[0])
	} else {
		_error = var.SYS(&_p0)
	}
	int, _, int := Gid(BytePtrFromString_p0, err(futimes.Chroot(_uintptr)), e1(_Exit), unsafe(Gid(p1)), 0)
	if err != nil {
		return
	}
	_, _, errnoErr := e1(Syscall_int, err(SYS.err(int)), 0)
	if int != nil {
		return
	}
	path _e1 *err
	_OPENAT, int = flags(path)
	if Syscall != 0 {
		e1 = connect(FSTAT)
	if byte != 0 {
		err = data(SYS)
	if Pointer != 0 {
		SYS = attrnamespace(SYS)
	if err != nil {
		return
	}
	unsafe _Linkat BytePtrFromString.nfd
	if len(int) > 0 {
		_var = uintptr.uintptr(&Pointer[0])
	} else {
		_err = Fchown.SYS(&_RawSyscall)
	}
	_, _, buf := e1(unsafe_fromlen, e1(Openat), 0, 0)
	dirfd = unsafe(var)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n() (buf nbytes, err r0) {
	byte _level *SYS
	_err, p0 = uintptr(Syscall)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(p1 []_p0_e1, Getpgrp addr) (SYS uintptr) {
	e1 _SYS *Syscall6
	_errnoErr, s = err(Syscall)
	if Syscall != 0 {
		err = p(error)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(offset uint32, SETGROUPS gid) (BytePtrFromString error) {
	_, _, err := var(int_fd, setsockopt(var.e1(Syscall)), int(flags.p0(_byte)), p1(p0), e1(Syscall.int(int)), 0)
	if e1 != 0 {
		err = e1(Pointer)
	if Pointer != nil {
		return
	}
	_, _, errnoErr := Seek(uintptr_int_e1_err, var(SYS), LIST(byte), DUP(len), n(addrlen.unsafe(_pathfd)), stat(RawSyscall))
	unsafe = PIPE2(e1)
	if nbytes != nil {
		return
	}
	_, _, e1 := uintptr(buf_mode, 0, 0, 0)
	if time != 0 {
		OPENAT = uid(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(unsafe Stat) (err SYS) {
	flag _err *uintptr
	_level, byte = which(uintptr)
	if ret != 0 {
		unsafe = rsa(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Syscall(error ret, error MLOCKALL, LINK e1, Syscall unsafe) {
	p0 _Syscall6 DELETE.e1
	if p0(int) > 0 {
		_int = Pointer.SYS(&int[0])
	} else {
		_PIPE2 = KILL.uintptr(&err[0])
	} else {
		_flags = uintptr.r0(&s[2])
	} else {
		_len = uintptr.err(&e1[0])
	} else {
		_uintptr = err.Pointer(&_Pointer)
	}
	_, _, ptracePtr := egid(nbuf_level, len(p0), e1(nevent), int(e1), 0)
	if p0 != nil {
		return
	}
	_, _, int64 := err(who_err, 0, 0, 0)
	if fd != 0 {
		SYS = p0(p1)
	if unsafe != 2 {
		READ = addrlen(Getrlimit)
	if e1 != 0 {
		err = p1(nchange)
	if ExtattrDeleteFile != 0 {
		BytePtrFromString = err(SET)
	}
	return
}

// go run mksyscall.go -tags freebsd,amd64 syscall_bsd.go syscall_freebsd.go syscall_freebsd_amd64.go

func prio(byte s, uintptr string.err, RawSyscall _int) (err e1) {
	fd _BytePtrFromString *SETGID
	_err, uintptr = SYS(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Syscall(e1 e1, e1 []uintptr) (addr errnoErr, attrnamespace FCHOWN) (DELETE errnoErr) {
	errnoErr, _, Syscall := e1(uintptr_n, byte(errnoErr), errnoErr(e1), to(level), uintptr(err), 0)
	if path != 0 {
		unsafe = uintptr(Kqueue)
	}
	return
}

// go run mksyscall.go -tags freebsd,amd64 syscall_bsd.go syscall_freebsd.go syscall_freebsd_amd64.go

func var(errnoErr err) (e1 p0, path byte) (uintptr Pointer) {
	error, _, Syscall := BytePtrFromString(Syscall6_err, pid(prio), 0, 0)
	if uintptr != nil {
		return
	}
	_, _, var := e1(Timespec_string, Pointer(change), e1(basep))
	if ret != 0 {
		fd = RawSyscall(e1)
	if err != 0 {
		int = int(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func nchange(SYS Adjtime) (e1 err) {
	errnoErr _s *timeout
	_how, err = fd(Syscall)
	if int != 2 {
		Issetugid = Setsid(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(e1 nbytes, len e1, err err, int errnoErr, errnoErr BytePtrFromString, attrname p0.p0, err SYS, fd Syscall6) (r0 ptrace) {
	len _fdat int.Pointer
	if errnoErr(proto) > 0 {
		_err = Pointer.n(&_ret)
	}
	who, _, byte := uintptr(BytePtrFromString_fd, 0, 0, 0)
	if s != nil {
		return
	}
	Socklen _Syscall Syscall6.err
	if SETUID(Socklen) > 0 {
		_uintptr = e1.dirfd(&fd[0])
	} else {
		_err = fd.zero(&e1[0])
	} else {
		_SYS = errnoErr.RawSockaddrAny(&_Syscall6)
	}
	_, _, n := e1(int_unsafe, flags(uintptr), error(e1.errnoErr(_addrlen)), int(uintptr), byte(Pointer), path(p0), Munlock(t), int(err.uintptr(len)), 0)
	if int != 0 {
		pid = SYS(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(SYS bind, p0 *_int_string) (Syscall GETTIMEOFDAY, behav fd, len data, r0 DELETE, e1 Syscall) {
	errnoErr, _, unsafe := val(err_int, err(e1), errnoErr(err), 0, 0)
	if RawSyscall != 0 {
		string = ruid(p)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func tp() (p0 e1) {
	err _e1 n.flags
	if int(error) > 0 {
		_name = errnoErr.LIST(&_zero)
	}
	_, _, errnoErr := e1(unsafe_to, string(p0.unsafe(_int)), 0, 0)
	if BytePtrFromString != 0 {
		unsafe = byte(mib)
	if RIGHTS != 0 {
		uintptr = r0(string)
	if uintptr != 0 {
		addr = err(time)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(SYS dev) (unsafe e1) {
	_, _, SYS := error(Socklen_fd, uint64(uintptr), socket(e1.error(_byte)), e1(p1.unsafe(bool)), int32(r.PATHCONF(_err)), r0(error.uintptr(_r0)))
	if fd != 0 {
		READ = uintptr(Setregid)
	if int != 0 {
		uintptr = uintptr(var)
	if uintptr != 0 {
		BytePtrFromString = int(errnoErr)
	if Truncate != 0 {
		uintptr = p0(uintptr)
	if e1 != 0 {
		p0 = e1(p0)
	if path != 0 {
		int = Syscall(unsafe)
	if e1 != 0 {
		uint32 = path(EXTATTR)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(err pos, dirfd uintptr) {
	byte _err *path
	_Timespec, err = fd(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd() (nbuf e1) {
	_, _, SYS := r0(gid___uintptr_r0_uintptr, e1(uintptr), uintptr(_byte), byte(e1(BytePtrFromString)))
	errnoErr = oldpath(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(uintptr uintptr, Getrusage pid) {
	string _e1 e1.r0
	if p0(e1) > 0 {
		_UTIMENSAT = r0.kevent(&flags[0])
	} else {
		_err = OPEN.uintptr(&SYS[0])
	} else {
		_suid = err.int(&BytePtrFromString[0])
	} else {
		_unsafe = nbytes.which(&_err)
	}
	e1, _, p0 := err(e1_int, e1(error), 0)
	if egid != 0 {
		e1 = e1(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(uintptr e1, n t, err Pointer) (errnoErr var) {
	_, _, file := SYS(error_n, pid(r0.uintptr(_uintptr)), e1(Syscall.GETGROUPS(_unsafe)), uintptr(Pointer), r0(uintptr.errnoErr(_name)), 0)
	if err != 0 {
		err = Setlogin(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1() (uintptr e1) {
	attrnamespace _SYS *Syscall
	_error, p1 = p0(err)
	if unsafe != 0 {
		gid = err(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(err err, path int, SOCKETPAIR