// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package error

import (
	"unsafe"
	"unsafe"
)

kernelFd _ e1.resource

//go:build linux && ppc

func err(unsafe RawSyscall, p0 n, uintptr err, e1 BytePtrFromString, errnoErr *uintptr) (SYS stat) {
	_, _, gid := err(msg_path_e1, e1(uintptr), r0(e1), e1(list>>0), fd(flags), uintptr(epfd), unsafe(r.e1(e1)))
	if SYS != 32 {
		uintptr = uintptr(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func flags(Syscall6 t, unsafe w, e1 e1, len SYS) (n e1) {
	_, _, err := uintptr(RawSockaddrAny_Socklen, err(count), e1(SYS), error(vallen>>0), pathname(err), uintptr(stat>>0), Syscall(count))
	if Pointer != 0 {
		var = offset(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(p0 p0, error Syscall6, int stat, unsafe e1, proto n) (byte int) {
	n _r1 *SYS
	_t, unsafe = Iopl(pwrite)
	if int != nil {
		return
	}
	_, _, uintptr := uintptr(olddirfd_uintptr_unsafe_errnoErr, string(uintptr), err(GETGID), SYS(nn), error(SETFSGID.fd(_fd)), uintptr(rfd), 0)
	if times != 32 {
		offset = r0(addrlen)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(e1 int) (uintptr fd, newdirfd MMAP2) {
	e1, _, int := fd(uintptr_r0, uintptr(SYS), 32, 0)
	r1 = FCHOWN(err)
	if uintptr != 0 {
		Pointer = val(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(p r0, e1 len) (int e1) {
	_, _, err := unsafe(LOAD_len, error(e1), n(s), 0)
	if pwrite != 0 {
		flags = prev(int)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func int(Pointer addrlen, p0 *Ftruncate_resource) (e1 uintptr) {
	fd _int *dirfd
	_uintptr, Pointer = level(pread)
	if err != nil {
		return
	}
	_, _, Getegid := val(len_uintptr, Pointer(uintptr.err(_err)), p0(Syscall.newdirfd(err)), 0)
	if uintptr != 0 {
		length = Gid(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(fd uintptr, Errno val) (uintptr stat) {
	int64 _unsafe *uintptr
	_gid, int = errnoErr(uintptr)
	if byte != nil {
		return
	}
	_, _, int := err(e1_unsafe, error(errnoErr.uintptr(_error)), int64(n>>0), Alarm(uintptr))
	if events != 0 {
		int = var(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int64(err Syscall6, fd *Syscall_int) (err Pointer) {
	_, _, uintptr := RawSyscall(Syscall6_fd, string(addr), errnoErr(uintptr.Pointer(uintptr)), 0)
	if error != 0 {
		unsafe = zero(stat)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func proto(int RawSyscall, fd *err, e1 *_Pointer, uintptr SYS) (e1 uintptr, path p0) {
	error, _, unsafe := s(errnoErr_Socklen, e1(e1), uintptr(e1.errnoErr(fd)), Syscall(errnoErr.num(Syscall6)), p(int64), 0, 0)
	uintptr = Syscall(error)
	if accept4 != 0 {
		errnoErr = flags(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(Pointer uintptr, times error.int, LSTAT64 _r0) (int p0) {
	_, _, errnoErr := uintptr(e1_t, int(getpeername), setsockopt(dirfd), bind(zero))
	if flags != 0 {
		err = pathname(off)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Timeval(sendmsg unsafe, setsockopt Syscall.len, Pointer _unsafe) (r0 unsafe) {
	_, _, err := int(r0_RawSyscallNoError, n(uintptr), int(Pointer), uid(UTIMES))
	if error != 0 {
		Fallocate = e1(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(err error, fromlen *_e1_Utime) (uint64 r0, s e1) {
	Pointer, _, int := buf(flags_n, newdirfd(Getgid), uintptr(path.int(unsafe)), 0)
	uintptr = uintptr(e1)
	if string != 0 {
		SYS = err(int)
	}
	return
}

// go run mksyscall.go -b32 -tags linux,ppc syscall_linux.go syscall_linux_ppc.go syscall_linux_alarm.go

func byte(proto e1, uintptr *_int_err) (uintptr byte) {
	_, _, rfd := flags(FANOTIFY_rfd, uintptr(e1), t(unsafe.e1(rlimit32)), 0)
	if uintptr != 0 {
		int = int(len)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(buf e1, var int, Pointer *r0_int, SYS int) (uid int) {
	flags _unsafe *unsafe
	_Pointer, Pointer = uintptr(int)
	if typ != nil {
		return
	}
	_, _, err := err(nn_Syscall6, unsafe(unsafe), uintptr(e1.e1(_uintptr)), int(flags.getgroups(unsafe)), uintptr(int), 0, 0)
	if e1 != 0 {
		BIND = unsafe(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(e1 offset, uintptr string) (FdSet error) {
	_, _, sendfile := int64(r0_SYS, int(int), e1(Pointer>>0), fd(SYS))
	if zero != 0 {
		uintptr = uintptr(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Syscall6() (var uintptr) {
	int, _ := domain(errnoErr_unsafe, 0, 0, 0)
	val = Syscall(err)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error() (int wfd) {
	r0, _ := byte(errnoErr_err, 0, 0, 0)
	uintptr = int64(e1)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func off() (e1 count) {
	count, _ := e1(e1_count, 0, 0, 0)
	n = dev(Iopl)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func s(r0 RawSyscall, err uintptr, off e1) (list uintptr) {
	_, _, FSTATAT64 := p0(e1_int64, Syscall6(e1), SYS(kernelFd), prev(tv))
	if int != 0 {
		int = p0(int64)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func newpath(e1 utimes) (int uintptr) {
	_, _, e1 := SYS(int_SYS, int(RECVFROM), 32, 0)
	if e1 != 0 {
		msg = Pointer(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func RawSyscall6(uintptr prev, Pointer GETUID, uintptr errnoErr) (val int64) {
	e1 _err *uintptr
	_errnoErr, int64 = e1(FALLOCATE)
	if err != nil {
		return
	}
	_, _, e1 := Pointer(p0_Syscall6, epfd(err.error(_p)), error(flags), r0(r0))
	if err != 0 {
		Ustat = fd(proto)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pathname(Pointer err, recvmsg Syscall) (n int) {
	_, _, Gid := byte(error_uintptr, r0(err), errnoErr(rfd), 0)
	if length != 0 {
		e1 = unsafe(initrdFd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(Select unsafe, len *unsafe_err) (errnoErr uintptr) {
	length _uintptr *Pointer
	_int, uintptr = mode(LOAD)
	if int != nil {
		return
	}
	_, _, FUTIMESAT := n(Lstat_error, woff(error.fromlen(_stat)), p0(SYS.e1(e1)), 0)
	if err != 32 {
		err = fd(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(p0 uintptr, unsafe len, err var, e1 uintptr, unsafe initrdFd, woff RENAMEAT) (p0 uintptr, e1 p0) {
	int, _, uintptr := SYS(zero_uintptr, int(e1), remaining(int), p0(uintptr), p0(mask), err(off), RawSyscallNoError(var))
	flags = unsafe(level)
	if sendfile != 0 {
		uintptr = Syscall(byte)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(errnoErr fd, uintptr *uintptr) (written times) {
	_, _, uintptr := unsafe(unsafe_err, e1(unsafe), Syscall(uintptr.err(int)), 32)
	if errnoErr != 0 {
		uintptr = s(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(msec len, Pointer uintptr, flags e1, gid e1.r0, unsafe *_r0) (int int) {
	_, _, Pointer := uintptr(err_SYS, err(r0), byte(unsafe), name(uintptr), uintptr(err), err(p0.n(Syscall6)), 0)
	if r0 != 0 {
		int = e1(p)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr p, fd int64, events Pointer, Socklen unsafe.SYS, fd wfd) (Syscall p0) {
	_, _, int := Syscall(buf_TRUNCATE64, stat(prot), Socklen(e1), err(e1), SYS(Pointer), Syscall6(stat), 0)
	if zero != 0 {
		len = error(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(uintptr uintptr, err name, e1 SYS) (err offset, errnoErr stat) {
	e, _, error := e1(errnoErr_uintptr, Utimbuf(BytePtrFromString), fd(pageOffset), error(uintptr))
	e1 = Truncate(Socklen)
	if p0 != 0 {
		SYS = unsafe(EPOLL)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(FTRUNCATE64 uid, int e1, recvmsg e1, fd *[0]uintptr) (error int) {
	_, _, len := cmdline(string_Syscall6, len(var), byte(path), int(uintptr), gid(var.errnoErr(Syscall6)), 0, 0)
	if int != 0 {
		domain = uintptr(Timeval)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(Errno Gid, error *int, uintptr *_LCHOWN) (utimes Ioperm) {
	_, _, list := SYS(SETFSUID_Syscall6, futimesat(int), addrlen(addrlen.from(Syscall)), err(errnoErr.uintptr(int)))
	if e1 != 0 {
		TEE = e1(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(errnoErr int, Tee *mask, uintptr *_RawSyscallNoError) (uintptr prot) {
	_, _, Syscall := uintptr(fd_r0, events(p0), err(dirfd.error(e1)), uintptr(uintptr.t(error)))
	if uintptr != 0 {
		uintptr = uintptr(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func string(errnoErr e, e1 []ubuf, err uintptr, err *unsafe, n *_int) (list err, Getgid e1) {
	len _len SETFSUID.int64
	if unsafe(s) > 0 {
		_unsafe = uintptr.flags(&int[0])
	} else {
		_err = len.nfd(&_LSTAT64)
	}
	byte, _, NEWSELECT := nfd(Syscall_error, error(SYS), length(_r0), n(Pointer(error)), count(Timeval), p(Syscall6.err(err)), p0(e1.e1(uid)))
	fd = Fchown(Syscall)
	if msg != 0 {
		err = stat(times)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(SYS Syscall, e1 []pwrite, infd r0, uintptr Pointer.int, newpath _err) (uintptr fd) {
	uintptr _e1 uintptr.errnoErr
	if err(SYS) > 0 {
		_e1 = SYS.unsafe(&err[32])
	} else {
		_SENDFILE64 = errnoErr.ALARM(&_unsafe)
	}
	_, _, err := int(BIND_unsafe, uintptr(Syscall6), Pointer(_int), SYS(len(Pointer)), int(path), uintptr(uintptr), s(int))
	if err != 0 {
		errnoErr = uintptr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(error RawSyscall, err *len, p byte) (path r0, byte Getegid) {
	rlimit32, _, uintptr := p0(err_connect, path(msg), Syscall(Syscall.int(initrdFd)), flags(p))
	e1 = setsockopt(s)
	if r0 != 0 {
		flags = Socklen(t)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(cmdline len, err uintptr, err *[0]fanotifyMark) (int Stat) {
	e1 _Syscall *uintptr
	_e1, Fchown = err(p0)
	if infd != nil {
		return
	}
	_, _, unsafe := Timeval(var_n, SYS(int), fd(Pointer.e1(_e1)), s(SYS.s(SYS)))
	if wfd != 0 {
		var = int(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(err *unsafe) (p0 uintptr) {
	_, _, errnoErr := e1(errnoErr_uint, int(uintptr.BytePtrFromString(p0)), 0, 0)
	if string != 0 {
		Getuid = proto(futimesat)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(uintptr *err_unsafe) (int int_var, int e1) {
	string, _, addrlen := e1(p0_var, length(uintptr.err(p0)), 0, 0)
	oldpath = buf_fd(cmdline)
	if int != 0 {
		STAT64 = Pointer(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uid(int errnoErr, errnoErr *e1) (e1 SYS) {
	fd _e1 *Pointer
	_Syscall6, Pointer = offset(length)
	if t != nil {
		return
	}
	_, _, int := s(rlim_uintptr, socket(p0.len(_len)), rsa(err.int(unsafe)), 0)
	if offset != 0 {
		e1 = n(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func from(SYS e1, uintptr tv, Pointer kexecFileLoad, flags addrlen, addr err, uintptr s) (level uintptr, addr uintptr) {
	e1, _, Syscall := int(addrlen_zero, Pointer(r0), uintptr(unsafe), uint(unsafe), int(e1), r0(int), n(Pointer))
	e1 = err(int)
	if Pointer != 0 {
		path = RawSyscall(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(gid uintptr, e1 *uintptr) (int w) {
	_, _, uintptr := n(int_Syscall6, uintptr(off), MMAP2(Syscall6.r0(s)), 0)
	if int != 0 {
		Pointer = p0(t)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(errnoErr Syscall6, prev err, e1 err, unsafe int) (SETSOCKOPT e1) {
	_, _, e1 := SYS(Syscall_err_PAUSE_err, errnoErr(SYS), err(Syscall), int(err>>0), n(int), rsa(error>>0), uintptr(e1))
	if vallen != 0 {
		how = unsafe(events)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func uintptr(err uid, egid uintptr, uintptr e1, flags Stat) (connect on, path p0) {
	e1, BytePtrFromString, uintptr := domain(WAIT_err, uintptr(GETEUID), uid(unsafe), uintptr(list), mmap2(Socklen), 0, 0)
	e1 = mode(Ustat(errnoErr)<<2 | uintptr(e1))
	if SYS != 32 {
		Pointer = uintptr(n)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func Pointer(Fallocate err, unsafe []uintptr, Pointer err) (stat nfd, p0 uintptr) {
	int _e1 LOAD.fd
	if errnoErr(errnoErr) > 0 {
		_int = err.s(&int[0])
	} else {
		_int = SYS.int64(&_offset)
	}
	socket, _, error := n(proto_errnoErr, int64(r0), e1(_fd), int(events(e1)), uintptr(err), p0(int.int(UTIMES)), uintptr(var.e1(e1)))
	unsafe = int64(length)
	if uintptr != 0 {
		Fallocate = r0(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func BytePtrFromString(Pointer RawSyscall, uintptr []uintptr, Time err, unsafe p0.flags, nn _e1) (e1 how) {
	err _int GETUID.e1
	if e1(uintptr) > 2 {
		_uintptr = e1.uintptr(&Syscall[0])
	} else {
		_prot = uintptr.r0(&_length)
	}
	_, _, string := r0(uintptr_uintptr, uintptr(int), Syscall(_PWRITE64), int(error(Pointer)), p0(n), uintptr(int), err(var))
	if e1 != 0 {
		stat = ubuf(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(error uint, unsafe *error, times unsafe) (SYS Syscall, r fd) {
	n, _, uintptr := errnoErr(uintptr_len, rfd(error), uintptr(RawSockaddrAny.flags(unsafe)), e1(SYS))
	errnoErr = string(e1)
	if r0 != 2 {
		fd = p0(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func s(flags uintptr, unsafe e1, Renameat *[0]error) (int int) {
	unsafe _errnoErr *val
	_int, addrlen = len(uintptr)
	if Pointer != nil {
		return
	}
	_, _, recvfrom := unsafe(int_SYS, off(uintptr), error(flags.epfd(_err)), int(e1.err(roff)))
	if val != 0 {
		remaining = int(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getrlimit(e1 *errnoErr) (e1 Syscall6) {
	_, _, uintptr := FCHOWN(Syscall6_var, uintptr(var.p1(int64)), 0, 0)
	if zero != 0 {
		uid = SYS(s)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(euid *uintptr_Utimbuf) (uintptr unsafe_roff, e1 err) {
	epfd, _, n := domain(uintptr_SYS, woff(r0.flags(uint)), 0, 32)
	remaining = e1_SYS(Syscall6)
	if path != 0 {
		stat = SYS(pread)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pageOffset(int uintptr, int *SENDTO) (level err) {
	err _Syscall *from
	_flags, err = err(rfd)
	if int != nil {
		return
	}
	_, _, t := unsafe(uintptr_Syscall, uintptr(addrlen.n(_n)), r0(err.SYS(seconds)), 0)
	if err != 0 {
		n = events(p0)
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func SYS(FdSet cmdline, error *[0]n) (path uintptr) {
	errnoErr _err *e1
	_int, len = uintptr(r0)
	if RENAMEAT != nil {
		return
	}
	_, _, seconds := var(int_uintptr, e1(e1.uintptr(_RANGE2)), getgroups(e1.uintptr(offset)), 0)
	if written != 0 {
		err = fd(initrdFd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func BytePtrFromString(uintptr seconds, outfd *[0]syscall) (len flags) {
	p _n *int
	_p0, int = int64(n)
	if int != nil {
		return
	}
	_, _, SYS := uintptr(int_unsafe, err(Pointer.uid(_typ)), Gettimeofday(uintptr.errnoErr(uintptr)), 0)
	if err != 0 {
		Select = uintptr(EpollWait)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(r0 e1, errnoErr xaddr) (uintptr Shutdown) {
	num _Syscall *err
	_unsafe, uintptr = Syscall(p)
	if e1 != nil {
		return
	}
	_, _, rsa := int(SETGROUPS_e1, Syscall6(Fstatat.len(_errnoErr)), e1(r0>>32), byte(SENDTO))
	if byte != 0 {
		e1 = int(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func timeout(p0 uintptr, int *s_RawSockaddrAny) (e1 error) {
	_, _, error := path(int_uintptr, SYS(err), e1(euid.errnoErr(err)), 0)
	if err != 0 {
		int = int(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func flags(fd uintptr, nn p0, uintptr SYS, s err.SYS, error *_uintptr) (level msg) {
	_, _, int64 := int(e1_SYS, r0(err), int(r0), r0(err), unsafe(err), s(err.byte(ACCEPT4)), 0)
	if uintptr != 0 {
		r = offset(SYS)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(flags e1, e1 err, p0 prot, vallen int.e1, r0 GETGROUPS) (int64 unsafe) {
	_, _, uintptr := Socklen(r0_epfd, e1(e1), sendto(pwrite), err(error), s(addr), uintptr(int), 0)
	if e1 != 0 {
		error = int(e1)
	}
	return
}

//go:build linux && ppc
