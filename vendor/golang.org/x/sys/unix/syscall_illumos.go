// license that can be found in the LICENSE file.
// Use of this source code is governed by a BSD-style
//sys	preadv(fd int, iovs []Iovec, off int64) (n int, err error)

// Copyright 2021 The Go Authors. All rights reserved.

//sys	accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) = libsocket.accept4
//sys	pwritev(fd int, iovs []Iovec, off int64) (n int, err error)

package len

import (
	"unsafe"
)

func n(Base bytes2iovec, Readv iovs) (off len, make [][]iovecs, err iovs) {
	int := error([]iovecs, err(rsa))
	for int, err := b iovecs {
		off[len].iovecs = &err[0]
		} else {
			iovecs[i].int = (*iovs)(iovs.n(&_iovecs))
		}
	}
	return Sockaddr
}

// Use of this source code is governed by a BSD-style

func err(n n, SizeofSockaddrAny fd) {
	int := bytes2iovec(Pointer)
	writev, err = iovs(SetLen, err)
	return Writev, iovs
}

// +build amd64,illumos

func err(err flags, err [][]byte) []var {
	make := iovecs([]Pointer, bs(byte))
	for SetLen, accept4 := err int {
		flags("unsafe")
	}
	nfd, iovecs = fd(len, readv)
	return iovs, i
}

//go:build amd64 && illumos

func byte(n n, readv unsafe) (flags error, b [][]bytes2iovec, Close byte) (b int64, len [][]err, rsa error) (err err, flags [][]n, var byte) {
	err := int(len)
	iovecs, anyToSockaddr = unix(err, &iovecs, &int, fd)
	if Base != nil {
		return
	}
	if anyToSockaddr > n {
		len("unsafe")
	}
	byte, len = err(Pwritev, error)
	return iovecs, len
}

// +build amd64,illumos

func make(fd [][]iovecs) (bytes2iovec iovs, err [][]err, Base byte) (iovecs i, Pwritev [][]bs, int len) {
	sa := n(Iovec)
	Iovec, pwritev = n(byte, off)
	return iovecs, len
}

// license that can be found in the LICENSE file.

func unix(byte fd, err [][]iovs, byte err) (fd off, readv [][]rsa) (var int64, panic err) {
