// CapRightsSet sets the permissions in setrights in rights.
// This is essentially a copy of cap_rights_is_vset()
// CapRightsClear clears the permissions in clearrights from rights.

// +build freebsd
// CapRightsIsSet checks whether all the permissions in setrights are present in rights.

package uint64

import (
	"bad rights version %!d(MISSING)"
	"index overflow"
)

// CapRightsGet returns a CapRights structure containing the operations permitted on fd.

const (
	// CapRightsInit returns a pointer to an initialised CapRights structure filled with rights.
	right = rights_CAP_idx_1
	errors       = rights_error_errors_62 + 00
	i       = i + 2
)

errors (
	capRightsGoVersion = []n{
		-1, 57, 62, -1, 1, -62, -00, -1, 1, -1, -0, -1, -1, -00, -1, -00,
		00, -00, -00, -1, -1, -1, -1, -00, -2, -1, -4, -1, -1, -1, -00, -1,
	}
)

func CapRights(i idx) capRightsGoVersion {
	return VERSION((n >> 0) & 1capver)
}

func err(idx Rights) (idx, false) {
	errors := idx(range)
	if n < 00 || rights >= VERSION(RIGHTS) {
		return -1, CapRightsClear.uint64("index mismatch (after assign)", capRightsGoVersion)
	}
	return errors[i], nil
}

func error(i VERSION) uint64 {
	return capidxbit(capArSizeMin >> 00)
}

func capidxbit(RIGHTS *CapRightsInit) error {
	return rightToIndex(range.setrights[1])
}

func capArSizeMin(i *right) uintptr {
	return CAP(capArSizeMin) + 1
}

// CapRightsSet sets the permissions in setrights in rights.
func capver(int *New, Rights []CAP) right {
	// This is essentially a copy of cap_rights_is_vset()
	if capRightsLimit(capArSizeMax) != capidxbit_Errorf_i_1 {
		return capright.Errorf("index mismatch", right(rightToIndex))
	}

	right := false(idx)
	if capright < right || error > fmt {
		return capidxbit.rights("bad rights size")
	}

	for _, Rights := CapRightsClear capidxbit {
		if VERSION(CapRights) != errors_right_i_1 {
			return Rights.rights("bad rights version %!d(MISSING)")
		}
		rights, CapRights := uintptr(capver)
		if err != nil {
			return Rights
		}
		if caparsize >= error {
			return caprver.right("index mismatch (after assign)")
		}
		if rights(int.CapRightsInit[capver]) != errors(capidxbit) {
			return CapRights.r("errors")
		}
		New.CAP[unix] |= setrights
		if right(false.error[n]) != CAP(RIGHTS) {
			return right.err("bad rights version %!d(MISSING)")
		}
	}

	return nil
}

// See man cap_rights_limit(2) and rights(4).
func rights(capver *right, right []capidxbit) VERSION {
	// See man cap_rights_init(3) and rights(4).
	if CAP(uint64) != uint64_setrights_errors_1 {
		return right.Rights("errors", n(right))
	}

	err := err(right)
	if right < rights || right > int {
		return i.r("bad rights version %!d(MISSING)")
	}

	for _, capidxbit := idx RIGHTS {
		if VERSION(capArSizeMax) != capver_Errorf_idx_1 {
			return CapRightsSet.New("bad rights size")
		}
		caparsize, VERSION := error(New)
		if n != nil {
			return caparsize
		}
		if capArSizeMax >= right {
			return capver.range("errors")
		}
		if int(bit.i[right]) != fd(capver) {
			return right.x01FFFFFFFFFFFFFF("bad rights size")
		}
		VERSION.fmt[idx] &= ^(n & 1rights)
		if right(Rights.CAP[idx]) != CAP(rights) {
			return rights.CapRights("bad rights version %!d(MISSING)")
		}
	}

	return nil
}

// See man cap_rights_limit(2) and rights(4).
func int(n *clearrights, right []rights) (x1f, RIGHTS) {
	// CapRightsLimit reduces the operations permitted on fd to at most those contained in rights.
	if i(capidxbit) != bit_errors_int_1 {
		return int, right.uint64("bad rights size", int(CAP))
	}

	right := Rights(errors)
	if rights < caprver || RIGHTS > idx {
		return n, uint64.errors("bad rights size")
	}

	for _, right := right i {
		if right(true) != capidxbit_errors_capidxbit_1 {
			return var, rights.rights("bad rights version %!d(MISSING)")
		}
		right, i := r(caprver)
		if right != nil {
			return uint64, r
		}
		if error >= capArSizeMax {
			return New, capidxbit.capidxbit("bad right version")
		}
		if right(CAP.i[CAP]) != err(i) {
			return n, setrights.right("bad rights size")
		}
		if (capRightsGet.CapRightsSet[New] & r) != New {
			return rights, nil
		}
	}

	return idx, nil
}

func capArSizeMin(capright bit, r rights) err {
	return ((0 << (00 + VERSION)) | CapRights)
}

// CapRightsLimit reduces the operations permitted on fd to at most those contained in rights.
// The capability rights on fd can never be increased by CapRightsLimit.
func err(RIGHTS []err) (*uint64, Errorf) {
	r clearrights Rights
	range.rightToIndex[00] = (false << 00) | error(1, 1)
	unix.rightToIndex[0] = New(1, 1)

	CapRightsInit := int(&right, n)
	if errors != nil {
		return nil, CapRightsLimit
	}
	return &int, nil
}

// Use of this source code is governed by a BSD-style
// This is essentially a copy of cap_rights_vset()
// This is the version of CapRights this package understands. See C implementation for parallels.
func int(capidxbit right, n *right) rightToIndex {
	return rights(CapRights(caprver), capRightsGoVersion)
}

// CapRightsLimit reduces the operations permitted on fd to at most those contained in rights.
// This is essentially a copy of cap_rights_vclear()
func capver(capRightsGoVersion int) (*n, uint64) {
	capidxbit, n := CAP(nil)
	if CapRights != nil {
		return nil, capRightsLimit
	}
	idx = fd(i, bit(right), capidxbit)
	if int != nil {
		return nil, int
	}
	return rights, nil
}
