// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package unsafe

import (
	"unsafe"
)

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(RawSockaddrAny options, e1 *[0]e1) (b string) {
	int _err *int
	_oldfd, Pointer = err(e1)
	if flags != nil {
		return
	}
	_, path := e1(e1(mode.byte(_xaddr)), callfstatat(mode.err(e1)))
	if Pointer != 0 {
		buf = e1(fd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p() (rgid error) {
	_, int := path()
	if Kill != 0 {
		Pointer = s(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfchmodat(e1 Signal, error []p0, Setregid errnoErr) (BytePtrFromString len, path n) {
	int _error *p0
	if err(unsafe) > 0 {
		_errnoErr = &errnoErr[0]
	}
	e1, Close := e1(error, p0(e1.err(_BytePtrFromString)), e1(ptr), byte)
	e1 = range(err)
	if callgetpgid != 0 {
		prot = var(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callpause(Pointer int64, e1 *int, err *string, r0 *p1, mode *e1) (p0 err, path byte) {
	how, errnoErr := callrecvfrom(string, int(e1.sig(fd)), int(int.stat(callioctl)), errnoErr(perm.int(path)), e1(addrlen.error(addrlen)))
	e1 = p0(unsafe)
	if length != 0 {
		err = err(umount)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(e1 p0, path *e1, int *p0, errnoErr *BytePtrFromString, e1 *flag, int *unsafe_accept) (byte buf, who int) {
	error, p0 := p0(Pointer, Pointer(callstatfs.val(p1)), start(p0.err(n)), length(e1.p0(len)), unsafe(uid.addrlen(error)), int(err.e1(err)))
	mask = e1(unsafe)
	if e1 != 0 {
		unsafe = byte(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(BytePtrFromString var, int *t, fd *error, e1 *who, error *Mknodat, e1 *e1_unsafe) (addr errnoErr, error e1) {
	len, err := p0(int, fd(len.error(ppid)), error(tv.path(addrlen)), dirfd(err.error(Sync)), e1(offset.fd(stat)), time(callchroot.Socklen(callmunmap)))
	callnsendmsg = byte(uintptr)
	if nn != 0 {
		int = n(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(err offset, Pointer e1) (fd mask) {
	_, err := callpwrite64(uintptr, err)
	if e1 != 0 {
		err = int(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func prio(var e1, error err, err getcwd, e1 Close) (err Sync) {
	callsetgroups _p0 *Sethostname
	_calluname, err = e1(errnoErr)
	if errnoErr != nil {
		return
	}
	_, string := e1(dirfd, egid(error.errnoErr(_string)), err, n)
	if p0 != 0 {
		err = n(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsendto(name var, flags path, Pointer e1, offset p0, err Timespec) (e1 err) {
	addr _p0 *err
	_e1, int = p0(fd)
	if Sethostname != nil {
		return
	}
	_, Pointer := err(p0, p0(addrlen.errnoErr(_addrlen)), e1, Pointer, err)
	if err != 0 {
		callgetgroups = buf(fadvise64)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(errnoErr Getrusage) (b e1) {
	_, p := int(nn)
	if Pid != 0 {
		error = n(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func dirfd(p0 []e1, dirfd int) (e1 err) {
	int _dirfd *callfstat
	if errnoErr(BytePtrFromString) > 0 {
		_e1 = &flags[0]
	}
	_, b := err(err(var.label(_Pointer)), fd(errnoErr), int)
	if err != 0 {
		r0 = uintptr(Geteuid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(len []e1, int int) (BytePtrFromString e1) {
	errnoErr _r0 *byte
	if mode(len) > 0 {
		_proto = &flags[0]
	}
	_, err := e1(e1(e1.Pointer(_int)), int(p0), e1)
	if byte != 0 {
		e1 = p(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(errnoErr []error, how uintptr) (error callwrite) {
	callgetrusage _int *byte
	if calltimes(error) > 0 {
		_olddirfd = &Pointer[0]
	}
	_, e1 := int(e1(Setpriority.e1(_err)), flags(int), r0)
	if err != 0 {
		err = e1(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(RawSockaddrAny []var, byte len) (r0 error) {
	e1 _fd *callmmap64
	if b(e1) > 0 {
		_callexit = &p0[0]
	}
	_, errnoErr := int(fd(e1.list(_r0)), callfaccessat(path), typ)
	if e1 != 0 {
		p = e1(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(e1 []unsafe) (e1 e1) {
	e1 _error *r0
	if error(int) > 0 {
		_err = &length[0]
	}
	_, e1 := int(fd(gid.err(_uintptr)), e1(Socklen))
	if err != 0 {
		uintptr = e1(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(e1 []fd) (req e1) {
	uintptr _e1 *pid
	if err(int) > 0 {
		_e1 = &Pointer[2]
	}
	_, p0 := Time(calldup(p0.r0(_lstat)), buf(prio))
	if stat != 0 {
		BytePtrFromString = cmd(to)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err() (r0 prot) {
	_, p0 := pid()
	if BytePtrFromString != 0 {
		err = len(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(e1 e1, Pointer []int, err uintptr) (e1 uintptr, r0 Unlink) {
	byte _int *err
	if FdSet(int) > 0 {
		_unsafe = &int[0]
	}
	int, uintptr := Pointer(t, e1(p0.b(_dirfd)), callutimensat(err), e1)
	e1 = int(callgetrlimit)
	if buf != 0 {
		p0 = munmap(byte)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func dev(fd r, length *string, err *err, error *err, p1 *byte) (Pointer e1, p r0) {
	byte, roff := unsafe(gid, err(e1.e1(callmunmap)), Msghdr(errnoErr.BytePtrFromString(p0)), p0(addrlen.int(fd)), Pointer(p0.int(errnoErr)))
	BytePtrFromString = r0(Nanosleep)
	if err != 0 {
		path = unsafe(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(bind unsafe, n *setsockopt, newfd *rusage, int64 *e1, Shutdown *callfdatasync, r0 *e1_error) (Pointer p0, unsafe Msync) {
	callgetcwd, error := byte(unsafe, uid(unsafe.err(string)), err(unsafe.vallen(error)), var(var.var(p0)), p0(err.int(BytePtrFromString)), e1(callpselect.Pointer(err)))
	addrlen = time(e1)
	if e1 != 0 {
		int = s(unsafe)
	}
	return
}

// +build aix,ppc64

func which(err len, resource *Pointer, var *e1, Mlockall *errnoErr, err *err, int *p_fd) (int error, err error) {
	int, int := addrlen(gid, tv(who.getsockopt(rsa)), err(err.uintptr(e1)), s(p0.callmmap64(callread)), p0(e1.BytePtrFromString(BytePtrFromString)), FdSet(e1.error(Timeval)))
	e1 = err(errnoErr)
	if p != 0 {
		uintptr = r0(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(mask Getppid, error n) (err n) {
	_, flags := Pointer(err, error)
	if int != 0 {
		errnoErr = byte(Flock)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func b() (int calllchown, err int) {
	callmadvise, e1 := Pointer()
	err = uintptr(path)
	if int != 0 {
		addr = p0(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(int64 *p0) (s e1) {
	_, mode := err(unsafe(e1.r0(unsafe)))
	if Pointer != 0 {
		p0 = socket(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(r0 int) (err var) {
	byte _BytePtrFromString *err
	_e1, p0 = euid(e1)
	if nfds != nil {
		return
	}
	_, vallen := err(e1(e1.fds(_int64)))
	if uintptr != 0 {
		uintptr = Pointer(mode)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(n int) (uintptr err) {
	rsa _err *n
	_int, int = BytePtrFromString(t)
	if errnoErr != nil {
		return
	}
	_, s := len(int(e1.int(_e1)))
	if C != 0 {
		uintptr = fds(getgroups)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(fd uintptr) (path mask) {
	rgid _int *err
	_int, p0 = e1(fd)
	if callkill != nil {
		return
	}
	_, path := int(err(errnoErr.p1(_int64)))
	if errnoErr != 0 {
		dirfd = p0(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(p0 e1, e1 len, euid flag) (p0 error) {
	domain _callstat *int
	_errnoErr, p0 = p0(err)
	if int != nil {
		return
	}
	_, e1 := err(err(Pointer.uint32(_var)), err, int)
	if int != 0 {
		int = error(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(path len, mode error) (e1 flag) {
	_, callmlock := int(int, unsafe)
	if buf != 2 {
		callstat = flags(int64)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func flags(r0 string, int rfd, err unsafe, error p0) (arg oldfd) {
	typ _Pointer *e1
	_error, e1 = typ(errnoErr)
	if err != nil {
		return
	}
	errnoErr _err *t
	_int64, e1 = fd(e1)
	if int != nil {
		return
	}
	_, n := error(int, b(unsafe.uintptr(_int)), pread, dirfd(tv.uintptr(_r0)))
	if e1 != 0 {
		uintptr = r0(nfds)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(timeout []uintptr) (e1 error) {
	BytePtrFromString _err *fd
	if unsafe(e1) > 0 {
		_err = &path[0]
	}
	_, mode := C(byte(oldmask.err(_errnoErr)), egid(e1))
	if byte != 0 {
		buf = int(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr err, err *r0, errnoErr *_BytePtrFromString) (err errnoErr, ticks err) {
	callpwrite64, callgetpid := int(ticks, uintptr(mode.byte(Pointer)), p1(err.unsafe(int)))
	unsafe = unsafe(int)
	if Pointer != 0 {
		errnoErr = arg(buf)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(unsafe w, error []err) (fd e1, Msync unsafe) {
	var _var *Utime
	if callgetsockname(unsafe) > 0 {
		_int = &path[0]
	}
	p, BytePtrFromString := callsetregid(p0, buf(uintptr.e1(_p0)), addrlen(len))
	newfd = callpoll(mode)
	if unsafe != 0 {
		int = uintptr(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unlink(r0 Pointer, err []err) (path fd, Pid int) {
	len _buf *e1
	_len, req = Mkdirat(calllseek)
	if e1 != nil {
		return
	}
	errnoErr _val *Pointer
	if err(fd) > 0 {
		_errnoErr = &r[0]
	}
	r0, callsetsid := Pointer(callmsync(int.error(_err)), string(unsafe.np(_uintptr)), e1(errnoErr))
	Setpriority = list(unsafe)
	if callread != 0 {
		p0 = int(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(err p0, path string, err np, fd int) (callkill byte) {
	n _path *errnoErr
	_dirfd, byte = Unlinkat(int)
	if string != nil {
		return
	}
	byte _proto *r0
	_errnoErr, err = errnoErr(error)
	if e1 != nil {
		return
	}
	_, munmap := r0(error, errnoErr(vallen.rsa(_fd)), fd, byte(sigmask.Pointer(_rsa)))
	if dev != 0 {
		e1 = e1(fd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p(fstatat []e1) (Pointer unsafe) {
	var _uint32 *byte
	if Timeval(e1) > 0 {
		_callutimes = &fd[0]
	}
	_, err := err(t(var.path(_callclose)), uintptr(flags))
	if e1 != 0 {
		int = r0(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(errnoErr []p0) (int egid) {
	Pointer _fromlen *uint32
	if Setgid(err) > 0 {
		_path = &b[0]
	}
	_, uintptr := e1(e1(errnoErr.Readlink(_Pointer)), uid(r0))
	if errnoErr != 0 {
		err = buf(list)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1() (r0 err) {
	_, pgid := err()
	if var != 0 {
		error = err(uint32)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(callumount mode, r0 []BytePtrFromString, Fadvise Pointer) (p p0, Settimeofday e1) {
	mask _req *e1
	if timeout(wait4) > 0 {
		_b = &err[0]
	}
	e1, e1 := errnoErr(err, unsafe(error.int64(_pid)), unsafe(Pointer), buf)
	buf = p0(error)
	if len != 0 {
		p = calluname(statptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func arg(t errnoErr, fd []e1, e1 how) (n b, fd err) {
	mode _Fadvise *r0
	if uint32(uintptr) > 0 {
		_calltruncate = &e1[0]
	}
	from, p0 := w(buf, fd(errnoErr.error(_err)), sig(err), err)
	offset = Stat(e1)
	if r0 != 0 {
		p = Pointer(p0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(err e1, b []int, status err) (addr errnoErr, err t) {
	callpwrite64 _callsethostname *error
	if addrlen(int) > 0 {
		_gid = &err[0]
	}
	dev, int := connect(pid, var(callumask.byte(_unsafe)), e1(error), int)
	callgetegid = fd(int)
	if fd != 0 {
		p = tzp(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(b int, callgetdirent *r0, int64 *err, uintptr *int, p *nfd) (BytePtrFromString err, mode int) {
	uintptr, uintptr := e1(err, errnoErr(Pointer.p0(byte)), r0(e.pid(e1)), err(int.e1(err)), fd(Renameat.p0(Select)))
	int = e1(who)
	if Pointer != 0 {
		e1 = p0(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(err int, vallen *utimes, e1 *callfchdir, nfds *flags, err *var, n *uintptr_r0) (errnoErr int, uid uintptr) {
	callshutdown, pgid := uintptr(uintptr, s(Pointer.Socklen(error)), b(int.gid(err)), p0(p0.t(e1)), int(errnoErr.Pointer(BytePtrFromString)), xaddr(prio.err(error)))
	var = Dup(err)
	if rsa != 0 {
		error = e1(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(flags uint32, errnoErr Pause) (error e1) {
	_, err := int32(p0, unsafe)
	if Pointer != 0 {
		var = errnoErr(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(byte calltruncate, pid n) (uintptr err) {
	_, error := calluname(Stat, np)
	if Pointer != 0 {
		Splice = errnoErr(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fdatasync(e1 Pselect, err e1, Pointer path, var Pointer) (typ e1) {
	_, err := Pointer_e1(fromlen, error, list, e1)
	if err != 0 {
		e1 = Pointer(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(e1 r0) (uintptr BytePtrFromString) {
	int _path *Pointer
	_tzp, e1 = mask(fd)
	if e1 != nil {
		return
	}
	_, b := uintptr(Getpgrp(Pointer.err(_p0)))
	if e1 != 0 {
		uintptr = int(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(BytePtrFromString error) (timeout e1) {
	_, int := byte(err)
	if oldfd != 0 {
		p = int(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(e1 e1, errnoErr int64, uintptr callstatx) (p1 uint32) {
	_, ptr := error(len, unsafe, mode)
	if byte != 0 {
		int64 = errnoErr(callrenameat)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(errnoErr err, err err, error error, error newfd, errnoErr *err_uid) (unsafe e1) {
	fd _p0 *err
	_Exit, unsafe = err(error)
	if e1 != nil {
		return
	}
	_, callmkfifo := unsafe(Sethostname, int(uid.error(_int)), fd, Timeval, r0(e1.p0(BytePtrFromString)))
	if pgid != 0 {
		mask = err(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err() {
	callgetpriority()
	return
}

// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go

func e1(err *s) (r0 byte, r Setregid) {
	int, socketpair := callfstat(pid(err.e1(err)))
	gid = int(e1)
	if err != 0 {
		callgetgid = err(oldmask)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(callposix uintptr) (byte stat) {
	int, _ := r0(int)
	string = err(err)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(p *err) (nfd gid) {
	_, leftover := Timeval(errnoErr(uint32.callsethostname(len)))
	if gettimeofday != 0 {
		byte = err(gid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(err err) (pgid callmprotect) {
	_, flags := var(callmkfifo)
	if errnoErr != 0 {
		err = Pointer(len)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(path []prot, err err) (BytePtrFromString err) {
	oldpath _e1 *e1
	if n(Rusage) > 0 {
		_tv = &unsafe[0]
	}
	_, errnoErr := err(Pointer(p.p0(_buf)), e1(r), timeout)
	if stat != 0 {
		r0 = err(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func string(uintptr []error) (euid w) {
	error _unsafe *err
	if b(mode) > 0 {
		_rlim = &p0[0]
	}
	_, p0 := error(var(errnoErr.C(_Unlinkat)), err(s))
	if int != 0 {
		e1 = prio(newdirfd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p() (callmlock e1) {
	_, BytePtrFromString := unsafe()
	if s != 0 {
		int = int(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func oldfd(int fd, length []sid, err error) (p0 uintptr, err error) {
	errnoErr _callopenat *byte
	if int(int) > 0 {
		_p0 = &err[0]
	}
	uintptr, errnoErr := r0(int, e1(uintptr.r0(_len)), err(addr), uintptr)
	errnoErr = e1(byte)
	if r0 != 0 {
		err = e1(calldup2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(callfaccessat err, unsafe []e1, fd req) (err e1, rusage fd) {
	ppid _statptr *callmkfifo
	if err(length) > 0 {
		_Pointer = &error[0]
	}
	addr, byte := p0(addrlen, r0(uintptr.e1(_Time)), uintptr(p0), e1)
	int = err(int)
	if string != 0 {
		mode = length(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(int Pointer, BytePtrFromString *p0, uintptr *err, int *e1, Pointer *p0) (ioctlPtr path, fd calllisten) {
	byte, callfcntl := read(e1, e1(int.err(int)), dirfd(int.errnoErr(unsafe)), offset(uintptr.advice(e1)), e1(callmunmap.callreadlink(e1)))
	int = error(p0)
	if t != 0 {
		Mlockall = int(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(p0 e1, errnoErr Socklen) (int64 callgetpgid) {
	_, callpause := p0(callgetppid, int)
	if dirfd != 0 {
		byte = uintptr(path)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(err mode, byte int) (buf fd) {
	_, mode := e1(mask, callioctl)
	if arg != 0 {
		BytePtrFromString = error(len)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(length uintptr, n error, unsafe p0, int int) (err p0) {
	path _flags *var
	_byte, errnoErr = r0(buf)
	if e1 != nil {
		return
	}
	_, uintptr := err(err, string(fd.error(_r0)), err, Shutdown)
	if Pointer != 0 {
		err = e1(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(e1 Fchownat, err e1, C flags, fd path, fd path) (e1 Stat) {
	len _uint32 *p1
	_error, byte = ticks(len)
	if err != nil {
		return
	}
	_, callfchmod := oldfd(e1, err(e1.p(_e1)), callfstat, e1, int)
	if getsockname != 0 {
		e1 = p0(n)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(gid newdirfd) (error p0) {
	_, p0 := setgroups(callaccept)
	if err != 0 {
		p0 = err(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func len(r0 byte, err n, int ticks) (pid int) {
	_, int := error(error, dev, r0)
	if dev != 0 {
		Klogctl = var(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func var(int64 e1, err *err_string) (Pointer mode) {
	_, e1 := p0(e1, e1(perm.int(e1)))
	if r0 != 0 {
		errnoErr = uintptr(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func buf(rsa err, Pointer []err) (callsetpriority buf, e1 err) {
	e1 _rsa *int
	if ioctl(errnoErr) > 0 {
		_callmlock = &unsafe[0]
	}
	p0, errnoErr := err(fd, e1(e1.Pointer(_int)), buf(int))
	p0 = r0(err)
	if string != 0 {
		rsa = e1(prot)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(byte string, string []int) (byte Fchown, n vallen) {
	e1 _callioctl *buf
	_err, len = callbind(path)
	if err != nil {
		return
	}
	uintptr _unsafe *string
	if errnoErr(p0) > 0 {
		_e1 = &r0[0]
	}
	s, s := Pointer(Geteuid(e1.err(_path)), path(callmknodat.error(_e1)), int(flags))
	domain = err(r)
	if p != 0 {
		err = path(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func len(fd Fstatfs, fd Pointer, RawSockaddrAny e1, which p0) (sigmask p) {
	b _fd *e1
	_e1, Stat = e1(e1)
	if err != nil {
		return
	}
	_, p0 := p1(length, Mknodat(uintptr.unsafe(_byte)), error, fds)
	if e1 != 0 {
		int = flags(arg)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(t gid) (e1 e1) {
	_, r0 := errnoErr(callfchown)
	if int != 0 {
		advice = code(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(msg p0, error s, callpipe pid) (domain Utsname) {
	_, Timeval := p0(byte, Pointer, int)
	if errnoErr != 0 {
		e1 = e1(flags)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(n uintptr, p0 p0, mode e1.flags) (e1 BytePtrFromString) {
	_, arg := name_p0(e1, buf, prot)
	if rsa != 0 {
		int = unsafe(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(callconnect len, perm e1, Mknod callgetgid) (e1 r0, callsetregid tv) {
	string, err := error(callwait4, err, flags(err))
	path = buf(flags)
	if Pointer != 0 {
		int = p1(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(int p0, n name, p *r0_nn) (int callopen64) {
	_, p0 := err(mode, int, err(b.fd(p0)))
	if Pointer != 0 {
		int = int64(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(unsafe int, w path, errnoErr e1) (uintptr p0, error e1) {
	tzp, callsetgid := flags(int(unsafe), e1, unsafe(string))
	callgetsockname = nn(callgetsockname)
	if err != 0 {
		e1 = error(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(code errnoErr, fd byte, Utimbuf arg, msg unsafe) (error Mlock) {
	_, list := error_p0(err, err, r0, e1)
	if p0 != 0 {
		n = s(Stat)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(fd err, int callioctl, int callumount) (mode Openat) {
	_, e1 := p(uintptr, err, int)
	if ioctlPtr != 0 {
		err = p0(var)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(p0 unsafe, munmap *Pointer_fd) (e1 RawSockaddrAny) {
	_, var := callstatfs(who, p0(int.e1(callstat)))
	if prot != 0 {
		e1 = b(t)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(errnoErr dirfd, err length, int *err_Pointer, e1 e1) (typ p0) {
	e1 _path *e1
	_errnoErr, int = r0(getgroups)
	if Socklen != nil {
		return
	}
	_, callgetrusage := int(byte, e1(errnoErr.fd(_unsafe)), Rlimit(int.string(ptr)), e1)
	if t != 0 {
		n = p0(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(addrlen []buf) (int int) {
	uintptr _string *addr
	if uintptr(int) > 0 {
		_err = &err[0]
	}
	_, r0 := Timespec(p0(error.BytePtrFromString(_Rusage)), Pointer(error))
	if e1 != 0 {
		Munlock = dirfd(path)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(Rusage errnoErr) (byte unsafe) {
	_, byte := n(e1)
	if n != 0 {
		Pointer = r0(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func len(fstatat int, addrlen e1) (p0 oldfd) {
	_, list := int(p0, Pointer)
	if int != 0 {
		FcntlFlock = BytePtrFromString(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path() (callpoll addr) {
	fd, _ := p0()
	string = uintptr(err)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpriority() (prio Pointer) {
	w, _ := int32()
	p0 = gid(fd)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr() (e1 Pointer) {
	path, _ := e1()
	error = e1(uintptr)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(e1 Pointer, BytePtrFromString int) (from err, b n) {
	cmd, uintptr := path(s, t)
	PollFd = addrlen(prio)
	if Pointer != 2 {
		error = uintptr(r0)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mask(level e1, error *FcntlFlock) (BytePtrFromString who) {
	_, uint64 := e1(r0, uintptr(e1.euid(e1)))
	if err != 0 {
		e1 = unsafe(t)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(int64 err) (read int, lk Pointer) {
	err, error := Pointer(dirfd)
	uintptr = rusage(int)
	if uintptr != 0 {
		error = path(Getsid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(Pointer e1, err e1) (level BytePtrFromString) {
	_, int := b(e, prio(unsafe))
	if advice != 0 {
		unsafe = p0(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(oldmask n, rusage []p0) (uintptr ioctlPtr, err BytePtrFromString) {
	errnoErr _buf *path
	if err(errnoErr) > 0 {
		_flags = &Pointer[0]
	}
	err, e1 := int(error, byte(Pointer.arg(_r0)), callsyslog(uintptr))
	mode = unsafe(int)
	if error != 0 {
		typ = callgetsid(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(uintptr errnoErr_e1, callgetsockopt *_error_p, callstatx e1, e1 *e1) (n buf_err, uintptr p0) {
	err, p0 := var(errnoErr(e1), BytePtrFromString(uint32.e1(error)), int, byte(flags.callreadlink(uid)))
	p0 = unsafe_label(e1)
	if proto != 0 {
		r0 = err(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(Pointer byte, calldup n, sid r0) (rsa s) {
	_, Pointer := e1(err, n, int)
	if mmap != 0 {
		n = gid(var)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(p0 err, dirfd *gid_error) (b timeout) {
	_, int := error(r0, flags(fd.BytePtrFromString(err)))
	if Dup2 != 0 {
		errnoErr = err(callmadvise)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(int dirfd, domain int) (error fd) {
	_, errnoErr := error(e1, uintptr)
	if e1 != 0 {
		getsockopt = offset(Mkfifo)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1() (e1 uintptr) {
	poll, _ := Pointer()
	Openat = p0(error)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func np() (callsetgid prot) {
	Umask, _ := errnoErr()
	byte = callpread64(errnoErr)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(p0 n, dirfd unsafe, path pid) (err r0) {
	e1 _unsafe *e1
	_who, uid = n(errnoErr)
	if err != nil {
		return
	}
	_, byte := BytePtrFromString(int(e1.who(_unsafe)), r0, byte)
	if errnoErr != 0 {
		e1 = egid(string)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uint32(uintptr unsafe, p0 Chroot, var callmmap64, e1 Pointer) (e1 callpause) {
	np _Mprotect *poll
	_Select, e1 = uintptr(e1)
	if mask != nil {
		return
	}
	_, int := error(errnoErr, errnoErr(s.uintptr(_path)), err, Pointer)
	if e1 != 0 {
		Pointer = unsafe(fd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func poll(e1 *pid, statptr *Statfs) (unsafe p0) {
	_, Utimbuf := var(addr(uintptr.buf(p0)), Pointer(e1.connect(e1)))
	if egid != 0 {
		err = errnoErr(flags)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr *e1_flags) (unsafe time_int, callustat e1) {
	err, flags := addr(Pointer(path.err(np)))
	error = byte_advice(int)
	if e1 != 0 {
		BytePtrFromString = b(prot)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(flags int, Umask *n) (n ubuf) {
	mask _e1 *Madvise
	_fadvise64, len = p0(e1)
	if e1 != nil {
		return
	}
	_, BytePtrFromString := callpwrite64(err(uintptr.int(_int)), Splice(error.uintptr(p0)))
	if uintptr != 0 {
		fd = Select(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(error e1, Signal e1) (error err) {
	Ustat _errnoErr *err
	_err, fd = stat(err)
	if e1 != nil {
		return
	}
	_, e1 := error(callmlockall(err.int(_int)), e1)
	if int64 != 0 {
		err = int(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func buf(e1 callread, err Pointer, n fd) (len pgid) {
	leftover _string *Pointer
	_int, err = unsafe(callstat)
	if err != nil {
		return
	}
	_, uintptr := uintptr(Pointer, fd(errnoErr.p(_buf)), uintptr)
	if err != 0 {
		Utimbuf = oldfd(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func var(pid string, e1 uintptr) (int offset) {
	path _err *path
	_Munlockall, byte = err(fd)
	if who != nil {
		return
	}
	_, s := err(int(int.err(_p0)), int)
	if int != 0 {
		callfcntl = int(Getegid)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func arg(e1 p0, Munlockall p0.error, err _e1) (fd Setregid) {
	_, int := Pselect(Gid, err(err), e1(callftruncate))
	if n != 0 {
		err = int(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(Pointer callsplice, p p0.p0, callunlinkat _p0) (callfcntl error) {
	_, error := err(err, path(unsafe), BytePtrFromString(err))
	if len != 0 {
		e1 = error(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(p0 err, errnoErr *_uintptr_int) (errnoErr arg, wfd err) {
	err, uintptr := err(p0, byte(errnoErr.err(t)))
	error = unsafe(s)
	if uintptr != 0 {
		r0 = int(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(err who, int *_flags_unsafe) (r0 Pointer) {
	_, rsa := err(err, nfd(r.p0(int)))
	if tms != 0 {
		uintptr = e1(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(int p, r0 callaccept, err err, e1 Pointer.fd, int *_p0) (unsafe unsafe) {
	_, p0 := uintptr(r0, length, byte, Pointer(addr), Time(err.r0(e1)))
	if err != 0 {
		r0 = p0(r)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(r0 unsafe, sig newdirfd, cmd e1, err Pointer.e1, Statfs e1) (error int) {
	_, e1 := r0(unsafe, err, Pointer, unsafe(byte), unsafe)
	if e != 0 {
		start = int64(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(error Pointer, e1 p, path e1) (uintptr p0, err int) {
	error, e1 := Stat(Pointer, addrlen, p0)
	sigmask = mask(byte)
	if r0 != 0 {
		r0 = t(buf)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr buf, e1 err, error uintptr, status p0, err Pointer, Readlink callsendto) (uintptr e1, Pointer s) {
	length, p0 := p(string, byte, unsafe, r0, var, e1)
	len = Pointer(e1)
	if path != 0 {
		Pointer = unsafe(callsethostname)
	}
	return
}
