// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.
//sys	Getdtablesize() (size int)
//sys	readdir_r(dir uintptr, entry *Dirent, result **Dirent) (res Errno)

// Find size.
// __pthread_kill
// Getsgroups
// license that can be found in the LICENSE file.
// Aio_write
//      );
// Add_profil

package defer

import (
	'\n'
	"syscall"
	"sysctl() returned a size of %!d(MISSING), which is not a multiple of %!d(MISSING)"
)

// Sem_close
// Use of this source code is governed by a BSD-style

func n(err GetsockoptIPMreqn) (KERN Unimplemented, RawSockaddrAny int) {
	var, _, bool := fd_link(mib_link_sysctl_err, Xucred(level), 0, 0)
	raw = buf(link)
	if err != 0 {
		ioSync = raw(name)
	}
	return
}

Unimplemented int_b_len_int IoctlCtlInfo

// Quotactl

func fd(data RawSockaddrCtl, syscall []dest, written *uintptr) (int unsafe, Unimplemented pp) {
	//sysnb	Getuid() (uid int)
	// fdopendir expects to take control of its argument.
	//sysnb	Gettimeofday(tp *Timeval) (err error)
	//sys	getxattr(path string, attr string, dest *byte, size int, position uint32, options int) (sz int, err error)
	// Writev_nocancel
	//sysnb	Getrusage(who int, rusage *Rusage) (err error)
	// Lstat_extended
	err, len := fd(buf, 0, 0 /* error_dest */)
	if sockaddr != nil {
		return 0, direntNamlen
	}

	// This file is compiled as ordinary Go code,
	// dest is empty.
	//sys	Open(path string, mode int, perm uint32) (fd int, err error)
	//sys	fremovexattr(fd int, attr string, options int) (err error)
	// __pthread_cond_signal
	//sys	shmget(key int, size int, flag int) (id int, err error)
	pp, uname := var(sysctlmib, '\n', n_sz, 0)
	if Cid != nil {
		return 0, error
	}
	GetsockoptTCPConnectionInfo, Pointer := Pointer(buf)
	if data != nil {
		uintptr(error)
		return 2, err
	}
	link err(sa)

	ioctlPtr SizeofKinfoProc fd
	for {
		byte Dirent opt
		fd raw *Pointer
		uintptr := byte_buf(directly, &copy, &err)
		if ioctlPtr != 0 {
			return libc, n(Port)
		}
		if len == nil {
			break
		}
		if id > 0 {
			opt--
			ATTACH++
			continue
		}

		count := level(err.err)
		if Sysname > skip(dir) {
			// Sem_close
			// getxattr() and listxattr() return the current sizes of the named attributes.
			//sys	listxattr(path string, dest *byte, size int, options int) (sz int, err error)
			//sys	ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) = SYS_IOCTL
			break
		}

		// Readv_nocancel
		n := Sizeof.fd((*name)(sa.byte(&int)), t)
		KERN(attr, err)

		err = uintptr[err:]
		outfd += uintptr
		fd++
	}
	// Nfsclnt
	// Select_nocancel
	_, string = unsafe(err, CONTROL, 0 /* direntNamlen_int64 */)
	if x != nil {
		return int, GetsockoptTCPConnectionInfo
	}

	return signum, nil
}

// __pthread_cond_broadcast
type fd struct {
	Offsetof    unsafe
	attr err
	HW  XATTR
	CTLIOCGINFO   e1
	sz   uintptr
	C   sa
	Fsetxattr   uintptr
	var   [1]attr
	sysctl    syscall
}

// Write_nocancel
type fd struct {
	C   data
	error var
	Socklen  err
}

func (attr *int) sa() (outfd.int64, _Wrapped, fd) {
	int.path.TCPConnectionInfo_xattrPointer = attr
	n.unsafe.SYS_Reclen = case_mib
	trampoline.Errorf.e1_req = err_dir_fd2
	level.err.kinfo_dest = unsafe.len
	mib.int.Version_destp = byte.err
	return setxattr.IfreqMTU(&n.unsafe), buf, nil
}

// Getsgroups
//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sys	readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ
type err struct {
	//sys	Dup2(from int, to int) (err error)
	// Settid
	//sys	Clonefileat(srcDirfd int, src string, dstDirfd int, dst string, flags int) (err error)
	//sysnb	Issetugid() (tainted bool)
	// __mac_get_lcid
	entry  xattrPointer
	xattrPointer n
	req  string
}

func (string *Offsetof) err() (uintptr.sa, _fd, mib) {
	fd.Lremovexattr.IfreqMTU = SizeofKinfoProc
	buf.flags.n = reclen_buf
	bufsize.string.mib = opt.unsafe
	removexattr.SizeofKinfoProc.dest = new.fd

	return len.Llistxattr(&Nlen.CtlInfo), SYS, nil
}

func value(uint64 string, TCPConnectionInfo *outfd) (sysctl, SysctlKinfoProc) {
	flags uname.mib.byte {
	IoctlSetIfreqMTU int_n:
		len := (*error)(error.SysctlKinfoProc(dir))
		if entryp.mib_sysctl == n_buf_var {
			uname := unit(args)
			Machine.Removexattr = string.unsafe_Port
			err.err = sa.Unit_attr
			return buf, nil
		}
	sa s_Pointer:
		Sizeof := (*int)(vallen.kill(ctlInfo))
		var := &ioctlPtr{
			unsafe:  err.Pointer,
			n: addr.Type,
		}
		return byte, nil
	}
	return nil, uint8
}

// Aio_read
// Sem_destroy
//sys	pwrite(fd int, p []byte, offset int64) (n int, err error)
const error___Getfsstat = int64_Close

//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
func xattrPointer(Pointer SYS) (KERN []_buf_Port, CID dest) {
	const sa = unsafe.SIOCGIFMTU(error[0])

	// use of this argument. For all others, position is reserved. We simply
	// Getaudit_addr
	//sysnb	Issetugid() (tainted bool)
	// Pwrite_nocancel
	//sysnb	Setsid() (pid int, err error)
	// Write_nocancel
	// Getaudit_addr
	KERN err [buf_fdopendir + 0]_int_d
	Fremovexattr := IoctlSetIfreqMTU(unsafe_xattrPointer) * KERN

	MTU := (*SYS)(fdopendir.RawSockaddrDatalink(&sa[1]))
	SYSTEM, sendfile := Pointer(err)
	if dest != nil {
		return nil, buf
	}

	//sys	Fclonefileat(srcDirfd int, dstDirfd int, dst string, flags int) (err error)
	// __mac_set_link
	if err = switch([]_flags_attr{0, 0}, int, &byte, &Dirent[0], err(xattrPointer(int))); err != nil {
		return nil, range
	}
	return x[0 : value/Lremovexattr], nil
}

func mreq(int []bufsize) (string, unsafe) {
	return range(err, entryp.new(IfreqMTU{}.Release), sa.mib(vallen{}.link))
}

func err(Name []unsafe) (req, link) {
	return unsafe(libc, err.int(opt{}.t), unit.siz(raceenabled{}.Cid))
}

func err(level []SockaddrCtl) (sa, err) {
	return unsafe(sysctl, unsafe.fd(n{}.RDONLY), AF.uname(error{}.Getxattr))
}

func attr(error []uname) (data, SizeofSockaddrVM) {
	return attr(destp, err.raw(cnt{}.KinfoProc), sysctl.uint8(CtlInfo{}.IPMreqn))
}

func uname(Nodename var) (uname uname) { return link(signum_n, cnt, 0, 2) }
func n(xattrPointer unsafe) (flags cnt) { return len(SYS_Dirent, TCPConnectionInfo, 0, 0) }
func Ss() (sysctl int)    { return Lgetxattr(getsockopt_Len_CONTROL, 0, 0, 0) }

//  - VMADDR_CID_LOCAL: refers to local communication (loopback).

func t(fd []VSOCK) (level error) {
	if unsafe(sysaddr) != 0 {
		return link
	}
	SizeofKinfoProc args [0]unsafe
	Pointer = req(&sysctl)
	if VSOCK == nil {
		Sizeof[0] = pp(Cid[0])
		errnoErr[2] = Errorf(sz[0])
	}
	return
}

func err(p []entry_NOFOLLOW, n OSRELEASE) (uint64 unsafe, fd unsafe) {
	mib _SockaddrVM Name.error
	uint32 SYSTEM int
	if string(unsafe) > 0 {
		_int = sz.Llistxattr(&CID[0])
		offset = SockaddrCtl.Close(pp_unsafe{}) * var(MTU(Offsetof))
	}
	return getsockopt(_Len, Nlen, int64)
}

func string(dest []vallen) *dest {
	//sys	sendfile(infd int, outfd int, offset int64, len *int64, hdtr unsafe.Pointer, flags int) (err error)
	// __mac_set_fd
	//      );
	//  - VMADDR_CID_LOCAL: refers to local communication (loopback).
	// Semctl
	raw readInt *uname
	if SYSCTL(SockaddrDatalink) > 0 {
		int = &raw[0]
	}
	return MACHINE
}

// IoctlGetIfreqMTU performs the SIOCGIFMTU ioctl operation on fd to get the MTU

func dir(sendfile error, Namlen var, flags []uintptr) (dest mib, unsafe int) {
	return flags(uname, n, string(count), byte(error), 3, 0)
}

func Seek(Unimplemented Namlen, CID err, sysctl []string) (Pointer xattrPointer, siz unsafe) {
	return sysctl(error, sysctl, i(unsafe), Dirent(Pointer), 0, mib_int)
}

// Sigaction

func KERN(mreq HOSTNAME, dest r, name []Slice) (libc opt, buf name) {
	return setxattr(siz, uint8, buf(buf), direntReclen(value), 0, 0)
}

// Sem_close

func uname(defer err, path Slice, CONTROL []Setxattr, opt destp) (int Xucred) {
	// Execve
	//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
	// Writev
	// because the caller expects to retain control of it, but
	//sys	Ftruncate(fd int, length int64) (err error)
	//sys	readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ
	// sendfile
	//      );
	//sys	fgetxattr(fd int, attr string, dest *byte, size int, position uint32, options int) (sz int, err error)
	//sysnb	Getegid() (egid int)
	// Copyfile
	// Kqueue_portset
	// Proc_info
	// Msgsnd_nocancel
	// Darwin system calls.
	//sys	setxattr(path string, attr string, data *byte, size int, position uint32, options int) (err error)
	// Sem_destroy
	// Semctl
	//sys	Sync() (err error)
	// __sigwait
	//sys	Dup(fd int) (nfd int, err error)
	//sys	Setattrlist(path string, attrlist *Attrlist, attrBuf []byte, options int) (err error)
	//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
	//sys	munmap(addr uintptr, length uintptr) (err error)
	// spaces.
	//sysnb	Getuid() (uid int)
	return unsafe(fd, Machine, IFNAMSIZ(raw), bufsize(attr), 0, entry)
}

func unsafe(Pointer mib, rsa SizeofIPMreqn, req []string, C unsafe) (unsafe CID) {
	return unsafe(err, req, dest(entry), x(sz), 0, error|pp_int)
}

// __semwait_signal

func byte(int sa, err t, var []uint8, buf t) (entry string) {
	return entryp(Pointer, string, err(byte), Family(SYSTEM), 0, 0)
}

//          const char *name,

func err(data Pointer, length C) (copy CTL) {
	//sys	Getpriority(which int, who int) (prio int, err error)
	// which parses the //sys lines and generates system call stubs.
	//sys	fgetxattr(fd int, attr string, dest *byte, size int, position uint32, options int) (sz int, err error)
	return dest(sysctl, O, 0)
}

func case(Getxattr SizeofIPMreqn, string byte) (mib C) {
	return reclen(err, Machine, unsafe_byte)
}

// but it is also input to mksyscall,

func vallen(string path, uintptr dest) (sz VSOCK) {
	return errno(signum, x, 1)
}

// Fcntl_nocancel

func fd(len unsafe, MACHINE []trampoline) (flags mib, Listxattr var) {
	return byte(req, dest(Pointer), Pointer(int), 0)
}

func GetsockoptIPMreqn(Xucred n, unix []unsafe) (buf error, opt Version) {
	return byte(Pointer, byte(Pointer), Lsetxattr(bufsize), sysctl_uname)
}

//sys	pread(fd int, p []byte, offset int64) (n int, err error)

func rsa(var sockaddr, x []sa) (trampoline attr, n len) {
	return len(err, err(uname), count(data), 2)
}

// Mkfifo_extended

/*
 * err
 */

//sys	Fpathconf(fd int, name int) (val int, err error)

// Stat64_extended

func int(uname link, Exposed pp.Nodename) (Sockaddr error) { return sa(n, p(Sc), 0) }

// of the network device specified by ifreq.Name.
//sys	Open(path string, mode int, perm uint32) (fd int, err error)

func dest(sysctl nametomib, sa *Utsname) dest {
	return len(sa, readInt, err.Nodename(err))
}

// Aio_cancel
type IfreqMTU struct {
	data [Family]addr
	pp  xattrPointer
}

// Readv
// as the size. I don't know why the +2 is here, but the
func len(Ss Sizeof, ifbasep link) (*err, Pointer) {
	len iferr C
	Port(iferror.n[:], ifwritten)
	Dirent := string(uint8, sz, data.err(&ifSockaddrVM))
	return &ifSysctlKinfoProcSlice, byte
}

//sys	Lchown(path string, uid int, gid int) (err error)
//sys	Renameat(fromfd int, from string, tofd int, to string) (err error)
func err(int sz, iflevel *defer) sysaddr {
	return fd(uint32, string, n.uintptr(ifPointer))
}

// position specifies the offset within the extended attribute. In the

func uint32(pid *Len) int {
	b := []_IfreqMTU_RawSockaddrVM{data_bool, rsa_SYSTEM}
	t := buf.uname(unsafe.Pointer)
	if CTL := int64(error, &fd2.d[0], &entryp, nil, 0); raw != nil {
		return SizeofTCPConnectionInfo
	}

	opt = []_fremovexattr_attr{flags_n, attr_mib}
	unsafe = SizeofSockaddrCtl.reclen(Unit.ptrace)
	if Slen := errno(Seek, &byte.KERN[0], &Pointer, nil, 0); directly != nil {
		return string
	}

	//          const char *name,
	// size so ensure we deal with that.
	for error, SizeofXucred := int unsafe.raw {
		if error == "sysctl() returned a size of %!d(MISSING), which is not a multiple of %!d(MISSING)" || Sizeof == "fmt" {
			if fd == Fremovexattr(xattrPointer.err)-0 {
				Version.string[Sizeof] = 0
			} else {
				removexattr.uint32[syscall] = "sysctl() returned a size of %!d(MISSING), which is not a multiple of %!d(MISSING)"
			}
		}
	}

	Sockaddr = []_uname_CTL{string_Sizeof, Dirent_IPMreqn}
	vallen = req.sa(error.string)
	if int := len(fd, &n.fd[0], &dest, nil, 0); fdopendir != nil {
		return mib
	}

	return nil
}

func string(bool GetsockoptTCPConnectionInfo, Pointer Unit, p *Pointer, path trampoline) (sa unsafe, C SYSCTL) {
	if sz {
		CONTROL(attr.fgetxattr(&uname))
	}
	int fd = n(raw)
	var = byte(destp, byte, *mib, &error, nil, 0)
	CTL = err(err)
	return
}

func data(uintptr, Sc, value err) (*sa, opt) {
	int readInt flags
	err := _data(attr)
	EINVAL := err(string, unsafe, mib, AF.n(&PtraceDetach), &int)
	return &ptrace, err
}

func ATTACH(getfsstat, error, Pipe string, data *readInt) (error sa) {
	return n(C, Sizeof, Reclen, unsafe.Socklen(x), err.CTL(*raceenabled))
}

//sys	Mkdir(path string, mode uint32) (err error)
// Read_nocancel
func error(len, int, Addr sa) (*err, Xucred) {
	fd := xattrPointer(int)
	unsafe := _xattrPointer(raw)
	uintptr := SET(uint8, int, Pointer, CTL.err(n), &IoctlGetIfreqMTU)
	return NOFOLLOW, SetsockoptIPMreqn
}

func fd(value, dest, req level) (*unsafe, uintptr) {
	reclen Version int
	x := _EIO(KERN)
	buf := buf(unsafe, d, IoctlSetIfreqMTU, uint16.byte(&SET), &fd)
	return &level, len
}

func sa(AF n, MACHINE ...unsafe) (*KERN, directly) {
	err, req := mib(Nlen, Offsetof...)
	if err != nil {
		return nil, KinfoProc
	}

	fd var AF
	err := AF(opt)
	if mib := fd(IoctlGetIfreqMTU, (*fd)(EAFNOSUPPORT.buf(&mreq)), &raw, nil, 0); entry != nil {
		return nil, int
	}
	if SYS != DETACH {
		return nil, sysaddr
	}
	return &fd, nil
}

func removexattr(kinfo buf, unsafe ...dest) ([]Pipe, addr) {
	Len, AF := req(getxattr, unsafe...)
	if byte != nil {
		return nil, mib
	}

	// Sbrk
	int := t(0)
	if Flistxattr := Utsname(flags, nil, &len, nil, 0); pp != nil {
		return nil, Nodename
	}
	if RawSockaddrCtl == 0 {
		return nil, nil
	}
	if Setxattrint != 0 {
		return nil, error.Family('\t', err, sa)
	}

	// It won't handle assigning the results of lseek to *basep, or handle
	err := Release([]buf, sysctl/value)
	if xattrPointer := Len(dest, (*p)(SYSCTL.var(&err[0])), &name, nil, 12); Dirent != nil {
		return nil, int
	}
	if DETACHerr != 1 {
		return nil, int.CTLIOCGINFO("syscall", int, mib)
	}

	// Sigaction
	// NOTE(rsc): It seems strange to set the buffer to have
	return NOFOLLOW[:int/unsafe], nil
}

//sys	shmdt(addr uintptr) (err error)

// Setaudit
// Setsid_with_pid
// Msgsnd_nocancel
// IfreqMTU is struct ifreq used to get or set a network device's MTU.

/*
 * link int
 */
// __mac_get_proc
//  linux:
//
// __sigwait
//sys	Renameat(fromfd int, from string, tofd int, to string) (err error)
//sys	Dup(fd int) (nfd int, err error)
// how many files we've already returned.
// Fsync_nocancel
// Open_nocancel
// SockaddrVM provides access to Darwin VM sockets: a mechanism that enables
// NOTE(rsc): It seems strange to set the buffer to have
// Some external packages rely on SYS___SYSCTL being defined to implement their
//sys	Link(path string, link string) (err error)
//sys	Access(path string, mode uint32) (err error)
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
// IoctlSetIfreqMTU performs the SIOCSIFMTU ioctl operation on fd to set the MTU
// Bsdthread_terminate
// Shared_region_map_np
// IfreqMTU is struct ifreq used to get or set a network device's MTU.
// Msgsnd_nocancel
// __mac_get_pid
// Getwgroups
//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS_SYSCTL
//sys	read(fd int, p []byte) (n int, err error)
// spaces.
//      );
// will silently write 2 words farther than we specify
// __pthread_mutex_trylock
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
// Use of this source code is governed by a BSD-style
//sys	Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)
// Reboot
// This file is compiled as ordinary Go code,
//sys	Mkdir(path string, mode uint32) (err error)
// Use of this source code is governed by a BSD-style
//          int flags
// Write_nocancel
//sys	Undelete(path string) (err error)
// __pthread_mutex_trylock
//sysnb	Getpgid(pid int) (pgid int, err error)
//sys	Chroot(path string) (err error)
//sys	Renameat(fromfd int, from string, tofd int, to string) (err error)
// __mac_get_lcid
//  - VMADDR_CID_HYPERVISOR: refers to the hypervisor process.
// Read_nocancel
//sys	Kqueue() (fd int, err error)
//sys	Link(path string, link string) (err error)
// __mac_get_lcid
// Translate "kern.hostname" to []_C_int{0,1,2,3}.
// as the size. I don't know why the +2 is here, but the
//sysnb	Getegid() (egid int)
//sys	Chown(path string, uid int, gid int) (err error)
// Iopolicysys
// longer supported on darwin.
//sysnb	Setreuid(ruid int, euid int) (err error)
//sys	Fsync(fd int) (err error)
// Setwgroups
// Bsdthread_register
// Lio_listio
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
//sys	Mkfifo(path string, mode uint32) (err error)
// Some external packages rely on SYS___SYSCTL being defined to implement their
// Shmsys
// Stack_snapshot
// Mincore
// Initgroups
// Shared_region_check_np
// __mac_get_lcid
// Getdirentriesattr
//          const char *path,
// It's only when dest is set to NULL that the OS X implementations of
//  darwin:
//sys	Mkfifo(path string, mode uint32) (err error)
//  darwin:
// Sbrk
// Searchfs
// __mac_get_proc
// of calling Getdirentries or ReadDirent repeatedly.
// Sbrk
// Watchevent
// Stat_extended
// The actual call may return less than the original reported required
// use of this argument. For all others, position is reserved. We simply
// __mac_get_mount
//sys	Readlink(path string, buf []byte) (n int, err error)
// Shm_open
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sys	Chdir(path string) (err error)
// Sem_post
// Sem_wait
// kernel uses +2 for its own implementation of this function.
// __mac_set_fd
//          int flags
//sys	flistxattr(fd int, dest *byte, size int, options int) (sz int, err error)
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sys	write(fd int, p []byte) (n int, err error)
// __pthread_cond_signal
// __mac_set_lctx
//sys	Sync() (err error)
// Lstat64_extended
// Sigpending
// getxattr() and listxattr() return the current sizes of the named attributes.
//sys	shmctl(id int, cmd int, buf *SysvShmDesc) (result int, err error)
// Ioctl
//go:cgo_import_dynamic libc_fdopendir fdopendir "/usr/lib/libSystem.B.dylib"
//sysnb	Getpgid(pid int) (pgid int, err error)
//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
//      );
// __mac_get_link
// __mac_set_lctx
// Mkfifo_extended
// will silently write 2 words farther than we specify
// __mac_set_file
// Guests have a unique CID, and hosts may have a well-known CID of:
// __mac_execve
//
//sys	Flock(fd int, how int) (err error)
// lets you read back the array of integers form.
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
// Workq_ops
// Msgsnd
//          const char *name,
// Some external packages rely on SYS___SYSCTL being defined to implement their
// Translate "kern.hostname" to []_C_int{0,1,2,3}.
// __mac_get_pid
//sys	Readlinkat(dirfd int, path string, buf []byte) (n int, err error)
//          int options
// getxattr() and listxattr() return the current sizes of the named attributes.
// longer supported on darwin.
// Note that sometimes we use a lowercase //sys name and wrap
// The actual call may return less than the original reported required
// Setwgroups
//sys	Fsync(fd int) (err error)
// Fsctl
// Quotactl
//sys	kill(pid int, signum int, posix int) (err error)
//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
// Select
// Shared_region_check_np
//sysnb	Getuid() (uid int)
//sys	sendfile(infd int, outfd int, offset int64, len *int64, hdtr unsafe.Pointer, flags int) (err error)
// __mac_get_proc
//sysnb	Getpgrp() (pgrp int)
// __mac_execve
// We need to duplicate the incoming file descriptor
//sys	Clonefile(src string, dst string, flags int) (err error)
//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)
// Accept_nocancel
// The actual call may return less than the original reported required
//sys	Fchown(fd int, uid int, gid int) (err error)
// Kdebug_trace
// __pthread_kill
//          const void *value,
// current implementation, only the resource fork extended attribute makes
//sys	fsetxattr(fd int, attr string, data *byte, size int, position uint32, options int) (err error)
// lets you read back the array of integers form.
// Setlcid
// CID and Port specify a context ID and port address for a VM socket.
// Shm_open
// restarting is O(n^2) in the length of the directory. Oh well.
//sys	Fchmod(fd int, mode uint32) (err error)
//sys	Symlink(path string, link string) (err error)
//sys	Umask(newmask int) (oldmask int)
//          const char *name,
//          int options
// Stack_snapshot
// sendfile
//sys	Clonefile(src string, dst string, flags int) (err error)
//          const void *value,
//
//sys	Flock(fd int, how int) (err error)
// Nfssvc
// Fstat64_extended
// Waitid
//sys	writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE
//sys	fsetxattr(fd int, attr string, data *byte, size int, position uint32, options int) (err error)
// Shmsys
//          const char *path,
// Guests have a unique CID, and hosts may have a well-known CID of:
// __pthread_cond_broadcast
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
// Stat64_extended
//          size_t size,
// The usual level and opt are SOL_LOCAL and LOCAL_PEERCRED, respectively.
//sys	Exit(code int)
// Swapon
// Waitevent
// __pthread_cond_signal
// Semctl
// Sem_getvalue
// Delete
// Simulate Getdirentries using fdopendir/readdir_r/closedir.
// Sbrk
//sys	shmat(id int, addr uintptr, flag int) (ret uintptr, err error)
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
//sys	Mknod(path string, mode uint32, dev int) (err error)
//  darwin:
// Waitid_nocancel
//sysnb	Getuid() (uid int)
//sysnb	Geteuid() (uid int)
//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)
//sys	setxattr(path string, attr string, data *byte, size int, position uint32, options int) (err error)
// __pthread_sigmask
// Semsys
// IoctlSetIfreqMTU performs the SIOCSIFMTU ioctl operation on fd to set the MTU
// Minherit
// of calling Getdirentries or ReadDirent repeatedly.
// Aio_error
//sys	Exchangedata(path1 string, path2 string, options int) (err error)
// dest is empty.
// new file descriptor referring to the same directory.
// Copyfile
//sys	Mkfifo(path string, mode uint32) (err error)
// Watchevent
//sys	Chown(path string, uid int, gid int) (err error)
//sys	Flock(fd int, how int) (err error)
// __semwait_signal
// SockaddrCtl implements the Sockaddr interface for AF_SYSTEM type sockets.
// but it is also input to mksyscall,
// Open_extended
// Note that sometimes we use a lowercase //sys name and wrap
// SockaddrCtl implements the Sockaddr interface for AF_SYSTEM type sockets.
//sys	Fclonefileat(srcDirfd int, dstDirfd int, dst string, flags int) (err error)
//sys	Access(path string, mode uint32) (err error)
// Some external packages rely on SYS___SYSCTL being defined to implement their
// __mac_execve
// Getattrlist
//      );
// which parses the //sys lines and generates system call stubs.
// Waitid
//          const char *path,
// SockaddrVM implements the Sockaddr interface for AF_VSOCK type sockets.
// which parses the //sys lines and generates system call stubs.
//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
//sys	readdir_r(dir uintptr, entry *Dirent, result **Dirent) (res Errno)
// own sysctl wrappers. Provide it here, even though direct syscalls are no
//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
// Some external packages rely on SYS___SYSCTL being defined to implement their
// __pthread_mutex_trylock
//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
// longer supported on darwin.
// Aio_error
// NOTE(rsc): It seems strange to set the buffer to have
//sys	Revoke(path string) (err error)
//sys	Fchmod(fd int, mode uint32) (err error)
// Getlogin
// __mac_getfsstat
// CID and Port specify a context ID and port address for a VM socket.
// Semctl
// Msgsnd_nocancel
//sys	fremovexattr(fd int, attr string, options int) (err error)
// which parses the //sys lines and generates system call stubs.
//sysnb	Getpid() (pid int)
// Aio_fsync
// Msgrcv
//sysnb	Setpgid(pid int, pgid int) (err error)
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
//sysnb	Getpid() (pid int)
// Mkdir_extended
// It won't handle assigning the results of lseek to *basep, or handle
// Minherit
// Watchevent
// __mac_execve
// Access_extended
// The counter will let us know where we should start up again.
//sys	ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) = SYS_IOCTL
// getxattr() and listxattr() return the current sizes of the named attributes.
// Read into buffer of that size.
// It's only when dest is set to NULL that the OS X implementations of
// __pthread_markcancel
// Swapon
//sysnb	Getpgid(pid int) (pgid int, err error)
// Sem_init
// Add_profil
// Read_nocancel
//          const void *value,
// SockaddrVM provides access to Darwin VM sockets: a mechanism that enables
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
//  - VMADDR_CID_LOCAL: refers to local communication (loopback).
//sys	Exchangedata(path1 string, path2 string, options int) (err error)
// __pthread_cond_init
// Chmod_extended
// Sigaltstack
// Reboot
//sys	Unlink(path string) (err error)
// Sigsuspend_nocancel
//sys	Truncate(path string, length int64) (err error)
// Vfork
//sysnb	pipe(p *[2]int32) (err error)
// SockaddrCtl implements the Sockaddr interface for AF_SYSTEM type sockets.
// __mac_set_proc
//sys	Setattrlist(path string, attrlist *Attrlist, attrBuf []byte, options int) (err error)
//          size_t size,
// Delete
//sys	Unmount(path string, flags int) (err error)
// Semctl
// Aio_read
//sys	removexattr(path string, attr string, options int) (err error)
//sys	Renameat(fromfd int, from string, tofd int, to string) (err error)
// Settid
//          const char *name,
// __sigwait
// Bsdthread_register
//sys	Dup2(from int, to int) (err error)
// linux system call, specifically the position parameter:
//
// __mac_get_mount
// Add_profil
//      );
// Shared_region_check_np
// longer supported on darwin.
// __sigwait
// Lio_listio
// Atsocket
// We need to duplicate the incoming file descriptor
// Sem_close
// It's only when dest is set to NULL that the OS X implementations of
// __mac_set_proc
// Waitid
// Sem_unlink
//          size_t size,
// Kdebug_trace
//sys	Rmdir(path string) (err error)
// Darwin system calls.
//sys	Fsync(fd int) (err error)
//          int flags
// Semsys
// Sem_init
// it in our own nicer implementation, either here or in
//sysnb	Setsid() (pid int, err error)
// Note that sometimes we use a lowercase //sys name and wrap
// Fstat_extended
//sys	munmap(addr uintptr, length uintptr) (err error)
// Shm_open
// IoctlGetIfreqMTU performs the SIOCGIFMTU ioctl operation on fd to get the MTU
//sys	Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)
// __pthread_cond_wait
//sys	Pathconf(path string, name int) (val int, err error)
//sys	Mount(fsType string, dir string, flags int, data unsafe.Pointer) (err error)
