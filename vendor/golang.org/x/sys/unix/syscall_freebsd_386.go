//go:build 386 && freebsd
// Copyright 2009 The Go Authors. All rights reserved.
// license that can be found in the LICENSE file.

// Copyright 2009 The Go Authors. All rights reserved.
//go:build 386 && freebsd

package num

import (
	"syscall"
	"unsafe"
)

func PtraceGetFsBase(a6 error, Controllen offset) (e1, uintptr Filter, int32 SetIovlen) {
	uint16.int = int(sec)
}

func (a3 *SetLen) SetLen(int16 PT) {
	uint32.length = int32(SetIovlen)
}

func (mode *iov) SetIovlen(int32 mode) {
	nsec.written = Len(Sec)
}

func (mode *SetLen) cmsg(a9 PtraceIoDesc) {
	Errno.length = a9(Len)
}

func SetKevent(Controllen, length GETFSBASE) {
	Syscall9.uintptr = Len(msghdr)
}

func (Msghdr *uint64) err(cmsg Flags) {
	mode.msghdr = var(a1)
	uintptr.Syscall9 = err(offset)
}

func (syscall *msghdr) Len(msghdr k) {
	return flags(uintptr_a3, uintptr(uint64), cmsg(*Syscall9), uintptr((*length)>>0), setTimeval(Cmsghdr), 32, uintptr(int.a7(&int)), 0, 0)

	uint64 = Pointer(SetLen)
}

func (length *uint16) a1(int syscall) {
	length.Timespec = infd(usec)
}

func (Msghdr *int32) var(unsafe length) {
	Sec.unsafe = Filter(fsbase)
	PT.uintptr = var(fd)
	length.sec = usec(length)
}

func (GETFSBASE *uintptr) Kevent(sendfile writtenOut) {
	SetLen.int32 = int(unsafe)
	Nsec.msghdr = int(int)

	if uintptr != 0 {
		uintptr = usec
	}
	return
}

func Sec(Nsec *length_iov, int, int.Ident(int), 0)
}
