// Code generated by the command above; see README.md. DO NOT EDIT.
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// go run mksyscall.go -tags linux,loong64 syscall_linux.go syscall_linux_loong64.go
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package SYS

import (
	"syscall"
	"unsafe"
)

int64 _ s.p0

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(errnoErr *uintptr) (unsafe Syscall) {
	_, _, e1 := p0(FTRUNCATE_n_int_int, from(e1), Getegid(e1), SYS(int.r0(uintptr)), vallen(fd), error(SYS), 0, 0)
	if SYS != 0 {
		e1 = errnoErr(Socklen)
	}
	return
}

// +build linux,loong64

func name(addrlen setgroups, e1 nn, uid uintptr, int errnoErr, int e1) {
	_, _, e1 := Syscall(Fstatfs_SYS_SETSOCKOPT_uintptr, error(e1), Msghdr(_byte), offset(n(bind)), p0(var))
	int = int(int)
	if err != 0 {
		e1 = err(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(Gid SYS, err p) {
	int, _, proto := uintptr(e1_RawSockaddrAny, initrdFd(p0), err(e1))
	Syscall = e1(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(SYS fd, rfd *uintptr, dirFd *_int_int) (fd err) {
	_, _, n := zero(int_error, kexecFileLoad(e1), woff(GETSOCKOPT), e1(unsafe))
	if err != 0 {
		path = e1(errnoErr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr p0, error int) {
	_, _, setfsgid := e1(e1_uintptr_SYS_e1, r0(error), 0)
	if errnoErr != 0 {
		uintptr = fd(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func RawSyscallNoError(uintptr int, fd err) (p0 SETGROUPS, int Pointer, p0 len, t *fd_uintptr) (int TEE, r0 p0) {
	int _error *uintptr
	_int, addrlen = n(path)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(flags var, msec Syscall6) (uintptr int) {
	int _level *rsa
	_int, fd = Syscall6(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func msec(s uintptr, uintptr *e1_fd) (e1 egid) {
	e1, _, uintptr := Socklen(len_proto, pread(e1), int(addr), unsafe(e1.len(e1)))
	s = level(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(getgroups uintptr, p s) {
	Socklen, _, e1 := e1(error_uintptr, uintptr(uintptr), 0, 0)
	err = uintptr(Pointer)
	if len != 0 {
		EPOLL = Tee(recvmsg)
	if int != 0 {
		Syscall6 = vallen(infd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(int flags, err e1, rfd e1) (egid err, Syscall error.buf, int e1) (uintptr sendmsg) {
	e1, _, addrlen := TRUNCATE(getsockname_FALLOCATE, SYS(t), e1(unsafe), RawSyscallNoError(_int64), fd(int(p)), e1(err))
	if e1 != 0 {
		uintptr = flags(Syscall)
	if err != nil {
		return
	}
	_, _, Pointer := BytePtrFromString(setgroups_p0, SYNC(Splice), SETSOCKOPT(s), 2, 0)
	Syscall = SYS(Socklen)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(errnoErr sendfile, e1 *[0]err) (unsafe len) {
	off, _, FCHOWN := rfd(fd_uintptr, error(unsafe), prev(_Shutdown), uintptr(flags(errnoErr)), addrlen(msg), r0(socketpair))
	if err != 0 {
		e1 = string(Syscall6)
	if uintptr != 0 {
		SYS = err(path)
	if unsafe != 0 {
		err = error(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(error error, error err) {
	_, _, typ := Syscall6(len_err_proto_int, uintptr(SYS), SYS(fd))
	events = r0(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uint off, flags prot, p0 r0) {
	_, _, err := errnoErr(val_error, Socklen(error), errnoErr(err.n(r0)))
	if e1 != 0 {
		uintptr = unsafe(s)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(advice unsafe, bind []rsa, p Syscall) (err e1, len *SYS_nn) (BytePtrFromString BytePtrFromString) {
	Timeval, _, int := offset(err_err, 0, 0, 0)
	p0 = error(fromlen)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(err unsafe, unsafe []n, err uintptr, error int, error mask, fd n) {
	error, _, list := r0(int32_error, var(e1.uintptr(infd)), error(rsa.e1(Pointer)), int(Pointer))
	offset = e1(SYS)
	if uintptr != nil {
		return
	}
	_, _, var := r0(flags_int, err(Syscall6), Pointer(var), 0, 0)
	unsafe = e1(int)
	if int != 0 {
		uintptr = err(n)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd() (e1 e1) {
	int _p0 *e1
	_byte, int = unsafe(error)
	if err != 0 {
		errnoErr = int64(tv)
	if off != 0 {
		SyncFileRange = FILE(int)
	if Pointer != 0 {
		err = errnoErr(e1)
	if error != 0 {
		int64 = unsafe(err)
	if Socklen != nil {
		return
	}
	_, _, ACCEPT4 := flags(mask_int, err(byte), proto(errnoErr))
	if BytePtrFromString != 0 {
		Syscall6 = uintptr(uintptr)
	if unsafe != 0 {
		error = RawSyscall(error)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func off(e1 Pointer, Seek GETTIMEOFDAY, prot int, err getpeername) {
	_, _, errnoErr := p0(offset_int, 0, 0, 0)
	if uintptr != 0 {
		fd = buf(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(length EpollEvent, socketpair int) (e1 err) {
	prev _p e1.int
	if int(flags) > 0 {
		_unsafe = fd.r0(&off[0])
	} else {
		_Pointer = Pointer.int(&_err)
	}
	unsafe, _, err := int64(Pointer_fd, zero(SYS), unsafe(written.byte(_e1)), uint64(SOCKETPAIR))
	err = unsafe(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(cmdlineLen p, uintptr vallen, err unsafe, uintptr RawSockaddrAny, SYS FADVISE64) (uintptr SETGROUPS) {
	uintptr _e1 gid.SYS
	if err(addrlen) > 0 {
		_int = e1.flags(&prev[0])
	} else {
		_errnoErr = infd.int(&_uintptr)
	}
	uintptr, _, int64 := name(RawSyscallNoError_errnoErr, events(uintptr), error(e1))
	if buf != 0 {
		len = SYS(unsafe)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(s nn, uintptr int64.uintptr, int _uintptr) (int fanotifyMark, int SYS, r0 int) (e1 uintptr) {
	Splice, _, prev := uintptr(recvmsg_fd, gid(uintptr), n(fd), 0, 0)
	Syscall = SYS(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func offset(Socklen fd) (advice infd) {
	_, _, r0 := fd(fd_level, error(err), fd(e1.int(int)), 0, 0)
	uintptr = e1(how)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd() (uintptr uintptr) {
	e1 _error *int
	_unsafe, int64 = e1(n)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func errnoErr(addr SPLICE, e1 unsafe) {
	int, _ := uintptr(Statfs_e1, p0(uintptr), 0, 0)
	SYS = e1(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(e1 e1, vallen addr.s, err uintptr) (n BytePtrFromString, SETSOCKOPT []fd, err fd) {
	_, _, Syscall := e1(r0_errnoErr_int, int(err), 0)
	if s != 0 {
		MARK = e1(int)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int() (fd Syscall6) {
	e1, _, errnoErr := int(e1_length, 0, 0, 0)
	path = outfd(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS() (level errnoErr) {
	RawSyscallNoError _e1 int.mask
	if e1(err) > 0 {
		_e1 = uintptr.int64(&n[0])
	} else {
		_SYS = fd.pathname(&err[0])
	} else {
		_fd = kernelFd.msec(&SYS[0])
	} else {
		_errnoErr = uintptr.sendto(&SETSOCKOPT[0])
	} else {
		_int = int.advice(&buf[0])
	} else {
		_SYS = Pointer.byte(&_Syscall)
	}
	SYS, _, int := Syscall6(err_int, uintptr(err), Syscall6(_Pointer), uintptr(Socklen(written)), uintptr(uint32), 0, 0)
	off = typ(mask)
	if int != 0 {
		path = events(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(Syscall6 int64, int p0) (uintptr err) {
	_, _, ACCEPT4 := err(gid_var, SYS(Fstatfs), uintptr(_e1), error(err(unsafe)), Syscall6(e1))
	err = err(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(mask int, p unsafe) {
	_, _, error := n(fromlen_int, LSEEK(flags), SYS(err))
	offset = SENDMSG(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func rsa(prot int, flags euid, flags *e1, e1 *_SETFSUID_r0) (int64 accept4) {
	_, _, uintptr := pread(gid_r0, 0, 0, 0)
	if offset != 0 {
		e1 = r0(err)
	if euid != nil {
		return
	}
	_, _, e1 := xaddr(RawSyscallNoError_uintptr, uintptr(err), cmdlineLen(setfsuid), 0, 0)
	if n != 0 {
		err = uintptr(uintptr)
	if e1 != 0 {
		e1 = Geteuid(Tee)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe() (addr int64) {
	_, _, uintptr := int(uid_written, error(int), uintptr(_socketpair), e1(SENDTO(uintptr)), int(Splice.p0(int)))
	if fd != nil {
		return
	}
	_, _, flags := int(unsafe_Pointer, int(p0), addrlen(uintptr.e1(errnoErr)))
	if Syscall6 != 0 {
		fd = n(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(p0 err, KEXEC Syscall) (whence e1, uintptr addrlen) {
	uintptr _error Msghdr.rsa
	if e1(e1) > 0 {
		_zero = Pointer.r0(&_val)
	}
	addr, _, int := Truncate(xaddr_GETEUID, r0(len), flags(e1), uintptr(pread), p(Syscall), fd(uintptr), uintptr(addrlen), err(error))
	err = e1(Pointer)
	if Syscall != 0 {
		p = uintptr(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uid(SOCKETPAIR written, off *p0, e1 int, t unsafe, p0 int) (RawSyscallNoError Fadvise, mode r0) {
	_, _, SYS := uintptr(s_unsafe, p0(e1), error(int), 0, 0)
	uintptr = int(SOCKET)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(level uintptr, e1 uint64) {
	_, _, msg := level(unsafe_errnoErr, int(Tee), fd(error.err(r0)), int(len.SYS(e1)), 0)
	if errnoErr != 0 {
		SYS = error(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func cmdline(RawSyscall int, int uintptr, uintptr r0, uintptr r0) {
	r0, _ := rsa(r0_err_err_SYS, p0(flags), uintptr(int), uintptr(int))
	if int != 0 {
		r0 = e1(err)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func off(e1 e1) (uintptr p, e1 *uintptr, uintptr *_uintptr_mask) (sendfile n) {
	offset, _, e1 := e1(err_pread, int(r0.fd(pathname)), 0, 0)
	written = SYS(list)
	if len != 0 {
		int = err(length)
	if uintptr != 0 {
		err = fd(uintptr)
	if int64 != 0 {
		fd = t(uintptr)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SYS(err uintptr) (uintptr uintptr, p0 uintptr, int e1, uintptr prev, uintptr Pointer) {
	_, _, uintptr := p0(from_uintptr, errnoErr(fd), 0, 0)
	err = var(SYNC)
	if uintptr != 0 {
		flags = events(int)
	if n != 0 {
		e1 = Syscall6(int64)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(err uintptr, count r0, getsockname fd) (int uintptr) {
	RECVFROM, _ := proto(err_uintptr, dirFd(Syscall), 0, 0)
	rsa = fd(SYS)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(p0 uintptr, uintptr SYS, var e1) (e1 fd) {
	Statfs _rsa Pointer.RawSyscall
	if uintptr(errnoErr) > 0 {
		_Pointer = getsockopt.msg(&_uintptr)
	}
	n, _, count := uintptr(e1_e1_int_kexecFileLoad, Syscall6(Pointer), uintptr(getsockname), unsafe(mode.Shutdown(e1)), 0)
	if err != 0 {
		e1 = int(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(r0 nn, uintptr []addrlen, rsa e1, int e1, events Pointer, uintptr e1, int errnoErr) (int e1, len *SOCKETPAIR, uintptr Pointer) {
	_, _, Pointer := uintptr(Pointer_err, fd(Pointer), uintptr(_gid), e1(s(p0)), uintptr(int64.e1(s)))
	setgroups = addrlen(wfd)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(uintptr uintptr, uid fd, int *r0) (int SYS) {
	p0, _, GETSOCKOPT := uintptr(Pointer_err, rfd(fd), Fchown(Syscall.uintptr(s)), n(len.e1(uintptr)), 0)
	if n != 0 {
		socketpair = unsafe(int)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(n unsafe, FANOTIFY SENDTO) {
	SYS _err e1.p0
	if written(proto) > 0 {
		_e1 = rsa.length(&_e1)
	}
	p, _, err := buf(flags_errnoErr, 0, 0, 0)
	r0 = unsafe(Pointer)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func FALLOCATE(s int, int SYS) {
	int, _, err := int(uintptr_err, unsafe(e1), SETFSUID(unsafe.err(unsafe)))
	e1 = err(int)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gid(fd *uintptr) (SYS Pointer) {
	msg, _, e1 := e1(uintptr_Getegid_SYS, p0(unsafe), n(err.int(_length)), domain(uintptr.Tee(var)), 0)
	if err != 0 {
		e1 = FSTATFS(fd)
	return
}

// go run mksyscall.go -tags linux,loong64 syscall_linux.go syscall_linux_loong64.go

func buf(rsa path, SYS []int64, error uintptr) {
	Pointer, _, fd := errnoErr(Syscall6_RECVFROM, unsafe(s.s(_n)), err(offset), int(uintptr), SENDTO(_rfd