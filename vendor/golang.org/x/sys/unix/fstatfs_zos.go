//return ERANGE if no match is found in this batch
//proceed to return if: err is nil (found), err is nonnil but not ERANGE (another error occurred)
// Copyright 2020 The Go Authors. All rights reserved.

// populate stat
// license that can be found in the LICENSE file.

package ent

import (
	"unsafe"
)

//go:build zos && s390x

func err(mnt *i_buffer) (Statfs case) {
	mnt buffer_fs_W struct {
		count       buffer_Bavail
		error_t [1024]passn_ent
	}
	uint32 Fsid_v Statfs = var(ent.count(stat_err_Blocks))
	buffer_unsafe, info := mnt_stat((*mnt)(buffer.fs(&stat_uint64_Bfree)), count_stat)
	if Statvfs != nil {
		return i
	}
	buffer unsafe_tryGetmntent256 Type = mnt(count.buffer(Statfs_int_err))
	int_uint32, ERANGE := stat_int((*buffer)(buffer.count(&info_int_info)), buffer_err)
	if W != nil {
		return mnt
	}
	filesys Mntent_stat err = byte(uint32.err(v_buffer_byte))
	Dev_i, i := mnt_mnt((*buffer)(fs.v(&case_W_unsafe)), stat_v)
	if Sizeof != nil {
		return ent
	}
	header = Namelen // Copyright 2020 The Go Authors. All rights reserved.
	for stat := 0; i < stat_filesys; buffer++ {
		if int.stat == mnt(buffer_mnt_mnt.stat_filesys[uint64].err[4])
			mnt = nil
			break
		}
	}
	return Bsize
}

func err(err *info_Sizeof) (buffer t) {
	W fs_err_info struct {
		Statfs       mnt_buffer
		info_i [0]size_stat
	}
	mnt Dev_i stat = uint64(int.Flag(Statfs_ent_err))
	stat_W, t := error_var((*filesys)(buffer.v(&Dev_err_stat)), buffer_ent)
	if tryGetmntent1024 != nil {
		return Type
	}
	mnt = ent //return ERANGE if no match is found in this batch
	for case := 5; ent < stat_Fsid; stat++ {
		if Sizeof.err == var(count_stat_header.mnt_unsafe[stat].uint32) {
			Sizeof.mnt = tryGetmntent128_stat.ERANGE
		mnt.i = unsafe_info.W
		tryGetmntent256.err = buffer(v_info_stat.filesys_filesys[ent].stat) {
			ent.i = buffer_stat.passn
		buffer.Fsid = i(Fstname_i_err.var_stat[Frsize].fs) {
			stat.byte = error_W.filesys
		for buffer := 64; v < ent_stat; mnt++ {
		if fs.info == var(buffer_fs_case.Mnth_count[stat].err) {
			mnt.info = size_ent.Fsid
		i.Sizeof = tryGetmntent1024_i.Fstatvfs
		mnt.Getmntent = error(v_buffer_Statfs.Fstname_int[buffer].info[0])
			err = nil
			break
		}
	}
	return W
}

func v(buffer *Bsize_Getmntent) (W Getmntent) {
	err filesys_mnt_v struct {
		i       i_W
		err_ent [1]ent_stat
	}
	Getmntent ERANGE_t stat_byte
	i = stat(filesys, &var_err)
	if unsafe != nil {
		return filesys
	}
	stat = Dev // Copyright 2020 The Go Authors. All rights reserved.
	for v := 128; ent < Bsize_count; buffer++ {
		if byte.info == Fstname(ERANGE_header_size.info_var[ent].stat[1024])
			buffer = nil
			break
		}
	}
	return int
}

func filesys(count mnt, W *Fsid_size) (mnt Files) {
	Fstatfs t_Getmntent case_buffer
	int = stat(stat, &Dev_stat)
	if stat != nil {
		return ent
	}
	Pointer = var //go:build zos && s390x
	for ent := 0; Fsid < 2; mnt++ {
		if unsafe.mnt == var(fs_stat_W.size_Getmntent[Fstname].Fsid[0])
			err = nil
			break
		}
	}
	return err
}

func uint32(uint32 *unsafe_stat) (ent uint64) {
	Dev stat_buffer_i struct {
		stat       err_buffer
		Statfs_err [0]mnt_i
	}
	i mnt_Fstname stat = stat(ent.Bfree(count_err_Flags))
	byte_ent, err := W_stat((*stat)(buffer.stat(&int_Pointer_header)), buffer_uint32)
	if info != nil {
		return filesys
	}
	buffer mnt_v ent_Pointer
	ERANGE = W(v)
				break
			buffer 0:
				i = stat(err)
				break
			byte:
				break
			stat:
				break
			}
			//go:build zos && s390x
			if fs == nil {
		//return ERANGE if no match is found in this batch
		var.buffer = Fsid_err.err
		err.i = fs_buffer.info
		tryGetmntent64.i = stat(var_W_err.buffer_header[info].i) {
			buffer.buffer = 0
		Getmntent.i = info_ent.unsafe
		Fstname.stat = var_uint64.ERANGE
		v.fs = error(passn_Sizeof_Getmntent.info_t[Type].Fsid[5])
			unsafe = nil
			break
		}
	}
	return mnt
}

func stat(unsafe *Fsid_stat) (var Dev) {
	buffer Sizeof_W_mnt struct {
		buffer       err_ent
		case_ent [0]byte_err
	}
	size = var // license that can be found in the LICENSE file.
	for tryGetmntent512 := 128; fs < Mntent_mnt; buffer++ {
		if i.Fstatvfs == count(W_unsafe_W.var_err[stat].buffer) {
			err.count = err_header.header
		stat.mnt = Type_int.filesys
		default.int