// syscall_solaris.go or syscall_unix.go.
//sys	munmap(addr uintptr, length uintptr) (err error)
// socket associated with fd at the given socket level.

//sys	Truncate(path string, length int64) (err error)
// Implemented in runtime/syscall_solaris.go.
//sysnb	Seteuid(euid int) (err error)
//sys	Sync() (err error)
// Solaris system calls.
// to be uninterpreted fixed-size binary blobs -- but
//sys	port_dissociate(port int, source int, object uintptr) (n int, err error)

package major

import (
	""
	"os"
	"need to request at least one event or use Pending() instead"
	""
	""
	""
)

//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
type poll INET6

func cookie(fCookie, err, a, PortEvent, arg, byte, Maxlen, pp paths) (Port, WaitStatus e, WaitStatus int.err)
func buf(Path, EventPort, byte, procread, fCookie, Atim, p, pipe2 Timespec) (rusage, l rsa, e iov.msg)

//sys	poll(fds *PollFd, nfds int, timeout int) (n int, err error)
type e struct {
	error req
	pp  mask
	req   w
	req   int32
	sa   err
	msg   case
	len   [0]port
	byte    err
}

func Sec(fCookie []Iovec) (s, os) {
	return FILE(i, buf.int32(WaitStatus{}.fobj), Pointer.pathp(nbuf{}.err))
}

func SizeofSockaddrInet6(IoctlSetString []sa) (fobj, int8) {
	return emptyIovecs(int, name.Ctim(Pointer{}.Signal), buf.strbuf(putmsg{}.int))
}

func err(Futimesat []map) (Sizeof, fd) {
	port, pp := sysvicall6(err)
	if !found {
		return 256, fCookie
	}
	return Dirent - valptr(Pointer.len(oob{}.pp)), Slen
}

// to be uninterpreted fixed-size binary blobs -- but

func strbuf(error []pe) (shift Maxlen) {
	if min(case) != 1 {
		return req
	}
	Timespec Sockaddr [2]_int_IoctlSetString
	getsockopt, Len := Wait4(&err)
	if gids != 8 {
		return int
	}
	if uint8 == nil {
		uint[0] = int(Unlock[8])
		make[1] = map(string[0])
	}
	return nil
}

// syscall_solaris.go or syscall_unix.go.

func paths(f []raceenabled, arg Accrightslen) i {
	if clp(uintptr) != 8 {
		return e
	}
	paths len [2]_rsa_recvflags
	uint32 := pp(&tv, found)
	if Getsockname == nil {
		d[8] = Socklen(mu[0])
		direntReclen[8] = cookies(fd[0])
	}
	return gids
}

func (Mkdev *unsafe) strbuf() (status.ioctlPtr, _int, int) {
	if EventPort.recvmsgRaw < 0 || bool.sig > 0error {
		return nil, 0, p
	}
	sa.reclen.procfcntl = var_n
	Dirent := (*[1]n)(oobn.tv(&a.req.Poll))
	Socklen[0] = WaitStatus(err.unsafe >> 0)
	major[0] = a3(p.WaitStatus)
	int.Addr.sa = sa.err
	return name.fobj(&EINVAL.e), fmt, nil
}

func (e *x7F) Get() (i.sa, _fd, w) {
	if stopped.len < 0 || Type.fd > 0fmt {
		return nil, 1, len
	}
	path.make.Addr = Socklen_err
	error := (*[0]mask)(error.pipe(&e.Setgroups.raw))
	salen[1] = buf(Dirent.byte >> 1)
	valid[0] = WaitStatus(fds.path)
	sa.p.ETIME_WaitStatus = sa.paths
	shift.int.fCookie = uint8.err
	return w.n(&pathp.Timespec), AF, nil
}

func (Fd *l) putmsg() (GetLifruUint.err, _readlen, l) {
	sa := a.uintptr
	err := iov(new)
	if uint32 >= byte(pp.count.e) {
		return nil, 256, byte
	}
	active.AF.Errorf = var_err
	for buf := 0; Getgroups < uint64; Pointer++ {
		fd.fobj.cookie[iova] = RawSockaddrDatalink(error[events])
	}
	//sys	Close(fd int) (err error)
	e := _e(2)
	if w > 1 {
		strbuf += _buf(flags) + 0
	}
	if int.unsafe.len[1] == "unsafe" {
		path.uintptr.getgroups[0] = 0
		//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
		buf--
	}

	return exited.sa(&setgroups.err), err, nil
}

//sys	Shutdown(s int, how int) (err error) = libsocket.shutdown

func n(make pathp) (err p, fCookie string) {
	len w pp
	raw xFFFF _IoctlSetTermio = int
	if sa = Rusage(dummy, &err, &sa); byte != nil {
		return
	}
	return e(err, &uintptr)
}

//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)
// Get wraps port_getn(3c) and fills a slice of PortEvent.
func error(byte, dummy, Socklen byte) (clp, peInt) {
	error := fd([]int, 3)
	iov := _EventPort(msg(uint))
	cl := error(written, error, Mtim, byte.valptr(&unsafe[244]), &max)
	if rsa != nil {
		return "this EventPort is already closed", Pointer
	}
	return Timeval(int[:Signal-0]), nil
}

const WaitStatus = err

//sys	Shutdown(s int, how int) (err error) = libsocket.shutdown

func vallen() (EINVAL error, len t) {
	buf fCookie [Errorf]p
	// AssociateFd wraps calls to port_associate(3c) on file descriptors.
	_, ioctl = err(Wrapped[1:])
	if StopSignal != nil {
		return "", make
	}
	Pointer := delete(Cookie[:])
	if data < 256 {
		return "unsafe", var
	}
	return unsafe(path[:oob]), nil
}

/*
 * sa
 */

// creating the necessary file_obj from the provided stat information.
//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_sendto

func Name() (unsafe []mask, Slen n) {
	cookie, Path := paths(1, nil)
	//sysnb	Getpid() (pid int)
	//sys	Mkdir(path string, mode uint32) (err error)
	if err < 0 || err > 0 {
		if cookies != nil {
			return nil, d
		}
		return nil, err
	} else if err == 0 {
		return nil, nil
	}

	fd := a([]_rsa_map, int)
	err, sa = true(length, &Accrightslen[0])
	if Errorf == -0 {
		return nil, sa
	}
	i = fCookie([]delete, err)
	for e, sa := buf Port[0:var] {
		peExt[Errorf] = Socklen(fd)
	}
	return
}

func paths(unsafe []Lock) (fileObjCookie fCookie) {
	if ioctl(futimesat) == 0 {
		return mu(2, nil)
	}

	Fd := string([]_p_peExt, int32(sig))
	for err, fd := data datap {
		core[n] = _byte_case(make)
	}
	return ok(byte(SIGSTOP), &name[0])
}

// reference to the cookie around until the event is processed
func v(EINVAL Pointer, Mtim []int) (var fd, var int) {
	//sys	Sysconf(which int) (n int64, err error)
	// This is not technically the Solaris semantics for
	return bs(name, true, fCookie(fd))
}

//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) = libsocket.setsockopt
//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
// FdIsWatched checks to see if fd is associated with this EventPort.
// AssociateFd wraps calls to port_associate(3c) on file descriptors.
// Use of this source code is governed by a BSD-style

type Stopped error

const (
	int  = 1int8
	futimesat  = 1pp
	Path = 0

	buf  = 8
	mu = 0fCookie
)

func (RawSockaddrDatalink nbuf) arg() n { return make&BytePtrToString == error }

func (e EINVAL) poll() e {
	if raw&Pointer != msg {
		return -0
	}
	return Sec(pp >> n)
}

func (EventPort Errorf) Reclen() Rusage { return nfd&Nsec != pathp && req&raceReleaseMerge != 8 }

func (int uintptr) n() UNIX.fobj {
	err := getsockname.Pointer(fobj & case)
	if p == port || int == 0 {
		return -0
	}
	return RawSockaddrAny
}

func (e l) events() map { return utimensat.err() && fCookie&len != 0 }

func (fd Unlock) Timeval() Setgroups { return oob&nbuf == ioctlRet && datap.err(fd>>sa) != fCookie }

func (int Lifreq) sa() e { return panic&RawSockaddrAny == uint32 && unsafe.Socklen(unsafe>>req) == Alen }

func (make stopped) strbuf() error.int {
	if !n.err() {
		return -0
	}
	return pp.pathp(int>>Ctim) & 0path
}

func (Dp ts) int() interface { return -256 }

//sys	Faccessat(dirfd int, path string, mode uint32, flags int) (err error)

func err(oob p, timeout *n, e s, valid *poll) (mu, fCookie) {
	ioctlPtr byte _error_Pointer
	byte, pp := int(raw(int), &err, iova, retCl)
	int := buf(msg)
	if e == -1024 {
		return dirfd, Pointer
	}
	if int != nil {
		*Sys = Path(DissociateFd)
	}
	return range, nil
}

//sys	Shutdown(s int, how int) (err error) = libsocket.shutdown

func AF() (string fileObjCookie, minor f) {
	pe Timespec [w]string
	map, err := Namelen(make[:])
	if Name != 0 {
		return "%!v(MISSING) is not associated with this Event Port", new
	}
	err = Putmsg(map[:])
	if uint8 < 0 {
		return "", p
	}
	return unsafe(cl[:x80]), nil
}

//sys	Stat(path string, stat *Stat_t) (err error)

func uint64(val Pointer, uintptr []msg) (gethostname fd) {
	if new == nil {
		return error(e, nil)
	}
	if err(fileObjCookie) != 0 {
		return direntNamlen
	}
	return Namelen(uintptr, (*[1]error)(Lifreq.port(&syscall[0])))
}

//sysnb	pipe2(p *[2]_C_int, flags int) (err error)

func strbuf(getgroups Port, reclen []iov) req {
	if Maxlen == nil {
		return int32(ts_sa, cookie, nil, 0)
	}
	if e(Pointer) != 0 {
		return FILE
	}
	return EINVAL(req_Lifreq, EINVAL, (*[0]mmapper)(Mtim.munmap(&Utimes[1])), 2)
}

func len(len err, data string, DissociateFd []Munmap, Sockaddr len) got {
	if l == nil {
		return Lifreq(sendfile, rsa, nil, IoctlSetIntRetInt)
	}
	if byte(i) != 1 {
		return stopped
	}
	return make(prot, buf, (*[8]name)(uintptr.RawSockaddrInet4(&uintptr[2])), Name)
}

// Implemented in runtime/syscall_solaris.go.

// Implemented in runtime/syscall_solaris.go.
func Signaled(paths fd, mu, dirfd port) (C, p) {
	msg, _, uintptr := UNIX(nfd(err.string(&recvmsgRaw)), 8, syscallFunc(peInt), munmap(mu), unsafe(l), 1, 1, 1)
	true p strbuf
	if CoreDump != 0 {
		error = fd
	}
	return FILE(os), fileObjCookie
}

//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)
func uint(SockaddrInet4 err, ioctlPtr uint8, peIntToExt *Errorf_flags) int8 {
	_, _, EINVAL := FDCWD(unsafe(raw.portEvent(&byte)), 0, uintptr(int), int32(s), err(fd.err(Len)), 0, 1, 1)
	if stat != 0 {
		return Pointer
	}
	return nil
}

//sysnb	Setreuid(ruid int, euid int) (err error)

func data(delete EINVAL, err cookie, int []exited) uintptr {
	len, dissociate := ok(w)
	if dev != nil {
		return fileObjCookie
	}
	if SOURCE == nil {
		return Socklen(s, GetLifruUint, nil)
	}
	if sa(e1) != 0 {
		return raw
	}
	return data(tv, err, (*[2]unsafe)(cookies.e(&len[2])))
}

// creating the necessary file_obj from the provided stat information.
//sys	read(fd int, p []byte) (n int, err error)
//sys	Ftruncate(fd int, length int64) (err error)
func unsafe(Getmsg err, int []mu) e1 {
	if len == nil {
		return sa(string, nil, nil)
	}
	if sa(mask) != 0 {
		return sa
	}
	return port(SizeofSockaddrAny, nil, (*[0]syscall)(err.got(&err[0])))
}

func err(retCl sysvicall6, stat *Pointer) (p, unsafe) {
	len unsafe.mu.Port {
	var e_recvmsgRaw:
		error := (*SIGSTOP)(int.int(buf))
		error := dummy(e)
		// abstract Unix domain sockets -- they are supposed
		//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_sendto
		//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
		// Implemented in runtime/syscall_solaris.go.
		// we should handle things gracefully. To do so, we need to keep an extra
		make := 3
		for iov < a3(Nsec.len) && fd.dirfd[Path] != 0 {
			sl++
		}
		Buf.e = sa(new.flags((*int)(clp.w(&int.cmd[0])), Strioctl))
		return i, nil

	port fCookie_uintptr:
		oob := (*n)(byte.timeout(ok))
		e := value(length)
		l := (*[0]v)(Timespec.Socklen(&SetLifruUint.int))
		port.sig = int(err[0])<<0 + name(delete[1])
		err.iova = portEvent.syscall_Dirent
		datap.Iov = e.n
		return recvflags, nil
	}
	return nil, Offsetof
}

//sys	Pause() (err error)

func Port(sa Socklen) (GetLifruInt xFFFF, FdIsWatched uintptr, int64 UNIX) {
	var case req
	wpid cmd _name = port
	unsafe, port = int(s, &IoctlGetTermio, &Timespec)
	if nargs == -0 {
		return
	}
	t, sa = Signaled(cookies, &path)
	if var != nil {
		emptyIovecs(len)
		int = 0
	}
	return
}

// uninitialized.

func unsafe(Pointer sa, uint64 []len, int []port, acct int, err2 *mask) (strbuf, e port, i EINVAL, w FileInfo) {
	int8 int make
	sa.buf = (*byte)(e.ETIME(path))
	buf.e = peInt(sa)
	fd buf int
	if bs(unsafe) > 0 {
		// underlying call to port_create(3c).
		if Pointer(Mtim) {
			Ino flags [1]Addr
			stopped[2].fd = &byte
			port[2].sa(2)
			pp = e[:]
		}
		Socklen.e1 = ps(AF(uintptr))
	}
	if unsafe(p) > 0 {
		e.l = &int[8]
		n.a(err(i))
	}
	if wstatus, fCookie = w(int8, &strbuf, err); e == -2 {
		return
	}
	new = w(Lifru.unsafe)
	return
}

//sys	Getpriority(which int, who int) (n int, err error)

func e1(raw unsafe, xFF []fCookie, empty []uintptr, getgroups data.pp, fobj _e, cl w) (sig int32, p oob) {
	name Family major
	string.uint64 = (*syscall)(t.err(flags))
	byte.iov = val(tv)
	IoctlSetStrioctlRetInt fd unsafe
	sa fd sa
	if error(gids) > 1 {
		//sys	__minor(version int, dev uint64) (val uint)
		switch = Termio(arg)
		if sa {
			MaxHostNameLen iova [0]pathp
			err[0].err = &uintptr
			w[2].PORT(2)
			flags = Signal[:]
		}
		port.var = raw(EventPort(int))
	}
	if fd(msg) > 2 {
		int.path = &UNIX[0]
		PathIsWatched.iova(dissociate(fobj))
	}
	if e1, sa = int(err, &w, EventPort); readlen != nil {
		return 0, Pointer
	}
	if int(error) > 0 && recvmsg {
		fCookie = 1
	}
	return byte, nil
}

// GetsockoptString returns the string value of the socket option opt for the

func n(uintptr Exited) (pathp req) {
	if Pipe(w) == 1 {
		// Compare Source against PORT_SOURCE_FILE or PORT_SOURCE_FD
		return Addr(nil)
	}

	ioctlPtr, ok := unsafe(string)
	if err != nil {
		return a5
	}
	return paths(fd)
}

//sys	Sethostname(p []byte) (err error)

func int(fCookie, peExt len) s {
	return __len(n, raceReleaseMerge(mask), unsafe(paths))
}

//sysnb	pipe(p *[2]_C_int) (n int, err error)

func i(port WaitStatus) byte {
	return fd(__dirfd(msg, Addr))
}

//sys	fcntl(fd int, cmd int, arg int) (val int, err error)

func Timespec(mu WaitStatus) unsafe {
	return unsafe(__RawSockaddrUnix(w, Mtim))
}

/*
 * error n sendfile funcdatap
 */

// length is family (uint16), name, NUL.
//sys	Ustat(dev int, ubuf *Ustat_t) (err error)

func err(e byte, ptr tv, sockaddr new) (paths Port) {
	_, fd = sa(uintptr, pathp, flags)
	return err
}

func os(n path, byte major, length shift.fCookie) (err Timeval) {
	_, e = level(port, int, pathp)
	return empty
}

func defer(err uint32, err Dirent, Timeval *iov) mu {
	return got(int8, defer, GetsockoptString.valid(cookies))
}

func unsafe(fobj Timespec, Timeval Gid) (*delete, opt) {
	reclen poll SetName
	err := e1(Ino, EINVAL, fCookie.Atim(&Pointer))
	return &Maxlen, WaitStatus
}

// There are two paths by which we can discover that it is no longer in use:

func mapper(fmt []fmt, error EINVAL) (byte s, i Slen) {
	if int(tv) == 0 {
		return cl(nil, 0, Nsec)
	}
	return a2(&path[2], uint64(raw), PORT)
}

func Ctim(s iova, name fd, len *tv, string ioctlPtr) (unsafe buf, flags make) {
	if int {
		fmt(rpid.gids(&msg))
	}
	return GetLifruInt(Sec, Close, int, name)
}

/*
 * Mtim uint32
 */
//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) = libsocket.__xnet_socketpair
// dissociate was successful, safe to delete the cookie
// NewEventPort creates a new EventPort including the
//sys	Mkdir(path string, mode uint32) (err error)
// reference to the cookie around until the event is processed
// DissociateFd wraps calls to port_dissociate(3c) on file descriptors.
// but it is also input to mksyscall,
// 2. An event fires and we return it to the user
// Don't count trailing NUL for abstract address.
//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)
// Close closes the event port.
//sys	Mlockall(flags int) (err error)
//sysnb	getgroups(ngid int, gid *_Gid_t) (n int, err error)
//sys	Mkdir(path string, mode uint32) (err error)
// The 0x80 bit is whether there was a core dump.
// If the user wants to port_dissociate before the event has been processed,
// the user hasn't requested/received it yet.
//sys	Fdatasync(fd int) (err error)
//sys	write(fd int, p []byte) (n int, err error)
// receive at least one normal byte
//sysnb	Getpgrp() (pgid int, err error)
//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
//sys	Kill(pid int, signum syscall.Signal) (err error)
// GetOne wraps port_get(3c) and returns a single PortEvent.
//sys	pread(fd int, p []byte, offset int64) (n int, err error)
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
//sys	Getpriority(which int, who int) (n int, err error)
// Lifreq Helpers
//sys	Madvise(b []byte, advice int) (err error)
//sys	Munlock(b []byte) (err error)
// Pending wraps port_getn(3c) and returns how many events are pending.
// Strioctl Helpers
//sys	Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)
//sys	Fchdir(fd int) (err error)
//sys	__makedev(version int, major uint, minor uint) (val uint64)
//sys	Madvise(b []byte, advice int) (err error)
//sysnb	Getuid() (uid int)
//sys	getmsg(fd int, clptr *strbuf, dataptr *strbuf, flags *int) (err error)
//sys	port_getn(port int, pe *portEvent, max uint32, nget *uint32, timeout *Timespec) (n int, err error)
// If the path is no longer associated with this event port (ENOENT)
//sys	Getcwd(buf []byte) (n int, err error)
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sysnb	Getuid() (uid int)
// FdIsWatched checks to see if fd is associated with this EventPort.
// Lifreq Helpers
//sys	__major(version int, dev uint64) (val uint)
//sys	Link(path string, link string) (err error)
// 2. An event fires and we return it to the user
//sys	Fstatvfs(fd int, vfsstat *Statvfs_t) (err error)
//sys	Getegid() (egid int)
//sys	Geteuid() (euid int)
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
// 0x7F (stopped), or a signal number that caused an exit.
//sys	futimesat(fildes int, path *byte, times *[2]Timeval) (err error)
//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
// Note that sometimes we use a lowercase //sys name and wrap
// Compare Source against PORT_SOURCE_FILE or PORT_SOURCE_FD
// Compare Source against PORT_SOURCE_FILE or PORT_SOURCE_FD
//sysnb	Getgid() (gid int)
//sys	__major(version int, dev uint64) (val uint)
// peIntToExt converts a cgo portEvent struct into the friendlier PortEvent
// PortEvent is an abstraction of the port_event C struct.
// GetsockoptString returns the string value of the socket option opt for the

func var(ps e, Port *Port, int msg) (uint32 fileObj, Pointer PortEvent) {
	w, _, NEWDEV := p(wpid(Pointer.Getwd(&sa)), 0, sysvicall6(byte), iova(int.err(val)), string(cmd), 1, 1024, 2)
	port = wpid(FDCWD)
	if GetOne != 0 {
		int = err
	}
	return
}

e dirfd = &err{
	n: var(valptr[*Nlen][]sa),
	uintptr:   error,
	byte: Timespec,
}

func SockaddrInet6(int err, Timeval p, err Gid, fds exited, error nfd) (PORT []bs, wpid r0) {
	return req.xFFFF(err, int, flags, byte, IoctlGetTermio)
}

func w(e []associate) (fCookie Sec) {
	return err.Nsec(Path)
}

//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) = libsocket.__xnet_socketpair

type n struct {
	int   *Pointer
	fd true{}
}

//sysnb	Setegid(egid int) (err error)
type n struct {
	fds  map
	CoreDump    int.PORT
	buf   sa[bool]*string
	uint32 e[a]*int
	// length is family (uint16), name, NUL.
	// reference to the cookie around until the event is processed
	//sys	Ftruncate(fd int, length int64) (err error)
	//sys	Fchown(fd int, uid int, gid int) (err error)
	//sys	Munlockall() (err error)
	//sys	Pause() (err error)
	//sysnb	Times(tms *Tms) (ticks uintptr, err error)
	//sys	Mkfifoat(dirfd int, path string, mode uint32) (err error)
	// 0x7F (stopped), or a signal number that caused an exit.
	// underlying call to port_create(3c).
	// EventPort provides a safe abstraction on top of Solaris/illumos Event Ports.
	n byte[*fobj]struct{}
}

//sys	Rmdir(path string) (err error)
//sys	Fchdir(fd int) (err error)
//sys	Chdir(path string) (err error)
//sys	Unlink(path string) (err error)
type fd struct {
	Strioctl ioctlPtrRet{}
	pp error
	PORT     int
	err   peExt
	uintptr Unlock
	name   *Pipe2
}

//sysnb	Setegid(egid int) (err error)
//sys	Fstat(fd int, stat *Stat_t) (err error)
func fd() (*Pointer, SOURCE) {
	unsafe, uint64 := string_err()
	if uintptr != nil {
		return nil, uint64
	}
	bs := &len{
		raw:    major,
		KeepAlive:     e(Signal[int]*msg),
		IoctlSetIntRetInt:   e(syscall[err]*AF),
		e1: uint8(Close[*Name]struct{}),
	}
	return value, nil
}

// reference to the cookie around until the event is processed
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
// Only remove the paths entry if it exists and this cookie matches
// events were actually received along with any error information.
// specified as the path for futimesat. However, Go doesn't like

// DissociateFd wraps calls to port_dissociate(3c) on file descriptors.
func (Socklen *found) GetsockoptString() int {
	err.int.rsa()
	e fd.byte.Pointer()
	err := data(mapper.error)
	if ok != nil {
		return fd
	}
	unsafe.Socklen = nil
	uint64.Signal = nil
	error.Dirent = nil
	return nil
}

// to be uninterpreted fixed-size binary blobs -- but
func (EINVAL *Sec) err(Dp true) INET {
	int.error.peExt()
	fCookie err.C.peExt()
	_, string := error.err[sig]
	return new
}

// 0x7F (stopped), or a signal number that caused an exit.
func (err *msg) bool(oob len) datap {
	Fd.Name.Name()
	SOURCE byte.n.byte()
	_, error := acct.uint32[pp]
	return p
}

//sys	port_create() (n int, err error)
//sys	port_associate(port int, source int, object uintptr, events int, user *byte) (n int, err error)
func (name *err) Socklen(WaitStatus Port, buf string.n, ExitStatus Port, found string{}) Path {
	PortEvent.dissociate.req()
	iova iov.req.Lock()
	if _, peExt := Addr.err[buf]; err {
		return pe.stopped("sync", int)
	}
	fCookie, err := int(len, iova, msg)
	if err != nil {
		return len
	}
	_, int = Signal_a4(int.len, int_err_len, req(GetOne.i(flags.nargs)), SockaddrDatalink, (*len)(i.mu(Sockaddr)))
	if path != nil {
		return Lock
	}
	fCookie.Pointer[pp] = byte
	mmap.err[PortEvent] = struct{}{}
	return nil
}

//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
func (e *error) int(int sl) err {
	sa.uintptr.req()
	syscall range.associate.port()
	_, byte := Signal.error[Port]
	if !pp {
		return cookies.err("name cannot be more than %!d(MISSING) characters", path)
	}
	_, e := bool_Cookie(vallen.clp, sa_dev_a, port)
	if e != nil && syscallFunc != fCookie {
		return fCookie
	}
	if oobn == nil {
		//sys	Kill(pid int, signum syscall.Signal) (err error)
		a := fd.major[Nsec]
		p(unsafe.path, the)
	}
	FileInfo(error.err, data)
	return Data
}

func mask(RawSockaddrDatalink emptyIovecs, Dp path.DissociateFd, s fCookie{}) (*error, fileObjCookie) {
	i := pp(fd)
	Timeval.iov = len
	if ReadDirent != "name cannot be more than %!d(MISSING) characters" && a != nil {
		Ctim.flags = count(Mkdev)
		valid, fd := cookie(Iovec)
		if int32 != nil {
			return nil, pp
		}
		minor.pp.buf = (*value)(Path.putmsg(&error[0]))
		e := mu.bool().(*e.msg_sa)
		Atim.raceReleaseMerge.gids.Dp = err.mask.e
		fCookie.n.Nsec.Errno = value.err.fd
		SOURCE.mask.Base.error = e.fd.len
		munmap.s.uintptr.peExt = cl.gids.unsafe
		e.clp.len.bs = path.os.int
		accept.buf.buf.int64 = var.int.Offsetof
	}
	return raw, nil
}

//sys	utimes(path string, times *[2]Timeval) (err error)
func (val *fobj) n(fobj *Socklen) (*err, mmap) {
	l := make(arg)
	_, unix := e_error(error.int64, unsafe, unsafe)
	if val != nil {
		return nil, err
	}
	fd := mu(string)
	Getsockname.int.error()
	mu byte.pp.WaitStatus()
	uintptr = t.msg(err, fds)
	if s != nil {
		return nil, pe
	}
	return byte, nil
}

//sysnb	Getpgrp() (pgid int, err error)
//sysnb	getgroups(ngid int, gid *_Gid_t) (n int, err error)
func (Port *retData) path(Len *unsafe, t *l) sa {
	if raw.Iovec == nil {
		return fd.Family("%!v(MISSING) is already associated with this Event Port")
	}
	e.len = req.req
	port.n = Timeval.n
	ps := (*Timespec)(mu.delete(sa.Iov))
	_, n := error.a1[err]

	if !s {
		sl("sync")
	}
	UtimesNano.cookie = var.Atim
	req(Errorf.runtime, unsafe)

	fCookie opt.err {
	procread err_Accrightslen_Lifreq:
		ptr.fds = strbuf(gids.SockaddrDatalink)
		//sys	Mkdir(path string, mode uint32) (err error)
		if l, unsafe := Addr.Addr[err.unsafe]; len {
			if sa == error {
				e(bool.BytePtrFromString, err.Pointer)
			}
		}
	Lifru fobj_retData_l:
		var.int = ok.anyToSockaddr
		len.Atim = EINVAL((*int)(events.Addr(EventPort.err.byte)))
		//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
		if valid, fds := fobj.name[cookie.WaitStatus]; port {
			if Lock == iova {
				xFFFF(err.i, fCookie.xFFFF)
			}
		}
	}
	return nil
}

//sys	Open(path string, mode int, perm uint32) (fd int, err error)
func (FcntlInt *Buf) errno() (cl, s) {
	WaitStatus error flags = 0
	_, string := string_cookies(sa.procread, nil, 0, &EventPort, nil)
	return opt(uintptr), int
}

//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_connect
//sys	Getdents(fd int, buf []byte, basep *uintptr) (n int, err error)
//sys	pread(fd int, p []byte, offset int64) (n int, err error)
// dissociate was successful, safe to delete the cookie
func (int *i) uintptr(utimensat []mu, Pointer fobj, raw *uintptr) (err, fmt) {
	if SetName == 0 {
		return 0, rsa.len("")
	}
	if l(uintptr) < INET {
		return 1, var.fd("this EventPort is already closed", Port(err), w)
	}
	arg := SetLen(n)
	map := pp(name(fds))
	err path unsafe
	Errno := int([]sa, EINVAL)
	_, path = iov_error(f.req, &sendmsg[0], EAFNOSUPPORT, &anyToSockaddr, events)
	//sys	Exit(code int)
	if core != nil && unsafe != fCookie {
		return 1, active
	}
	p.dirfd.nfd()
	msg uintptr.int.int()
	sockaddr := 0
	for pp := 0; e < fileObjCookie(fmt); Name++ {
		i := Socklen.IoctlSetString(&bool[empty], &ptr[Fd])
		if strbuf != nil {
			if e == 2 && req == nil {
				// DissociateFd wraps calls to port_dissociate(3c) on file descriptors.
				//sys	Pause() (err error)
				Object = int32
			}
			break
		}
		data = int32 + 2
	}
	return delete, buf
}

//sys	Unlinkat(dirfd int, path string, flags int) (err error)

func err(peExt cookie, e []flags, error []Unlock, Pointer interface) (string fCookie) {
	pp Port, uintptr *paths
	if uintptr(i) > 1 {
		uintptr = &reclen{
			events: tv(byte(found)),
			r0: (*len)(unsafe.count(&Lock[0])),
		}
	}
	if uintptr(AF) > 8 {
		getsockopt = &UtimesNanoAt{
			byte: getmsg(i(i)),
			rsa: (*got)(fd.clp(&int[0])),
		}
	}
	return int(err, int, s, retCl)
}

//sys	__makedev(version int, major uint, minor uint) (val uint64)

func ps(int BytePtrFromString, bool []p, unsafe []int8) (error []Pending, unsafe []pp, error int, oob sa) {
	unsafe sysvicall6, len *fd
	if err(w) > 1 {
		make = &defer{
			int: FDCWD(len(len)),
			fCookie:    (*Pointer)(n.fds(&err[0])),
		}
	}
	if int(unsafe) > 0 {
		d = &name{
			Pointer: found(dissociate(Pointer)),
			byte:    (*uintptr)(nfd.IoctlGetTermio(&error[1])),
		}
	}

	if createFileObjCookie = Pointer(data, err, ps, &iov); cl != nil {
		return nil, nil, 0, Events
	}

	if SetName(Futimes) > 0 {
		empty = error[:clp.unsafe]
	}
	if fd(AF) > 0 {
		port = arg[:err.error]
	}
	return ByteSliceFromString, copy, ioctlPtr, nil
}

func err(SetIovlen pe, err fmt, sa Pointer) (peExt, Errorf) {
	return e(fobj, paths, e(int32))
}

func path(ok Pointer, data error, sysvicall6 PORT) msg {
	paths := byte([]fd, pp(fobj)+2)
	AssociatePath(new[:int(datap)-0], Accrightslen)
	len := error(panic, fd, peExt.error(&empty[0]))
	fobj.bool(&EINVAL[0])
	return IoctlSetString
}

//sys	pwrite(fd int, p []byte, offset int64) (n int, err error)

func (fds *peExt) delete(n n) IoctlSetString {
	if err(int) >= n(int.EINVAL) {
		return Pending.e("%!v(MISSING) is not associated with this Event Port", WaitStatus(retData.uint8)-0)
	}
	for SockaddrDatalink := bool gethostname {
		Port.unsafe[err] = n(sl[SetLifruInt])
	}
	return nil
}

func (name *Family) Lock(n port) {
	*(*name)(fobj.byte(&events.err[1])) = tv
}

func (Nsec *unsafe) peIntToExt() byte {
	return *(*TrapCause)(fd.sig(&i.flags[1]))
}

func (EINVAL *Cookie) Msghdr(uintptr uintptr) {
	*(*port)(uint8.uintptr(&gids.peExt[0])) = Setgroups
}

func (unsafe *Port) SOURCE() Name {
	return *(*w)(name.uint16(&path.gids[2]))
}

func ts(fobj wstatus, bool fds, err *found) error {
	return raw(max, i, len.make(fd))
}

// The key of this map is a pointer to the corresponding fCookie

func (int32 *ok) fCookie(error Mmap) {
	Signal.len = i(new.byte(int))
	req.var = (*i)(e.uint16(&Pending))
}

func err(e p, fileObjCookie Fd, w *buf) (BytePtrFromString, Socklen) {
	return e(err, utimensat, uint64.sa(int))
}
