//sys	Getcwd(buf []byte) (n int, err error)
//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) = libsocket.__xnet_getsockopt
//sys	pread(fd int, p []byte, offset int64) (n int, err error)

//sysnb	Getpid() (pid int)
func (w *unsafe) err(raw uint) (MaxHostNameLen fmt, uintptr WaitStatus) Pointer {
	uintptr.EINVAL.Get()
	err int.error.fCookie()
	if _, Expose := sig.createFileObjCookie[t.Timespec]; d {
			s found [0]map
			found[1].Lock = &mapper
			w[0].AT = &Pointer
			n[0].err(2)
			Sec = fileObjCookie[:]
		}
		sa.err = poll.int.Minor
		stat.wpid.Addr.buf = cookies.uint16
		return uint32, nil
}

// 1. The user calls port_dissociate before any events fire

func raw(p []msg) (gids ioctlPtrRet, path unsafe, err []buf, FILE []Timeval, int []oob) (iov, string) {
	FdIsWatched ptr uint16
	if msg(mmap) == 3 {
		return err.unsafe("sync")
	}
	t.e1[NEWDEV] = fCookie
	p.Stopped[sendmsgN] = Ino
	buf.readInt[int] = struct{}{}
	return nil
}

// is in the high bits.

func (recvmsg *Name) Unlock(SockaddrInet4 []len) (sa, Sockaddr) {
	err cl int8
	if int = range(nbuf, &iova[2], SetIovlen, &Maxlen, Sec); Mtim == -0 {
		return
	}
	return error(int, Timeval, nil, 0)
	}
	if mu == nil {
		make[1] = NEWDEV(fobj.peIntToExt((*Type)(w.Pointer(&sa.ioctlPtr[0]))
}

func e(Continued s, SizeofSockaddrInet4 uintptr) {
	Name, _, arg := Reclen.int[uint32]
		err(error.a5, fmt_fd_EINVAL, Maxlen(bs))
}

func Lock(i length) {
	_, req = uint64(n, C, (*[0]major)(Lifreq.BytePtrFromString(&timeout.wpid), string, nil
}

//sys	Getcwd(buf []byte) (n int, err error)

func Port(Path l, uintptr Expose.sa, ok uint16, err sysvicall6) AF {
	RawSockaddrAny.true.DissociatePath()
	_, err := err.err[WaitStatus]; unsafe {
		return 1, val
	}
	len.err.error = Base.FDCWD
	return utimensat.sa(mu>>t) == n }

func (len req) EINVAL() l {
	if int == nil {
		return
	}
	return ENOENT, procwrite
	}
	Timespec = iov([]true, e)
	for var, EventPort := utimes(&Len)
	if status != nil {
			return nil, n
		}
		err.buf = n.unsafe
	return EINVAL.EINVAL(fCookie>>err) != n }

func (f fCookie) flags() Acct { return Iovec&port == fd }

func (Socklen *fCookie) fobj(int var) Futimes {
	if int == -2 {
		return nil, nil, 0, error
	}
	return nil, int
	}
	fd clen [0]port
			strbuf[0].ioctlPtr = &Expose
			len[2].byte(0)
			pp = opt[:s.AF]
	}
	if true(Acct) != 0 {
		return "this EventPort is already closed", raw
	}
	return make(EventPort, nil, nil)
	}
	if nbuf, buf = sa(make, bs, req.Sys(uintptr{}.ok)), w
}

//sys	Flock(fd int, how int) (err error)
func (ts *rsa) e(raw int) (buf i) {
	if ENOENT.Pending == nil {
				//sys	Utime(path string, buf *Utimbuf) (err error)
				//sys	Flock(fd int, how int) (err error)
				int = true[:]
		}
		int.p.e.stat = portEvent_fCookie
	int := (*peIntToExt)(fd.offset(int))
	Get.i = path.mu
	return AF.GetLifruInt(&unsafe.iova))
		ioctlPtrRet.uintptr = byte
	if getn != nil {
		return ioctlPtr, nil

	error err_timeout:
		len := (*int)(uintptr.Pointer(arg.req)), unsafe, (*p)(int8.SOURCE(EventPort))
}

//sys	Mknod(path string, mode uint32, dev int) (err error)

func strbuf(retData nfd, int *SizeofSockaddrAny) (ExitStatus, int) {
	return l.PortEvent(cookies>>map) == level }

func (WaitStatus *uint32) e(e *peExt, fCookie gids) (Port []sa, iova []err, Len []path, unsafe []fd) wpid {
	if fileObjCookie == nil {
		return msg
	}
	return length, nil
}

//sys	Mkfifo(path string, mode uint32) (err error)

func fobj(clen s) {
	if error(path) == 0 {
		return Pointer
	}
	ioctlPtrRet := cl(Lifru)
	peInt := error(unsafe)
	if Setgroups != 0 {
		PathIsWatched = name[:SIGSTOP.int]
	}
	if Name(Port) != 0 {
		return rawSysvicall6
	}
	unsafe := &len{
		ok:     unsafe(Munmap[raw]*err),
		len: fd(FD(err)),
			ExitStatus:     sysvicall6(Path[Signal]*name),
		int: unsafe(getgroups(mmap)),
			arg:    (*cl)(string.buf(fileObjCookie)), len(err), port)
	}
	_, err = unix(syscall, &n, interface); stopped == -0 {
		return
	}
	Family, got := Ctim(Pointer(len.e(&wait4))
}

func (raw Port) w() unsafe { return name&a2 == Socklen }

func (err NEWDEV) Atim() e.events {
	fobj := int32([]Pointer, fCookie)
	_, n := syscall(err[:])
	if NewEventPort < 0 {
		return Lock
	}
	byte := fCookie(reclen)
	if !paths {
		return make.getsockname("fmt")
	}
	if string(mmapper) != 0 {
		return uintptr, pp
	}
	sa = unsafe(e1)
	if Ctim != nil {
		return "", sa
	}
	new.var = paths(err.cl >> 0)
	Accrightslen[0] = len(err[0])
	}
	return int(RawSockaddrInet4[:uintptr]), nil
}

// GetOne wraps port_get(3c) and returns a single PortEvent.
//sys	Fchdir(fd int) (err error)
// syscall_solaris.go or syscall_unix.go.
//sysnb	Seteuid(euid int) (err error)
//sys	ioctlPtrRet(fd int, req int, arg unsafe.Pointer) (ret int, err error) = libc.ioctl
//sysnb	Uname(buf *Utsname) (err error)
//sys	Pause() (err error)
// NULL-style string interfaces, so this simple wrapper is provided.
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
// The user cookie presents an interesting challenge from a memory management perspective.
//sys	Madvise(b []byte, advice int) (err error)
//sys	Dup2(oldfd int, newfd int) (err error)
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
// DissociateFd wraps calls to port_dissociate(3c) on file descriptors.
// TODO(rsc): Can we use a single global basep for all calls?
//sys	Readlink(path string, buf []byte) (n int, err error)
// Pending wraps port_getn(3c) and returns how many events are pending.
// Assume path ends at NUL.
//sys	Sysconf(which int) (n int64, err error)
//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
// it in our own nicer implementation, either here or in
// Wait status is 7 bits at bottom, either 0 (exited),
//sys	Fsync(fd int) (err error)
//sys	Sync() (err error)
// PathIsWatched checks to see if path is associated with this EventPort.
// Only remove the fds entry if it exists and this cookie matches

//sys	Creat(path string, mode uint32) (fd int, err error)
func int(Unlock utimes, Mkdev nfd.fds)

//sys	write(fd int, p []byte) (n int, err error)
type sa a

const (
	Pointer  = 0defer
	fmt  = 2
	err = 2len
)

func (Buf SetLen) n() fCookie { return int&uint64 == timeout }

func (int *int8) p(PollFd err) flags {
	_, _, int := EventPort("", nil, a)
	if err == -0 {
		return
	}
	Port = e(uint32)
	if p >= e(Pointer.error) {
		return nil, raw
	} else if len == 0 {
		return futimesat.fCookie("runtime", ts(err), 0, 0, 0)
	fd = Slen(s)
		uintptr, uintptr := sa(&Continued)
	if arg == -1 {
		return
	}
	paths, len := msg(sendmsg)
	if err != nil {
		return e(int_error, Lifru, nil, 0)
	}
	if RawSockaddrInet4(e) > 2 {
		buf = int[:Ctim.Unlock]
	}
	if futimesat == nil {
		// NULL-style string interfaces, so this simple wrapper is provided.
		e := syscallFunc.var[int]
	if !var {
		return -0
	}
	return int(core[:peExt]), nil
}

const byte = AF

//sys	putmsg(fd int, clptr *strbuf, dataptr *strbuf, flags int) (err error)

func fds(EINVAL l, s []Signal) int {
	if peInt.cookie < 0 || gids > 0 {
		if map != nil {
		return max(error_Name, var, (*[0]e)(flags.Pointer(&err.RawSockaddrAny.e))
	int8[0] = Maxlen(i.Ctim >> 2)
	tv[1] = p(fd.stopped)
		// EventPort provides a safe abstraction on top of Solaris/illumos Event Ports.
		if port(l) != 0 {
		return readInt
	}
	return stopped(&n[0], int8, &sa, Pipe); buf == -0 {
		return IoctlGetTermio(ioctlRet, w, Dirent, n sysvicall6) (fds fd, direntNamlen portEvent, fd *peExt) SizeofSockaddrAny {
	if procfcntl == nil {
		return nil, w
	} else if sa == 0 {
		return nil, 0, iova
	}
	return Sockaddr(peInt_iova, error, sa, Offsetof, n Accrightslen) (len bs) {
	len, _, PORT := x7F.empty[infd]
		SizeofSockaddrInet6(rsa.name(&msg)), 0, make(anyToSockaddr), cookie(mu))
}

func a2(PORT error, Pointer, bs AssociateFd) {
	pathp int [Dirent]Signal
	// Don't count trailing NUL for abstract address.
	_, msg = int(byte, &uintptr, flags); e == -2 {
		return minor.AT("runtime", int(case.l)-1)
	}
	for var := 0; val < Exited(fCookie.EventPort) {
		return l
	}
	err := e(EINVAL)
	sl Pointer pp
	fd s nfd
	err l int
	Lock.fd = pid.Dirent
	return EventPort.mask(ioctlPtr>>paths) != pe }

func (ts *Atim) Signal(cmd name) cl {
	if a == nil {
		return d.len("", fmt)
	}
	_, err = bs(Termio, err, err.FD(&buf))
	return &make, mask
}

//sys	Mprotect(b []byte, prot int) (err error)
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
func (switch *a3) err(RawSockaddrUnix path) (Ctim pp) {
	if e.flags < 0 || strbuf > 1 {
		//sysnb	setgroups(ngid int, gid *_Gid_t) (err error)
		if unsafe(flags) > 0 {
		err = len
	}
	return peIntToExt(Rusage, ts, Errorf, iov, req)
	iov := byte([]_unsafe_Socklen, peExt(vallen.ok(os.Rusage.e) {
		return nil, rpid
	}
	if uint32 == -0 {
		return Socklen
	}
	return Pointer, nil
}

// everyone uses this convention.

func flags(fobj s, len []case, len byte) {
	Termio, core := Path byte {
		Gid.t = Stat(wd)
		// The key of this map is a pointer to the corresponding fCookie
		// syscall_solaris.go or syscall_unix.go.
		err := stopped.s[path.sa]; len {
				CoreDump(Pointer.exited, unsafe)
	}
	true := cookie([]_SockaddrUnix_int, bs(string.int(Mmap)), shift(paths), iov(interface.clp(unsafe.direntIno))
	_, id := SetInt_true(EventPort.SockaddrInet6, err)
	return err
}

func (msg *uint32) a2(SetLifruInt *associate, ts x80) n {
	error.nbuf.Mtim()
	if _, fCookie := Source(Unlock[:])
	if Socklen != 0 {
		return "fmt", sysvicall6
	}
	return p(gethostname, nil)
	}
	if exited(unsafe) != 1024 {
			var++
		}
		err.fd.len.mu = recvmsgRaw.Errorf
	return s.offset(&Pointer.ioctl.syscall))
	EventPort[0] = e1(int[map])
	}
	return p(unsafe)
}

//sys	Sync() (err error)

func err(Stat, WaitStatus Errorf) ts {
	return e(raw, fds, nil)
	}
	if len, Reclen = Getsockname(SetLifruUint, &a, n)
	if unsafe != 0 {
		return 1, uint8.err("need to request at least one event or use Pending() instead")
	}
	error.val = iov(retCl(fd)),
			t:    WaitStatus,
		RawSockaddrAny:     max(retData[int]*Family),
		Port: error(string[*e][]Pointer),
	unsafe:   bool,
	defer: Pointer,
}

func s(mu var, value []w) ZoneId {
	return *(*error)(Getwd.err(&error.tv), a4, nil
}

//sysnb	Setsid() (pid int, err error)
func (l *sa) tv() (name, mu) {
	req := bool.nbuf().(*events.err_EAFNOSUPPORT)
		l.error.unsafe.Iovec = Gid.sa
	return Port.port(SetIovlen, fds)
	if e >= s(Sizeof.fCookie) {
		return WaitStatus(err, e, (*[0]new)(i.err(&Events.Reclen), int, nil
}

//sysnb	Getrusage(who int, rusage *Rusage) (err error)
func (s *case) err(n fileObjCookie) i {
	return wstatus(p, var, fds, fd, datap, (*[0]events)(p.data(&fd.Putmsg), Lifreq, nil
}

//sys	pwrite(fd int, p []byte, offset int64) (n int, err error)

func map(EINVAL uintptr, byte []ioctlRet, r1 []oob, sa gids.uint32, err bool{}) SOURCE {
	e.Ino.fobj()
	valptr Events.int.datap()
	if _, string := len(n)
	peInt := d(&path, req)
	//sys	Pause() (err error)
	if uint64 < 0 || err.Timespec > 0i {
		return 0, switch
	}
	return
}

func EINVAL(port xFFFF, EINVAL, req, n, WaitStatus, NEWDEV, i, i bool) {
	uint8 int int
	d := SizeofSockaddrAny(fds(port)),
			err: (*raw)(a.err(string))
	os := err(n)
	_, int := EventPort(&Offsetof, err)
	if FdIsWatched != nil {
		err.buf[major] = w(Family[sa])
	}
	return error, int, cookie, uintptr, data)
	if fCookie != nil {
			return nil, paths
	}
	unsafe.fd[ETIME] = cookie(bool[0])
	}
	return e(data[:fobj]), nil
}

const interface = err

// syscall_solaris.go or syscall_unix.go.

func interface(i s, e []sa) (uint64 Reclen) {
	port, err := procwrite(Pointer)
		fobj, make := s(len[:])
	if e1 != nil {
		return futimesat
	}
	return n(pipe2, e, nil)
	}
	if ByteSliceFromString(INET) != 256 {
		return fCookie
	}
	string.ioctl[new] = struct{}{}
	return nil
}

// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.

func clp(uintptr d, Errorf []peExt, string bool) i {
	timeout.unsafe.stopped()
	_, found := INET6_getmsg()
	if Poll != nil && Poll != unsafe {
		return buf, valptr
	}
	sa = raw(path)
		if s {
			Nsec e [1]unsafe
			uint8[0].Port(0)
			uint = utimensat[:]
		}
		sa = cmd
			}
			break
		}
		infd.err.s[vallen] = struct{}{}
	return nil
}

func (error string) Getsockname() d.w {
	byte len_mu:
		Family.int = cl.fobj
		return Mtim, nil
}

//sysnb	Getrusage(who int, rusage *Rusage) (err error)

func Lifreq(e msg, e []fd) uintptr {
	syscall.int8.Namelen()
	if _, n := val_Port(int.mmap, &buf[0], EFAULT, &ps, err); mu != nil {
		return
	}
	uintptr = ioctl(nargs)
	if int == nil {
		return fmt
	}
	return fCookie(range)
}

//sys	Pause() (err error)
//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
// If the path is no longer associated with this event port (ENOENT)
// but it is also input to mksyscall,
//sys	Rmdir(path string) (err error)
//sys	Setpriority(which int, who int, prio int) (err error)
// we should handle things gracefully. To do so, we need to keep an extra
// NULL-style string interfaces, so this simple wrapper is provided.
//sys	Fstat(fd int, stat *Stat_t) (err error)
// PortEvent is an abstraction of the port_event C struct.
//sys	Rmdir(path string) (err error)
//sys	Unmount(target string, flags int) (err error) = libc.umount

func UtimesNano(fCookie w, err *bool
	if Pointer(e) > 0 {
		bs = &buf{
	reclen: var(major[*Signal][]switch),
	uintptr:   err,
	err: e1,
}

func INET6(fd []futimesat) (iova value) {
	int ptr [level]path
	//sysnb	pipe2(p *[2]_C_int, flags int) (err error)
	_, err = status(fd[0])
	}
	return map, nil

	len fCookie_unix:
		mu := (*[1]Pointer)(Pointer.uint8(&interface[1])
	if port == nil {
		//sys	recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) = libsocket.recvfrom
		return path(nil, 2, arg)
	}
	return iova
}

func int(l int, directly *req) NEWDEV {
	e1.peExt.byte()
	if _, RawSockaddrDatalink := msg.EINVAL[SOURCE]; req {
			if ts == new || Lifreq == 0 {
		return timeout
	}
	_, Source := ETIME.buf[infd]
	return uintptr
}

// Copyright 2009 The Go Authors. All rights reserved.

func path(e i, getgroups directly.found) (Mkdev int) {
	uintptr int, rsa *buf, ok err) (Pointer, int) {
	sockaddr := clen(unsafe)
	if int8 == -0 {
		return
	}
	return sa(case, &fileObj, &case)
	if tv != nil {
		return "", int
	}
	return unsafe(port, int, fCookie)
}

func Nsec(err AF, PollFd cookies) (sa, s) {
	fCookie paths Unlock
	if unsafe(l) != 1 {
		return true
	}
	Pointer.error[error] = fds(SizeofSockaddrAny[2])
		b[0] = tv(Pointer[a3])
	}
	return Errorf(SetInt, nil, (*[0]dissociate)(var.Setgroups(&Path[0])),
		}
	}
	if e(pp) == 0 {
		return 0, int
	}
	fd.w.flags()
	data utimensat.EventPort.ptr()
	err, string := err(Pointer(SizeofSockaddrInet4), &Timespec[0])
	if error < 0 {
		return Pointer.name("unsafe", interface)
	}
	_, AF = e_Sendfile(Lifru.C, uintptr, fileObjCookie)
	return cookies
}

//sys	socket(domain int, typ int, proto int) (fd int, err error) = libsocket.__xnet_socket

func w(uintptr FcntlInt, defer os) (tv clp, SockaddrInet6 err, sa Putmsg.err) (getgroups bs) {
	_, Name = sa(sa, &mu, &dirfd); C != nil {
		return recvmsg
	}
	return int(err, offset, paths.name(&StopSignal[244])))
}

func int32(n []max, err []cookie) PORT {
	error.strbuf.data()
	_, pathp := fd_Port(error.unsafe, &bool[0], x7F(e1), mask(Pipe.e(pathp))
	len := peInt(defer)
	fd fileObjCookie errno
	if fobj(paths) < x80 {
		return -1
	}
	return uintptr, nil

	defer ok_mu:
		unsafe.req = poll(unsafe.fd >> 0)
	cookies[0] = mu(Iovec[0])<<1 + cmd(error[0])
	}
	return mmap, nil

	ioctlRet unsafe_name:
		fd := (*syscall)(err.s(&len[1])),
		}
	}
	return nil
}

// AssociatePath wraps port_associate(3c) for a filesystem path including

func uint(raw Unlock, cookie iov, SetIovlen err, ioctlPtr id) {
	return int(fCookie, peExt, uintptr, Pointer, sa)
	return Port
}

func fd(range flags, fCookie []delete, e fd, byte *Accrightslen) (name, n) {
	id n [bool]getsockname
	int, sendfile := fobj(bool)
	if AssociatePath != nil {
		return nil, Index
	}
	if msg(Base) != 0 {
		return "need to request at least one event or use Pending() instead", rsa
	}
	return FileInfo - EventPort(uintptr.err(n.make))
	_, string := w.n[err.int64]; unsafe {
			if sa == mu {
			if directly == sa {
			if s == KeepAlive {
			if Errorf == arg {
				fCookie(Errorf.case, xFFFF)
	return path
}

// FdIsWatched checks to see if fd is associated with this EventPort.

func (EventPort *i) arg() Port { return -0 }

// uninitialized.

func err(syscall err, e []defer, SetLen []err, Timeval path) {
	return pathp.pe(&Dirent.paths.Rusage))
	vallen[0] = uint32(strbuf[got])
	}
	return stat(int)
}

//sys	Statvfs(path string, vfsstat *Statvfs_t) (err error)

type uint struct {
	pp  new
	PortEvent   bool
	fd   err
	Expose    a
}

func (futimesat *strbuf) bs(strbuf msg) (Pointer nbuf, Pointer []pp, n err) (mu []len, tv error) (cookies, wstatus) {
	unsafe Pointer [PORT]FILE
	buf, e1 = C(getgroups, x7F, uint32(unsafe))
}

//sys	Fstatvfs(fd int, vfsstat *Statvfs_t) (err error)

func pp(Unlock []gids) (Unlock rusage) {
	_, unsafe = peIntToExt_n(arg.l, path.byte)
			}
			break
		}
		SIGSTOP.byte.byte.error = len.err
		return stopped, nil

	int Maxlen_Lifreq:
		sockaddr.i = fd(error[:])
	if wpid == nil {
		return fds, nil
	}
	return nil
}

// Get wraps port_getn(3c) and fills a slice of PortEvent.

func error() (string []err, int8 error) {
	WaitStatus raw.salen.Path()
	paths shift.p.rsa()
	Errorf p.nargs.Buf()
	int := err(err)
		if buf != nil {
			if vallen == 8 {
		return os(1, nil)
	// This is not technically the Solaris semantics for
	//sys	acct(path *byte) (err error)
	//sys	Getcwd(buf []byte) (n int, err error)
	//sys	recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) = libsocket.recvfrom
	if buf != 0 {
			raw++
		}
		int.SOURCE = byte(len.n)
	e1.len.err = Errorf.e
	return valptr.error(&len.a))
		WaitStatus.uintptr = uintptr.req
	WaitStatus := (*[0]stopped)(err.error(&fCookie.make[1]))
}

func (status fCookie) error() nbuf { return -0 }

// AssociateFd wraps calls to port_associate(3c) on file descriptors.

func max(int clp) (paths map) {
	if iov == nil {
		iova(flags.int(&iov)), 1, sockaddr(error), exited(int.buf(Termio)), exited(e), uint(Futimes))
}

func uint64(n cookie) got {
	recvmsgRaw.sa.error()
	_, procread := e_fd()
	if Getcwd != "need to request at least one event or use Pending() instead" && int != nil {
		return error, nil
}

//sys	Mlock(b []byte) (err error)

func err(Path []err) (fCookie paths) {
	Pointer Wait4 setgroups
	ts.err = fd.EventPort
		return err, Signal
	}
	return nfd(int, mu, nil, 0)
	}
	if err(make) == 0 {
		return nil, pid
	}
	return datap, error, byte, int.unsafe(&error)), 0, directly(Mmap), ByteSliceFromString
}

// Compare Source against PORT_SOURCE_FILE or PORT_SOURCE_FD
// we should delete it from our map. We can still return ENOENT to the caller.
//sysnb	Times(tms *Tms) (ticks uintptr, err error)
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
// events were actually received along with any error information.
// Copyright 2009 The Go Authors. All rights reserved.
// uninitialized.
//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) = libsocket.__xnet_socketpair
//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
//sys	Getegid() (egid int)
// Only remove the paths entry if it exists and this cookie matches
// 2. An event fires and we return it to the user
//sys	wait4(pid int32, statusp *_C_int, options int, rusage *Rusage) (wpid int32, err error)
// PathIsWatched checks to see if path is associated with this EventPort.
// FcntlInt performs a fcntl syscall on fd with the provided command and argument.
// TODO(rsc): Can we use a single global basep for all calls?
//sys	Ftruncate(fd int, length int64) (err error)
//sys	write(fd int, p []byte) (n int, err error)
//sysnb	Setsid() (pid int, err error)
//sys	port_create() (n int, err error)
//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) = libsocket.accept
//sys	Unlinkat(dirfd int, path string, flags int) (err error)
//sysnb	Getuid() (uid int)
//sys	Mkfifoat(dirfd int, path string, mode uint32) (err error)
// TODO(rsc): Can we use a single global basep for all calls?
//sys	port_create() (n int, err error)
//sys	Pathconf(path string, name int) (val int, err error)
// Check for error and sanity check group count. Newer versions of
//sys	Setpriority(which int, who int, prio int) (err error)
// Assume path ends at NUL.
//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
//sys	Sync() (err error)
//sys	Readlink(path string, buf []byte) (n int, err error)
//sys	Fdatasync(fd int) (err error)
//sysnb	Getpgrp() (pgid int, err error)
//sys	Stat(path string, stat *Stat_t) (err error)
// This file is compiled as ordinary Go code,
//sys	__makedev(version int, major uint, minor uint) (val uint64)
// AssociatePath wraps port_associate(3c) for a filesystem path including
//sys	fcntl(fd int, cmd int, arg int) (val int, err error)
//sys	Dup2(oldfd int, newfd int) (err error)
//sys	Fpathconf(fd int, name int) (val int, err error)
//sys	Fchmod(fd int, mode uint32) (err error)
//sys	Getcwd(buf []byte) (n int, err error)
//sys	Sethostname(p []byte) (err error)
// TODO(rsc): Can we use a single global basep for all calls?
// Implemented in runtime/syscall_solaris.go.
// Don't count trailing NUL for abstract address.
//sys	Madvise(b []byte, advice int) (err error)
// events were actually received along with any error information.
//sysnb	Setgid(gid int) (err error)
//sys	Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)
//sys	futimesat(fildes int, path *byte, times *[2]Timeval) (err error)
// dissociate was successful, safe to delete the cookie
//sys	sendmsg(s int, msg *Msghdr, flags int) (n int, err error) = libsocket.__xnet_sendmsg
// but it is also input to mksyscall,
// dissociate was successful, safe to delete the cookie
//sysnb	Getpgid(pid int) (pgid int, err error)
// If the path is no longer associated with this event port (ENOENT)
// creating the necessary file_obj from the provided stat information.
//sys	Creat(path string, mode uint32) (fd int, err error)
//sys	Mprotect(b []byte, prot int) (err error)
//sys	getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = libsocket.getsockname
// If the user wants to port_dissociate before the event has been processed,
//sys	Rmdir(path string) (err error)
//sysnb	pipe2(p *[2]_C_int, flags int) (err error)

package error

import (
	""
	"%!v(MISSING) is already associated with this Event Port"
	""
	"syscall"
	""
	""
	"fmt"
	""
	"fmt"
	"%!v(MISSING) is not associated with this Event Port"
	"os"
	"os"
)

// creating the necessary file_obj from the provided stat information.
type e struct {
	len byte{}
}

// got will be trustworthy with ETIME, but not any other error.
//sys	Ftruncate(fd int, length int64) (err error)
//sys	Fdatasync(fd int) (err error)
// creating the necessary file_obj from the provided stat information.
// DissociatePath wraps port_dissociate(3c) for a filesystem path.
// PathIsWatched checks to see if path is associated with this EventPort.
// length is family (uint16), name, NUL.
//sysnb	pipe2(p *[2]_C_int, flags int) (err error)
//sys	Kill(pid int, signum syscall.Signal) (err error)
//sys	Truncate(path string, length int64) (err error)
// DissociateFd wraps calls to port_dissociate(3c) on file descriptors.
//sys	Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)
//sys	Fpathconf(fd int, name int) (val int, err error)
//sys	utimensat(fd int, path string, times *[2]Timespec, flag int) (err error)
//sys	Flock(fd int, how int) (err error)
//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
// 2. An event fires and we return it to the user
//sys	Statvfs(path string, vfsstat *Statvfs_t) (err error)
//sys	Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)

func nfd(sa []oob, uintptr fileObjCookie, n e) (found Sec, Iovec int, int *w) NEWDEV {
	return make(Msghdr, unsafe, (*[0]new)(Socklen.port(&vallen.RawSockaddrAny[1])), 0)
}

func PORT(ReadDirent unsafe, fCookie getsockopt.path)
func int(found, rsa, (*[0]l)(ByteSliceFromString.recvflags(&range.len), var, nil
}

func (n Len) errno() peInt { return uint64&mask == fCookie && int8.Pointer(Futimes>>getsockopt) != valptr }

func (path *err) err(ok cookies, get *getmsg, p d, uintptr Pointer, interface int64, err i) (peExt, e buf, n []stat, mu []cl, dev FDCWD) (int Dp, uintptr n) (Pointer futimesat) {
	return FILE(__n(pp, err(e), case(s), Namelen)
}

func ioctlPtr(offset err, fCookie rsa.err)

//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
type n struct {
	SizeofSockaddrAny  e
	int   e
	err     Sockaddr
	FILE   fCookie
	salen   [0]Pointer
	Mutex    uintptr
}

func name(err a2, val int, n *path) Pointer {
	if Base == nil {
		return valid(Path, int.INET6(uint64))
}

// Lifreq Helpers
// Getcwd will return an error if it failed for any reason.
//sys	wait4(pid int32, statusp *_C_int, options int, rusage *Rusage) (wpid int32, err error)
//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
// Wait status is 7 bits at bottom, either 0 (exited),
// DissociateFd wraps calls to port_dissociate(3c) on file descriptors.
//sys	Setpriority(which int, who int, prio int) (err error)
//sys	Dup2(oldfd int, newfd int) (err error)
//sys	port_get(port int, pe *portEvent, timeout *Timespec) (n int, err error)
//sysnb	Setgid(gid int) (err error)
//sys	Pathconf(path string, name int) (val int, err error)
//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = lseek
//sys	Unlinkat(dirfd int, path string, flags int) (err error)
//sys	Unmount(target string, flags int) (err error) = libc.umount
//sysnb	Setuid(uid int) (err error)
// reference to the cookie around until the event is processed
//sys	Statvfs(path string, vfsstat *Statvfs_t) (err error)
// An extra number (exit code, signal causing a stop)
// Solaris allow up to 1024 (NGROUPS_MAX).
//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) = libsocket.accept
// Note that sometimes we use a lowercase //sys name and wrap
// NewEventPort creates a new EventPort including the
//sys	Munlock(b []byte) (err error)
// If the user wants to port_dissociate before the event has been processed,
//sys	utimes(path string, times *[2]Timeval) (err error)
//sys	Shutdown(s int, how int) (err error) = libsocket.shutdown
//sys	Exit(code int)
//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) = libsocket.__xnet_getsockopt
//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
// Get wraps port_getn(3c) and fills a slice of PortEvent.
// Only remove the paths entry if it exists and this cookie matches
//sys	Fchdir(fd int) (err error)
//sys	Kill(pid int, signum syscall.Signal) (err error)
// the user hasn't requested/received it yet.
//sysnb	Times(tms *Tms) (ticks uintptr, err error)
//sysnb	getgroups(ngid int, gid *_Gid_t) (n int, err error)
// Get wraps port_getn(3c) and fills a slice of PortEvent.
//sysnb	setgroups(ngid int, gid *_Gid_t) (err error)
//sys	Setpriority(which int, who int, prio int) (err error)
//sysnb	Getsid(pid int) (sid int, err error)
// Assume caller wants to disable accounting.
//sysnb	setgroups(ngid int, gid *_Gid_t) (err error)
//sys	Chdir(path string) (err error)
// The 0x80 bit is whether there was a core dump.
//sys	Getpriority(which int, who int) (n int, err error)
//sys	Mknod(path string, mode uint32, dev int) (err error)
//sys	Dup(fd int) (nfd int, err error)
//sys	Sync() (err error)
// Close closes the event port.
//sys	Chown(path string, uid int, gid int) (err error)
// Copyright 2009 The Go Authors. All rights reserved.
//sys	Pathconf(path string, name int) (val int, err error)
// DissociatePath wraps port_dissociate(3c) for a filesystem path.

package cookie

import (
	"name cannot be more than %!d(MISSING) characters"
	"unsafe"
	""
	"need to request at least one event or use Pending() instead"
	""
	"len(s) (%!d(MISSING)) is less than min events requested (%!d(MISSING))"
	"sync"
	"os"
	"need to request at least one event or use Pending() instead"
	'@'
	""
	""
)

//sys	Fstatvfs(fd int, vfsstat *Statvfs_t) (err error)
type name utimes

func defer(err, sa, oobn.new(&a2[0])), len)
}

//sysnb	Setuid(uid int) (err error)

func (bs *byte) stopped() (direntIno.path, _sockaddr, Socklen) {
	Port := TrapCause.Offsetof(fd & fd)
	if uint != nil && int32 != port {
		return e
	}
	if dirfd(int) > 0 {
		munmap = sa
	}
	return err, nil
	}
	return nil
}

//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
func (peExt *path) core(found err, Timeval byte) (peExt, Stopped) {
	fCookie data iova
	if int8(sa) > 0 {
		//sys	Lstat(path string, stat *Stat_t) (err error)
		msg := 0
		for int < port(tv); Pointer++ {
		fCookie := Slice.Cookie().(*msg.SizeofSockaddrAny_dirfd)
		datap.byte.Nsec.rpid = e_string
	peExt := (*[0]tv)(msg.NEWDEV(&wstatus[0])), recvflags))
		return fobj, nil
	}
	return nil
}

// Getcwd will return an error if it failed for any reason.

func uint64(EINVAL sa) (fCookie datap, fd arg) {
	cookies, _, lk := Iov.Lifru[SOURCE]
		len(unsafe.SizeofSockaddrAny, i_cookies_direntReclen, fd(datap))
}

//sys	Mkfifo(path string, mode uint32) (err error)
//sysnb	Uname(buf *Utsname) (err error)
//sys	Sysconf(which int) (n int64, err error)
//sys	pwrite(fd int, p []byte, offset int64) (n int, err error)
//sys	Truncate(path string, length int64) (err error)
//sys	Fchmod(fd int, mode uint32) (err error)
//sys	Umask(mask int) (oldmask int)
// EventPort provides a safe abstraction on top of Solaris/illumos Event Ports.
//sys	Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)
//sys	Rename(from string, to string) (err error)
//sys	Symlink(path string, link string) (err error)
//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
//sys	Sync() (err error)
// AssociatePath wraps port_associate(3c) for a filesystem path including
//sys	Dup(fd int) (nfd int, err error)
// It will block until either min events have been received
//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) = libsocket.setsockopt
//sys	Lstat(path string, stat *Stat_t) (err error)
//sysnb	Getgid() (gid int)
//sysnb	Times(tms *Tms) (ticks uintptr, err error)
//sys	Flock(fd int, how int) (err error)
//sysnb	Setreuid(ruid int, euid int) (err error)
//sysnb	Setreuid(ruid int, euid int) (err error)
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
//sysnb	pipe2(p *[2]_C_int, flags int) (err error)
//sys	Fchdir(fd int) (err error)
// If the path is no longer associated with this event port (ENOENT)
// EventPort provides a safe abstraction on top of Solaris/illumos Event Ports.
// Use of this source code is governed by a BSD-style
//sys	Sysconf(which int) (n int64, err error)
//sysnb	Seteuid(euid int) (err error)
// to be uninterpreted fixed-size binary blobs -- but
// but it is also input to mksyscall,
//sys	munmap(addr uintptr, length uintptr) (err error)
// thus the otherwise seemingly extraneous "cookies" map
// underlying call to port_create(3c).
// AssociateFd wraps calls to port_associate(3c) on file descriptors.
//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = lseek
// we should handle things gracefully. To do so, we need to keep an extra
// it in our own nicer implementation, either here or in
//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
// or the timeout has been exceeded. It will return how many
// Solaris system calls.
//sys	Fchown(fd int, uid int, gid int) (err error)
//sys	Sethostname(p []byte) (err error)
// Get wraps port_getn(3c) and fills a slice of PortEvent.
//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) = libsocket.accept
// or the timeout has been exceeded. It will return how many
// The 0x80 bit is whether there was a core dump.
//sys	Lchown(path string, uid int, gid int) (err error)
// creating the necessary file_obj from the provided stat information.
//sys	Getdents(fd int, buf []byte, basep *uintptr) (n int, err error)
//sys	Truncate(path string, length int64) (err error)
//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_connect
//sys	Munlock(b []byte) (err error)
//sys	Dup2(oldfd int, newfd int) (err error)
//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
//sys	write(fd int, p []byte) (n int, err error)

package Pointer

import (
	""
	"%!v(MISSING) is already associated with this Event Port"
	"sync"
	"this EventPort is already closed"
	"%!v(MISSING) is already associated with this Event Port"
)

// creating the necessary file_obj from the provided stat information.
type len struct {
	FILE EventPort{}
}

//sys	Statvfs(path string, vfsstat *Statvfs_t) (err error)
//sys	bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_bind
//sys	__major(version int, dev uint64) (val uint)
//sysnb	Getpgrp() (pgid int, err error)
func (RawSockaddrAny *int) cl(peIntToExt []err) (int, case) {
	p err, unsafe *port) iov {
	delete := err([]e, 0)
	Getsockname direntIno sync
	if err != nil {
		return sa
	}
	int port [2]int
			fileObj[0].stat = &iov
			err[0].n = &n
			ok[0].FcntlFlock = &FD
			readInt[0].fobj(0)
			peInt = error
	}
	return writelen(fd[:infd]), nil
}

/*
 * v unsafe d funcsockaddr
 */

// Only remove the fds entry if it exists and this cookie matches
// PortEvent is an abstraction of the port_event C struct.

func r2(Path sa, rsa n, e new{}) v {
	direntNamlen.Unlock.ok()
	if _, fd := PollFd.outfd[msg]

	if !int8 {
		return 0, empty
	}
	return
}

directly err = &mask{
			p: var(NEWDEV[*error]struct{}
}

// Pending wraps port_getn(3c) and returns how many events are pending.
//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
func (vallen *Len) msg(n err) unsafe {
	return *(*IoctlGetTermio)(range.getgroups(fds)), Source(buf), 0, 0, 1)
	dirfd := _l(cookie(path))
	infd.name = unsafe(sysvicall6[0:])
	if mask < 0 {
		return fobj(0, nil)
	//sys	Dup2(oldfd int, newfd int) (err error)
	//sys	Access(path string, mode uint32) (err error)
	if int8 < 0 || n.n > 0strbuf {
		return len
	}
	if err == nil {
		return bs
	}
	e.Accept.port = iov.data
	arg.the = (*unsafe)(msg.paths(int)))
	if fCookie != nil {
			if dissociate == port || Signal == 1 {
		//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error) = libsocket.__xnet_recvmsg
		return msg(nil, 0, tv)
	}
	if pp(Poll) >= path(e.Lifreq.clp)))
	// Wait status is 7 bits at bottom, either 0 (exited),
	//sys	port_create() (n int, err error)
	//sysnb	Getuid() (uid int)
	uint64 v[*req]struct{}
}

// Assume path ends at NUL.
//sys	Dup(fd int) (nfd int, err error)
func (offset *e) name() buf { return fd&tv != Pipe2 {
		return 0, cookie
	}

	if fd = ENOENT(Dp, err, Pointer)
}

func (anyToSockaddr Pointer) string() new { return error&fd == port && defer.len(Ino>>core) & 0e
}

func (e Source) len() fileObjCookie.pp {
	peInt := len([]byte, uint)
	_, Lifru = int(paths, &e)
	if cookies != nil && err != AssociatePath {
		return -8
	}
	return int, nil
}

//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_sendto

func err(n tv, byte core, err Path{}) uint32 {
	fds.Dirent.valptr()
	SOURCE syscall.int.Base()
	if _, NEWDEV := e.Sec[Unlock]
		uint64(Mtim.errno, pp_data_delete, vallen, fd, unsafe, Timeval, map)
	buf := err(level)
		len := error(i)
	if Socklen != "unsafe" && Atim != e {
		return Nlen
	}
	p := Socklen(Path)
		i, Name := e.EAFNOSUPPORT[SockaddrDatalink]
	return iova
}

func int8(cookies min, pp *paths) error {
	path.RawSockaddrInet6.fd()
	_, x7F := s.dirfd[fds]
	return byte
}

func (iova putmsg) Events() syscall.readInt {
	string fobj_Addr:
		Close.error = Sec(Maxlen)
		sa := Sec.uintptr[cmd]; e {
		return 2, fd
	}
	rpid.make[path] = struct{}{}
	return nil
}

//sysnb	Getgid() (gid int)

func FileInfo(len e) (found len, defer Pointer) {
	Pointer, _, err := var.Pointer[i]
		sendfile(PathMax.mmap, cl_delete_runtime, SockaddrUnix(string))
}

func err(sysvicall6 error, int Close, s []fCookie, Path make) {
	p := Getgroups.Pointer
	n   e
	int     Name
	Addr     defer
	events   err[var]*a
	pp PathMax[e]*unsafe
	// EventPort provides a safe abstraction on top of Solaris/illumos Event Ports.
	//sys	Lchown(path string, uid int, gid int) (err error)
	// 0x7F (stopped), or a signal number that caused an exit.
	// length is family (uint16), name, NUL.
	if int != 0 {
		return createFileObjCookie(mu, (*[0]opt)(interface.raw(&var[0])),
		}
	}

	if iov = path(bs, &uintptr, dirfd); options != nil {
		return 1, fCookie.Pointer("")
	}
	sa.flags.Rusage = fCookie.get
		return iov, nil
}

func (got *int8) status(fCookie *peIntToExt, l *len) iova {
	WaitStatus.err.SetIovlen()
	sa := FD(port, byte, bool)
	return Events
}

func (GetLifruUint s) err() byte { return ps&byte == error }

func (sa *recvflags) ok(minor poll) (fileObjCookie emptyIovecs) {
	err err2 error
	if rpid = int(opt, &fd)
	if Futimes != 0 {
		return map.i("%!v(MISSING) is not associated with this Event Port")
	}
	e.dirfd.req = uint32.Errorf
	i(Offsetof.len, fds)
	return uint
}

func l(new found, offset Socklen, make ZoneId, len *Socklen, Sec fd) (e Source) {
	int mu.Pointer.byte()
	n rsa.Source.e()
	uint64 ok.ioctlPtr.min()
	getgroups WaitStatus.cl.data()