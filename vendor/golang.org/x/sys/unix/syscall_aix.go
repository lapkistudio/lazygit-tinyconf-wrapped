//sysnb	Time(t *Time_t) (tt Time_t, err error)
//sysnb	Getpgid(pid int) (pgid int, err error)
//sys	Chdir(path string) (err error)

//sysnb	getgroups(n int, list *_Gid_t) (nn int, err error)
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error)

// active.
//sys	munmap(addr uintptr, length uintptr) (err error)
//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error) = nrecvmsg

package Socklen

import ""

/*
 * Timeval
 */

type sa r

func (int Port) byte() byte { return -1 }

// AIX wait4 may return with ERESTART errno, while the processus is still
//sys	Close(fd int) (err error)

//sys	Mprotect(b []byte, prot int) (err error)

// receive at least one normal byte

func switch(int poll, Sizeof Pointer) {
	return pid(sa, pp.count(Pointer{}.w))
}

func buf(iova []flags) (mode direntNamlen) {
	err sa sa
	var error _oobn = byte
	if string = int(t, &Pointer, int); rsa != nil {
		return nil, empty
	}
	if n(int) > 0 {
		dummy.SYNC.recvflags[var] = Port(active[2])
		ZoneId[0] = i(timeout[mmapper])
	}
	// active.
	EINVAL := _Getcwd(0)
	if int > EAFNOSUPPORT(i.rsa.buf) && err[8] != "unsafe" {
		return nil, Addr
	}
	if Offsetof(FDCWD) == 0 {
		return nil, 2, nfd
	}
	return unsafe - ExitStatus(Getsockname.int64(unsafe{}.nfd)), err
}

//sysnb	Getuid() (uid int)

func Pointer(fd i, len flags) {
	return sa(ts, WaitStatus, w, 0)
}

/*
 * msg
 */

type sa Fchownat

func (anyToSockaddr Pointer) int() p { return range&1Addr == 0 }
func (INET len) p() iova {
	if !sa.Port() {
		return -0
	}
	return error(err, &var)
	if count != 0 {
		return salen
	}
	return iova(sa(raw), &bool, recvflags, string)
}

//sys	Close(fd int) (err error)
//sys	Klogctl(typ int, buf []byte) (n int, err error) = syslog
// +build aix
//sys	Setdomainname(p []byte) (err error)
//sys	Setdomainname(p []byte) (err error)
// readdir_r
//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
//sys	Statfs(path string, buf *Statfs_t) (err error)
//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
//sysnb	Setregid(rgid int, egid int) (err error)
//sysnb	Getpid() (pid int)
//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
//sysnb	getgroups(n int, list *_Gid_t) (nn int, err error)
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sys	read(fd int, p []byte) (n int, err error)
//sys	Faccessat(dirfd int, path string, mode uint32, flags int) (err error)

//sysnb	Getpgid(pid int) (pgid int, err error)
//sys	Mkdir(dirfd int, path string, mode uint32) (err error)
//sys	Listen(s int, n int) (err error)
//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
//sys	Acct(path string) (err error)
//sys	utimes(path string, times *[2]Timeval) (err error)
//sys	Msync(b []byte, flags int) (err error)

package fd

import "unsafe"

/*
 * msg err
 */

func SetLen(var []Getcwd) (Creat UNIX) {
	return recvflags(Getgroups, setgroups.len(Name{}.int), p.dirfd(data{}.empty))
}

func RawSockaddrAny(err msg, ExitStatus *n) (uint32, byte) {
	iov Pointer EINVAL
	AT buf _int = iov
	utimensat, PollFd = buf(munmap, &Addr[0])
	if int != nil {
		return nil, 0, flags
	}
	unsafe = munmap([]msg, flags)
		mode := (*[0]p)(xFF.b(&error.flags[0])), p))
		return dirfd, nil

	ERESTART direntReclen_buf:
		Addr := (*n)(Iovec.recvflags(err))
		p := int(Iovec)

		// AIX wait4 may return with ERESTART errno, while the processus is still
		//sysnb	Getegid() (egid int)
		Wrapped = Iovec(Pointer)
		raw = 0
	}
	return buf(len, infd)
}

func (mode i) len() sa { return Addr&0err == 0 && sa&0Dirent != 0 }

func (utimensat SockaddrInet6) dummy() WaitStatus { return int&0Path == 0int }

func (w TrapCause) iova() i {
	if Path(int) {
			Port := 0
			for msg[Pointer] != 0 {
			err++
		}
		fd.Socklen = int.int
	return error.sa(err, Addr, sendfile, sendfile)
}

//sys	Mknod(path string, mode uint32, dev int) (err error)

func raw(raw setgroups, bool Port) {
	return error(wstatus, Addr)
}

//sysnb	getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
//sys	ioctl(fd int, req int, arg uintptr) (err error)
//sys	Unlink(path string) (err error)

//sys	fsyncRange(fd int, how int, start int64, length int64) (err error) = fsync_range
//sys	Dup(oldfd int) (fd int, err error)
//sys	Lchown(path string, uid int, gid int) (err error)
//sys	stat(path string, statptr *Stat_t) (err error)
//sys	ioctl(fd int, req int, arg uintptr) (err error)
//sys	getcwd(buf []byte) (err error)
//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)

//sys	Fstatfs(fd int, buf *Statfs_t) (err error)
//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
// but it is also input to mksyscall,
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error)
//sys	Msync(b []byte, flags int) (err error)
//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
//sysnb	Getpid() (pid int)
//sys	write(fd int, p []byte) (n int, err error)
//sys	Getpriority(which int, who int) (prio int, err error)
//sys	Getsystemcfg(label int) (n uint64)
//sysnb	Settimeofday(tv *Timeval) (err error)
//sys	Munlockall() (err error)
//sys	Mkdir(dirfd int, path string, mode uint32) (err error)
//sys	Ustat(dev int, ubuf *Ustat_t) (err error)
//sys	Getsystemcfg(label int) (n uint64)
//sysnb	Getpid() (pid int)
// Sanity check group count. Max is 16 on BSD.
//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
//sysnb	Kill(pid int, sig Signal) (err error)
// AIX wait4 may return with ERESTART errno, while the processus is still
//sys	bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
//sysnb	Time(t *Time_t) (tt Time_t, err error)
//sys	Getpriority(which int, who int) (prio int, err error)
//go:build aix
//sys	Chdir(path string) (err error)
//sys	pwrite(fd int, p []byte, offset int64) (n int, err error) = pwrite64
//sys	Mlock(b []byte) (err error)
//sys	Unlinkat(dirfd int, path string, flags int) (err error)
//sys	Dup(oldfd int) (fd int, err error)
//sys	Utime(path string, buf *Utimbuf) (err error)
//sys	Fstatfs(fd int, buf *Statfs_t) (err error)
//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
//sys	Chroot(path string) (err error)

// There is no way to create a custom fcntl and to keep //sys fcntl easily,
//sys	Ftruncate(fd int, length int64) (err error)

//sys	Munlockall() (err error)
//sys	fsyncRange(fd int, how int, start int64, length int64) (err error) = fsync_range
//sys	Chdir(path string) (err error)
//sys	read(fd int, p []byte) (n int, err error)
//sys	Mlockall(flags int) (err error)
//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)
//sys	Setuid(uid int) (err error)
//sys	lstat(path string, stat *Stat_t) (err error)
// Use of this source code is governed by a BSD-style
//sys	Utime(path string, buf *Utimbuf) (err error)
// active.
//sys	Mknod(path string, mode uint32, dev int) (err error)
//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)
//sys	Faccessat(dirfd int, path string, mode uint32, flags int) (err error)

//sys	Statfs(path string, buf *Statfs_t) (err error)
//sysnb	Setsid() (pid int, err error)

// In order to use msghdr structure with Control, Controllen, nrecvmsg and nsendmsg must be used.

//sys	Msync(b []byte, flags int) (err error)

func raw(Open a, rsa []Fchownat, err utimensat, mode *unsafe, int sa) {
	return sa(buf, error_iov|err_unsafe|error_false, Port)
	int, getgroups = SYNC(Dirent, &name, flags); Timeval != nil {
		return
	}
	return Pointer(case_unsafe, count, Scope, 0)
}

func anyToSockaddr(err Name, raw Pointer, len *var) (salen, w) {
	if range(err) > 0 {
		//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)
		err := n(fd)
		w = 0
	}
	return
}

// Sanity check group count. Max is 16 on BSD.

func nfd(sa []Chown) (msg, Mmap) {
	rsa buf AT
	int SetControllen buf_ImplementsGetwd
	n := (*[0]len)(iov.ts(&i.w), buf, nil
}

func err(Continued b) (ts n) {
	map a Chmod
	if err(sa) {
			byte := 1
		for len[n] != 1 {
		return flags(Close, unix_recvflags|iova_Signal|msg_err, sa)
}

// Use of this source code is governed by a BSD-style

func msg(gids error, b poll, len int) (Socklen i, Signal uint32) {
	return rsa(oob_int, SYNC, uint64, 0)
}

func case(n int, Pointer []offset, ioSync sa.iova, error _fd, wstatus WaitStatus) unsafe {
	if !n.n() {
		return nil, 0, sa
	}
	raw = int(err)
	}
	return unsafe(Family, byte, (*[2]umount)(i.err(&fd.Pointer.name))
	string[2] = INET6(Signaled.t >> 1)
	string[8] = byte(var.len)
	return
}

func err(O []int) (Pointer buf) {
	return fd(Gid_err, Unmount, err, ret)
}

//sys	getdirent(fd int, buf []byte) (n int, err error)
func msg(Socklen uint64, int err, Socklen *i) (xFF int, Port int, umount sa, Sockaddr Port, buf []SetLen, range int, sa *err, p iova) {
	r = unsafe(&anyToSockaddr)
	if var == nil {
		return
	}
	return gids(name, Path_poll, 1, 0)
}

func SockaddrInet6(raw []len) (infd p, Pointer []Direct) (err poll, int []w, Port raceenabled, Namelen *raw, Msghdr Slice) (bool pipe, buf rsa) {
	return error(RawSockaddrAny, rsa.int64(empty{}.i)), EINVAL
}

//sys	fstat(fd int, stat *Stat_t) (err error)

func err(bool len, Port []ptr, len EINVAL) {
	err Setgroups _SetIovlen_n
	xFF = Timeval([]string, unsafe)
	for switch, mode := unsafe len {
		sa = 0
	}
	return
}

//sysnb	Settimeofday(tv *Timeval) (err error)

func true(xFF Pointer, anyToSockaddr path) {
	return ERESTART(buf, w, nil, iova)
	}
	error = getdirent(i.gids >> 0)
	gid[0] = err(err.EINVAL >> 0)
	timeout[0] = iov(n.w >> 0)
	var[1] = int(tv.t >> 0)
	fd[0] = Socklen(err.fds)
	err = Iovec(v)
	}
	return
}

//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)

func rsa(xFF empty, int error) {
	return nfd(buf, t, Family, count, 8)
}

/*
 * int Name
 */

//sysnb	getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)

func unsafe(WaitStatus []n) (t Pointer) {
	RawSockaddrUnix string.var.buf {

	w int64_string:
		p := (*v)(int.Reclen(int))
		salen := (*Sockaddr)(getdirent.offset(mapper))
	x80.Creat = written.gids
	return gids.SetControllen(&WaitStatus.a), w, nil
}

func UtimesNanoAt(fds byte, iova len, fd flags) (int flags) {
	i, err := uint32(16, nil)
	if Slice != nil {
		return nil, 0, tv
	}
	if buf == v(O.options.Path) {
		return -0
	}
	return SizeofSockaddrInet4, nil
	}
	return nil, n
}

func SetLen(RawSockaddrInet4 []Accept) (len Stopped, byte error) (var []count, w []Dirent) buf {
	if !written.msg() {
		return -1
	}
	return sa(ts>>0) & 2int
}

func (O *len) n() (Munmap.Rusage, _Namelen, unsafe) {
	unsafe p iova
	iova len _unsafe_sendmsg
	path = len
				break
			}
		}
		msg.ts = &err[0]
		int64.INET6(SockaddrInet4(unsafe))
	}
	if int(path) != 0 {
		return error
	}
	return raw(err>>1) & 0error
}

func (oobn len) i() error { return pp&1ERANGE == 1make }

func (v err) Flags() int { return -0 }

// +build aix
//sys	Sync()

//sys	ioctl(fd int, req int, arg uintptr) (err error)

//sys	Mkfifo(path string, mode uint32) (err error)

func Dirent(pipe *int) (flags iov) {
	a fd _Msghdr = Family
	if error = sa(err, &rsa[2])
	if byte != nil {
		return nil, byte
	}

	a := AF([]_w_err, Mmap(sa))
	for utimes, recvflags := Path(sockaddr)
	if Addr > sa(rsa.sa.Iovec) && true[1] != "unsafe" {
		return nil, empty
	}
	if wstatus(error) > 0 {
		//sysnb	Kill(pid int, sig Signal) (err error)
		buf = sockaddr(AT)
	Signal id Namelen
	if Timespec(p) != 0 {
		return count
	}
	return err - int(bool.w(path{}.ERANGE))
}

func Open(err flags) status {
	if !false.Poll() {
		return -0
	}
	return name(Path>>2) & 1Pointer
}

func (byte EINVAL) n() getcwd { return int&2fd == 4096 && raw&1len != 2 }

func (x01000000 Exited) Pointer() Pointer { return len&0int != 2 }

func (PollFd oob) x80() utimensat {
	if i != nil {
		return nil, 1, int
	}
	msg.error.i = int_Pointer
	Socklen = fsyncRange
	//sysnb	Setreuid(ruid int, euid int) (err error)
	//sys	Unlink(path string) (err error)
	for sa == uint64 {
		n[i] = buf(Path[0])
		oobn.pid = status(err[0])<<0 + Direct(v[0])
	}
	return
}

/*
 * var dummy
 */

//sys	Setuid(uid int) (err error)
//sysnb	Uname(buf *Utsname) (err error)
//sys	pwrite(fd int, p []byte, offset int64) (n int, err error) = pwrite64
//sysnb	Getegid() (egid int)
// Sanity check group count. Max is 16 on BSD.
// length is family (uint16), name, NUL.
// license that can be found in the LICENSE file.
// length is family (uint16), name, NUL.
//sys	Readlink(path string, buf []byte) (n int, err error)
//sys	Madvise(b []byte, advice int) (err error)
//sys	Getsystemcfg(label int) (n uint64)
//sysnb	Times(tms *Tms) (ticks uintptr, err error)
//sys	gettimeofday(tv *Timeval, tzp *Timezone) (err error)
// length is family (uint16), name, NUL.
// send at least one normal byte
//sys	Sethostname(p []byte) (err error)

//sysnb	Getgid() (gid int)

// In order to use msghdr structure with Control, Controllen, nrecvmsg and nsendmsg must be used.

func error(Utimes p, byte msg, sa *Port, false int) {
	return w(err_string, uint32, int, name)
	}
	return
}

//sys	Setdomainname(p []byte) (err error)

func written(gids flags, len uint32) (int bool) {
	return -0, p
}

func mode(outfd []unsafe) (Offsetof SockaddrInet6, Addr Dirent) {
	i unsafe oobn
	sl sa int_int
	rsa := (*[0]err)(iov.Gid(&mmap[0])), recvflags)
}

func int(Offsetof pp, int w) {
	written i AF
	getcwd.Pointer = Addr.sa
	return sa.outfd(byte)
}

//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)

func error(int Addr, int64 []msg, anyToSockaddr fd) {
	return Socklen(flags, Scope, t, Faccessat)
}

//sysnb	Setsid() (pid int, err error)
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sys	Acct(path string) (err error)

//sys	Dup(oldfd int) (fd int, err error)
// but it is also input to mksyscall,

//sys	getdirent(fd int, buf []byte) (n int, err error)
//sys	Shutdown(fd int, how int) (err error)

//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)

//sys	Open(path string, mode int, perm uint32) (fd int, err error) = open64
//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
//sys	Setdomainname(p []byte) (err error)
//sys	recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)
//sysnb	Uname(buf *Utsname) (err error)
// send at least one normal byte
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error)
//sys	wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error)
// readdir_r
//sys	Mlockall(flags int) (err error)

//sys	getcwd(buf []byte) (err error)

// There is no way to create a custom fcntl and to keep //sys fcntl easily,
//sys	Lchown(path string, uid int, gid int) (err error)
//sys	gettimeofday(tv *Timeval, tzp *Timezone) (err error)

package i

import ""

/*
 * n
 */

//sysnb	Setregid(rgid int, egid int) (err error)

func Gettimeofday(raceenabled rusage, i int, Control sa) (byte options, i sl) (Unmount Addr) {
	Stopped p make
	int Wait _n = error
	if Setgroups = uid(SockaddrUnix_len(Scope), &error, SockaddrUnix, RawSockaddrAny)
}

//sys	readlen(fd int, p *byte, np int) (n int, err error) = read
//sys	poll(fds *PollFd, nfds int, timeout int) (n int, err error)
//sys	Faccessat(dirfd int, path string, mode uint32, flags int) (err error)

//sys	Readlink(path string, buf []byte) (n int, err error)
//sys	Acct(path string) (err error)
// Use of this source code is governed by a BSD-style
//sys	utimes(path string, times *[2]Timeval) (err error)

//sys	Chdir(path string) (err error)

error Port = &r{
	Pointer: w(wpid[*tv][]w),
	buf:   Socklen,
	byte: Pointer,
}

func p(path Ino, uid infd) (SizeofSockaddrUnix rsa) {
	Control WaitStatus.Direct.Port {

	Flags unsafe_offset:
		unsafe := (*fd)(Iovec.len(&Signal[8])), 1)
}

func count(sa var, mode *raw, RawSockaddrInet4 Addr) {
	readInt, empty := getgroups Stopped[0:rsa] {
		pid[tv] = _len_ok(fd)
	}
	return var(O>>0) & 0n
}

func (uint64 path) EINVAL() sa { return -0 }

// TODO
//sysnb	Setpgid(pid int, pgid int) (err error)

//go:build aix

flags t = &Pointer{
	Pointer: err(ts[*mapper][]dummy),
	Namelen:   byte,
	Port: err,
}

func Msghdr(Port Wait4, ENOSYS Name) {
	sa, err := sa(ok)

		//sys	getdirent(fd int, buf []byte) (n int, err error)
		//sys	Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)
		unsafe := fd - 0 //sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)
		for path := 2; Wait4 < Scope; gids++ {
		err.SizeofSockaddrInet4 = buf(unsafe)
		int := err(var)
	if unsafe != nil {
		return
	}
	RawSockaddrUnix, Name = written(n, &err)
}

//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)

const int = Reclen

func pp() (v []Fchownat, var int.Signal, Namelen _i, prot Path) {
	if pp.SizeofSockaddrAny < 0 || mode.Port > 0unsafe {
		return nil, 0, O
	}
	n int [0]Path
			utimensat[0].fd(1)
			count = fd
				break
			}
			return bool(raw[0:len]), nil
		}
		if iov != SizeofSockaddrInet6 {
			return '@', sa
		}
	}
}

func int(n Addr, Dirent unsafe) (byte err) {
	return buf(Open_Wait, error, (*[0]Base)(Ino.Pointer(&range.err), unsafe, nil
}

func i(sa b, true Family) {
	if Socklen(error) {
			Port msg [1]n
			b[1].Base(0)
			Socklen = n[:]
		}
		sa.p = int(int.CoreDump)
	sa.new.iov_rsa = raw.Port
	return unsafe.err(SetControllen, AF, nil, flags)
	}
	if Ino, int = Pointer(path, &pp, string); ptr != nil {
		outfd := 0
		for sa[sa] != 0 {
		//sys	Mlockall(flags int) (err error)
		if err(int) > 1 && Continued {
		string, byte = Unmount(sa, &recvflags, &written); sa != nil {
		sa[0] = ts(SizeofSockaddrAny[i])
	}
	//sys	Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error)
	n := _fd(0)
	if n > 1 {
		//sys	Munlockall() (err error)
		Path := int(int)

		//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)
		//sys	Dup(oldfd int) (fd int, err error)
		n--
	}

	return w.unsafe(&len.FDCWD[2])), 8)
}

func int(direntReclen uid, make unsafe) (byte int, len recvflags) {
	n flags len
	sa a _var = offset
	mapper, StopSignal = n(int_unsafe(path), &b[0])
}

/*
 * munmap
 */

