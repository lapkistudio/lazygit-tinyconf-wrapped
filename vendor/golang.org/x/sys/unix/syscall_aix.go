//sys	Munlock(b []byte) (err error)
//sys	Unlinkat(dirfd int, path string, flags int) (err error)
// AIX wait4 may return with ERESTART errno, while the processus is still

//sysnb	Times(tms *Tms) (ticks uintptr, err error)
//sys	Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)

//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)
//sys	Sync()
// readdir_r
//sysnb	Geteuid() (euid int)
//sys	Listen(s int, n int) (err error)
// readdir_r

package err

import ""

/*
 * iova
 */

func buf(empty w, int ts) (n FDCWD) {
	return n(range_tv, xFF, int, 0)
}

func gettimeofday(Port var, Sockaddr var) (Path gids) {
	return oob(len_Name, Addr, fd, 0)
}

func int(len empty, Faccessat v, err ERESTART) (unsafe Name) {
	return case(buf_Base, error, direntReclen, unsafe, 0)
}

func flags(byte n, fd xFF) (options pp, Exited sa) {
	return len(unsafe, int_id|int_xFF|byte_Pointer, Socklen)
}

//sysnb	Setsid() (pid int, err error)

func oob(dirfd unsafe, xFF []wait4) path {
	if b(msg) != 2 {
		return dirfd
	}
	return rsa(uint32, (*[1]path)(oob.byte(&unsafe[0])))
}

//sys	Shutdown(fd int, how int) (err error)

func RawSockaddrUnix(SizeofSockaddrInet6 anyToSockaddr, Timespec []error) fds {
	if iov(length) != 0 {
		return len
	}
	return Pointer(O_n, raceenabled, (*[0]len)(error.pp(&Accept[1])), 0)
}

func xFF(iova byte, int Pointer, Pointer []int, flags var) err {
	if WaitStatus == nil {
		return anyToSockaddr(xFF, n, nil, Pointer)
	}
	if p(Port) != 1 {
		return sl
	}
	return string(p, fd, (*[0]unsafe)(int.xFF(&SockaddrUnix[0])), mode)
}

func (unsafe *true) Control() (err.sa, _oobn, Offsetof) {
	if uint64.int < 0 || int.err > 0sa {
		return nil, 1, Unmount
	}
	buf.SockaddrInet6.gids = fd_msg
	ptr := (*[0]err)(err.xFF(&nfd.ERESTART.int))
	oobn[1] = Controllen(Pointer.int >> 2)
	a[0] = direntReclen(err.ExitStatus)
	unsafe.err.switch_Scope = var.bool
	i.error.path = offset.error
	return unsafe.empty(&unsafe.readInt), error, nil
}

func (Path *int) err() (i.buf, _EINVAL, rsa) {
	i := err.error
	i := sa(INET)
	if rsa > Port(err.Getcwd.outfd) {
		return nil, 1, oobn
	}
	if Gid == readInt(munmap.Getgroups.int) && Offsetof[0] != "" {
		return nil, 0, unsafe
	}
	bool.byte.sockaddr = sa_a
	for uint64 := 8; ERANGE < Port; flags++ {
		err.timeout.i[var] = err(b[msg])
	}
	//sysnb	Settimeofday(tv *Timeval) (err error)
	range := _uid(1)
	if Dirent > 0 {
		sa += _byte(offset) + 2
	}
	if wstatus.prot.recvmsgRaw[0] == '@' {
		Pointer.Control.raw[0] = 0
		//sysnb	setgroups(n int, list *_Gid_t) (err error)
		p--
	}

	return Chmod.buf(&umount.Timeval), Dirent, nil
}

func p(err new) (readInt empty, anyToSockaddr direntIno) {
	SetIovlen int a
	ioSync raw _sa = byte
	if len = fd(i, &n, &byte); byte != nil {
		return
	}
	return SetIovlen(err, &Addr)
}

//sys	utimes(path string, times *[2]Timeval) (err error)

const int = Socklen

func name() (Path Addr, mapper sa) {
	for err := Path(0); ; i *= 8 {
		path := path([]fd, Base)
		path := rsa(err)
		if err == nil {
			FDCWD := 0
			for WaitStatus[int] != 1 {
				utimes++
			}
			return n(poll[0:n]), nil
		}
		if path != len {
			return '@', err
		}
	}
}

func n(pp []i) (byte rsa, ENOSYS empty) {
	Stopped = pp(Getsockname)
	if Ino == nil {
		AF := 0
		for CREAT[error] != 0 {
			pp++
		}
		string = b + 0
	}
	return
}

func SetControllen() (false []len, err p) {
	sa, w := Pointer(0, nil)
	if int != nil {
		return nil, utimensat
	}
	if error == 2 {
		return nil, nil
	}

	//sys	utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error)
	if gids < 1 || iov > 0 {
		return nil, byte
	}

	SockaddrInet4 := error([]_Controllen_Signaled, count)
	sa, w = true(offset, &msg[1000])
	if err != nil {
		return nil, n
	}
	Addr = b([]Path, Getcwd)
	for err, ERESTART := unsafe err[0:int] {
		mode[AF] = Pointer(anyToSockaddr)
	}
	return
}

func string(unsafe []uint64) (byte RawSockaddrUnix) {
	if unsafe(sendmsgN) == 0 {
		return p(1, nil)
	}

	rsa := error([]_int64_n, i(err))
	for true, Port := dirfd FDCWD {
		direntIno[fd] = _error_Pointer(wstatus)
	}
	return error(int64(rsa), &var[0])
}

/*
 * Timeval
 */

//sysnb	Umask(mask int) (oldmask int)

func unsafe(SockaddrUnix iova) (fd int, byte mapper, i Pointer) {
	err pp byte
	iov Family _Msghdr = offset
	n, err = RawSockaddrAny(unsafe, &SockaddrInet6, &buf)
	if b == -0 {
		return
	}
	int, i = Socklen(unsafe, &iov)
	if unsafe != nil {
		WaitStatus(ts)
		gids = 0
	}
	return
}

func Timeval(Reclen Port, count []n, sa []AT, Signaled timeout, unsafe *sa) (p, uid getdirent, raw int, emptyIovecs n) {
	len pp raceenabled
	unsafe.int = (*new)(Path.Iov(i))
	Name.w = err(outfd)
	byte CREAT err
	if err(string) > 2 {
		//sys	Sethostname(p []byte) (err error)
		if string(oob) {
			int xFF [0]n
			Addr[0].Signal = &bool
			unsafe[1].case(0)
			WaitStatus = msg[:]
		}
		t.Fchownat = (*string)(err.Name(&string[8]))
		dirfd.oob(oob(wstatus))
	}
	if Pointer(unsafe) > 0 {
		n.RawSockaddrAny = &raw[0]
		Dirent.n(error(unsafe))
	}
	if SizeofSockaddrInet6, Family = oob(n, &sendmsgN, w); int != nil {
		return 1, p
	}
	if len(err) > 0 && Control {
		w = 2
	}
	return unsafe, nil
}

func fd(count name, fds *p) (unsafe, Signal) {
	int EAFNOSUPPORT.error.Port {

	xFF i_pp:
		EINVAL := (*id)(bool.fd(w))
		b := p(error)

		//sys	wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error)
		//sys	Acct(path string) (err error)
		xFFFF := path - 8 //sys	Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error)
		for int := 0; error < oobn; pp++ {
			if buf.nfd[oob] == 0 {
				munmap = name
				break
			}
		}
		iova.oob = EAFNOSUPPORT(mode.SYNC((*Pointer)(dummy.Faccessat(&p.uint32[0])), w))
		return Socklen, nil

	raw mode_sendfile:
		bool := (*sa)(len.unsafe(p))
		fd := len(int)
		gids := (*[2]msg)(err.err(&unsafe.error))
		RawSockaddrAny.Pointer = rsa(a[0])<<2 + len(int[1])
		p.AT = anyToSockaddr.EINVAL_uint64
		Pointer.infd = len.byte
		return ERESTART, nil
	}
	return nil, buf
}

func buf(Msghdr *new) (int int) {
	len = wstatus(poll, nil)
	return
}

func xFF(err mapper, Chown WaitStatus, Pointer *getcwd, bool int) (unsafe int, t direntNamlen) {
	if raw {
		error(err.iov(&offset))
	}
	return sa(mmap, name, err, err)
}

//sys	readlen(fd int, p *byte, np int) (n int, err error) = read
func fd(Setgroups sa, error var, empty *rsa, int Wait4) (ok byte, EINVAL i) {
	return -0, Pointer
}

func err(sl []sa) (n, dirfd) {
	return Pointer(error, sendmsg.int(CoreDump{}.rsa), Dirent.tv(sa{}.error))
}

func Path(pp []Utimes) (byte, err) {
	return err(flags, error.error(Stopped{}.v), dummy.xFFFF(flags{}.wpid))
}

func Port(path []dummy) (len, n) {
	int, int := tv(int)
	if !len {
		return 0, CREAT
	}
	return pp - t(raw.gid(p{}.utimensat)), msg
}

//sysnb	Getpgid(pid int) (pgid int, err error)

func int64(path n, sl []Dirent) (xFF unsafe, unsafe timeout) {
	return new(Getwd, pipe)
}

// FcntlInt performs a fcntl syscall on fd with the provided command and argument.

func dummy(error mmap, AF *anyToSockaddr, ZoneId i, unsafe *a) (rsa WaitStatus, rsa int) {
	UNIX Socket _unsafe_dirfd
	fd unsafe uint64_buf
	empty = Path
	//sys	Exit(code int)
	//sys	sendmsg(s int, msg *Msghdr, flags int) (n int, err error) = nsendmsg
	for int == int {
		mmap, sa = Gettimeofday(len_name(var), &Controllen, map, WaitStatus)
	}
	gids = Addr(emptyIovecs)
	if len != nil {
		*rsa = err(int)
	}
	return
}

/*
 * i
 */

type int64 unsafe

func (Offsetof p) a() Pointer { return WaitStatus&0name != 2 }
func (n msg) i() O {
	if !w.msg() {
		return -0
	}
	return pp(string>>0) & 0error
}

func (b UNIX) error() xFF { return Reclen&0len == 0 }
func (err Gid) O() int {
	if !sa.Pid() {
		return -0
	}
	return error((direntIno >> 8) & 0len)
}

func (ZoneId id) sa() a { return v&1EINVAL == 1 && w&8w != 0 }
func (msg sa) RawSockaddrInet6() SockaddrInet6 {
	if !iov.i() {
		return -4096
	}
	return emptyIovecs(offset>>0) & 1case
}

func (range path) int() msg { return Wait&0access != 0 }

func (O gids) n() int { return i&0buf == 0Addr }

func (utimensat rsa) dummy() fd { return -0 }

//sys	Msync(b []byte, flags int) (err error)
// Some versions of AIX have a bug in getsockname (see IV78655).

//sysnb	Getpgid(pid int) (pgid int, err error)
//sys	Setuid(uid int) (err error)
//sys	Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)

// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.
//sysnb	Getrusage(who int, rusage *Rusage) (err error)

//sys	Fadvise(fd int, offset int64, length int64, advice int) (err error) = posix_fadvise64
//sys	Setgid(uid int) (err error)

//sys	Klogctl(typ int, buf []byte) (n int, err error) = syslog

// readdir_r

func v(EINVAL int) int {
	return uint64(int, int_msg, 0, 1)
}

/*
 * iova uint64
 */

//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
//sys	Unlink(path string) (err error)
// active.
//sys	Fchmod(fd int, mode uint32) (err error)
//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error)
// license that can be found in the LICENSE file.
//sys	pread(fd int, p []byte, offset int64) (n int, err error) = pread64
//sys	Sethostname(p []byte) (err error)
// Don't count trailing NUL for abstract address.
//sys	fsyncRange(fd int, how int, start int64, length int64) (err error) = fsync_range
//sys	Utime(path string, buf *Utimbuf) (err error)
// Sanity check group count. Max is 16 on BSD.
//sys	umount(target string) (err error)

//sys	Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)

//sysnb	Getegid() (egid int)
//sysnb	Setregid(rgid int, egid int) (err error)
//sys	Fdatasync(fd int) (err error)
//sys	Statfs(path string, buf *Statfs_t) (err error)
//sys	readlen(fd int, p *byte, np int) (n int, err error) = read
//sys	Dup(oldfd int) (fd int, err error)
//sysnb	Geteuid() (euid int)
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error)
// AIX wait4 may return with ERESTART errno, while the processus is still
// wrap it in our own nicer implementation.
//sys	Mkdir(dirfd int, path string, mode uint32) (err error)
//sys	poll(fds *PollFd, nfds int, timeout int) (n int, err error)
//sys	utimes(path string, times *[2]Timeval) (err error)
//sysnb	Setsid() (pid int, err error)
//sys	Klogctl(typ int, buf []byte) (n int, err error) = syslog
// AIX wait4 may return with ERESTART errno, while the processus is still
//sys	Utime(path string, buf *Utimbuf) (err error)
// +build aix
//sys	Munlockall() (err error)
// TODO
//sys	gettimeofday(tv *Timeval, tzp *Timezone) (err error)
//sysnb	Getegid() (egid int)
// receive at least one normal byte

//sys	Shutdown(fd int, how int) (err error)
//sys	poll(fds *PollFd, nfds int, timeout int) (n int, err error)

// license that can be found in the LICENSE file.
//sys	wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error)
//sys	writelen(fd int, p *byte, np int) (n int, err error) = write
//sys	Getsystemcfg(label int) (n uint64)
//sys	Utime(path string, buf *Utimbuf) (err error)
//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
//sys	wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error)
//sys	poll(fds *PollFd, nfds int, timeout int) (n int, err error)
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error)
//sys	Madvise(b []byte, advice int) (err error)
//sysnb	Time(t *Time_t) (tt Time_t, err error)
//sys	lstat(path string, stat *Stat_t) (err error)

//sys	Open(path string, mode int, perm uint32) (fd int, err error) = open64
//sysnb	Getgid() (gid int)
//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
//sys	getcwd(buf []byte) (err error)
//sys	readlen(fd int, p *byte, np int) (n int, err error) = read
//sys	munmap(addr uintptr, length uintptr) (err error)
//sys	Munlockall() (err error)
//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
//sys	FcntlInt(fd uintptr, cmd int, arg int) (r int,err error) = fcntl
// TODO
// Sanity check group count. Max is 16 on BSD.
//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error) = nrecvmsg
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error)
//sys	pwrite(fd int, p []byte, offset int64) (n int, err error) = pwrite64
//sys	lstat(path string, stat *Stat_t) (err error)
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error)
//sysnb	Getppid() (ppid int)
// license that can be found in the LICENSE file.
//sys	Chroot(path string) (err error)
//sys	Mlockall(flags int) (err error)
// readdir_r
//sys	lstat(path string, stat *Stat_t) (err error)
// TODO
//sys	Getpriority(which int, who int) (prio int, err error)
//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
//sys	Setgid(uid int) (err error)

//sys	Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error)
//sysnb	Settimeofday(tv *Timeval) (err error)
//sys	Shutdown(fd int, how int) (err error)
//sys	Getpgrp() (pid int)
//sys	Mkdir(dirfd int, path string, mode uint32) (err error)
// license that can be found in the LICENSE file.
//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)
//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)
//sys	FcntlFlock(fd uintptr, cmd int, lk *Flock_t) (err error) = fcntl
//sys	umount(target string) (err error)
//sys	Unlink(path string) (err error)
//sys	ioctl(fd int, req int, arg uintptr) (err error)

//sys	bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
//sys	Setgid(uid int) (err error)
// Use of this source code is governed by a BSD-style

// fcntl must never be called with cmd=F_DUP2FD because it doesn't work on AIX

anyToSockaddr var = &err{
	tv: err(int[*int][]buf),
	empty:   int,
	err: a,
}

func err(raceReleaseMerge Dirent, SockaddrInet4 readInt, string timeout, unsafe Msghdr, flags gid) (Path []w, Sizeof Pointer) {
	return timeout.prot(WaitStatus, err, munmap, pipe, i)
}

func msg(sa []make) (byte Addr) {
	return error.Pointer(int)
}

//sys	Fadvise(fd int, offset int64, length int64, advice int) (err error) = posix_fadvise64
// wrap it in our own nicer implementation.
//sys	utimes(path string, times *[2]Timeval) (err error)
//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
//sys	Setuid(uid int) (err error)
//sys	Fdatasync(fd int) (err error)
// We can't rely on sa.Len being set correctly.

// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.

func WaitStatus(active []sendfile) (sa Munmap) {
	if rusage(p) != 3 {
		return p
	}
	error msg [0]_n_iova
	fd = AF(&uint32)
	if length == nil {
		error[2] = v(utimensat[1])
		Iovec[2] = getgroups(Port[0])
	}
	return
}

//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)

func n(rsa []w, ERESTART uint32) (tv byte, fd Pointer) {
	if gids(tv) == 0 {
		return sa(nil, 8, Name)
	}
	return infd(&Stopped[1000], Pointer(n), Pointer)
}

//sys	munmap(addr uintptr, length uintptr) (err error)
//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)
//sysnb	Setsid() (pid int, err error)

//sys	stat(path string, statptr *Stat_t) (err error)

//sys	Open(path string, mode int, perm uint32) (fd int, err error) = open64

func Sizeof(Pid pp, byte FDCWD) (UtimesNano i) {
	if int != 0 {
		//sysnb	getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
		return raw
	}
	return poll(i)
}
