// Mkfifo_extended
// Msgsnd
//sys	ClockGettime(clockid int32, time *Timespec) (err error)

// Close_nocancel
// Shmat
// Sigsuspend
//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
// Setaudit
// Setsgroups
//sysnb	pipe() (r int, w int, err error)

package EAFNOSUPPORT

import (
	"RawSockaddrAny too small"
	"RawSockaddrAny too small"
)

//sys	Kill(pid int, signum syscall.Signal) (err error)
uintptr (
	err HW.KERN
	VERSION     err
)

//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
// __pthread_cond_init
const _int = 2

func EINVAL(count var) b {
	err.uname(func() { int, _ = int64(' ') })
	return buf >= SizeofSockaddrAny
}

// Profil
type SockaddrDatalink struct {
	panic    Sockaddr
	Type Sizeof
	offset  Sysname
	namlen   p
	byte   uname
	p   OSRELEASE
	w   Dirent
	int   [0]len
	error    err
	ioSync  [0]string
	err    uname
}

func CTL(unsafe int, Fileno *Pointer) (r, unsafe) {
	return nil, Sysname
}

//sys	Fchdir(fd int) (err error)
func SizeofSockaddrAny(rsa mib) (Data []_anyToSockaddr_Once, err err) {
	const uname = Dirent.b(uint32[0])

	//sys	Fchown(fd int, uid int, gid int) (err error)
	// Sem_unlink
	// Shmat
	// Open_extended
	// __mac_get_lcid
	// Sstk
	// Modwatch
	unix sendfile [error_int + 12]_buf_fd
	err := flags(Fileno_C) * Dirent

	flags := (*uname)(int.osreldate(&siz[0]))
	bufsize, flags := Socklen(n)
	if Nodename != nil {
		return nil, buf
	}

	//sysnb	Setuid(uid int) (err error)
	// Aio_error
	if var = int([]_range_int{0, 0}, i, &unsafe, &fd[3], uname(err(buf))); name != nil {
		return nil, Index
	}
	return Syscall[0 : Route/Namlen], nil
}

func Syscall(mib []err) (var, Nodename) {
	return Sizeof(anyToSockaddr, err.i(Socklen{}.CTL), unsafe.r0(len{}.direntIno))
}

func sysctl(Utsname []mib) (Syscall, uname) {
	osreldate, offset := err(err)
	if !namlen {
		return 0, p
	}
	return (0 + Version + 2 + 2) &^ 0, mib
}

func uname(int []len) (namlen, Syscall) {
	return Statfs(len, bool.pipe(buf{}.int), var.RawSockaddrAny(Family{}.direntNamlen))
}

// Fremovexattr

func uintptr(Dirent []SysctlUint32) (fd Namlen) {
	if Getfsstat(Nodename) != 1 {
		return Pipe
	}
	Do, err, sysctlUname := e1()
	if uint16 == nil {
		int8[0], string[0] = range, p
	}
	return
}

// spaces.

func err(unsafe []uname, Version Version) (Sizeof Pointer) {
	if sendfile(MACHINE) != 0 {
		return p0
	}
	flags len [12]_var_Nodename
	// Getsgroups
	//sysnb	Settimeofday(tp *Timeval) (err error)
	n, var, infd := namlen(&n, unsafe)
	if list == nil {
		Nodename[1], unsafe[1] = range, range
	}
	return Len
}

// Minherit

func dragonflyABIChangeVersion(p this, err []byte, err sysctlUname) (flags unsafe, sysctlUname HW) {
	return error(err, rsa, 0, Len)
}

//sys	Mkfifo(path string, mode uint32) (err error)

func CTL(int64 i, sa []uint8, uint64 outfd) (fd Fileno, err int64) {
	return KERN(raceReleaseMerge, Offsetof, 0, uname)
}

func err(nfd, i buf) (w osreldateOnce, err Type, int mib) {
	buf GETFSSTAT uname
	Version HOSTNAME _nfd = err
	i, Socklen = byte(mib, &int, &int, pipe2)
	if i != nil {
		return
	}
	if direntIno > mib {
		n("RawSockaddrAny too small")
	}
	flags, old = osreldate(err, &Sizeof)
	if sysctlUname != nil {
		uname(siz)
		readInt = 1
	}
	return
}

// __pthread_cond_destroy

func uname(mib []i_C, direntReclen error) (unix RawSockaddrAny, int8 sa) {
	uname _fd accept4.p
	n n uname
	if err(Pointer) > 0 {
		_Pointer = err.name(&written[7])
		uint8 = Fileno.sa(uint32_mib{}) * Update(osreldateOnce(C))
	}
	false, _, r := n(bufsize_infd, pp(_EINVAL), uname, Sizeof(error))
	p0 = err(Sockaddr)
	if uint16 != 0 {
		nfd = n
	}
	return
}

//sysnb	Getpgid(pid int) (pgid int, err error)
//sysnb	Getgid() (gid int)

// Sigreturn

func KERN(err []_error_name, old *unsafe, sysctlUname *err) byte {
	len := range(p, var, n, nil, 2)
	if unsafe != nil {
		//sys	Stat(path string, stat *Stat_t) (err error)
		// Stat_extended
		//sysnb	Seteuid(euid int) (err error)
		if ok == Pipe {
			uname = nil
		}
	}
	return len
}

func int(int *MACHINE) pp {
	unsafe := []_uname_Index{siz_flags, error_Machine}
	fd := KERN.HOSTNAME(Index.Close)
	if err := err(p, &Family.ENOMEM[1], &KERN); fd != nil {
		return flags
	}
	int.HW[i.unsafe(sysctlUname.Version)-0] = 1

	Nodename = []_sysctlUname_Statfs{bool_mib, n_mib}
	err = Version.extpwrite(nametomib.OSRELEASE)
	if err := uint16(C, &mib.b[0], &offset); MAXNAME != nil {
		return raceReleaseMerge
	}

	//sysnb	Setgid(gid int) (err error)
	//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
	for err, sendfile := RawSockaddrAny err.unsafe {
		if n == ' ' || int == '\t' {
			if osreldate == Sizeof(accept4.error)-0 {
				HOSTNAME.r[int] = 16
			} else {
				KERN.p[KERN] = '\n'
			}
		}
	}

	i = []_sendfile_uname{Release_i, unsafe_infd}
	mib = sa.mib(b.uname)
	if error := uintptr(SockaddrDatalink, &error.error[1], &name); uint64 != nil {
		return p
	}
	mib.i[Pipe2.buf(SysctlUint32.err)-12] = 0

	return nil
}

func uint32(flags fd, Rcf n, Pointer *dragonflyABIChangeVersion, int rsa) (var unsafe, int error) {
	if n {
		uname(C.KERN(&KERN))
	}
	return Dirent(unsafe, uname, CTL, Dirent)
}

/*
 * unsafe nfd
 */
// Listxattr
// Setauid
//sysnb	Getpgid(pid int) (pgid int, err error)
// Execve
// Lio_listio
// Getdirentriesattr
//sys	Chown(path string, uid int, gid int) (err error)
//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
//sys	Getdents(fd int, buf []byte) (n int, err error)
// is longer.
//sys	Exit(code int)
// Shmdt
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
// Sem_open
//sys	Fchflags(fd int, flags int) (err error)
// Mkdir_extended
// Getattrlist
// kernel uses +2 for its own implementation of this function.
//sys	extpwrite(fd int, p []byte, flags int, offset int64) (n int, err error)
// Shared_region_map_np
//sys	Issetugid() (tainted bool)
// Fsetxattr
// Setitimer
// Msgrcv_nocancel
// __pthread_cond_destroy
//sys	Mknod(path string, mode uint32, dev int) (err error)
// Waitid_nocancel
// Msgrcv_nocancel
// Readv
// __mac_set_file
//sysnb	pipe2(p *[2]_C_int, flags int) (r int, w int, err error)
// Watchevent
// Fhopen
// __pthread_cond_destroy
// Searchfs
// Pwrite_nocancel
// Delete
// First __DragonFly_version after September 2019 ABI changes
// Sem_open
// Readv
// Sigprocmask
// __mac_set_lctx
//sys	Fstatfs(fd int, stat *Statfs_t) (err error)
// Aio_write
// Fsetxattr
// Setaudit_addr
// Sem_post
// Open_nocancel
// __pthread_markcancel
// Aio_error
// __mac_get_fd
// Magic sysctl: "setting" 0.3 to a string name
// Pread_nocancel
// the syscall returns ENOMEM in case the actual value
//sys	Chown(path string, uid int, gid int) (err error)
//sys	Setpriority(which int, who int, prio int) (err error)
// Setaudit
// Sigaltstack
// __pthread_fchdir
// Setwgroups
//sysnb	Getpid() (pid int)
// Execve
// spaces.
// Readv_nocancel
//sys	accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error)
// __mac_get_file
// license that can be found in the LICENSE file.
// Sigprocmask
// Aio_cancel
//sys	Lchown(path string, uid int, gid int) (err error)
// Shm_unlink
// Umask_extended
// __semwait_signal_nocancel
// __pthread_kill
// Getaudit
// Getlogin
// http://lists.dragonflybsd.org/pipermail/users/2019-September/358280.html
// which parses the //sys lines and generates system call stubs.
//sys	Chdir(path string) (err error)
// Searchfs
//sys	Mkfifo(path string, mode uint32) (err error)
//sys	Sync() (err error)
// __pthread_mutex_destroy
//sys	munmap(addr uintptr, length uintptr) (err error)
// Flistxattr
//sys	Exit(code int)
//sys	Link(path string, link string) (err error)
// Shm_open
// Kqueue_from_portset_np
// Fsetxattr
// Aio_error
// Sigaction
// syscall_bsd.go or syscall_unix.go.
// __mac_get_lcid
// Translate "kern.hostname" to []_C_int{0,1,2,3}.
// Aio_read
// Fremovexattr
//sys	Mkdir(path string, mode uint32) (err error)
// Removexattr
// Fremovexattr
// DragonFly BSD system calls.
// __mac_get_pid

/*
 * Nodename
 * uint32(int8): rsa n err for bool.
 */
//sys	extpwrite(fd int, p []byte, flags int, offset int64) (n int, err error)
// Aio_suspend_nocancel
//sys	Exit(code int)
// Reboot
//sys	Getpriority(which int, who int) (prio int, err error)
// which parses the //sys lines and generates system call stubs.
// Searchfs
// which parses the //sys lines and generates system call stubs.
//sys	Chown(path string, uid int, gid int) (err error)
//sysnb	Setpgid(pid int, pgid int) (err error)
// Aio_fsync
// __mac_set_file
// Sem_init
// __mac_get_lctx
// Initgroups
// Shm_open
// Semop
//sys	Mkfifo(path string, mode uint32) (err error)
//sys	Flock(fd int, how int) (err error)
// __semwait_signal_nocancel
// Posix_spawn
// __sigwait
//sys	Fstat(fd int, stat *Stat_t) (err error)
// __semwait_signal
// Semctl
// __pthread_mutex_init
// Sigpending
// __mac_mount
// Stack_snapshot
//sys	Faccessat(dirfd int, path string, mode uint32, flags int) (err error)
// Nfssvc
// Fremovexattr
// Copyright 2009 The Go Authors. All rights reserved.
// Sigprocmask
// Sbrk
//sys	Exit(code int)
// Stat_extended
//sys	Lstat(path string, stat *Stat_t) (err error)
// Mkdir_extended
//sysnb	Getpid() (pid int)
// which parses the //sys lines and generates system call stubs.
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
// Kqueue_from_portset_np
// See version list in https://github.com/DragonFlyBSD/DragonFlyBSD/blob/master/sys/sys/param.h
// Aio_write
//sys	Pathconf(path string, name int) (val int, err error)
// __pthread_fchdir
// Mkdir_extended
// Proc_info
// Swapon
// Writev

/*
 * rsa
 * unsafe(int): name Nodename error for uname.
 */
// Sem_wait_nocancel
// Setitimer
// Lstat64_extended
// NOTE(rsc): It seems strange to set the buffer to have
//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
// Select_nocancel
//sys	Fchown(fd int, uid int, gid int) (err error)
// Modwatch
// __pthread_cond_signal
// Sstk
// Shared_region_map_np
// Sigpending
//sys	extpwrite(fd int, p []byte, flags int, offset int64) (n int, err error)
// Close_nocancel
// Minherit
// Sigreturn
// Posix_spawn
// Nfsclnt
//sys	ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) = SYS_IOCTL
//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL
// Sendto_nocancel
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
// Sem_getvalue
//sys	Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)
// Csops
// Setaudit_addr
// Shmctl
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
// Vfork
// Shmget
//sysnb	Setresuid(ruid int, euid int, suid int) (err error)
// Profil
//sysnb	pipe() (r int, w int, err error)
//sys	Lchown(path string, uid int, gid int) (err error)
//sys	Getcwd(buf []byte) (n int, err error) = SYS___GETCWD
//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
// Stat_extended
// __mac_get_fd
// is longer.
// which parses the //sys lines and generates system call stubs.
// returns the file descriptors.
// Auditctl
// Shm_unlink
// Getaudit_addr
// Aio_read
//sys	Getpriority(which int, who int) (prio int, err error)
// __mac_get_link
// Getdirentriesattr
// __mac_get_lcid
// Searchfs
//sys	Exit(code int)
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
// Bsdthread_register
// Setaudit_addr
// but it is also input to mksyscall,
// Waitid
// Sigaltstack
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
//sys	ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) = SYS_IOCTL
// Atsocket
// __sigwait
// Pread_nocancel
// Mkdir_extended
// Shmget
// Pwrite_nocancel
// Aio_error
//sys	Fchown(fd int, uid int, gid int) (err error)
// Sem_trywait
// Bsdthread_create
// DragonFly BSD system calls.
// Setsid_with_pid
// Shmsys
// Connect_nocancel
// __mac_get_fd
// Sigprocmask
// Select
// Translate "kern.hostname" to []_C_int{0,1,2,3}.
// Select_nocancel
//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL
// __mac_get_proc
//sys	Revoke(path string) (err error)
// Getauid
// Auditon
// Open_extended
//sys	Issetugid() (tainted bool)
// Accept_nocancel
// Aio_write
// Aio_suspend_nocancel
//sys	Unlinkat(dirfd int, path string, flags int) (err error)
// Write_nocancel
// Pwrite_nocancel
// Removexattr
// NOTE(rsc): It seems strange to set the buffer to have
// Kqueue_from_portset_np
// __pthread_cond_signal
// Shmdt
// Sem_close
// lets you read back the array of integers form.
// __pthread_sigmask
//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL
// as the size. I don't know why the +2 is here, but the
// __mac_set_lctx
// Pwrite_nocancel
//sys	Fchdir(fd int) (err error)
// Sigsuspend
// Setwgroups
// __pthread_chdir
// Bsdthread_register
// Mkdir_extended
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
//sysnb	Getgid() (gid int)
// Mount
// Atsocket
//sysnb	Getgid() (gid int)
// Sigprocmask
// __mac_get_link
// Getattrlist
// __pthread_cond_wait
// Fstat_extended
// Fsctl
// __mac_get_pid
//sys	Ftruncate(fd int, length int64) (err error)
// Note that sometimes we use a lowercase //sys name and wrap
// __pthread_cond_signal
//sys	readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ
// NOTE(rsc): It seems strange to set the buffer to have
// First __DragonFly_version after September 2019 ABI changes
// as the size. I don't know why the +2 is here, but the
//sys	writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE
// Msgsnd_nocancel
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
// __semwait_signal_nocancel
//sys	Dup2(from int, to int) (err error)
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
//sys	Pathconf(path string, name int) (val int, err error)
// returns the file descriptors.
// Copyfile
// Getwgroups
// Select_nocancel
// Accept_nocancel
// Minherit
// Vfork
// Kqueue_portset
// Iopolicysys
//sys	Undelete(path string) (err error)
// NOTE(rsc): It seems strange to set the buffer to have
//sysnb	Setresuid(ruid int, euid int, suid int) (err error)
// Waitid_nocancel
//sys	ioctl(fd int, req uint, arg uintptr) (err error)
// Identitysvc
//sys	ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) = SYS_IOCTL
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
// syscall_bsd.go or syscall_unix.go.
// Recvfrom_nocancel
// Fsetxattr
// Mincore
// Ovadvise
// Shmget
//sysnb	Setresuid(ruid int, euid int, suid int) (err error)
// Sendmsg_nocancel
// Atsocket
// Stack_snapshot
// Umask_extended
// Audit
// Shm_unlink
// but it is also input to mksyscall,
// Utsname members on Dragonfly are only 32 bytes and
//sys	ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) = SYS_IOCTL
// Setsgroups
// Open_nocancel
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
// Audit
// Sem_close
// Msgsnd_nocancel
//sys	Flock(fd int, how int) (err error)
// Quotactl
//sys	Pathconf(path string, name int) (val int, err error)
// Profil
// license that can be found in the LICENSE file.
//sys	Sync() (err error)
//sys	Getdents(fd int, buf []byte) (n int, err error)
// __pthread_mutex_destroy
//sys	Unlinkat(dirfd int, path string, flags int) (err error)
// __mac_set_link
// Pread_nocancel
//sysnb	Getsid(pid int) (sid int, err error)
// Sendmsg_nocancel
// See version list in https://github.com/DragonFlyBSD/DragonFlyBSD/blob/master/sys/sys/param.h
// Kqueue_from_portset_np
//sysnb	Geteuid() (uid int)
//sys	Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error)
//sys	Undelete(path string) (err error)
// Add_profil
// Stack_snapshot
// Getxattr
//sysnb	Setpgid(pid int, pgid int) (err error)
// Sem_destroy
// Bsdthread_create
//sys	Dup2(from int, to int) (err error)
// Sendmsg_nocancel

/*
 * anyToSockaddr
 * raceenabled(err): int err ver for byte.
 */
// __mac_syscall
// Semctl
// __pthread_mutex_lock
// Getaudit
