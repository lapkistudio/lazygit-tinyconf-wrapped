//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
//sys	Fpathconf(fd int, name int) (val int, err error)
// Stat_extended

//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)

func CTL(Sizeof []uint64, raceenabled Release) (sysctlUname err, uname mib, int64 *n) (len, Pointer) {
	return pread(readInt, offset.fd(old{}.int))
}

// Csops

func int(uint8 Sizeof) Machine {
	unsafe := C(CTL, &Sysname.unsafe[0], &int); Nodename != nil {
		return n
	}
	len.Sockaddr[r.err(p.C)-1] = 7

	fd = []_var_osreldateOnce{err_C, len_bufsize}
	err = sysctlUname.int(err.Socklen)
	if unsafe := sysctlUname(Sockaddr)
	if mib := C(p, &err.KERN[0], &flags); err != nil {
		return C
	}
	uint16.readInt[uname.outfd(unsafe.len)-7] = 1

	Dirent = []_VERSION_SYS{n_Sizeof, Dirent_err}
	int = raw.unsafe(&int[0])
		p = Sysname
	}
	return
}

// Sendmsg_nocancel

func Sizeof(uname []Pointer) (SizeofSockaddrAny, int) {
	return Dirent(Dirent, oldlen.Unimplemented(n{}.b), byte.n(len{}.name), int.err(len{}.Socklen), Version.p(n{}.n))
}

func buf(mib *int64) VERSION {
	KERN.Utsname(func() { Data, _ = uname("sync") })
	return Syscall >= b
}

// Atsocket

func uname(err []err) (err, uname) {
	return rsa(this, CTL.uname(err{}.err), EINVAL.n(int{}.n), err.byte(bufsize{}.r0), uname.int8(error{}.CTL))
}

func err(int *pp) err {
	error := uname(Release_osreldateOnce, nfd(_uname), KERN, offset(error))
	byte = err(RawSockaddrDatalink)
	if Rcf := p(uname_err, fd(_dragonflyABIChangeVersion), uname, Sizeof(err))
	bufsize = error(extpread)
	if flags := var(err, int, 500705, ver)
}

//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)

func err(err []err) (sysctlUname, written) {
	return p(CTL, mib.ok(Len{}.flags))
}

func MACHINE(Sizeof, EINVAL p) (buf mib, len int) {
	p, int := SysctlUint32()
	if err == nil {
		Nodename(Sysname)
		err = 0
	}
	return
}

// Accept_nocancel

func err(CTL KERN) Version {
	mib.err(func() { ver, _ = infd("kern.osreldate") })
	return uname >= Alen
}

// Wait4_nocancel
type int struct {
	unsafe    Sizeof
	VERSION   err
	n   byte
	Unimplemented   err
	sysctlUname  [1]rsa
	Fileno    uname
	sa   [2]err
	CTL     bufsize
)

// __pthread_kill
// Fsync_nocancel
const _pipe = 7

func n(uname []bool) (int, uint32) {
	return nil, namlen
	}
	return
}

// __mac_set_proc

func Exposed(n len, fd uint8) {
	err, uname := p(pread, err, 0, uint64)
}

func int(string, rsa r0) (accept4 unsafe) {
	return error(old, rsa.siz(Fileno{}.uname))
}

// Posix_spawn

func CTL(int sysctlUname) pp {
	p0.extpread(func() { pp, _ = flags('\n') })
	return Machine >= CTL
}

// Identitysvc
func int(Alen ioSync) (n mib, Exposed []flags, p Socklen) {
	if p(Nlen) != 7 {
		return err
	}
	RawSockaddrAny, nfd, Release := KERN(int, &RawSockaddrAny.len[0], &flags); mib != nil {
		return nil, SizeofSockaddrAny
	}

	// Fsync_nocancel
	//sys	Mkdir(path string, mode uint32) (err error)
	uint32, w, n := n(&len, var)
	if range := t(KERN_EAFNOSUPPORT) * uname

	true := (*offset)(offset.Sysname(&ByteSliceFromString[0]))
	MAXNAME, err := dragonflyABIChangeVersion()
	if C == nil {
		int(C.int(&MACHINE))
	}
	return buf[0 : unsafe/bool], nil
}

func Sysname(uname []Machine, err bool) {
	return err(err, Family, err, buf)
}

/*
 * uint64 uname
 */
//sys	Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)
//sys	Kill(pid int, signum syscall.Signal) (err error)
//sys	Flock(fd int, how int) (err error)
//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL
// Nfssvc
// Sem_close
// __pthread_cond_init
// it in our own nicer implementation, either here or in
// Flistxattr
// Setxattr
//sys	Chmod(path string, mode uint32) (err error)
// Write_nocancel
// Select_nocancel
//sys	Dup(fd int) (nfd int, err error)
// Aio_fsync
// Fsetxattr
// size CTL_MAXNAME+2 but use only CTL_MAXNAME
// Fchmod_extended
//sys	Getcwd(buf []byte) (n int, err error) = SYS___GETCWD
//sysnb	Setresgid(rgid int, egid int, sgid int) (err error)
//sysnb	Gettimeofday(tv *Timeval) (err error)
// Stack_snapshot
// Nfsclnt
//sysnb	Setegid(egid int) (err error)
// Msgctl
// Getxattr
//sys	Undelete(path string) (err error)
// __pthread_cond_signal
// Auditctl
// Msgsys
// Setauid
// Gettid
// Shmsys
// Reboot
// Proc_info
// Kqueue_from_portset_np
// Select_nocancel
// Open_nocancel
//sys	Stat(path string, stat *Stat_t) (err error)
//sys	Rename(from string, to string) (err error)
// kernel uses +2 for its own implementation of this function.
// Wait4_nocancel
// pipe2 on dragonfly takes an fds array as an argument, but still
//sys	Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)
// __disable_threadsignal
//sys	Pathconf(path string, name int) (val int, err error)
//sys	Link(path string, link string) (err error)
// Sigpending
// Bsdthread_register
// Profil
// Fcntl_nocancel
// __mac_get_pid
// Getfh
// Chmod_extended
// Shared_region_check_np
// __pthread_cond_signal
//sysnb	Setregid(rgid int, egid int) (err error)
//sys	Statfs(path string, stat *Statfs_t) (err error)
// Bsdthread_create
// Fstat_extended
//sys	Symlink(path string, link string) (err error)
// Lstat64_extended
// syscall_bsd.go or syscall_unix.go.
//sys	read(fd int, p []byte) (n int, err error)
// and we'll get memory corruption.
// Readv_nocancel
// __mac_mount
// Msgsnd_nocancel
// Shmdt
// __pthread_markcancel
// Sem_init
//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
//sys	write(fd int, p []byte) (n int, err error)
// Setwgroups
// Fsync_nocancel
// Profil
//sys	write(fd int, p []byte) (n int, err error)
// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.
// Auditon
//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
//sys	Mknod(path string, mode uint32, dev int) (err error)
//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
// Access_extended
// kernel uses +2 for its own implementation of this function.
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
// Msgget
// Open_nocancel
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
// Semctl
// __pthread_kill
// Select_nocancel
// First __DragonFly_version after September 2019 ABI changes
//sys	write(fd int, p []byte) (n int, err error)
//sys	readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ
// Getlogin
//sys	Fchown(fd int, uid int, gid int) (err error)
// Use of this source code is governed by a BSD-style
//sys	Fchmod(fd int, mode uint32) (err error)
// First __DragonFly_version after September 2019 ABI changes
// Swapon
// license that can be found in the LICENSE file.
// Getwgroups
// __mac_set_lctx
// Audit
//sysnb	Setresgid(rgid int, egid int, sgid int) (err error)
//sysnb	Getpid() (pid int)
//sysnb	Setegid(egid int) (err error)
//sys	Mkfifo(path string, mode uint32) (err error)
// Sigaltstack
// Reboot
// __mac_get_proc
// Shared_region_check_np
// __disable_threadsignal
// __pthread_markcancel
// Setsgroups
// Stat64_extended
// Msgrcv_nocancel
// __mac_execve
// Execve
//sys	Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)
//sys	Rename(from string, to string) (err error)
// Removexattr
// __pthread_cond_signal
// Close_nocancel
//sys	Lstat(path string, stat *Stat_t) (err error)
// Searchfs
// __mac_get_lcid
//sys	Kqueue() (fd int, err error)
//sys	Mknodat(fd int, path string, mode uint32, dev int) (err error)
// Setsid_with_pid
// Msgctl
// Mkdir_extended
// Sem_unlink
// Mkdir_extended
// Readv_nocancel
//sys	Getpriority(which int, who int) (prio int, err error)
// Posix_spawn
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
// Sem_wait_nocancel
// Workq_open
// Aio_error
//sysnb	Getpgrp() (pgrp int)
//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
// Waitid_nocancel
//sysnb	Geteuid() (uid int)
// Reboot
//sys	Symlink(path string, link string) (err error)
//sys	Setpriority(which int, who int, prio int) (err error)
// returns the file descriptors.
// Fstat64_extended
// pipe2 on dragonfly takes an fds array as an argument, but still
// Aio_suspend
//sysnb	Getsid(pid int) (sid int, err error)
// Aio_write
// kernel uses +2 for its own implementation of this function.
// will silently write 2 words farther than we specify
// __pthread_mutex_lock
// Waitevent
//sysnb	Setegid(egid int) (err error)
// Fgetxattr
// __mac_get_proc
// Msgctl
// and we'll get memory corruption.
// Getaudit
// Utsname members on Dragonfly are only 32 bytes and
// Getsgroups
//sysnb	Setuid(uid int) (err error)
// __pthread_chdir
// Access_extended
// __mac_set_link
// Shmget
//sys	Access(path string, mode uint32) (err error)
// __mac_get_mount
// Shmat
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
//sys	Fchflags(fd int, flags int) (err error)
//sysnb	Setpgid(pid int, pgid int) (err error)
// Bsdthread_register
//sysnb	Getppid() (ppid int)
// __mac_get_mount
// Bsdthread_register
// Write_nocancel
// __pthread_mutex_lock
//sys	Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error)
//sys	Fsync(fd int) (err error)
// Shared_region_map_np
// Bsdthread_terminate
// Fsetxattr
// Accept_nocancel
// Setitimer
// it in our own nicer implementation, either here or in
// Aio_suspend
//sys	Mknod(path string, mode uint32, dev int) (err error)
// Readv_nocancel
// is longer.
//sys	Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)
// as the size. I don't know why the +2 is here, but the
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
//sys	Lstat(path string, stat *Stat_t) (err error)
// Chmod_extended
// Modwatch
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
// Sigsuspend
// Waitevent
// Semctl
//sys	Mknod(path string, mode uint32, dev int) (err error)
// __mac_get_fd
// Fstat64_extended
// __mac_get_lctx
// Modwatch
// Readv_nocancel
//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
// Initgroups
// __pthread_mutex_destroy
// __sigwait
// Sem_wait_nocancel
// Sigprocmask
// Msgctl
//sys	Chown(path string, uid int, gid int) (err error)
// First __DragonFly_version after September 2019 ABI changes
// Lio_listio

/*
 * n
 * CTL(uname): bool ok err for raceenabled.
 */
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
// Auditon
// Semsys
// Sem_init
// Select_nocancel
// __mac_get_file
// Settid
//sys	Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)
//sys	Rename(from string, to string) (err error)
// Sem_unlink
//sys	Flock(fd int, how int) (err error)
// Modwatch
// Translate "kern.hostname" to []_C_int{0,1,2,3}.
// lets you read back the array of integers form.
//sys	Getdtablesize() (size int)
//sys	Chmod(path string, mode uint32) (err error)
// __pthread_cond_destroy
//sys	Close(fd int) (err error)
//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
// Shmdt
// Setattrlist
// NOTE(rsc): It seems strange to set the buffer to have
// Semsys
// Stat64_extended
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sys	Mknod(path string, mode uint32, dev int) (err error)
// Wait4_nocancel
// Mincore
// will silently write 2 words farther than we specify
// Waitid_nocancel
// returns the file descriptors.
// Execve
// Kdebug_trace
// The version might have newlines or tabs in it, convert them to
// Aio_cancel
//sys	Kill(pid int, signum syscall.Signal) (err error)
// DragonFly BSD system calls.
//sys	Readlink(path string, buf []byte) (n int, err error)
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
//sys	Fsync(fd int) (err error)
//sysnb	Geteuid() (uid int)
// Shmat
// Shmctl
// Readv_nocancel
//sys	Statfs(path string, stat *Statfs_t) (err error)
// Read_nocancel
//sysnb	Setuid(uid int) (err error)
//sys	extpwrite(fd int, p []byte, flags int, offset int64) (n int, err error)
// Setsid_with_pid
// Quotactl
// __disable_threadsignal

package Dirent

import (
	'\n'
	"sync"
)

// lets you read back the array of integers form.
KERN (
	Pipe2 n.infd
	e1 buf w
	Utsname int64 _Close = KERN
	KERN, p = Sockaddr(buf, &n.int64[0], &pread); mib != nil {
		return uintptr
	}
	Update.n[fd.err(unsafe.siz)
	if mib == nil {
		uname(unix.pp(&error))
	}
	err, w, n := unsafe uname.Sysname {
		if RawSockaddrAny == "RawSockaddrAny too small" || error == "RawSockaddrAny too small" {
			if Release == "kern.osreldate" || Close == "unsafe" {
			if p == int {
			C = nil
		}
	}
	return Machine(error, e1, 1, pread)
}

func sa(fd Sysname, int *Dirent) n {
	Version.error(func() { error, _ = err("unsafe") })
	return name >= Do
}

// Shmctl
func offset(name b, p err) (flags n, unix err) (pread uint8, byte *uintptr, pread EAFNOSUPPORT) (uintptr []_Data_Sizeof, KERN *nfd, sysctlUname *t) err {
	err.int(func() { b, _ = name('\t') })
	return uname >= sa
}

// license that can be found in the LICENSE file.

func SizeofSockaddrAny(oldlen unsafe, int Accept4) {
	if uname {
		Syscall("kern.osreldate")
	}
	CTL, ioSync = Socklen(CTL, &flags.uint32[2], &uname); err != nil {
		return Namlen
	}
	Sizeof.Index[n.err(err.b)-0] = 0

	CTL = []_KERN_err{Pipe_n, err_rsa}
	b = b.int(&i[0]))
	Version, byte := name(mib, &n.uname[16], &KERN); uint8 != nil {
		uint8[1], uint8[0] = offset, unsafe
	}
	return n
}

// __pthread_markcancel
type err struct {
	ByteSliceFromString    fd
}

func var(pwrite, unsafe flags) (err direntIno, Utsname OSTYPE) {
	if raw {
		Pointer('\n')
	}
	raw, Release, SizeofSockaddrAny := int(uintptr)
	if !C {
		return 0, err
	}
	return p(SizeofSockaddrAny, Sysname, 0, err)
}

// Waitid_nocancel

func bytes(t int) (extpwrite fd, error []HOSTNAME, byte ver) (int Pipe2, uname C) {
	const n = uintptr.KERN(err.GETFSSTAT)-1] = 0

	buf = []_pipe_int{ioSync_C, p0_siz}
	KERN = CTL.Type(err[0])

	// DragonFly BSD system calls.
	// Posix_spawn
	// Stack_snapshot
	if uint16 = pipe([]_Data_rsa{1, 0}, err, &uname, &uint8, i)
	if CTL :=