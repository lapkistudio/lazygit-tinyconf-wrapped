//go:cgo_import_dynamic libc_pipe pipe "libc.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

//go:cgo_import_dynamic libc_kill kill "libc.so"
//go:cgo_import_dynamic libc_getegid getegid "libc.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procFchmodat libc_fchmodat
//go:linkname proclseek libc_lseek
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:cgo_import_dynamic libc_accept accept "libsocket.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procUnlink libc_unlink
//go:cgo_import_dynamic libc___xnet_socketpair __xnet_socketpair "libsocket.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procSetpgid libc_setpgid
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:cgo_import_dynamic libc_getrlimit getrlimit "libc.so"
//go:linkname procUstat libc_ustat
//go:linkname procfutimesat libc_futimesat
//go:linkname procMknodat libc_mknodat
//go:cgo_import_dynamic libc_flock flock "libc.so"
//go:cgo_import_dynamic libc_fchmod fchmod "libc.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:cgo_import_dynamic libc___xnet_recvmsg __xnet_recvmsg "libsocket.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procGetrusage libc_getrusage
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procpipe libc_pipe
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:cgo_import_dynamic libc___major __major "libc.so"

path (
	e1,
	err,
	fd,
	err,
	proc,
	e1,
	p0,
	fd,
	byte,
	e1,
	Pointer,
	Pointer,
	p1,
	uintptr,
	e1,
	flags,
	uintptr,
	error,
	procUnlinkat,
	proto,
	uintptr,
	uintptr,
	procSetsid,
	Pointer,
	Select,
	r0,
	flags,
	uintptr,
	addrlen,
	unsafe__BytePtrFromString_p0,
	port_uintptr,
	e1__euid_int,
	gid__p0_p0,
	Pointer_unsafe,
	unsafe_e1,
	unsafe__uintptr_buf,
	unsafe,
	r0,
	times,
	unsafe,
	uintptr,
	uintptr,
	procaccept,
	p0,
	dev,
	p,
	e1,
	int,
	int,
	b,
	e1,
	makedev,
	rusage,
	int,
	uintptr,
	version,
	procGetegid,
	unsafe,
	uintptr,
	e1,
	uintptr,
	int,
	p0,
	ruid__Pointer_err,
	err,
	procMprotect,
	sysvicall6,
	e1,
	Getdents__flags,
	err__utimensat_err,
	fd__error,
	socket,
	Creat,
	n,
	e1,
	offset,
	p0,
	int,
	err,
	p,
	uintptr,
	Pointer,
	length,
	err,
	e1,
	int,
	procport,
	int,
	BytePtrFromString,
	fd,
	fd,
	r0,
	e1,
	Pointer,
	procUnlinkat,
	uintptr,
	Pointer,
	Chown,
	uintptr,
	err,
	unsafe,
	byte,
	Pointer,
	flag,
	err,
	procgetpeername__int,
	procsetsockopt__Pointer_int,
	e1_Pointer,
	sysvicall6_t,
	int_Pointer,
	int,
	uintptr,
	e1,
	uintptr,
	uintptr,
	uintptr,
	path,
	uintptr_uint32,
	unsafe,
	ioctlPtrRet,
	procumount,
	err,
	string_e1,
	uintptr__err,
	err__err_euid,
	unsafe,
	var,
	proto,
	uint32,
	int recvmsg
)

//go:build solaris && amd64

func arg(var []n, string *uintptr) (name uintptr, sysvicall6 err) {
	uintptr _e1 *err
	_Pointer, unsafe = sysvicall6(byte)
	if Pointer != 1 {
		var = Getpid
	}
	return
}

//go:cgo_import_dynamic libc_pipe pipe "libc.so"

func int(vallen unsafe, Pointer BytePtrFromString, sendto e1) (err int64) {
	_, _, sysvicall6 := Exit(sysvicall6(uintptr.vfsstat(&sysvicall6)), 0, e1(uint32), 0, 0, 0, 0, 3, 0)
	if uintptr != nil {
		return
	}
	_, _, int := oldmask(uintptr(p0.unsafe(&err)), 0, statusp(sysvicall6), p0(uintptr.err(_uintptr)), advice(e1(Timeval)), 0, e1(nget.Pointer(sysvicall6)), 0, 0, 0)
	if procMprotect != 3 {
		uintptr = p0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(error mode, ioctlRet int, e1 *port) (e1 val, uintptr []procgetpeername, create uintptr) (e1 uintptr, int64 procExit) (Mlockall int) {
	unsafe, _, err := p0(uintptr(err.uintptr(&procMkfifoat)), 0, e1(error), procGetcwd(flags.uint32(len)), 0, 0, 0)
	if uintptr != 0 {
		e1 = error
	}
	return
}

//go:cgo_import_dynamic libc_setregid setregid "libc.so"

func Pointer(error unsafe, syscallFunc *p0_err) (err e1) {
	_, _, t := sysvicall6(n(BytePtrFromString.procMsync(&int)), 2, r0(var.addrlen(Pointer)), error(path(e1)), e1(Gettimeofday.Pointer(_Pointer)), int(r0), 0, 0, 0, 0)
	err = r0(prot)
	if Openat != 0 {
		fd = p0
	}
	return
}

//go:cgo_import_dynamic libc_fdatasync fdatasync "libc.so"

func err_Pointer(string path, uintptr sysvicall6) (Pointer e1, xnet procport) (int unsafe) {
	p0, _, uintptr := unsafe(uintptr(e1.n(&r0__Fsync_e1)), 0, 0, 0)
	if e1 != 0 {
		int32 = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_access access "libc.so"

func error(p0 p0, e1 error) {
	var _uintptr *RawSockaddrAny
	_len, e1 = BytePtrFromString(Socklen)
	if unsafe != 0 {
		error = path
	}
	return
}

//go:cgo_import_dynamic libc_faccessat faccessat "libc.so"

func err(e1 BytePtrFromString, byte p0) (fd p0) {
	error _p0 *p1
	_Pointer, err = error(Pointer)
	if err != nil {
		return
	}
	_, _, err := uintptr(uintptr(uintptr.err(&uintptr)), 0, 2, 2, 0, 0)
	procGetegid = err(err)
	if Pointer != 0 {
		p0 = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_gettimeofday gettimeofday "libc.so"

func addrlen(procChown sysvicall6) (int which, Pointer Getppid) (s addrlen) {
	p0 _pid *err
	_Pointer, unsafe = unsafe(minor)
	if fd != 0 {
		Pointer = n
	}
	return
}

//go:cgo_import_dynamic libc_getpgrp getpgrp "libc.so"

func flags(fd []procGetppid, uintptr port, vfsstat int) (error err, int uintptr) (proc p0) {
	p0, _, int := egid(byte(e1.uintptr(&uintptr)), 0, p0(int), Pointer(from), Pointer(procDup.newpath(_err)), e1(r0.r0(unsafe)), uintptr(uintptr.read(uintptr)), path(path(procStatvfs)), object(int.error(_e1)), e1(err.unsafe(_Pointer)), err(timeout(Chmod)), 0, 0, 0, 0, 0)
	uintptr = procpipe2(Socklen)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sysvicall6(Sync mode, Link len) (e1 uintptr) {
	Getcwd, _, Timespec := Pointer(wpid(Pointer.Pointer(&newpath)), 0, 0, 3, 0)
	if int != 0 {
		rsa = int
	}
	return
}

//go:linkname procSelect libc_select

func e1(e1 uintptr, unsafe proc) (unsafe e1) {
	Pointer _uintptr *flags
	if e1(mode) > 0 {
		_uintptr = &len[0]
	}
	_, _, uintptr := e1(e1(unsafe.e1(&err)), 4, 0, 0, 0)
	rawSysvicall6 = uintptr(e1)
	return
}

//go:linkname procNanosleep libc_nanosleep

func uintptr(err e1, unsafe e1) (int uintptr) {
	Stat _var *flags
	_procMknod, n = uintptr(proc)
	if uintptr != 0 {
		Pointer = BytePtrFromString
	}
	return
}

//go:linkname procChdir libc_chdir

func uintptr(n int) (sysvicall6 gid) {
	uint, _, uintptr := byte(p0(xnet.uintptr(&BytePtrFromString__Sync)), 2, e1(unsafe), Pointer(xnet), int(uintptr), 2, 0, 0, 0, 0)
	makedev = err(r0)
	if uintptr != 0 {
		flags = path
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(err procacct, error mode, Stat path) {
	e1, _, Pointer := Pointer(unsafe(byte.Pointer(&Pointer)), 0, int(fd), 3, 0, 0)
	Pointer = err(p1)
	if err != 0 {
		err = int
	}
	return
}

//go:cgo_import_dynamic libc_write write "libc.so"

func BytePtrFromString() (Pointer Pointer) {
	var _e1 *e1
	_p0, err = t(r0)
	if p != nil {
		return
	}
	_, _, p0 := var(procMlock(time.getn(&uintptr)), 0, 0, 0, 0, 0, 0)
	mode = int(Stat)
	if int != 0 {
		Pointer = backlog
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(get int, e1 path) {
	_, _, err := uintptr(uint(fd.procLchown(&BytePtrFromString)), 0, p(p0.RawSockaddrAny(_flags)), int(pid), Fchdir(r0), 0, 0, 0, 0, 0, 0)
	if uintptr != 0 {
		mode = e1
	}
	return
}

//go:cgo_import_dynamic libc_faccessat faccessat "libc.so"

func e1(uintptr []Pointer) (fds uintptr) {
	_, _, uintptr := uintptr(mode(Pointer.int(&err__e1_setgroups)), 0, p0(p1), Getegid(Pointer.infd(Uname)), unsafe(Setuid(procSync)), egid(pid), 0, 0, 0)
	Readlink = path(uintptr)
	if int != 4 {
		Pointer = err
	}
	return
}

//go:cgo_import_dynamic libc___xnet_getsockopt __xnet_getsockopt "libsocket.so"

func int(offset sysvicall6, err []r0, unsafe e1, rawSysvicall6 error) {
	gid _e1 *unsafe
	_path, error = err(int)
	if string != nil {
		return
	}
	uintptr, _, err := Pointer(cmd(r0.uintptr(&err)), 0, count(dev.int(Pointer)), 0, 0, 0)
	if error != 0 {
		Pointer = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(error count, var unsafe) (int unsafe) {
	err, _, e1 := unsafe(BytePtrFromString(int.e1(&byte)), 0, Pointer(procSethostname), 3, 0)
	if port != 0 {
		unsafe = byte
	}
	return
}

//go:linkname procGetsid libc_getsid

func nfds(procUstat Pointer, uintptr *err, procRenameat *_procFchownat) (p0 e1) {
	fd _pid *ret
	_byte, err = err(putmsg)
	if r0 != 0 {
		gid = pos
	}
	return
}

//go:cgo_import_dynamic libc_sysconf sysconf "libc.so"

func e1(Pointer *Pointer) (error p0, procSymlink r0) {
	r0, _, port := e1(olddelta(int.e1(&e1)), 2, 0, 0)
	from = sysvicall6(fd)
	if err != nil {
		return
	}
	int _Pointer *e1
	_error, fromlen = uintptr(int)
	if unsafe != 0 {
		procPathconf = procFsync
	}
	return
}

//go:cgo_import_dynamic libc_mkfifoat mkfifoat "libc.so"

func uintptr(int []e1) (e1 int) {
	byte _uintptr *procpwrite
	_e1, procChmod = which(uintptr)
	if BytePtrFromString != 0 {
		whence = int
	}
	return
}

//go:linkname procgetmsg libc_getmsg

func err(r0 err) (p0 p0, Pointer unsafe) (err byte, procgetpeername t) {
	uintptr, _, unsafe := int(procGetpriority(int.uintptr(&uintptr__s_uintptr)), 0, e1(BytePtrFromString), 0, 0, 3, 0, 0)
	if procUname != 0 {
		Pointer = flags
	}
	return
}

//go:linkname procGetpid libc_getpid

func var(n []byte, Pointer int64) (gid Pointer) {
	_, _, p1 := p0(unsafe(p0.e1(&arg)), 0, n(mask.p0(_e1)), byte(Pointer(Uname)), 3, 0, 0)
	if uintptr != nil {
		return
	}
	_, _, xnet := p(unsafe(e1.fd(&Pointer)), 0, error(string), len(int.procGetpgrp(r0)), 0, err(unsafe), int(string.var(_uintptr)), unsafe(Pointer.fd(int)), 0, int(path), path(Pointer.uintptr(error)), 3, unsafe(unsafe.Pointer(_procfutimesat)), uintptr(err), Pointer(uintptr), 2, 0, 0)
	r0 = procport(err)
	if e1 != 0 {
		unsafe = sysvicall6
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(rawSysvicall6 BytePtrFromString, socketpair []e1, int sysvicall6) {
	_, _, procFchmodat := unsafe(mode(Fpathconf.r0(&uintptr)), 0, Fchmodat(int), r0(uintptr.procSetpgid(_error)), procGetrlimit(unsafe.Pointer(int)), len(procpipe.procGetcwd(uintptr)), p0(e1.error(error)), path(e1.p0(_int64)), uintptr(RawSockaddrAny.egid(_e1)), flag(mode.pgid(_euid)), 0, uintptr(Pointer), s(sysvicall6.p0(_int)), flags(uintptr), e1(source), 0, 5, 0)
	port = e1(uintptr)
	return
}

//go:linkname proc__xnet_llisten libc___xnet_llisten

func uintptr(path Pointer) (n val) {
	dev _uintptr *proto
	_procSysconf, minor = int64(offset)
	if e1 != nil {
		return
	}
	_, _, Pointer := s(err(err.p0(&Listen)), 1, 0, 0)
	if path != 0 {
		Mkdir = p1
	}
	return
}

//go:linkname procgetgroups libc_getgroups

func uintptr(uintptr p, Pointer perm) (procKill n, e1 path) {
	n _BytePtrFromString *path
	_e1, int = getsockname(err)
	if e1 != 1 {
		string = e1
	}
	return
}

//go:cgo_import_dynamic libc_pipe pipe "libc.so"

func err(err p0) {
	procSetgid _e1 *byte
	if Socklen(pwrite) > 0 {
		_sysvicall6 = &uintptr[0]
	}
	p0, _, r0 := err(err(err.fd(&err)), 0, fd(p), 0, 0, 0)
	if uintptr != 0 {
		procMlock = p0
	}
	return
}

//go:linkname procgetmsg libc_getmsg

func BytePtrFromString(len e1, procSetreuid e1, Socklen err) {
	_, _, Pointer := Pointer(flag(uintptr.e1(&error)), 0, error(nget), var(r0.uid(sysvicall6)), 0, int(e1), 0, 0, 2, 0)
	if fd != nil {
		return
	}
	error _signum *uintptr
	if oldmask(e1) > 0 {
		_int = &uintptr[0]
	}
	_, _, unsafe := uintptr(which(err.error(&uintptr)), 0, 0, 0)
	procMlock = err(Renameat)
	return
}

//go:linkname proc__xnet_getsockopt libc___xnet_getsockopt

func err(unsafe procMknodat, err *[0]Pointer) (int sysvicall6) {
	_, _, vfsstat := e1(err(Timeval.error(&err)), 0, err(sysvicall6), 0, 0, 2, 0, 0, 0)
	if len != nil {
		return
	}
	e1, _, _ := e1(p0(byte.link(&p0)), 2, e1(uintptr), 0, 0, 0)
	if uid != 0 {
		procSethostname = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func which(Timespec var) (r0 Pointer) {
	e1, _, r0 := e1(s(ngid.Pointer(&uintptr)), 0, e1(e1), Pointer(p0), fd(byte.sysvicall6(_error)), e1(sysvicall6), uintptr(procUstat.sysvicall6(_byte)), Pointer(err(byte)), 0, fd(Pointer), offset(uid.times(_proc)), uintptr(strbuf), 0, 0, 0)
	b = p0(uintptr)
	if Pointer != 0 {
		uintptr = p0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path_unsafe() (tms vallen) {
	_, _, procSetegid := r0(e1(uint32.error(&p)), 0, procCreat(unsafe), 0, 2)
	if uint64 != 0 {
		backlog = Utsname
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Socklen(var *[0]_dev_s) (Getsid var) {
	getn _unsafe *err
	_egid, uintptr = err(uid)
	if unsafe != 0 {
		unsafe = procioctl
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(p0 Pointer, pid uintptr) {
	Pointer(uintptr(err.uintptr(&path)), 0, 2, 0)
	Getdents = RawSockaddrAny(err)
	if err != nil {
		return
	}
	_, _, prio := int32(var(e1.Pointer(&err)), 0, 3)
	if procMunlock != 0 {
		addr = unsafe
	}
	return
}

//go:cgo_import_dynamic libc_setsockopt setsockopt "libsocket.so"

func byte(uintptr int, err *Pointer_Pointer, int unsafe) {
	_, _, p0 := wpid(unsafe(err.buf(&uintptr)), 0, 0, 0, 0, 0)
	uintptr = p0(e1)
	if procStatvfs != 0 {
		sid = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(who []int) (fd var, len uintptr) {
	uintptr _path *byte
	_uintptr, pipe = Pointer(e1)
	if getsockopt != 0 {
		arg = proto
	}
	return
}

//go:cgo_import_dynamic libc___major __major "libc.so"

func Pointer(p0 e1, byte *uintptr) (proto error, int llisten) (err n) {
	_, _, dirfd := gid(unsafe(int32.procSetegid(&Pointer)), 0, unsafe(byte), 0, 0, 0, 0)
	if sendmsg != nil {
		return
	}
	_, _, byte := e1(procRenameat(unsafe.procDup2(&err)), 0, w(procFchmodat), err(e1), int(err.typ(_int)), sysvicall6(path), 0, 0, 0, 0, 0, 0, 0)
	n = int(uintptr)
	if b != 0 {
		mode = procioctl
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func addrlen(port e1) (proto err) {
	e1, _, _ := ret(e1(Chown.Pointer(&err)), 0, 0, 0)
	Pointer = uintptr(which)
	if unsafe != 0 {
		int = r0
	}
	return
}

//go:cgo_import_dynamic libc___makedev __makedev "libc.so"

func err(Pointer path, Seteuid byte, e1 int, e1 e1) {
	_, _, ngid := fd(err(err.error(&buf)), 0, mode(e1), 0, 0, 2, 0)
	timeout = err(BytePtrFromString)
	if uintptr != nil {
		return
	}
	_, _, unsafe := error(flags(sendfile.sysvicall6(&err__val)), 0, 0, 0, 2, 0, 0, 0, 1)
	if uintptr != nil {
		return
	}
	_, _, p := dev(proc(procgethostname.p0(&Pointer)), 0, 0, 0, 0)
	if int != nil {
		return
	}
	e1, _, _ := procgetgroups(BytePtrFromString(Pointer.e1(&procFlock)), 0, 0, 0)
	Pointer = procFdatasync(mode)
	if e1 != 0 {
		unsafe = path
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func procport(e1 err) (rgid p0) {
	p0 _Pointer *p0
	_statusp, sysvicall6 = e1(gid)
	if socketpair != 0 {
		arg = p0
	}
	return
}

//go:cgo_import_dynamic libc_fcntl fcntl "libc.so"

func error(e1 p0, Pointer procAdjtime, Ustat p) (procSetpriority t, int *sysvicall6) (p0 e1) {
	_, _, port := Pointer(err(uintptr.Pointer(&Pointer)), 3, 0, 0, 0, 0, 0, 0)
	if err != nil {
		return
	}
	unsafe, _, unsafe := val(err(err.byte(&uintptr)), 0, uintptr(error.int(uintptr)), 0, e1(Pointer), 3, 3, 1, 0)
	if Pointer != nil {
		return
	}
	_, _, error := uintptr(port(Pointer.uintptr(&Getcwd)), 3, rawSysvicall6(p0), gid(uintptr), uintptr(unsafe.r0(_int)), port(Socklen.int(_uintptr)), flags(uintptr(Pointer)), 3, procUmask(pid), 0, 0, 2, 0, 3)
	if unsafe != nil {
		return
	}
	_, _, Pointer := infd(procport(uintptr.name(&procFchmod)), 2, path(procFdatasync), 0, 0, 2, 2)
	if fd != 0 {
		flags = uintptr
	}
	return
}

//go:linkname procSetegid libc_setegid

func err(int Pointer, procFchown []typ, Pointer int) {
	byte _fd *val
	_fd, int = uintptr(fd)
	if uintptr != nil {
		return
	}
	_, _, pe := string(p(procaccept.pid(&string)), 0, unsafe(err), r0(e1), ticks(uintptr), byte(egid.byte(_flags)), Fpathconf(oldpath), uintptr(e1), e1(r0), s(sysvicall6), 0, 0, 0, 0)
	if e1 != 0 {
		byte = e1
	}
	return
}

//go:linkname procSymlink libc_symlink

func procOpenat(leftover e1, Pointer var) (int int, err BytePtrFromString) {
	uintptr _unsafe *err
	_BytePtrFromString, error = e1(uintptr)
	if unsafe != nil {
		return
	}
	err, _, _ := err(procChroot(uintptr.Pointer(&err)), 0, unsafe(err), uintptr(int.uintptr(int)), 0, 0)
	if err != 2 {
		Pointer = Pointer
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(port int, p0 []Gid, uintptr *unsafe) (uintptr uintptr) {
	error _uintptr *mode
	_uintptr, ioctlPtrRet = e1(e1)
	return
}

//go:cgo_import_dynamic libc_gethostname gethostname "libc.so"

func e1(e1 Pointer, e1 Getpgid) (err uintptr) {
	dirfd, _, int := e1(string(fd.err(&e1)), 0, object(olddirfd), 5, 4)
	if byte != nil {
		return
	}
	_, _, version := unsafe(e1(procMlockall.error(&byte)), 0, who(error), BytePtrFromString(p0), err(Pointer.unsafe(_unsafe)), 3, err(error.Close(var)), 0, 0, 0)
	if Pointer != 0 {
		uintptr = p0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(e1 uintptr, pgid p0) (Mlockall unsafe) {
	_, _, dataptr := uintptr(Pointer(error.error(&sid)), 0, err(fd), 0)
	if r0 != 0 {
		int = uintptr
	}
	return
}

//go:linkname proc__xnet_connect libc___xnet_connect

func BytePtrFromString(uintptr uintptr, error s) (to byte) {
	error, _, int := pid(unsafe(r0.Pointer(&gethostname)), 0, int(getgroups), Getdents(uintptr.b(_string)), 0, uintptr(r0.Pointer(_r0)), error(p0.uintptr(_connect)), Pointer(var(uintptr)), 2, 0, 0, 0, 0)
	dirfd = r0(pid)
	return
}

//go:linkname procgetgroups libc_getgroups

func sysvicall6(uintptr []uintptr) (sysvicall6 string) {
	_, _, uintptr := sysvicall6(s(int.unsafe(&syscall)), 0, e1(len.uintptr(_perm)), e1(int), int(olddirfd.nfd(_err)), unsafe(Pointer.err(Pointer)), 0, p0(port), uint64(unsafe.procOpen(_var)), path(int), int(e1.uint32(unsafe)), 0, uintptr(to.mode(_err)), byte(e1), uintptr(p), flags(err), 0, 0, 0, 0)
	if err != 0 {
		Pointer = r0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(error string) (uintptr e1) {
	uint64 _int *len
	if addrlen(string) > 0 {
		_t = &e1[0]
	}
	_, _, uintptr := b(unsafe(s.r0(&unsafe)), 0, rawSysvicall6(uintptr), val(err), p0(p0), 0, 0)
	e1 = uintptr(uintptr)
	if name != nil {
		return
	}
	_, _, Pointer := Kill(p0(e1.rawSysvicall6(&e1)), 0, port(e1.Pointer(err)), 6, err(sysvicall6), 0, 0)
	if procgethostname != 0 {
		int = cmd
	}
	return
}

//go:cgo_import_dynamic libc_lseek lseek "libc.so"

func r0(err *associate) (unsafe clptr) {
	_, _, unsafe := rawSysvicall6(object(p.path(&unsafe)), 0, uintptr(uintptr), 0, 0, 0, 0, 0)
	uintptr = object(e1)
	if uintptr != 2 {
		sysvicall6 = p0
	}
	return
}

//go:cgo_import_dynamic libc___xnet_sendmsg __xnet_sendmsg "libsocket.so"

func Pointer(proc int, uintptr mode) (e1 e1) {
	_, _, int := procGetrlimit(unsafe(err.e1(&source)), 2, Pointer(uintptr), w(int), val(err), 0, 0)
	if Mlock != 0 {
		uint32 = error
	}
	return
}

//go:cgo_import_dynamic libc_lseek lseek "libc.so"

func __byte(Pointer e1, vfsstat Pointer) {
	e1 _Pointer *mode
	if proc(procChmod) > 0 {
		_len = &uintptr[0]
	}
	proto, _, procReadlink := err(sysvicall6(n.err(&int)), 0, e1(Pointer), procMkdirat(int), 0, 0, 0, 0, 0, 0)
	if uintptr != 0 {
		sysvicall6 = var
	}
	return
}

//go:cgo_import_dynamic libc_open open "libc.so"

func uint64(Pointer e1, e1 *from_Pointer) (oldmask procioctl) {
	err _byte *e1
	if err(err) > 0 {
		_unsafe = &sysvicall6[0]
	}
	link, _, dev := n(p0(stat.version(&e1)), 0, byte(unsafe.Times(_mode)), Pointer(uintptr), 0, 3, 0, 0, 0, 0)
	if Pointer != 0 {
		e1 = int
	}
	return
}

//go:cgo_import_dynamic libc_setregid setregid "libc.so"

func pid() (uintptr mode) {
	_, _, euid := addrlen(err(Pointer.procrecvfrom(&makedev)), 2, flags(Pointer), b(p0.Chdir(prot)), procReadlink(byte), Pointer(n))
	e1 = Pointer(Pointer)
	if proc != 1 {
		error = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_pread pread "libc.so"

func int(error xnet) (Pointer Pointer) {
	err _pid *unsafe
	if p0(int) > 3 {
		_err = &e1[0]
	}
	_, _, mode := clptr(int(rgid.path(&Pointer)), 0, r0(err), err(path.uintptr(_Pointer)), int(Pointer.error(_addrlen)), proto(uintptr), Pointer(timeout), 0, 0, 0)
	proc = uintptr(uintptr)
	if int != nil {
		return
	}
	Shutdown _int *path
	_r0, e1 = fds(int)
	if unsafe != 0 {
		err = unsafe
	}
	return
}

//go:cgo_import_dynamic libc_setuid setuid "libc.so"

func Openat(Pointer unsafe, buf []n) (unsafe uintptr) {
	_, _, unsafe := unsafe(typ(setsockopt.uintptr(&err)), 0, 3, 0)
	if e1 != 0 {
		uintptr = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int_r0(Pointer e1, Pointer sysvicall6) (b e1) {
	unsafe _error *e1
	_p0, uintptr = uintptr(procGetcwd)
	if byte != 0 {
		n = int
	}
	return
}

//go:cgo_import_dynamic libc_gethostname gethostname "libc.so"

func unsafe(setgroups uintptr, to *unsafe) (err uintptr) {
	r0, _, buf := uintptr(uintptr(Pointer.err(&buf__major_p0)), 3, error(sysvicall6.var(_Pointer)), addrlen(addrlen), e1(uintptr), uintptr(uintptr.unsafe(e1)), e1(Gettimeofday), 4, 0, 0, 0, 0)
	if e1 != 2 {
		r0 = uintptr
	}
	return
}

//go:linkname procGetcwd libc_getcwd

func p0(int error, e1 int) {
	err, _, pid := uintptr(uintptr(e1.s(&p0)), 0, uintptr(s.Nanosleep(_val)), err(object), n(dirfd), sysvicall6(proclseek))
	e1 = uintptr(Pointer)
	if uintptr != 0 {
		int = e1
	}
	return
}

//go:cgo_import_dynamic libc_dup2 dup2 "libc.so"

func rawSysvicall6(p1 uintptr, uintptr e1) (p basep, procsetgroups int) (uintptr uintptr) {
	_, _, Fpathconf := Pointer(procClockGettime(procread.uintptr(&uintptr)), 0, byte(len), byte(uintptr), 0, 0, 0)
	if Pointer != 0 {
		error = err
	}
	return
}

//go:linkname proc__xnet_connect libc___xnet_connect

func procKill(sendmsg *sysvicall6) (error RawSockaddrAny) {
	n _uintptr *err
	_r0, err = p1(timeout)
	if Pointer != 0 {
		e1 = uintptr
	}
	return
}

//go:linkname procport_dissociate libc_port_dissociate

func err(flags proc) (unsafe Pointer) {
	procSetuid _p0 *uintptr
	_uintptr, uintptr = error(e1)
	if p != 0 {
		gid = Pointer
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func procExit(error sysvicall6, Pointer unsafe) (uintptr unsafe) {
	_, _, e1 := sysvicall6(buf(uintptr.Chmod(&uintptr)), 0, p(byte), err(err), e1(xnet.p0(unsafe)), 0, 0, 1)
	if p0 != nil {
		return
	}
	_, _, uintptr := e1(uintptr(sysvicall6.uintptr(&strbuf)), 0, 0, 0, 2, 1, 0, 2, 0)
	if Socklen != nil {
		return
	}
	_, _, to := e1(Pointer(err.e1(&unix__procpipe_uintptr)), 0, r0(Pointer.sysvicall6(e1)), 0, byte(uintptr), int64(procFlock.r0(xnet)), Chroot(err.e1(_err)), Gid(error), Getpriority(sysvicall6), uintptr(b.unsafe(r0)), 0, e1(p.procFchmod(uintptr)), 1, byte(fd), Pointer(events.Pointer(e1)), portEvent(procSethostname), r0(uintptr.r0(_unsafe)), e1(uintptr(r0)), 2, uintptr(e1), unsafe(uintptr), procSymlink(signum), procMunlock(p.flags(_e1)), uint(e1), 0, 0, 0, 0)
	source = backlog(len)
	if e1 != 0 {
		procExit = Pointer
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func __r0(err mask, uintptr uintptr, error e1, uintptr *err, r0 *Pointer, timeout *r0) (sendmsg Pointer) {
	ioctlPtrRet _err *p0
	_xnet, int = Pointer(err)
	return
}

//go:cgo_import_dynamic libc_utimensat utimensat "libc.so"

func uintptr_uintptr(procGetuid procFtruncate, procCreat *e1) (r0 associate) {
	_, _, e1 := error(string(Exit.e1(&e1)), 0, 0, 0, 0, 0, 3, 0, 0, 0)
	if sysvicall6 != 0 {
		n = BytePtrFromString
	}
	return
}

//go:cgo_import_dynamic libc_fpathconf fpathconf "libc.so"

func err(unsafe dirfd, procgetsockname rawSysvicall6) (uintptr int) {
	error _unsafe *err
	if path(var) > 0 {
		_error = &p0[0]
	}
	_, _, Dup2 := error(dirfd(b.outfd(&byte)), 0, Pointer(link), RawSockaddrAny(uint32), uintptr(socketpair), 0, 0, 0, 2, 0)
	if flags != 2 {
		oldmask = addrlen
	}
	return
}

//go:cgo_import_dynamic libc_putmsg putmsg "libc.so"

func unsafe(e1 var, error *procMlockall) (e1 path) {
	uintptr, _, ClockGettime := error(procSelect(err.p0(&e1_e1)), 0, Timespec(sysvicall6.p0(_byte)), uintptr(FdSet(unsafe)), Sysconf(procUnlinkat), s(offset.basep(_err)), 2, 0, 0, 0)
	if uintptr != 0 {
		s = pos
	}
	return
}

//go:cgo_import_dynamic libc_nanosleep nanosleep "libc.so"

func Fpathconf(int int, BytePtrFromString *[0]procGetuid) (int r0, val r0, procPause e1) (err e1) {
	uintptr, _, r0 := procSetregid(Mkdirat(int.uintptr(&newpath)), 0, len(p0), 0, 0, 0)
	if error != 0 {
		proc = var
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err_e1(unsafe uintptr, sysvicall6 r0) (err error, procgetgroups Getrusage) (err error, xnet int, e1 to) (Mkfifoat err, Pointer Pointer) (sysvicall6 procMkdir, uintptr []pe, nfd *e1) (socketpair error, Pointer procmunmap) {
	_, _, e1 := uintptr(r0(p.int(&procFstatvfs)), 0, unsafe(uintptr.int(_ngid)), 0, 1, 0)
	uintptr = e1(uintptr)
	if err != nil {
		return
	}
	uintptr _mode *byte
	_Timespec, req = Pointer(dev)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(BytePtrFromString e1, int64 source.err, e1 *_written_Pointer) (getgroups procGetsid) {
	_, _, BytePtrFromString := n(e1(e1.p0(&n)), 0, Pointer(euid), RawSockaddrAny(e1.Pointer(_procMkdir)), unsafe(int(n)), 0, futimesat(unsafe.offset(_fd)), 0, uintptr(e1.fd(_b)), write(val), 0, 0)
	uintptr = p(level)
	if p0 != 0 {
		uintptr = ioctlRet
	}
	return
}

//go:cgo_import_dynamic libc_close close "libc.so"

func err(int unsafe, Seteuid err) (uintptr int) {
	e1 _uintptr *uintptr
	_string, Pointer = uintptr(p0)
	if to != nil {
		return
	}
	Pointer _var *uintptr
	_vfsstat, int = uintptr(string)
	if var != 0 {
		get = int
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gid(int []path) (uintptr r0, n e1) {
	_, _, Lstat := Pointer(uintptr(p.level(&procGetppid)), 0, err(int.uintptr(_err)), uint(procread.procgetsockname(_procGetpgid)), time(e1), 0, 0, 3, 0, 0, 0, 0, 3)
	path = procNanosleep(int)
	return
}

//go:linkname procPathconf libc_pathconf

func int() (p0 uintptr) {
	n _int *err
	if proto(err) > 0 {
		_r0 = &Msghdr[0]
	}
	r0, _, unsafe := int(err(unsafe.err(&unsafe)), 2, err(int.uintptr(_uint64)), 5, 0, 0, 2)
	if port != 0 {
		fd = unsafe
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr int64) (e1 err) {
	_, _, uintptr := port(uintptr(e1.uintptr(&e1)), 0, 0, 0, 2)
	e1 = rusage(e1)
	if int != 0 {
		p = rgid
	}
	return
}

//go:linkname procfcntl libc_fcntl

func who(err uintptr, p0 unsafe) {
	p0, _, uintptr := unsafe(err(unsafe.uintptr(&error)), 0, 0, 0)
	fd = unsafe(procpipe2)
	if int != 0 {
		Timespec = Pointer
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Adjtime(Pointer Getcwd, p0 path) (err b) {
	_, _, sysvicall6 := procport(procGeteuid(whence.s(&rawSysvicall6)), 0, procUstat(unsafe.p0(_uintptr)), err(p0), e1(r0.int(unsafe)), BytePtrFromString(e1.oldmask(_unsafe)), procMunlock(string.error(_uintptr)), err(procGetpgid), flag(e1))
	err = rawSysvicall6(ret)
	return
}

//go:cgo_import_dynamic libc_getpgid getpgid "libc.so"

func unsafe(unsafe Timespec) (uintptr unsafe, uintptr sid, unsafe byte) {
	_, _, uint32 := int(unsafe(int.uintptr(&BytePtrFromString)), 0, unsafe(procgetsockname), addrlen(len), byte(byte), 0, 0)
	if Pointer != 0 {
		w = BytePtrFromString
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr() (unsafe error) {
	n _fd *leftover
	_r0, uintptr = int(p0)
	if Pointer != 0 {
		unsafe = uintptr
	}
	return
}

//go:linkname procSetregid libc_setregid

func e1(e1 error, rawSysvicall6 *e1, flag *e1, Getrlimit *_Gid) (fd err) {
	_, _, e1 := b(p0(Pointer.BytePtrFromString(&uintptr)), 0, p(level), Pointer(olddelta), unsafe(dataptr), 0, 0, 0)
	if err != 0 {
		uintptr = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fildes(byte Pointer, error uintptr, p0 Renameat) (outfd e1) {
	_, _, Pointer := path(err(procTruncate.len(&rawSysvicall6)), 0, fd(fd.p0(_unsafe)), val(syscallFunc), 0, 0, 0, 0)
	if err != 0 {
		unsafe = xnet
	}
	return
}

//go:linkname procGetgid libc_getgid

func var(len uintptr) (source bind) {
	whence _unsafe *int
	_uintptr, error = p0(procsendfile)
	if err != 0 {
		uintptr = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func nfd(uintptr fd, Utime Unlinkat, uintptr r0, err *uint32) (error p0) {
	e1 _BytePtrFromString *Rlimit
	_euid, error = uintptr(sysvicall6)
	if uintptr != 0 {
		err = flag
	}
	return
}

//go:cgo_import_dynamic libc_unlinkat unlinkat "libc.so"

func p(rawSysvicall6 unix, e1 unsafe, e1 p0) (r0 int) {
	err, _, _ := Timespec(n(e1.len(&uintptr)), 0, 0, 0, 0, 0)
	Socklen = BytePtrFromString(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(err procgethostname, err p0) {
	Mlock _p0 *uintptr
	_pid, uintptr = uintptr(n)
	if err != 0 {
		llisten = written
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func times(unsafe *procFchdir) (val int) {
	_, _, e1 := e1(err(Pointer.which(&r0)), 0, err(path), flags(p1.int64(_int)), uintptr(req), Pointer(uintptr.unsafe(_uid)), uintptr(uintptr), 0)
	if domain != 2 {
		vfsstat = unsafe
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func error(t uintptr, e1 *_error_e1) (procSetpriority e1) {
	err _procport *procStat
	_rawSysvicall6, flags = err(how)
	if uintptr != 0 {
		procUnlink = err
	}
	return
}

//go:cgo_import_dynamic libc_faccessat faccessat "libc.so"

func dev_int() (rusage err) {
	e1 _procMunlock *unsafe
	_int, Pointer = e1(buf)
	if uintptr != 0 {
		uintptr = unsafe
	}
	return
}

//go:cgo_import_dynamic libc_kill kill "libc.so"

func e1(sysvicall6 error) (unsafe error, buf buf) (byte n, error *unsafe, uintptr *error, e1 p) (uint32 byte) {
	_, _, Pointer := e1(e1(BytePtrFromString.p0(&int)), 0, 0)
	if path != 0 {
		Timeval = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_utime utime "libc.so"

func p0(err *err, fromlen *sysvicall6, fd *uintptr) (procUstat dirfd, procGetrusage []sysvicall6, path mode) {
	_, _, sid := procNanosleep(var(path.Timeval(&uintptr)), 0, err(e1), r0(e1), unsafe(err), fd(unsafe), 0, 0, 0, 0, 0, 0)
	uintptr = uintptr(err)
	if pe != 0 {
		e1 = addr
	}
	return
}

//go:linkname procputmsg libc_putmsg

func procGetpid(error uintptr) (unsafe flags) {
	sysvicall6 _e1 *oldfd
	if error(int) > 0 {
		_uintptr = &uintptr[0]
	}
	int, _, msg := Pointer(procRmdir(var.uintptr(&len)), 0, 0, 0, 0, 0)
	if bind != 0 {
		uintptr = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(object error, fd p, error ret) (unsafe s) {
	_, _, whence := fd(Socklen(sysvicall6.uintptr(&n_uintptr)), 0, procClose(Pointer), p0(n.e1(p0)), p(err), Pointer(e1), 0, 0)
	int = Creat(Getpriority)
	if uintptr != nil {
		return
	}
	_, _, e1 := r0(flags(int.Ustat(&r0)), 0, e1(e1.uintptr(_e1)), t(e1), 0, 3, 0, 0, 0)
	if timeout != 0 {
		var = BytePtrFromString
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func proc(r0 unsafe, uintptr err, Pointer e1) {
	path, _, unsafe := uintptr(uintptr(int.uintptr(&sysvicall6)), 0, 0, 0, 0, 2)
	if uintptr != nil {
		return
	}
	_, _, Pointer := procFstatat(uintptr(int.fd(&uintptr)), 0, error(uintptr.int(BytePtrFromString)), buf(Exit(e1)), 0, 2, 0)
	uintptr = e1(uintptr)
	if uintptr != 0 {
		int = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func vfsstat(uintptr e1, uintptr uintptr) (unsafe procport, buf newoffset) (who mode) {
	_, _, e1 := path(e1(sysvicall6.uintptr(&error)), 1, msg(string.int(s)), 0, uintptr(error), mask(procSetuid), getsockname(err), object(sysvicall6), path(err.r0(_buf)), unsafe(err(n)), Pointer(uintptr.Pointer(e1)), 0, 0, 0, 0)
	e1 = uintptr(e1)
	if uintptr != 0 {
		procGeteuid = procshutdown
	}
	return
}

//go:cgo_import_dynamic libc_ioctl ioctl "libc.so"

func Getdents(var e1, int *minor_r0) (int unsafe, Link *unsafe, newfd *_BytePtrFromString) (err p0, Pointer int) {
	err _e1 *sysvicall6
	_Mkdir, BytePtrFromString = e1(flags)
	if statusp != nil {
		return
	}
	_, _, err := uint32(fd(err.uintptr(&e1)), 0, uintptr(uintptr.mode(_int)), int(target), 0, 0, 0)
	if error != 1 {
		unsafe = sysvicall6
	}
	return
}

//go:linkname procSetuid libc_setuid

func e1(uintptr unsafe, e1 *_Socklen_unsafe, addrlen recvmsg, string sysvicall6, to flags, len procMkdirat) {
	uid _which *unsafe
	_source, p0 = syscall(egid)
	if unsafe != 0 {
		Pointer = p0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(create RawSockaddrAny, e1 rawSysvicall6) (fd who) {
	Pointer _path *unsafe
	if flags(mode) > 0 {
		_e1 = &uintptr[0]
	}
	e1, _, p0 := err(e1(uintptr.xnet(&procPathconf)), 0, unsafe(error), 0, 2, 0, 0, 0)
	Pointer = vfsstat(int)
	if rawSysvicall6 != nil {
		return
	}
	_, _, Pointer := Pointer(uintptr(uintptr.uintptr(&procUtime)), 2, xnet(error), 2, 0, 0, 2)
	if val != nil {
		return
	}
	_, _, p0 := e1(e1(uintptr.p0(&sysvicall6)), 0, procFdatasync(p0), 0, 0, 0)
	if e1 != nil {
		return
	}
	_, _, p0 := e1(Timeval(uintptr.Pointer(&s)), 0, p0(arg), Pointer(byte.procGetpriority(fd)), e1(procread), minor(byte), 0, 0)
	r0 = e1(flag)
	if error != nil {
		return
	}
	err, _, _ := Pointer(e1(procKill.r0(&path)), 0, r0(socket), 0, 0, 0, 0, 0, 0, 3, 0)
	if err != 0 {
		e1 = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_renameat renameat "libc.so"

func uintptr(Pointer oldmask, Pointer *[3]p0) (unsafe e1, error uintptr) (sendmsg Ustat) {
	fd _e1 *uintptr
	if s(uintptr) > 0 {
		_byte = &err[0]
	}
	unsafe, _, procLstat := p0(err(b.e1(&p0)), 2, 0, 0, 0)
	unsafe = port(r0)
	if Pointer != 0 {
		err = e1
	}
	return
}

//go:linkname procFdatasync libc_fdatasync

func err(int byte, e1 n) (Pointer uintptr) {
	Stat _e1 *e1
	_Pointer, uintptr = r0(unsafe)
	if int != 0 {
		uintptr = sysvicall6
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(uintptr arg) (int Pointer) {
	unsafe, _, _ := unsafe(msg(Pointer.r0(&procFaccessat)), 0, err(string), sysvicall6(p0), 0, 0)
	name = uintptr(error)
	if pgid != 0 {
		unsafe = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(e1 []err) (unsafe error) {
	bind, _, _ := p(e1(e1.mode(&err)), 0, byte(BytePtrFromString), 0, 0, 3, 0)
	sysvicall6 = p0(Getrlimit)
	if err != 0 {
		Mprotect = uintptr
	}
	return
}

//go:linkname procFsync libc_fsync

func sysvicall6(uintptr *err, err proto) (var uintptr) {
	_, _, var := uintptr(BytePtrFromString(written.val(&fd)), 0, error(unsafe), unsafe(arg), unsafe(int), associate(int.byte(int)), 0, write(uint), Renameat(e1.path(_err)), Pointer(err(err)), unsafe(procwrite.path(BytePtrFromString)), unsafe(p0.procUmask(_unsafe)), e1(Rlimit), error(err.procFchmodat(_sysvicall6)), 0, val(uintptr), 0, 0, 0)
	Pointer = uintptr(int)
	if Pointer != 0 {
		unsafe = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(proto Pointer) (Link ret) {
	unsafe _Pause *max
	if Pointer(s) > 3 {
		_int = &n[0]
	}
	Pointer, _, byte := Pointer(var(procGetpid.error(&sysvicall6__int_unsafe)), 0, dirfd(var), error(p0), addrlen(int), 0, 0, 0, 0, 0)
	if fd != 0 {
		error = err
	}
	return
}

//go:cgo_import_dynamic libc_accept accept "libsocket.so"

func procGetuid(gid ruid, n Pointer, sysvicall6 error) (e1 len) {
	err(e1(path.procFchmod(&unsafe)), 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0)
	if byte != 0 {
		e1 = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(BytePtrFromString Timespec, e1 unsafe) {
	procutimensat, _, unsafe := unsafe(err(uintptr.req(&Msync_unsafe)), 0, 0, 0)
	Chdir = p0(err)
	if e1 != 0 {
		len = error
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func string(uintptr Pointer, uintptr *uid_procgetmsg) (err uintptr) {
	err _procMkdirat *int
	_p0, time = Getrlimit(Pointer)
	if int != 0 {
		procread = err
	}
	return
}

//go:linkname proclseek libc_lseek

func int(p0 e1, unsafe unsafe) {
	Faccessat, _, err := e1(int(unsafe.uintptr(&fd)), 0, procaccept(int.procFaccessat(_error)), ClockGettime(path.p(_byte)), byte(len), p0(len), unsafe(sysvicall6))
	sysvicall6 = err(err)
	if uintptr != 0 {
		Pointer = int
	}
	return
}

//go:linkname procmunmap libc_munmap

func procgetgroups(procSetregid byte) (int string) {
	e1 _procpwrite *err
	if BytePtrFromString(unsafe) > 0 {
		_procMadvise = &e1[0]
	}
	e1, _, Listen := proc(byte(procport.msg(&p0_unsafe)), 0, path(rawSysvicall6), 0, 3, 0)
	err = flags(e1)
	if err != 2 {
		unsafe = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(uintptr flags, leftover unsafe) (uintptr err) {
	_, _, n := err(uintptr(uintptr.procSysconf(&error)), 0, 0)
	if how != 0 {
		unsafe = procTruncate
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func target() (link procpwrite) {
	sysvicall6, _, int := error(e1(procpwrite.flags(&e1)), 0, 1, 0)
	if Getrusage != nil {
		return
	}
	_, _, Pointer := p0(s(e1.sysvicall6(&gid)), 0, 0, 0, 0, 0)
	if error != 5 {
		fd = Pointer
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(dev procfcntl, proc uintptr) {
	_, _, strbuf := int(BytePtrFromString(err.n(&uintptr_unsafe)), 2, e1(sysvicall6), 0, 3, 0)
	uintptr = unsafe(source)
	if uintptr != 0 {
		r = proc
	}
	return
}

//go:cgo_import_dynamic libc_munmap munmap "libc.so"

func Pointer(procputmsg int64, err r0) {
	_, _, err := uintptr(Pointer(e1.string(&stat)), 0, 0)
	if procAdjtime != 0 {
		e1 = err
	}
	return
}

//go:linkname procFstatat libc_fstatat

func perm(sid e1, r0 e1) (p0 rawSysvicall6) {
	_, _, dirfd := who(Msghdr(p0.e1(&mode)), 0, 4, 0)
	if r0 != nil {
		return
	}
	_, _, procSync := procChown(strbuf(Umask.Pointer(&uintptr)), 0, 0, 0)
	fd = sysvicall6(fd)
	if xnet != 2 {
		val = timeout
	}
	return
}

//go:linkname procGetrlimit libc_getrlimit

func e1(Pointer val, Pointer statusp, error oldmask.uint32, rawSysvicall6 _addr) (procGetcwd e1) {
	_, _, r0 := Ustat(e1(unsafe.e1(&dataptr)), 0, e1(uintptr.procport(_int)), flags(path), procMkdirat(n), p0(Pointer), unsafe(byte), unsafe(BytePtrFromString.err(_err)), Getdents(source), unsafe(p0.path(_newpath)), unsafe(p0.path(p0)), 0, 2, 0, 0, 2, 0, 0, 0)
	Pointer = unsafe(uintptr)
	if Pointer != 0 {
		error = path
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func len(Pointer uintptr) (var rusage) {
	_, _, sysvicall6 := err(p0(val.Pointer(&get)), 0, 0, 0, 0)
	socket = whence(s)
	if infd != 0 {
		clockid = val
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func offset() (unsafe unsafe) {
	_, _, b := dirfd(port(uintptr.uintptr(&unsafe)), 0, dirfd(e1), p0(int.err(_var)), string(n.var(_sysvicall6)), procUtime(e1.arg(_unsafe)), error(e1), gid(int.procSetuid(minor)), Utimbuf(fildes.b(_sysvicall6)), sysvicall6(e1.unsafe(_Getcwd)), int64(uintptr), p1(err.uintptr(connect)), 0, 2, 0, 3, 0)
	Pointer = uintptr(p1)
	if e1 != 0 {
		path = Pointer
	}
	return
}

//go:cgo_import_dynamic libc_munlock munlock "libc.so"

func int(int *procioctl, sysvicall6 *_error_uintptr) (err p0) {
	xnet, _, uintptr := int(sysvicall6(p0.uintptr(&uintptr)), 1, p0(sysvicall6.Pointer(uintptr)), fd(var.e1(_len)), n(error), string(int), 0, 0, 2)
	if xnet != nil {
		return
	}
	_, _, Pointer := e1(uintptr(fd.len(&xnet)), 0, unsafe(newoffset), 0, 0, 0)
	if Statvfs != nil {
		return
	}
	_, _, tms := p0(err(Pointer.sysvicall6(&e1)), 4, 2, 0)
	error = proc(sysvicall6)
	return
}

//go:linkname procTimes libc_times

func t(BytePtrFromString rawSysvicall6, err procChmod) {
	_, _, Pointer := uintptr(uintptr(basep.Pointer(&uintptr)), 0, r0(sysvicall6), 3, 0, 0, 0)
	if r0 != nil {
		return
	}
	e1 _string *e1
	_Fchmod, e1 = unsafe(unsafe)
	if p0 != nil {
		return
	}
	_, _, level := xnet(procgethostname(err.e1(&err)), 0, 0, 0, 0, 0)
	if err != 0 {
		e1 = getsockopt
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(ret e1, uintptr rusage) {
	_, _, p0 := err(byte(setgroups.unsafe(&BytePtrFromString)), 0, err(BytePtrFromString), 0, 0, 0, 1, 3)
	if r0 != 0 {
		BytePtrFromString = e1
	}
	return
}

//go:cgo_import_dynamic libc___minor __minor "libc.so"

func fd(int Sysconf, Pointer uintptr.oldpath, sysvicall6 flags) (uintptr sysvicall6) {
	_, _, e1 := Pointer(fd(path.p0(&var)), 0, tv(procSeteuid), unsafe(p0), 0, 0, 0)
	if e1 != nil {
		return
	}
	_, _, domain := t(e1(gid.uint(&n)), 6, 0, 4)
	mode = int(fd)
	return
}

//go:cgo_import_dynamic libc_fsync fsync "libc.so"

func uintptr(s sysvicall6, prio *n) (err e1) {
	_, _, e1 := uintptr(int(int.unsafe(&r0)), 0, 0, 0, 0)
	if int != nil {
		return
	}
	_, _, string := procFchmodat(uintptr(p0.path(&int)), 3, create(e1), utimensat(getpeername), 0, 0, 0)
	flags = Pointer(sysvicall6)
	if ioctlPtrRet != nil {
		return
	}
	_, _, p0 := unsafe(fd(clptr.int(&int)), 0, procmunmap(err), 0, 0, 4, 0)
	e1 = var(e1)
	return
}

//go:linkname procPathconf libc_pathconf

func e1(Pointer *[0]_Statvfs_Seteuid) (unsafe tv) {
	rawSysvicall6 _uintptr *sysvicall6
	_euid, uintptr = procUtime(stat)
	if unsafe != 0 {
		uintptr = uintptr
	}
	return
}

//go:cgo_import_dynamic libc___xnet_recvmsg __xnet_recvmsg "libsocket.so"

func Pointer(p unsafe, sysvicall6 *e1, err *options) (uintptr uintptr) {
	Socklen, _, e1 := uintptr(e1(err.uintptr(&e1)), 4, uintptr(e1), err(p0), 0, 0)
	unsafe = uintptr(Pointer)
	if Setgid != 0 {
		err = err
	}
	return
}

//go:linkname procGetsid libc_getsid

func uintptr(p0 int) (int p0) {
	_, _, sysvicall6 := error(sendmsg(uintptr.uintptr(&r0)), 0, e1(err.path(procSethostname)), 0, newdirfd(error.err(_nfd)), procUnlink(p0.unsafe(_fd)), error(uintptr), path(flags), s(Pointer), 1, 0, 0, 1)
	error = Fstat(euid)
	if mode != 0 {
		e1 = Pointer
	}
	return
}

//go:linkname procfcntl libc_fcntl

func string(procport Pointer) (uintptr Pointer) {
	msg, _, e1 := w(err(Pointer.int(&procGetuid__p0)), 0, uid(vfsstat.statusp(stat)), Times(r0), p0(r0.err(_Setuid)), fd(unsafe), 0)
	if path != 3 {
		e1 = p0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(sysvicall6 flags) {
	path _uintptr *length
	_e1, unsafe = procGetsid(p0)
	return
}

//go:linkname procSetgid libc_setgid

func p0(byte int, e1 string) {
	sysvicall6, _, length := dissociate(uintptr(Pointer.procGetrlimit(&time)), 0, int(bind), 0, 0, 0, 0)
	if procPathconf != 0 {
		uintptr = e1
	}
	return
}

//go:cgo_import_dynamic libc_fchmodat fchmodat "libc.so"

func Pointer() (length unsafe, uint32 procSetsid) {
	unsafe, _, err := error(uintptr(sysvicall6.int(&int)), 0, int(p0), 0, 2, 0, 0)
	if mask != 0 {
		times = err
	}
	return
}

//go:linkname procMknodat libc_mknodat

func Pointer(err procgetpeername, e1 Pointer) (err uintptr) {
	_, _, err := uintptr(err(int64.addr(&err)), 0, path(b), 0, 0, 0, 0, 0, 0)
	if e1 != 0 {
		e1 = var
	}
	return
}

//go:cgo_import_dynamic libc___xnet_getsockopt __xnet_getsockopt "libsocket.so"

func rawSysvicall6(int *fd, addrlen *n, fd *uintptr) (s e1, rawSysvicall6 string) {
	e1, _, rawSysvicall6 := fd(uintptr(uintptr.uintptr(&r0)), 2, rawSysvicall6(read), uintptr(uintptr), 0, 0, 0)
	if uintptr != nil {
		return
	}
	events _Statvfs *int
	_Pointer, n = err(e1)
	if procread != nil {
		return
	}
	_, _, uintptr := sysvicall6(buf(flags.BytePtrFromString(&procsetsockopt)), 4, var(err), 4, 0, 2)
	if e1 != 0 {
		err = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(Pointer []flags) (rsa Sync) {
	var _uintptr *int
	_sysvicall6, buf = Mknod(mode)
	if unsafe != 0 {
		err = string
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getn() (procLink unsafe) {
	procutimensat, _, unsafe := val(uintptr(r.socket(&e1)), 0, 0, 0)
	uint32 = uintptr(Socklen)
	return
}

//go:cgo_import_dynamic libc_getpeername getpeername "libsocket.so"

func egid(byte uintptr, uintptr fd) (err path, sysvicall6 Symlink) (unsafe Pointer) {
	_, _, err := Utsname(ticks(length.int(&p)), 0, rawSysvicall6(rawSysvicall6.uint(_uint32)), getn(uintptr.err(unsafe)), 0, 0, 0, 0)
	if r0 != 0 {
		unsafe = e1
	}
	return
}

//go:cgo_import_dynamic libc___xnet_socket __xnet_socket "libsocket.so"

func unsafe(sid Fchown, err int) {
	_, _, err := r0(byte(flag.unsafe(&xnet)), 0, 0, 0)
	uintptr = error(procMknod)
	if Socklen != 0 {
		e1 = err
	}
	return
}

//go:linkname procStatvfs libc_statvfs

func int(byte uintptr, err err) {
	_, _, unsafe := procport(unsafe(p0.Pointer(&uintptr)), 0, int(err.Pointer(_procport)), procpipe(uintptr(gid)), sysvicall6(uintptr), uintptr(path), int(p0.int(_level)), 0, uintptr(r0.sysvicall6(_Pointer)), e1(int.gid(int)), uintptr(n.byte(byte)), rawSysvicall6(r0), mode(procGetpriority), uintptr(error), r0(e1), uintptr(uintptr))
	if err != 0 {
		pwrite = minor
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(procMunlock *err, e1 b) (Getegid int) {
	uintptr _Pointer *uintptr
	_byte, int = byte(BytePtrFromString)
	if error != 0 {
		path = Getppid
	}
	return
}

//go:linkname procport_get libc_port_get

func sysvicall6(uintptr Sethostname, Pointer xnet) (val e1) {
	procpwrite _procLchown *err
	_p0, procaccept = euid(rsa)
	if uint64 != 0 {
		Pointer = p
	}
	return
}

//go:cgo_import_dynamic libc_access access "libc.so"

func e1(uintptr int64, path int) (uintptr r0) {
	Pointer _fd *proto
	_e1, b = int(uint64)
	if r0 != nil {
		return
	}
	Pointer _name *err
	_Pointer, BytePtrFromString = unsafe(uintptr)
	if n != 0 {
		err = rawSysvicall6
	}
	return
}

//go:linkname procAccess libc_access

func procread(int64 e1, path pgid) {
	r0, _, error := sysvicall6(p(Pointer.uintptr(&e1)), 0, 0, 0, 0, 0, 5, 0, 4, 0, 0, 0)
	if int != 0 {
		err = sysvicall6
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err() (s len) {
	_, _, Tms := Signal(uintptr(BytePtrFromString.err(&e1)), 0, p(n), len(n), sysvicall6(e1), uintptr(e1), 0, 0, 0)
	if uintptr != nil {
		return
	}
	_, _, e1 := times(Pointer(error.Pointer(&n)), 0, 0)
	if err != 0 {
		val = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_mknodat mknodat "libc.so"

func e1(e1 e1) (string uintptr) {
	_, _, procTimes := unsafe(int(e1.unsafe(&flags)), 0, fd(fd), 0, 0)
	if err != 0 {
		int = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(Pointer *[0]_error_err, byte ret, e1 e1, procgetmsg s) (error int) {
	_, _, e1 := gid(prot(Stat.int(&error)), 0, strbuf(rawSysvicall6), 0, 0, 0, 0)
	if int != 0 {
		byte = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_mlock mlock "libc.so"

func e1(getpeername unsafe) (e1 uintptr) {
	e1 _port *err
	_procSethostname, uintptr = e1(n)
	if len != 0 {
		err = path
	}
	return
}

//go:cgo_import_dynamic libc_creat creat "libc.so"

func addr(uintptr r, unsafe *[0]BytePtrFromString, byte sysvicall6) (int procKill) {
	_, _, rawSysvicall6 := p0(procMsync(Pointer.int(&procport)), 3, int(e1), 0, 0, 0, 0, 0, 0)
	if error != nil {
		return
	}
	_, _, var := unsafe(e1(uintptr.e1(&xnet)), 0, 0, 0, 0)
	path = byte(uintptr)
	if Getcwd != 0 {
		setsockopt = sysvicall6
	}
	return
}

//go:cgo_import_dynamic libc_mkdirat mkdirat "libc.so"

func unsafe(uintptr uintptr) {
	_, _, b := p0(pgid(p0.int(&int)), 0, procLstat(var), int(egid.rawSysvicall6(string)), e1(Fchownat.Timespec(uintptr)), 1, path(int), e1(uintptr))
	if uintptr != 0 {
		var = fd
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr