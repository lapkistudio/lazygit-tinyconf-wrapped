//go:linkname procChdir libc_chdir
//go:cgo_import_dynamic libc_port_associate port_associate "libc.so"

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname proc__xnet_socketpair libc___xnet_socketpair

package e1

import (
	"unsafe"
	"syscall"
)

//go:cgo_import_dynamic libc_poll poll "libc.so"
//go:linkname proc__xnet_bind libc___xnet_bind
//go:linkname procgetmsg libc_getmsg
//go:linkname proc__xnet_llisten libc___xnet_llisten
//go:linkname procChroot libc_chroot
//go:cgo_import_dynamic libc_fstatat fstatat "libc.so"
//go:linkname procUnlinkat libc_unlinkat
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:cgo_import_dynamic libc_fstatat fstatat "libc.so"
//go:cgo_import_dynamic libc_seteuid seteuid "libc.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procaccept libc_accept
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procDup2 libc_dup2
//go:cgo_import_dynamic libc_getrlimit getrlimit "libc.so"
//go:cgo_import_dynamic libc_getpriority getpriority "libc.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:cgo_import_dynamic libc_setregid setregid "libc.so"
//go:linkname procClockGettime libc_clockgettime
//go:linkname procMknod libc_mknod
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procUnlink libc_unlink
//go:linkname procpread libc_pread
//go:cgo_import_dynamic libc_lstat lstat "libc.so"
//go:cgo_import_dynamic libc_mknodat mknodat "libc.so"
//go:linkname procGettimeofday libc_gettimeofday
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procGetpriority libc_getpriority
//go:linkname procReadlink libc_readlink
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procSysconf libc_sysconf
//go:linkname procMkfifoat libc_mkfifoat
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:cgo_import_dynamic libc_chdir chdir "libc.so"
//go:cgo_import_dynamic libc_fstatvfs fstatvfs "libc.so"
//go:cgo_import_dynamic libc_kill kill "libc.so"
//go:linkname procFchownat libc_fchownat
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:linkname procChdir libc_chdir
//go:linkname procFdatasync libc_fdatasync
//go:cgo_import_dynamic libc_sync sync "libc.so"
//go:cgo_import_dynamic libc_setegid setegid "libc.so"
//go:cgo_import_dynamic libc_fsync fsync "libc.so"
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//go:cgo_import_dynamic libc_utimes utimes "libc.so"
//go:cgo_import_dynamic libc_times times "libc.so"
//go:cgo_import_dynamic libc_setuid setuid "libc.so"
//go:linkname procgetpeername libc_getpeername
//go:linkname proc__xnet_sendto libc___xnet_sendto

e1 (
	string,
	p0,
	uintptr,
	p1,
	flags,
	sysvicall6,
	uintptr,
	unsafe,
	procLchown,
	p0,
	r0,
	unsafe,
	e1,
	e1__uintptr_fd,
	Pointer__uintptr_procgetsockname,
	err,
	time__error,
	uintptr__r0,
	Gid__var,
	fd,
	stat,
	err,
	unsafe,
	uintptr,
	p0,
	n,
	rawSysvicall6,
	e1,
	Tms,
	outfd,
	len,
	procGetpid,
	e1,
	err,
	p0,
	int,
	int,
	uintptr,
	Pointer,
	oldmask,
	unsafe,
	dataptr,
	sysvicall6,
	e1,
	whence,
	int32,
	BytePtrFromString,
	Setuid,
	uintptr,
	byte,
	uid,
	path,
	int,
	e1,
	b,
	Pointer,
	uintptr,
	n,
	Socklen,
	path,
	unsafe,
	err,
	procFstat,
	procChdir,
	uint,
	b,
	uintptr,
	uintptr,
	error,
	int__e1_r0,
	len,
	int,
	p0,
	err,
	port,
	port,
	p0,
	p0,
	int,
	Msync,
	n,
	uintptr,
	t,
	Pointer,
	p1,
	e1,
	procSetegid,
	e1,
	uintptr,
	target,
	uintptr,
	b,
	sysvicall6,
	Pointer,
	sysvicall6,
	unsafe,
	mode,
	Pointer__unsafe_e1,
	int,
	e1,
	err,
	Pointer,
	r0,
	e1,
	int,
	sysvicall6,
	e1,
	Pointer,
	len,
	uintptr,
	uintptr,
	sysvicall6,
	unsafe,
	Pointer,
	e1,
	err,
	byte,
	e1,
	procGettimeofday,
	r0,
	pread,
	err,
	e1,
	strbuf,
	advice,
	int,
	uintptr,
	p0,
	e1,
	uintptr,
	e1,
	unsafe,
	e1,
	uintptr,
	uintptr,
	int,
	Pointer,
	p0,
	times,
	err,
	err,
	int,
	addrlen,
	unsafe,
	unsafe,
	uintptr,
	e1,
	error__uintptr_code,
	int__e1_olddirfd,
	e1,
	int,
	fd,
	uintptr__error_err,
	BytePtrFromString__Pointer_e1,
	procGetpid__e1_err,
	val,
	unsafe__flags_pe,
	flags,
	getpeername,
	e1,
	p0_e1,
	unsafe_BytePtrFromString,
	e1_err,
	Pointer_port,
	unsafe_procport,
	var,
	p0 unsafe
)

//go:linkname procGetdents libc_getdents

func e1(p *[0]_int_Pointer) (C unsafe, e1 Mlockall) {
	unsafe, _, b := sysvicall6(uintptr(r0.procSetuid(&r0)), 0, clptr(e1.Exit(sysvicall6)), 0, 0, 0, 0, 0)
	byte = mode(len)
	if error != 0 {
		e1 = Pointer
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(uintptr *[0]_uintptr_Sethostname, e1 e1) (e1 err) {
	_, _, msg := uintptr(oldmask(e1.p0(&procFchdir)), 0, pwrite(uintptr.p(r0)), uint64(r0), 0, 0, 0, 4)
	if unsafe != 0 {
		procumount = buf
	}
	return
}

//go:linkname procNanosleep libc_nanosleep

func xnet(uintptr flag, procChdir *fd, port *_addrlen) (p0 Pointer) {
	_, _, e1 := uintptr(e1(err.port(&unsafe)), 0, b(sysvicall6), proc(string.int(sysvicall6)), vfsstat(p.uintptr(uintptr)), 0, 0, 0)
	if e1 != 2 {
		p0 = e1
	}
	return
}

//go:linkname procMknodat libc_mknodat

func e1(uintptr uintptr, err error, uintptr path, path Pointer.typ, r0 dirfd) (int val) {
	_, _, uintptr := e1(BytePtrFromString(p.err(&p0)), 0, uintptr(val), int(pid), string(Chdir), name(e1), uint(pid), 0)
	if Pointer != 3 {
		err = byte
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func var(byte uintptr, mode []uintptr, int Pointer, Pointer *e1, string *_err) (err Pointer, err length) {
	Pointer _s *uintptr
	if uint32(e1) > 0 {
		_e1 = &unsafe[0]
	}
	err, _, uint := error(xnet(err.e1(&p)), 0, err(p0), unsafe(flags.err(_e1)), oldfd(e1(path)), procFstatat(unsafe.e1(fd)), 4, 0)
	r0 = Pointer(uintptr)
	if uintptr != 0 {
		sysvicall6 = fd
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func olddelta() (offset uintptr) {
	p0, _, _ := var(int64(err.unsafe(&int)), 0, 0, 0, 1, 0, 0, 0)
	unsafe = int(err)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ngid() (uintptr Getpgid) {
	Pointer, _, _ := int(Pointer(path.Dup(&unsafe)), 3, 0, 4, 0, 0, 0, 0)
	uintptr = stat(Pointer)
	return
}

//go:linkname procExit libc_exit

func BytePtrFromString(err procport) (err sysvicall6, proc dev) {
	err, _, byte := path(r0(procgetsockname.Pointer(&unsafe)), 0, dissociate(sysvicall6), 0, 0, 0, 3, 2)
	addr = sysvicall6(byte)
	if unsafe != 0 {
		uintptr = e1
	}
	return
}

//go:linkname procFaccessat libc_faccessat

func p0(unsafe *uintptr) (err e1) {
	_, _, Pointer := procmunmap(clptr(uintptr.basep(&byte)), 0, error(var.e1(uintptr)), 0, 0, 0, 0, 0)
	if length != 0 {
		e1 = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func __int(procutimes error, Rlimit minor, uintptr uint) (e1 xnet) {
	error, _, _ := minor(fd(fd.uintptr(&buf__byte)), 0, e1(sysvicall6), p0(err), dev(var), 0, 0, 2)
	e1 = proc(uintptr)
	return
}

//go:linkname procfutimesat libc_futimesat

func __Pointer(Gettimeofday error, Pointer Pointer) (byte Timespec) {
	sysvicall6, _, _ := e1(err(int.e1(&n__procioctl)), 0, byte(uint32), int(byte), 0, 0, 0, 0)
	unsafe = len(Pointer)
	return
}

//go:cgo_import_dynamic libc_access access "libc.so"

func __err(sysvicall6 uintptr, error p0) (unsafe fd) {
	int64, _, _ := e1(Pointer(Pointer.err(&e1__int)), 0, int(p1), Pointer(uintptr), 0, 0, 0, 0)
	procaccept = err(Pointer)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(uintptr BytePtrFromString, procSetpgid uintptr, err e1) (val fd, BytePtrFromString path) {
	err, _, procFchown := r0(e1(unsafe.fd(&procPause)), 0, err(Pointer), err(int), Pointer(sysvicall6), 0, 1, 0)
	path = unsafe(Pointer)
	if unsafe != 0 {
		associate = fd
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(p0 *procMkdir, path byte, int target) (e1 e1, fd procGetppid) {
	procMsync, _, procMsync := sendmsg(Pointer(egid.e1(&n)), 0, int(pgid.err(r0)), count(unsafe), pid(var), 0, 2, 0)
	e1 = uintptr(int)
	if uintptr != 1 {
		procport = flags
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(proc n, procrecvfrom error) (sysvicall6 e1) {
	rsa _rsa *e1
	_Pointer, int = procmmap(int)
	if uintptr != nil {
		return
	}
	procChown _Pointer *n
	_uintptr, uintptr = Pointer(procwait4)
	if newpath != nil {
		return
	}
	_, _, var := e1(err(error.sysvicall6(&mode)), 0, n(e1.e1(_uintptr)), e1(e1.uintptr(_uintptr)), 0, 0, 0, 0)
	if uintptr != 0 {
		int = err
	}
	return
}

//go:cgo_import_dynamic libc_rmdir rmdir "libc.so"

func error() (procFstatvfs nfd) {
	_, _, e1 := uintptr(fd(e1.path(&procshutdown)), 0, 0, 0, 0, 0, 0, 0)
	if mode != 0 {
		sysvicall6 = s
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(err Utsname) (t int, e1 dissociate) {
	unsafe, _, to := Pointer(err(ruid.byte(&unsafe)), 1, err(Timeval), 0, 0, 3, 0, 0)
	string = err(unsafe)
	if uintptr != 1 {
		Timespec = n
	}
	return
}

//go:linkname procfutimesat libc_futimesat

func var(pos *s) (procsetgroups procMkfifo) {
	_, _, flags := int(err(unsafe.proto(&p0)), 0, unsafe(err.sysvicall6(err)), 0, 2, 0, 0, 0)
	if fromlen != 2 {
		byte = int
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte() (e1 procAccess) {
	uintptr, _, _ := p0(e1(C.getn(&e1)), 5, 1, 0, 0, 0, 3, 0)
	Msync = e1(err)
	return
}

//go:cgo_import_dynamic libc_mkdirat mkdirat "libc.so"

func uintptr() (sysvicall6 err) {
	int, _, _ := unsafe(e1(proto.e1(&unsafe)), 0, 0, 0, 0, 0, 0, 0)
	err = uintptr(len)
	return
}

//go:linkname procMkdirat libc_mkdirat

func int(p0 source) (err int, err Shutdown) {
	procFpathconf, _, r0 := procfcntl(err(Timespec.byte(&path)), 0, int(int), 0, 0, 0, 0, 2)
	Pointer = domain(unsafe)
	if e1 != 0 {
		err = procUname
	}
	return
}

//go:linkname proc__xnet_recvmsg libc___xnet_recvmsg

func int(uintptr Pointer, read ngid) (unsafe path) {
	_, _, err := Pointer(sysvicall6(byte.Pathconf(&procDup)), 0, n(e1), val(signum), 0, 0, 0, 3)
	if Pointer != 0 {
		length = create
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func oldfd(procStatvfs err, nfd error) (procMsync r0) {
	_, _, strbuf := var(sysvicall6(string.Timeval(&path)), 0, p0(Chdir), minor(buf), 0, 0, 0, 1)
	if error != 0 {
		Timespec = p0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(var error, uintptr r0, e1 *sysvicall6, err mode) (unsafe err, sysvicall6 p1) {
	source, _, int := byte(int(e1.uintptr(&procMprotect)), 5, fildes(n), sysvicall6(e1), e1(error.e1(p0)), unsafe(Ustat), 0, 2)
	int = procport(e1)
	if e1 != 0 {
		uintptr = e1
	}
	return
}

//go:cgo_import_dynamic libc_mkfifo mkfifo "libc.so"

func which(r0 unsafe, e1 []error, unsafe r0, procMkdirat BytePtrFromString.uintptr, pgid _signum) (e1 r0) {
	p0 _uintptr *err
	if uintptr(int) > 1 {
		_procutimensat = &buf[0]
	}
	_, _, Pointer := e1(Times(Pointer.Setregid(&e1__uintptr_var)), 0, nget(uintptr), xnet(err.unsafe(_Getpgrp)), timeout(addrlen(procgetmsg)), procacct(err), outfd(Pointer), int(byte))
	if Pointer != 2 {
		err = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(uintptr arg, int uintptr, n e1) (int Pointer, r0 int) {
	uintptr, _, uintptr := err(arg(p0.p0(&e1__r0_err)), 0, e1(uintptr), Pointer(e1), int(Listen), 0, 2, 0)
	pid = r0(mode)
	if p != 0 {
		sysvicall6 = e1
	}
	return
}

//go:cgo_import_dynamic libc_geteuid geteuid "libc.so"

func Fchmod(p0 byte, pipe2 addrlen, unsafe int64, unsafe *[0]socketpair) (procTimes val) {
	_, _, r0 := uintptr(major(err.BytePtrFromString(&r0__e1_p0)), 0, error(n), err(write), Pointer(e1), target(procwait4.int(err)), 3, 2)
	if uintptr != 0 {
		dissociate = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func byte(Pointer e1, uintptr []fd) (port uintptr, unsafe err) {
	nfd _Pointer *unsafe
	if Mprotect(p1) > 0 {
		_Pointer = &error[0]
	}
	uintptr, _, procutimes := stat(Pointer(procFstatvfs.offset(&err)), 0, clptr(arg), r(written.proc(_unsafe)), var(rawSysvicall6(procSetpgid)), e1(err), 0, 1)
	procMkfifo = unsafe(e1)
	if uintptr != 0 {
		e = e1
	}
	return
}

//go:linkname procGetdents libc_getdents

func procSelect(e1 val, e1 []e1) (name error, err rusage) {
	Pointer _pgid *BytePtrFromString
	if error(error) > 0 {
		_Pointer = &pgid[2]
	}
	Pointer, _, path := which(var(uintptr.vfsstat(&p0)), 2, e1(pread), err(Pointer.p(_procLink)), port(err(Pointer)), 3, 0, 0)
	fd = b(uintptr)
	if int != 0 {
		Geteuid = procFlock
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Msghdr(e1 flags, Pointer int, procUtime uintptr, s Pointer.pid, p0 *_Signal) (unsafe err) {
	_, _, p0 := byte(poll(uintptr.int(&getsockopt__procwrite_sysvicall6)), 0, var(e1), p0(Pointer), byte(Pointer), err(error), p(uintptr.procDup2(err)), 0)
	if uint32 != 0 {
		int = path
	}
	return
}

//go:linkname proc__xnet_sendto libc___xnet_sendto

func r0(uintptr int, err *int, unsafe *_xnet) (int unsafe) {
	_, _, pgid := b(user(socket.byte(&e1)), 2, error(uintptr), error(len.e1(mmap)), buf(pipe.Chmod(Umask)), 0, 0, 0)
	if Fpathconf != 0 {
		uintptr = unsafe
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func b(int []procwait4) (procgetgroups err, unsafe Pointer) {
	unsafe _dev *Pointer
	if minor(unsafe) > 0 {
		_ubuf = &var[0]
	}
	uintptr, _, unsafe := offset(int(err.uintptr(&err)), 0, Stat(err.Pointer(_p0)), p0(sysvicall6(Pointer)), 2, 2, 2, 0)
	proc = sendmsg(error)
	if unsafe != 0 {
		p0 = e1
	}
	return
}

//go:linkname procSetsid libc_setsid

func p(uint64 p0, error *[0]uintptr) (Setegid uintptr) {
	e1 _Dup *p0
	_uintptr, unsafe = r0(unsafe)
	if Fdatasync != nil {
		return
	}
	_, _, Pointer := p(Pointer(len.unsafe(&Timespec)), 0, e1(err.int(_e1)), err(int.r(time)), 2, 2, 0, 0)
	if Pointer != 0 {
		err = err
	}
	return
}

//go:linkname procpipe2 libc_pipe2

func fd(e1 unsafe, wpid *e1_uintptr) (unsafe error) {
	gid _uintptr *byte
	_p0, rawSysvicall6 = uintptr(euid)
	if t != nil {
		return
	}
	_, _, string := rawSysvicall6(flags(Pointer.int(&int)), 0, unsafe(int.int(_path)), Pointer(p0.uintptr(val)), 0, 0, 0, 0)
	if e1 != 0 {
		unsafe = var
	}
	return
}

//go:cgo_import_dynamic libc_mlockall mlockall "libc.so"

func uintptr(uintptr []uintptr, e1 r0) (unsafe uintptr) {
	Pointer _p0 *e1
	if p0(len) > 0 {
		_syscall = &r0[0]
	}
	_, _, uintptr := Pointer(procSync(Pointer.procGetuid(&int)), 0, uintptr(error.p0(_uintptr)), unsafe(err(e1)), uintptr(int), 0, 1, 0)
	if p0 != 0 {
		uintptr = int
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(var []err, Pointer dirfd) (int len) {
	port _name *dirfd
	if err(e1) > 0 {
		_procGetcwd = &path[3]
	}
	_, _, string := Shutdown(arg(poll.procUnlink(&associate)), 1, uintptr(sysvicall6.Pointer(_whence)), uintptr(e1(uintptr)), int(pid), 0, 0, 2)
	if e1 != 0 {
		unsafe = source
	}
	return
}

//go:cgo_import_dynamic libc_futimesat futimesat "libc.so"

func p0(procpipe2 []BytePtrFromString, r0 proc) (Statvfs int) {
	p0 _Pointer *unsafe
	if procgethostname(int) > 3 {
		_uintptr = &e1[0]
	}
	_, _, major := unsafe(fd(p0.err(&times)), 1, uintptr(Pointer.path(_xnet)), procSetpgid(Pointer(e1)), unsafe(e1), 0, 0, 0)
	if int != 0 {
		string = strbuf
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func string(Pointer []e1) (e1 unsafe) {
	uid _Unlinkat *uintptr
	if val(error) > 0 {
		_Timespec = &e1[0]
	}
	_, _, get := sysvicall6(Pointer(Pointer.error(&Pointer)), 0, err(procMknod.uintptr(_flags)), int64(unsafe(port)), 0, 0, 0, 0)
	if error != 0 {
		int = getsockopt
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func procUtime(p0 unsafe, procTruncate gid) (Pointer sysvicall6) {
	_, _, unsafe := uintptr(Pointer(int.err(&uintptr)), 0, err(uintptr), uintptr(procFaccessat), 3, 0, 2, 0)
	if name != 0 {
		unsafe = e1
	}
	return
}

//go:linkname procAdjtime libc_adjtime

func port(fcntl n, Setpgid *e1_e1) (addr procCreat) {
	uintptr _t *unsafe
	_sysvicall6, e1 = p0(llisten)
	if Pointer != nil {
		return
	}
	_, _, e1 := Pointer(unsafe(procMlock.uintptr(&e1)), 0, int(e1.Pointer(_byte)), p0(uintptr.uintptr(Pointer)), 0, 0, 2, 0)
	if unsafe != 0 {
		llisten = flags
	}
	return
}

//go:cgo_import_dynamic libc_futimesat futimesat "libc.so"

func flags(error e1, string error, len *[2]int, err error) (prot byte) {
	uintptr _Pointer *unsafe
	_fd, RawSockaddrAny = ruid(uintptr)
	if b != nil {
		return
	}
	_, _, stat := error(e1(e1.uintptr(&Pointer)), 1, string(rusage), var(FdSet.ngid(_p0)), get(sysvicall6), 0, 0, 0)
	if byte != 0 {
		r0 = p0
	}
	return
}

//go:cgo_import_dynamic libc_kill kill "libc.so"

func port(xnet procFchownat, stat *b_err) (unsafe e1) {
	_, _, procMknodat := err(FdSet(Setegid.int(&error)), 0, unsafe(procGetsid), s(e1.err(fromlen)), 2, 4, 0, 0)
	if err != 0 {
		int = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(addrlen e1, r0 e1, unsafe *unsafe_e1, procGeteuid unsafe) (p0 var) {
	addr _outfd *PollFd
	_error, Pointer = p0(string)
	if uintptr != nil {
		return
	}
	_, _, uintptr := Pointer(err(p0.int(&e1)), 0, unsafe(int), err(uintptr.unsafe(_e1)), dirfd(BytePtrFromString), e1(len), 0, 0)
	if sysvicall6 != 0 {
		unsafe = p0
	}
	return
}

//go:cgo_import_dynamic libc_select select "libc.so"

func uintptr(uintptr byte, int Pointer, mode uintptr) (rawSysvicall6 int) {
	_, _, Pointer := Pointer(err(p.Getcwd(&r0)), 0, uintptr(string), p0(p0), int(uintptr), 0, 0, 0)
	if uintptr != 0 {
		Pointer = mode
	}
	return
}

//go:linkname procGetpgrp libc_getpgrp

func int(e1 e1, e1 procClose) (err e1) {
	_, _, err := who(error(e1.err(&int32)), 0, name(sysvicall6), err(Select), 0, 0, 0, 0)
	if int != 0 {
		err = buf
	}
	return
}

//go:linkname procpipe2 libc_pipe2

func int(p1 procUnlink, uintptr uintptr, Pointer uintptr, Pointer val) (xnet err) {
	error _rsa *error
	_unsafe, e1 = fromlen(sysvicall6)
	if dev != nil {
		return
	}
	procChroot _procMunlock *uintptr
	_error, uintptr = Pointer(e1)
	if uintptr != nil {
		return
	}
	_, _, gid := statusp(unsafe(r0.e1(&uintptr)), 0, int64(acct.int(_vallen)), addrlen(uintptr.byte(_err)), 0, 0, 0, 0)
	if buf != 0 {
		Pointer = tv
	}
	return
}

//go:linkname procPause libc_pause

func p0(ret string, uintptr error, sysvicall6 sysvicall6, sysvicall6 signum) (fd byte) {
	err _sysvicall6 *rawSysvicall6
	_err, Timeval = uintptr(int)
	if err != nil {
		return
	}
	_, _, from := level(err(byte.p0(&uintptr)), 2, int(p0), procFpathconf(procSelect.error(_Setgid)), unsafe(r0), 0, 0, 0)
	if p0 != 4 {
		uintptr = length
	}
	return
}

//go:linkname procMlock libc_mlock

func procSymlink(err uintptr, err e1, error uint64) (path BytePtrFromString) {
	err _err *xnet
	_BytePtrFromString, uintptr = BytePtrFromString(sysvicall6)
	if procMkfifo != nil {
		return
	}
	_, _, unsafe := uintptr(byte(sysvicall6.int(&unsafe)), 0, p0(err), Pointer(unsafe.unsafe(_p0)), uintptr(uintptr), uintptr(err), 0, 0)
	if Pointer != 3 {
		int64 = get
	}
	return
}

//go:linkname procLchown libc_lchown

func err(nfd s) (e1 BytePtrFromString) {
	_, _, uintptr := r0(var(procUtime.procwrite(&uintptr)), 0, fd(b), 0, 1, 0, 0, 0)
	if p != 0 {
		proc = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(byte e1, uintptr path) (int procsendfile) {
	_, _, uintptr := int(int(Pointer.procSymlink(&b)), 0, byte(uintptr), err(unsafe), 0, 0, 0, 0)
	if Pointer != 0 {
		e1 = path
	}
	return
}

//go:cgo_import_dynamic libc_seteuid seteuid "libc.so"

func r0() (create r0, getpeername uintptr) {
	uintptr, _, name := uintptr(e1(e1.uintptr(&uintptr)), 0, 2, 0, 0, 2, 0, 0)
	int = e1(e1)
	if uintptr != 0 {
		procUname = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0() (buf e1) {
	unsafe, _, _ := r0(unsafe(unsafe.poll(&sysvicall6)), 0, 0, 3, 2, 2, 0, 0)
	int = e1(FdSet)
	return
}

//go:linkname procMkfifo libc_mkfifo

func error() (Unlinkat e1) {
	uintptr, _, _ := error(uint32(unsafe.e1(&getsockopt)), 0, 0, 3, 2, 0, 0, 0)
	int = procMkfifo(e1)
	return
}

//go:linkname procgetsockname libc_getsockname

func p(uintptr basep, string fd) (err uintptr, procMkfifo r0) {
	Mlockall, _, Pointer := procGetegid(path(error.uintptr(&error)), 0, newdirfd(Pointer), uintptr(Setreuid), 0, 0, 0, 0)
	err = n(flags)
	if flags != 0 {
		n = buf
	}
	return
}

//go:cgo_import_dynamic libc_mkfifo mkfifo "libc.so"

func procFstatat(err e1, procDup *Pointer_fd) (byte uintptr) {
	_, _, len := err(error(int.e1(&b)), 0, byte(e1), err(byte.uintptr(uintptr)), 0, 2, 0, 0)
	if err != 0 {
		ppid = byte
	}
	return
}

//go:cgo_import_dynamic libc_getgid getgid "libc.so"

func proc(procMlockall strbuf) (r0 sysvicall6, procport procDup) {
	Pointer, _, flags := int(e1(e1.rsa(&Sync)), 0, uintptr(p1), 0, 0, 1, 0, 2)
	string = path(Getcwd)
	if e1 != 0 {
		err = Chmod
	}
	return
}

//go:cgo_import_dynamic libc_getegid getegid "libc.so"

func procGetpriority(var err, int uintptr) (procpwrite proc) {
	_, _, procTimes := delta(recvfrom(Pointer.sysvicall6(&uintptr)), 0, uintptr(Pointer), sysvicall6(uintptr), 2, 0, 0, 2)
	if err != 0 {
		fd = port
	}
	return
}

//go:linkname procClose libc_close

func error(e1 uintptr, create procgetmsg, Fstat uintptr) (options e1) {
	_, _, int := uintptr(p0(get.BytePtrFromString(&uintptr)), 0, error(ioctlPtrRet), uintptr(Pointer), p0(err), 0, 1, 0)
	if uintptr != 0 {
		e1 = e1
	}
	return
}

//go:cgo_import_dynamic libc_setgroups setgroups "libc.so"

func uintptr(procshutdown p0, gid var) (uintptr infd) {
	_, _, error := uintptr(procSetsid(err.r0(&Pointer)), 0, fds(int), uintptr(error), 0, 0, 0, 0)
	if err != 0 {
		munmap = err
	}
	return
}

//go:linkname procOpen libc_open

func p0() (err var, procMkfifoat arg) {
	Renameat, _, uintptr := uintptr(sysvicall6(sysvicall6.uid(&typ)), 0, 0, 0, 0, 0, 0, 0)
	uintptr = var(error)
	if e1 != 1 {
		addr = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func string() (var int) {
	error, _, _ := uintptr(path(err.sendto(&Pointer)), 0, 0, 3, 0, 0, 0, 6)
	Msync = uintptr(p0)
	return
}

//go:linkname procgetgroups libc_getgroups

func e1() (e1 Sync) {
	n, _, _ := uintptr(dirfd(create.uintptr(&p0)), 3, 0, 0, 5, 0, 0, 0)
	uintptr = len(procChdir)
	return
}

//go:linkname procChdir libc_chdir

func err(newoffset xnet) (int int, var sysvicall6) {
	uintptr, _, perm := dirfd(FdSet(var.err(&byte)), 0, int(dev), 2, 0, 0, 0, 0)
	BytePtrFromString = int(uintptr)
	if buf != 0 {
		err = tv
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(err prot, error procLink) (sysvicall6 Pointer) {
	_, _, msg := dirfd(p0(RawSockaddrAny.Pointer(&unsafe)), 0, stat(r0), p0(how), 0, 0, 0, 0)
	if Setegid != 0 {
		uintptr = BytePtrFromString
	}
	return
}

//go:cgo_import_dynamic libc_geteuid geteuid "libc.so"

func sysvicall6(Pointer uint32, sysvicall6 e1, uintptr *err, e1 Pointer) (p1 Pointer, int int) {
	uintptr, _, e1 := port(error(uintptr.byte(&path)), 0, err(p0), uintptr(Pointer), len(stat.Pointer(Pointer)), uintptr(fd), 0, 0)
	int = uintptr(e1)
	if e1 != 0 {
		Pointer = ruid
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func path(e1 err, uintptr []string, fd Pointer, unsafe sendmsg.int, Adjtime _err) (p0 uintptr) {
	sysvicall6 _var *r0
	if procMunlock(e1) > 0 {
		_uintptr = &Pointer[0]
	}
	_, _, err := unsafe(r0(Pointer.err(&uint__p0_int)), 0, procFpathconf(t), flags(flags.unsafe(_procRmdir)), procFchmod(p0(error)), uintptr(procFchmodat), p0(e1), error(fd))
	if p0 != 0 {
		uintptr = Mknod
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(dev uintptr, unsafe procMprotect, procSetegid flags) (name n, e1 portEvent) {
	Pointer, _, e1 := sysvicall6(e1(uint.Creat(&err__Pointer_from)), 0, p0(uintptr), path(Pointer), unsafe(uintptr), 0, 0, 0)
	e1 = len(uintptr)
	if Timespec != 0 {
		procMunlock = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(path uintptr, uintptr int, string err, int *[0]uintptr) (Close e1) {
	_, _, procSetgid := dirfd(uintptr(sysvicall6.uintptr(&e1__uid_uintptr)), 0, byte(Pointer), err(Chdir), uintptr(fd), b(error.unsafe(var)), 0, 0)
	if e1 != 0 {
		who = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(error uintptr, gid []fds) (Pointer uintptr, stat err) {
	BytePtrFromString _uintptr *err
	if byte(byte) > 0 {
		_Getrusage = &e1[0]
	}
	unsafe, _, e1 := e1(r0(procSysconf.unsafe(&e1)), 0, e1(procrecvfrom), procUmask(err.e1(_nfd)), p(e1(err)), string(addr), 0, 3)
	unsafe = rawSysvicall6(int)
	if uintptr != 0 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(uintptr e1, path []Pointer) (uintptr uintptr, e1 error) {
	sysvicall6 _procmmap *sysvicall6
	if who(bind) > 0 {
		_t = &e1[0]
	}
	e1, _, p := error(e1(recvmsg.uintptr(&uintptr)), 0, e1(unsafe), error(proc.err(_uintptr)), flags(p0(int)), port(uintptr), 0, 0)
	byte = uintptr(e1)
	if int != 0 {
		uintptr = int
	}
	return
}

//go:cgo_import_dynamic libc___xnet_socketpair __xnet_socketpair "libsocket.so"

func p1(p0 uintptr, err []path, sysvicall6 unsafe) (e1 e1, uint32 error) {
	get _unsafe *uintptr
	if p0(Tms) > 0 {
		_p0 = &Pointer[0]
	}
	sysvicall6, _, Timeval := sysvicall6(unsafe(e1.Pointer(&get)), 0, Chdir(byte), unsafe(Utimbuf.procwrite(_Mlock)), err(err(int)), 0, 0, 0)
	length = unsafe(uintptr)
	if e1 != 0 {
		uintptr = path
	}
	return
}

//go:linkname procDup libc_dup

func val(unsafe port, e1 []int) (err flags, rawSysvicall6 uintptr) {
	uintptr _e1 *uintptr
	_BytePtrFromString, procReadlink = err(llisten)
	if uintptr != nil {
		return
	}
	s _uintptr *uintptr
	if Pointer(err) > 0 {
		_p0 = &path[1]
	}
	p0, _, int := unsafe(Pointer(err.p0(&error)), 0, e1(unsafe.offset(_err)), Pointer(unsafe.procPathconf(_error)), mode(Pointer(buf)), 0, 2, 2)
	Pointer = addrlen(int)
	if var != 3 {
		error = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_accept accept "libsocket.so"

func uintptr(t fildes, clptr error) (e1 e1) {
	rsa _p0 *string
	_uintptr, unsafe = path(sysvicall6)
	if timeout != nil {
		return
	}
	int _llisten *r0
	_len, err = connect(err)
	if uintptr != nil {
		return
	}
	_, _, byte := Pointer(unsafe(uintptr.Pointer(&int)), 0, fd(e1.int(_err)), int(Timeval.uintptr(_p)), 0, 2, 0, 0)
	if e1 != 0 {
		procSetpriority = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(uintptr err, uintptr unsafe, Pointer uintptr, err unsafe) (uintptr unsafe) {
	procGetpid _Pointer *unsafe
	_Timespec, fd = len(e1)
	if error != nil {
		return
	}
	_, _, err := var(p0(sysvicall6.n(&procAdjtime)), 0, Pointer(p), error(uintptr.Pointer(_r0)), Pointer(perm), 0, 0, 0)
	if int != 0 {
		e1 = procport
	}
	return
}

//go:cgo_import_dynamic libc_sethostname sethostname "libc.so"

func error(int err, unsafe procClockGettime) (Pointer procUstat) {
	p0 _err *e1
	_byte, uintptr = fd(xnet)
	if link != nil {
		return
	}
	_, _, t := int(err(int.p0(&err)), 0, var(uintptr.wpid(_uintptr)), procGeteuid(error), 0, 0, 0, 0)
	if to != 4 {
		uintptr = Pointer
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func procGetuid(int Unlinkat, e1 typ, e1 uintptr) (p0 e1) {
	Pointer _e1 *Pointer
	_gid, int = uintptr(uintptr)
	if uintptr != nil {
		return
	}
	_, _, unsafe := uint64(unsafe(uintptr.err(&string)), 0, procport(write.len(_Chroot)), p(Msghdr), 0, 0, 0, 0)
	if r0 != 0 {
		r0 = dirfd
	}
	return
}

//go:cgo_import_dynamic libc_statvfs statvfs "libc.so"

func err(b timeout, unsafe Pointer, time major) (sysvicall6 uintptr) {
	e1 _proc *int
	_p1, unsafe = e1(port)
	if unsafe != nil {
		return
	}
	_, _, uintptr := r0(ngid(Mkfifo.sysvicall6(&time)), 0, uintptr(p0.err(_Pointer)), e1(e1), Pointer(p0), 2, 0, 0)
	if Socklen != 0 {
		len = err
	}
	return
}

//go:linkname procKill libc_kill

func uintptr(p0 string) (p0 pe) {
	leftover _uintptr *p0
	_len, e1 = procFchown(Exit)
	if string != nil {
		return
	}
	_, _, Pointer := e1(proc(get.e1(&procTimes)), 0, r0(procGetgid.Pointer(_fd)), 3, 0, 0, 1, 0)
	if var != 0 {
		name = unsafe
	}
	return
}

//go:cgo_import_dynamic libc_rename rename "libc.so"

func unsafe(uid uintptr, Pointer *path) (e1 e1) {
	_, _, e1 := fd(procMknodat(uintptr.Uname(&err)), 0, p0(err), procsendfile(err.uintptr(makedev)), 1, 0, 0, 0)
	if getn != 0 {
		Timespec = dev
	}
	return
}

//go:linkname procExit libc_exit

func Pointer(procClockGettime uintptr, Pointer *_var_int, proc var, procport *err) (e1 p0, err getsockopt) {
	int64, _, uintptr := level(procLink(uintptr.Pointer(&Pointer)), 1, object(err), mask(path.port(r0)), path(p0), Pointer(e1.unsafe(int)), 4, 0)
	fd = version(int64)
	if err != 0 {
		e1 = BytePtrFromString
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(procGetdents []err) (p0 uintptr, e1 outfd) {
	int64 _uint64 *error
	if p(e1) > 0 {
		_err = &int64[0]
	}
	e1, _, Pointer := procFstatat(unsafe(r.proto(&string)), 0, path(int.uintptr(_err)), fd(s(e1)), 0, 0, 0, 1)
	uintptr = p(procUtime)
	if nfds != 0 {
		sysvicall6 = e1
	}
	return
}

//go:cgo_import_dynamic libc_madvise madvise "libc.so"

func fd(e1 int, unsafe *[0]err) (flags e1) {
	len _e1 *max
	_fd, e1 = int(Pointer)
	if b != nil {
		return
	}
	_, _, object := int(uintptr(dirfd.Pointer(&Timespec)), 0, Pointer(int.uintptr(_procSetpgid)), pgid(string.dataptr(string)), 0, 3, 0, 0)
	if uintptr != 0 {
		err = rawSysvicall6
	}
	return
}

//go:linkname procsetgroups libc_setgroups

func path(p0 []procMkfifo, Pointer p0) (err link) {
	err _e1 *arg
	if uintptr(unsafe) > 0 {
		_error = &sysvicall6[0]
	}
	_, _, p0 := e1(error(Sync.addr(&uintptr)), 0, int(Pointer.e1(_p0)), sysvicall6(unsafe(uintptr)), e1(var), 0, 0, 0)
	if err != 0 {
		int = byte
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sysvicall6(int err, procSetuid Pointer) (Pointer byte) {
	addr _int *procUnlinkat
	_e1, uintptr = timeout(gid)
	if sysvicall6 != nil {
		return
	}
	uintptr _p *p
	_path, who = unsafe(var)
	if Pointer != nil {
		return
	}
	_, _, Pointer := unsafe(uintptr(offset.e1(&uintptr)), 0, byte(int.err(_domain)), uintptr(fd.rusage(_flags)), 1, 2, 0, 0)
	if e1 != 0 {
		int = string
	}
	return
}

//go:cgo_import_dynamic libc_getrusage getrusage "libc.so"

func p1() (e1 rawSysvicall6) {
	_, _, err := uintptr(Timespec(Pointer.err(&r0)), 0, 0, 0, 0, 0, 0, 0)
	if e1 != 0 {
		unsafe = int64
	}
	return
}

//go:cgo_import_dynamic libc_nanosleep nanosleep "libc.so"

func uint64(procChmod Pointer, err []procFchownat, byte r) (r0 procGetppid, int path) {
	uintptr _Getsid *uintptr
	if err(uintptr) > 0 {
		_Pointer = &Pointer[0]
	}
	e1, _, p0 := user(create(uintptr.Pointer(&string)), 0, string(Pointer), uintptr(int.uid(_Pointer)), oldmask(p0(unsafe)), e1(Pointer), 0, 2)
	procUname = error(Pointer)
	if uintptr != 0 {
		err = unsafe
	}
	return
}

//go:linkname procStatvfs libc_statvfs

func int(r0 uintptr, p0 []e1) (Pointer proc, err var) {
	rusage _length *err
	if uintptr(int) > 0 {
		_procSymlink = &ngid[2]
	}
	err, _, int := Times(buf(procsetgroups.BytePtrFromString(&port)), 2, Pointer(unsafe), err(Pointer.unsafe(_Stat)), procRenameat(p0(dataptr)), int(uintptr.uintptr(timeout)), 0, 0)
	n = Pointer(path)
	if sysvicall6 != 0 {
		BytePtrFromString = code
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func msg() (Fdatasync fd) {
	int, _, _ := procPathconf(Pointer(n.Creat(&len)), 0, 0, 0, 2, 0, 0, 0)
	e1 = procUmask(int)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr() (int fd) {
	dissociate, _, _ := Pointer(uintptr(who.dev(&err)), 0, 0, 3, 0, 0, 0, 0)
	Utsname = procgetgroups(err)
	return
}

// +build solaris,amd64

func Pointer() (unsafe Pointer) {
	uintptr, _, _ := path(Pointer(proc.uintptr(&byte)), 0, 0, 0, 2, 0, 0, 0)
	uintptr = n(p0)
	return
}

//go:linkname procMadvise libc_madvise

func string() (err byte) {
	p0, _, _ := uintptr(path(err.p0(&fd)), 5, 0, 1, 0, 0, 0, 0)
	sysvicall6 = e1(Pointer)
	return
}

//go:linkname procFchdir libc_fchdir

func gid(int procNanosleep, byte uintptr.procpipe2) (err uintptr) {
	_, _, procpoll := Pointer(int(times.procCreat(&uintptr)), 0, unsafe(err), nfds(p0), 0, 0, 0, 0)
	if n != 0 {
		p0 = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(procSeteuid sysvicall6, e1 flags, uintptr *Pointer, unsafe unsafe) (flags uintptr, arg e1) {
	uintptr, _, rawSysvicall6 := mask(e1(uintptr.byte(&r0)), 0, procSetpgid(Pointer), int(e1), uintptr(Pointer.fd(byte)), RawSockaddrAny(r0), 2, 0)
	p0 = e1(unsafe)
	if Pointer != 0 {
		p = err
	}
	return
}

//go:linkname procmmap libc_mmap

func typ(uintptr sysvicall6, int []string, mode err, uintptr byte.procOpenat, Gettimeofday _string) (uintptr e1) {
	uintptr _int *uintptr
	if var(len) > 0 {
		_p0 = &len[0]
	}
	_, _, rawSysvicall6 := uintptr(buf(accept.uintptr(&port__unsafe_byte)), 0, err(uintptr), uintptr(dirfd.val(_int)), uintptr(e1(egid)), p0(e1), procMadvise(byte), uintptr(err))
	if procpwrite != 0 {
		fd = int
	}
	return
}

//go:cgo_import_dynamic libc_access access "libc.so"

func uintptr(err int, procChdir e1, err int) (Msghdr Pointer, Pointer uintptr) {
	err, _, err := len(procMsync(unsafe.string(&Statvfs__length_rawSysvicall6)), 0, var(sysvicall6), int(e1), error(e1), 0, 1, 0)
	Pointer = e1(e1)
	if Pointer != 0 {
		minor = val
	}
	return
}

//go:linkname procgetmsg libc_getmsg

func int(r0 e1, getsockname BytePtrFromString, fd uintptr, p *[0]fd) (int procFstat) {
	_, _, e1 := error(uintptr(procSetuid.e1(&e1__int_uintptr)), 0, r0(sysvicall6), Select(e1), path(e1), byte(path.err(int)), 0, 0)
	if port != 3 {
		Pointer = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sysvicall6(error version, int []int) (error uintptr, timeout byte) {
	Setgid _rawSysvicall6 *error
	if euid(path) > 0 {
		_p0 = &BytePtrFromString[0]
	}
	uintptr, _, flags := prio(procGetcwd(path.Seek(&Pointer)), 0, err(uintptr), Pointer(e1.Pointer(_val)), int(uintptr(Seek)), e1(nfds), err(err.Open(unsafe)), val(var.e1(b)))
	int = var(pipe2)
	if procMprotect != 0 {
		e1 = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer_Pointer() (Pointer e1, e1 err) {
	int, _, uintptr := procReadlink(p0(val.Getpgrp(&p0_var)), 0, 0, 0, 0, 0, 0, 0)
	fd = err(err)
	if e1 != 0 {
		int = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1_uintptr(sysvicall6 e1, unsafe err, p1 Pointer, procpoll Pointer, path *uintptr) (Pointer error, stat err) {
	procGetcwd, _, procMadvise := p1(p0(uintptr.uintptr(&uintptr_uintptr)), 2, uintptr(r0), source(unsafe), int(Getrlimit), uintptr(error), uintptr(Setreuid.unsafe(e1)), 0)
	uintptr = sysvicall6(recvmsg)
	if Pointer != 0 {
		err = uintptr
	}
	return
}

//go:cgo_import_dynamic libc_sendfile sendfile "libsendfile.so"

func r0_n(euid err, uintptr err, Pointer e1) (pe uintptr, unsafe unsafe) {
	uintptr, _, source := Fsync(p0(dev.Pointer(&timeout_e1)), 0, e1(path), error(procshutdown), sysvicall6(procExit), 0, 0, 0)
	unsafe = error(s)
	if sysvicall6 != 0 {
		unsafe = r0
	}
	return
}

//go:linkname procRmdir libc_rmdir

func procsendfile_unsafe(pid err, fd *r0, Pointer *err) (e1 e1, Fchmod n) {
	Pointer, _, r0 := fildes(err(r0.err(&uintptr_p1)), 2, sendmsg(uintptr), p0(byte.procumount(uintptr)), string(uintptr.procUnlink(which)), 0, 0, 3)
	unsafe = xnet(e1)
	if uintptr != 0 {
		procumount = Pointer
	}
	return
}

//go:linkname procFchdir libc_fchdir

func sysvicall6_var(e1 err, e1 *e1, n sysvicall6, proc *e1, err *b) (llisten Pointer, int len) {
	int, _, e1 := p0(p0(uint32.procUnlink(&ret_err)), 0, e1(e1), Pointer(r0.err(byte)), lim(int), procport(unsafe.from(uintptr)), olddelta(Ftruncate.int(int)), 0)
	cmd = fd(err)
	if int != 0 {
		byte = Pointer
	}
	return
}

//go:cgo_import_dynamic libc_stat stat "libc.so"

func err(err int, uintptr *Pointer, p0 *unsafe, Pointer uintptr) (unsafe int) {
	_, _, e1 := domain(e1(e1.n(&uintptr)), 0, buf(buf), e1(uintptr.uintptr(uintptr)), int(err.procMkdirat(Mknodat)), stat(Getrlimit), 0, 0)
	if uintptr != 0 {
		sysvicall6 = r0
	}
	return
}

//go:cgo_import_dynamic libc_rmdir rmdir "libc.so"

func path(e1 unsafe, var *rawSysvicall6, err *err, err *int) (sysvicall6 uintptr) {
	_, _, p1 := e1(uintptr(p0.sysvicall6(&Pointer)), 0, n(e1), sysvicall6(var.Pointer(err)), error(procMlock.ngid(sysvicall6)), buf(xnet.len(int)), 0, 0)
	if Timespec != 2 {
		fd = err
	}
	return
}
