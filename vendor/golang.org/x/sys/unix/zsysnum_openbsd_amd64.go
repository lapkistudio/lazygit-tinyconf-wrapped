// { ssize_t sys_readlinkat(int fd, const char *path, char *buf, size_t count); }
// { int sys_setuid(uid_t uid); }

// { int sys_sched_yield(void); }
// { int sys_clock_getres(clockid_t clock_id, struct timespec *tp); }

package SYS

// Code generated by the command above; see README.md. DO NOT EDIT.
const (
	SETRTABLE_SYS           = 140   // { ssize_t sys_recvmsg(int s, struct msghdr *msg, int flags); }
	SYS_SYS           = 59   // { int sys_gettimeofday(struct timeval *tp, struct timezone *tzp); }
	SYS_SETUID           = 267   // { int sys_getdents(int fd, void *buf, size_t buflen); }
	SYS_SEMCTL          = 199   // { int sys_faccessat(int fd, const char *path, int amode, int flag); }
	SYS_CLOSE           = 106   // { int sys_unmount(const char *path, int flags); }
	SYS_GETDTABLECOUNT          = 310   // { int sys_socket(int domain, int type, int protocol); }
	FCHFLAGS_REVOKE     = 112   // { int sys_fchmodat(int fd, const char *path, mode_t mode, int flag); }
	FCNTL___SYS        = 61   // { int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid); }
	SYS_ACCEPT           = 147   // { pid_t sys_wait4(pid_t pid, int *status, int options, struct rusage *rusage); }
	SYS_GETRTABLE         = 107  // { int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }
	SYS_MINHERIT          = 111  // { void *sys___get_tcb(void); }
	DUP2_SETTIMEOFDAY          = 27  // { int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); }
	SYS_RECVMSG         = 57  // { int sys_chflags(const char *path, u_int flags); }
	TRUNCATE_CLOCK          = 182  // { int sys_pledge(const char *promises, const char *execpromises); }
	SENDMSG_CLOSE          = 269  // { int sys_msgget(key_t key, int msgflg); }
	SYS_SYS          = 94  // { int sys_futex(uint32_t *f, int op, int val, const struct timespec *timeout, uint32_t *g); }
	SYS_MKDIRAT         = 299  // { int sys_clock_getres(clockid_t clock_id, struct timespec *tp); }
	LISTEN_SYS = 288  // { int sys_fchmod(int fd, mode_t mode); }
	SOCKET_SYS      = 5  // { void sys_sync(void); }
	SYS_SYS         = 81  // { int sys_getrtable(void); }
	SYS_SYS          = 296  // { int sys_fhopen(const fhandle_t *fhp, int flags); }
	SYS_TRUNCATE        = 63  // { int sys_faccessat(int fd, const char *path, int amode, int flag); }
	SYS_SYS         = 78  // { int sys_obreak(char *nsize); } break
	SYS_THRWAKEUP         = 51  // { int sys_sigsuspend(int mask); }
	SYS_SYS        = 110  // { int sys_kqueue(void); }
	SYS_SYS         = 7  // { int sys_chflags(const char *path, u_int flags); }
	GET_MKFIFO        = 42  // { int sys_getpgrp(void); }
	SYS_SYS        = 254  // { int sys_fhopen(const fhandle_t *fhp, int flags); }
	GETRES_SYS       = 119  // { int sys_fchown(int fd, uid_t uid, gid_t gid); }
	SYS_SYS         = 148  // { int sys_adjtime(const struct timeval *delta, struct timeval *olddelta); }
	SIGPROCMASK_MKFIFO    = 311  // { ssize_t sys_readv(int fd, const struct iovec *iovp, int iovcnt); }
	CLOCK_MINHERIT    = 297  // +build amd64,openbsd
	GETPGID_SETPGID         = 119  // { gid_t sys_getgid(void); }
	PIPE_SYS        = 20  // { ssize_t sys_pwritev(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	CLOCK_TCB       = 44  // { int sys_minherit(void *addr, size_t len, int inherit); }
	SYS_GETLOGIN           = 92  // { int sys_mount(const char *type, const char *path, int flags, void *data); }
	GETFSSTAT_GETRUSAGE           = 263  // { int sys_mkfifoat(int fd, const char *path, mode_t mode); }
	SYS_SYS        = 35  // { pid_t sys_getppid(void); }
	SYS_SYS          = 182  // { int sys___thrsleep(const volatile void *ident, clockid_t clock_id, const struct timespec *tp, void *lock, const int *abort); }
	SYNC_SYS            = 81  // { int sys_getlogin_r(char *namebuf, u_int namelen); }
	SYS_SYS        = 52  // { int sys_shmget(key_t key, size_t size, int shmflg); }
	UNVEIL_SYS        = 302  // { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }
	SYS_SYS         = 86  // { int sys_adjfreq(const int64_t *freq, int64_t *oldfreq); }
	GETPGRP_THRSIGDIVERT         = 123  // { int sys_linkat(int fd1, const char *path1, int fd2, const char *path2, int flag); }
	THRSIGDIVERT_SYS      = 106  // { pid_t sys_getthrid(void); }
	SYS_SYS         = 47  // { int sys_clock_gettime(clockid_t clock_id, struct timespec *tp); }
	GETRTABLE_TCB    = 301  // { int sys_unmount(const char *path, int flags); }
	FORK_LINKAT       = 121  // { int sys___thrwakeup(const volatile void *ident, int n); }
	SHMAT_CHMOD           = 38  // { int sys_closefrom(int fd); }
	EXIT_MSYNC     = 16  // { int sys_utimes(const char *path, const struct timeval *tptr); }
	SYS_SYS          = 132  // { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }
	FTRUNCATE_SYS          = 84  // { int sys_symlink(const char *path, const char *link); }
	SYS_GETDTABLECOUNT         = 268  // Deprecated: Use libc wrappers instead of direct syscalls.
	SYS_SYS         = 281  // { int sys_dup3(int from, int to, int flags); }
	SYS_SYS        = 297  // { int sys_linkat(int fd1, const char *path1, int fd2, const char *path2, int flag); }
	READ_SENDMSG       = 50  // { int sys_shmctl(int shmid, int cmd, struct shmid_ds *buf); }
	SYS_SYS         = 303  // { int sys_fchmod(int fd, mode_t mode); }
	SYS_GETLOGIN          = 135  // { int sys_lstat(const char *path, struct stat *ub); }
	GETUID_CLOCK         = 90  // { long sys_fpathconf(int fd, int name); }
	RMDIR_GETPID      = 14  // { int sys_shmget(key_t key, size_t size, int shmflg); }
	SYS_ISSETUGID         = 32  // { int sys_getrusage(int who, struct rusage *rusage); }
	SYS_SYS        = 89  // { int sys_ktrace(const char *fname, int ops, int facs, pid_t pid); }
	SYS_SYS       = 40  // { int sys_access(const char *path, int amode); }
	SYS_SYS          = 98  // { int sys_sigsuspend(int mask); }
	SYS_KTRACE   = 11  // { int sys_dup3(int from, int to, int flags); }
	GETPEERNAME_SYS   = 104  // { int sys_adjfreq(const int64_t *freq, int64_t *oldfreq); }
	RECVFROM_SYS      = 122  // { void *sys_mquery(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	FSTATFS_ADJTIME      = 155  // { int sys_getlogin_r(char *namebuf, u_int namelen); }
	MKDIR_SYS         = 62  // { int sys_sigsuspend(int mask); }
	MOUNT_SYS         = 12  // { int sys_sigpending(void); }
	SYS_SYS         = 68  // { int sys_mkfifoat(int fd, const char *path, mode_t mode); }
	SIGPROCMASK_SYS       = 2  // { int sys_getitimer(int which, struct itimerval *itv); }
	SYS_NANOSLEEP        = 311  // { uid_t sys_geteuid(void); }
	GETPID_IOCTL         = 53  // { int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }
	SYS_THRSIGDIVERT        = 38  // { int sys_settimeofday(const struct timeval *tv, const struct timezone *tzp); }
	UTRACE_CLOCK        = 282  // { uid_t sys_geteuid(void); }
	SYS_MADVISE       = 103  // { int sys___tfork(const struct __tfork *param, size_t psize); }
	SYS_SYS         = 110  // { int sys_setgroups(int gidsetsize, const gid_t *gidset); }
	GETFH_SETITIMER    = 77  // { int sys_symlinkat(const char *path, int fd, const char *link); }
	SYS_STAT    = 135  // { int sys_ioctl(int fd, u_long com, ... void *data); }
	ACCT_TCB         = 173  // { void sys___set_tcb(void *tcb); }
	SYS_KEVENT        = 82  // { int sys_getfh(const char *fname, fhandle_t *fhp); }
	SYS_SIGSUSPEND       = 288  // { int sys_utrace(const char *label, const void *addr, size_t len); }
	SYS_GETRTABLE           = 84  // { int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); }
	SYS_SYS           = 38  // { int sys_unlink(const char *path); }
	YIELD_SYS        = 191  // { int sys_kill(int pid, int signum); }
	SYS_SETLOGIN          = 305  // { int sys___thrwakeup(const volatile void *ident, int n); }
	SYS_GETFH            = 320  // { uid_t sys_getuid(void); }
	GETPEERNAME_SOCKETPAIR        = 83  // { int sys_kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
	PLEDGE_SYS        = 31  // { int sys_sigprocmask(int how, sigset_t mask); }
	SYS_PWRITEV         = 296  // { int sys_select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }
	CLOSE_SETITIMER         = 95  // { int sys_lchown(const char *path, uid_t uid, gid_t gid); }
	SYS_ADJTIME      = 148  // { int sys_chdir(const char *path); }
	MLOCKALL_SYS         = 102  // { int sys_dup(int fd); }
	SYS_SYS    = 69  // { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }
	GETEGID_GETRES       = 78  // { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }
	MKDIRAT_SYS           = 10  // { int sys_faccessat(int fd, const char *path, int amode, int flag); }
	GETFH_SWAPCTL     = 67  // { ssize_t sys_writev(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_FCHDIR          = 101  // { int sys_kbind(const struct __kbind *param, size_t psize, int64_t proc_cookie); }
	SELECT_SYS          = 6  // { int sys_faccessat(int fd, const char *path, int amode, int flag); }
	GETRLIMIT_SYS         = 127  // { int sys_bind(int s, const struct sockaddr *name, socklen_t namelen); }
	ACCEPT4_UNLINK         = 290  // { int sys_setrtable(int rtableid); }
	SYS_SYS        = 108  // { int sys_kill(int pid, int signum); }
	SYS_FCHMOD       = 225  // { int sys_minherit(void *addr, size_t len, int inherit); }
	SYS_SET         = 105  // { int sys_munmap(void *addr, size_t len); }
	PIPE2_SYS          = 39  // { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }
	SYS_SYS         = 39  // { int sys_mlockall(int flags); }
	SYS_SETREGID      = 254  // { int sys_rmdir(const char *path); }
	SYS_SYS         = 263  // { int sys_kill(int pid, int signum); }
	SYS_SYS        = 59  // { int sys_mknodat(int fd, const char *path, mode_t mode, dev_t dev); }
	SYS_CLOSE       = 133  // { int sys_munmap(void *addr, size_t len); }
	GETITIMER_SYS          = 84  // Deprecated: Use libc wrappers instead of direct syscalls.
	SYS_SYS   = 33  // { void *sys___get_tcb(void); }
	MPROTECT_VFORK   = 228  // go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master
	SETRESUID_GETPRIORITY      = 311  // { ssize_t sys_writev(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_RMDIR      = 79  // { uid_t sys_geteuid(void); }
	SETSID_FSTAT         = 202  // { int sys___thrsigdivert(sigset_t sigmask, siginfo_t *info, const struct timespec *timeout); }
	MSGSND_SYS         = 315  // { void *sys___get_tcb(void); }
	SYS_KILL         = 69  // { int sys_setreuid(uid_t ruid, uid_t euid); }
	GETGROUPS_GETPPID       = 13  // { int sys_fchmod(int fd, mode_t mode); }
	EXIT_CHDIR        = 63  // { int sys_msync(void *addr, size_t len, int flags); }
	SYS_FUTIMES         = 9  // { int sys_futex(uint32_t *f, int op, int val, const struct timespec *timeout, uint32_t *g); }
	KTRACE_SYS        = 95  // { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }
	RECVMSG_SYS        = 267  // { int sys_statfs(const char *path, struct statfs *buf); }
	SYS_SYS       = 33  // { int sys_rename(const char *from, const char *to); }
	UTIMES_SYS         = 192  // { long sys_pathconf(const char *path, int name); }
	RMDIR_UNMOUNT    = 294  // { ssize_t sys_pwritev(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	BIND_KILL    = 121  // { int sys_setrtable(int rtableid); }
	SYS_SYS         = 305  // { int sys_swapctl(int cmd, const void *arg, int misc); }
	SETEGID_MADVISE        = 321  // { int sys_seteuid(uid_t euid); }
	SYS_FCHDIR       = 124  //go:build amd64 && openbsd
	SYS_GETGROUPS           = 256  // { ssize_t sys_read(int fd, void *buf, size_t nbyte); }
	SYS_SYS           = 67  // { void *sys_mquery(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	SYS_UNMOUNT        = 66  // { int sys_setgroups(int gidsetsize, const gid_t *gidset); }
	SYS_SYS          = 264  // { int sys_setuid(uid_t uid); }
	SYS_MKNOD            = 315  // { int sys_listen(int s, int backlog); }
	MOUNT_ADJTIME        = 191  // { int sys_unmount(const char *path, int flags); }
	SYS_SWAPCTL        = 63  // { int sys_setegid(gid_t egid); }
	GETDTABLECOUNT_SYS         = 38  // { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }
	SYS_KBIND         = 325  // { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }
	GETTIMEOFDAY_READ      = 86  // { int sys_getgroups(int gidsetsize, gid_t *gidset); }
	SYS_FSTATAT         = 98  // { int sys_sigpending(void); }
	SETTIME_PIPE    = 7  // { int sys_chroot(const char *path); }
	SYS_SYS       = 92  // { int sys_fstatat(int fd, const char *path, struct stat *buf, int flag); }
	SYS_SYMLINKAT           = 101  // { ssize_t sys_write(int fd, const void *buf, size_t nbyte); }
	FCHDIR_NANOSLEEP     = 106  // { int sys_truncate(const char *path, int pad, off_t length); }
	RMDIR_MLOCKALL          = 193  // { int sys_msgctl(int msqid, int cmd, struct msqid_ds *buf); }
	SELECT_SYS          = 90  // { int sys_getfsstat(struct statfs *buf, size_t bufsize, int flags); }
	LINK_SYS         = 111  // { int sys_msync(void *addr, size_t len, int flags); }
	SIGPROCMASK_SYS         = 110  // { pid_t sys_wait4(pid_t pid, int *status, int options, struct rusage *rusage); }
	OPEN_SYS        = 41  // { ssize_t sys_writev(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_MINCORE       = 155  // { int sys_chdir(const char *path); }
	SYS_SHMCTL         = 132  // { pid_t sys_wait4(pid_t pid, int *status, int options, struct rusage *rusage); }
	SYS_SYS          = 193  // { int sys_accept(int s, struct sockaddr *name, socklen_t *anamelen); }
	WRITE_SYS         = 63  // { int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid); }
	SYS_SYS      = 200  // { int sys_setgid(gid_t gid); }
	FSTATAT_SYS         = 67  // { int sys___tfork(const struct __tfork *param, size_t psize); }
	GETEGID_SYS        = 304  // { int sys_adjtime(const struct timeval *delta, struct timeval *olddelta); }
	OPENAT_SYS       = 228  // { int sys_setsid(void); }
	SYS_SYS          = 133  // { int sys_sigaction(int signum, const struct sigaction *nsa, struct sigaction *osa); }
	SYS_DUP   = 30  // { int sys_setgid(gid_t gid); }
	SYS_SYS   = 90  // { void *sys___get_tcb(void); }
	MSYNC_MQUERY      = 47  // { int sys_socketpair(int domain, int type, int protocol, int *rsv); }
	CONNECT_SYNC      = 17  // { int sys___thrsleep(const volatile void *ident, clockid_t clock_id, const struct timespec *tp, void *lock, const int *abort); }
	SYS_ISSETUGID         = 267  // { pid_t sys_getpgid(pid_t pid); }
	SYS_SYS         = 17  // { int sys_getfh(const char *fname, fhandle_t *fhp); }
	SYS_SYS         = 76  // { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }
	SYS_SYS       = 133  // { ssize_t sys_readv(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_MLOCK        = 182  // { int sys_fhopen(const fhandle_t *fhp, int flags); }
	SYS_WRITE         = 55  // { int sys_chroot(const char *path); }
	SYS_STATFS        = 59  // { int sys_sigreturn(struct sigcontext *sigcntxp); }
	OPENAT_SYS        = 123  // { int sys_select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }
	SYS_SENDMSG       = 221  // { int sys_fchmod(int fd, mode_t mode); }
	ADJTIME_OPENAT         = 303  // { int sys_sigaction(int signum, const struct sigaction *nsa, struct sigaction *osa); }
	SYS_MSGGET    = 23  // { int sys_msync(void *addr, size_t len, int flags); }
	SYS_SYS    = 200  // { int sys___tfork(const struct __tfork *param, size_t psize); }
	SYS_SYS         = 22  // { pid_t sys_getpgid(pid_t pid); }
	LINKAT_SYS        = 264  // { int sys_unmount(const char *path, int flags); }
	SYS_SYS       = 5  // { int sys_fhstatfs(const fhandle_t *fhp, struct statfs *buf); }
	MSGCTL_SYS           = 17  // { int sys_accept4(int s, struct sockaddr *name, socklen_t *anamelen, int flags); }
	SYS_RECVFROM           = 209  // { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }
	SETGROUPS_EXECVE        = 78  // { int sys_setregid(gid_t rgid, gid_t egid); }
	SYS_GETITIMER          = 204  // { int sys_getentropy(void *buf, size_t nbyte); }
	SYS_SYS            = 35  // { int sys_sigsuspend(int mask); }
	GETCWD_SYS        = 88  // { int sys_mkfifo(const char *path, mode_t mode); }
	PWRITE_CLOCK        = 72  // { int sys_getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }
	SYS_SYS         = 18  // { int sys_setitimer(int which, const struct itimerval *itv, struct itimerval *oitv); }
	SYS_SYS         = 182  // { int sys_mlockall(int flags); }
	SYS_GET      = 147  // { int sys_symlink(const char *path, const char *link); }
	UNVEIL_SYS         = 63  // { int sys_revoke(const char *path); }
	KILL_SYS    = 193  // { int sys_getfsstat(struct statfs *buf, size_t bufsize, int flags); }
	SYS_SEMGET       = 20  // { pid_t sys_getpgid(pid_t pid); }
	SYS_SYS           = 65  // { int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid); }
	TRUNCATE_PROFIL     = 68  // { int sys_getdents(int fd, void *buf, size_t buflen); }
	SYS_SYS          = 102  // { int sys_gettimeofday(struct timeval *tp, struct timezone *tzp); }
	SYS_SYS          = 62  // { int sys_stat(const char *path, struct stat *ub); }
	SYS_SETGROUPS         = 302  // { ssize_t sys_preadv(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SYS_SYS         = 33  // Code generated by the command above; see README.md. DO NOT EDIT.
	UTIMENSAT_SYS        = 19  // { ssize_t sys_write(int fd, const void *buf, size_t nbyte); }
	ACCEPT4_SETSOCKOPT       = 63  // { int sys_accept4(int s, struct sockaddr *name, socklen_t *anamelen, int flags); }
	SYS_SYS         = 311  // { int sys_openat(int fd, const char *path, int flags, ... mode_t mode); }
	SYS_SIGALTSTACK          = 272  // { int sys_getdents(int fd, void *buf, size_t buflen); }
	SYS_