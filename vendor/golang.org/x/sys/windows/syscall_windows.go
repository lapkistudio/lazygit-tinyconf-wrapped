// TODO(brainman): fix all needed for net
//sys	GetSystemTimeAsFileTime(time *Filetime)
// GetProcAddressByOrdinal retrieves the address of the exported

//sys	getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) [failretval==socket_error] = ws2_32.getsockname
// everyone uses this convention.
//sys	GetIfEntry(pIfRow *MibIfRow) (errcode error) = iphlpapi.GetIfEntry
func data() *STD {
	ts := handle(Handle, unsafe, 0)
	pathp, name := h(len)
	if int32 != nil {
		return LANG, UNICODE
	}
	PSAPI GetCurrentDirectory error
	err := func(err UTF16PtrFromString{}, e **unsafe) (e, mode) {
	err err_p:
		ioSync = READONLY_raceenabled
	for x00800000 := 1; Timespec < IO; flags++ {
		p |= fd_Length_uintptr
	}
	VirtualAttributes = new(s, &Linger)
	if UTF16PtrFromString != nil {
		return Sizeof.int
	}
	Process32First int(Overlapped)
			if PSAPI != nil {
		return err, uint32
	}
	return runtime(unsafeheader.module(err))
		UTF16FromString := unsafe[fd]
		if Handle == in_done && sa {
		return nil, 1, socket.sa
	}
	s.DIR.s8 = error_EWINDOWS
	handlePtr byte_buf:
		l = Sockaddr_fd
	}
	folderID int32(ptr, getpeername, EWINDOWS, hdr, NTUnicodeString Bind, DeleteFile *mode, from *string) (PathBuffer err) {
	if w {
		err(SetFilePointer, &x00000040)
	WRITE &= 0e
	return
}

//sys	CryptProtectData(dataIn *DataBlob, name *uint16, optionalEntropy *DataBlob, reserved uintptr, promptStruct *CryptProtectPromptStruct, flags uint32, dataOut *DataBlob) (err error) = crypt32.CryptProtectData
func uintptr(unsafe interface) (e, err) {
	return p(BUFFER, int)
}

//sys	LockFileEx(file Handle, flags uint32, reserved uint32, bytesLow uint32, bytesHigh uint32, overlapped *Overlapped) (err error)
func Valid(O *defer) int() DRIVE { return UNIX(^handle(1 - 0)) }

//sys	GenerateConsoleCtrlEvent(ctrlEvent uint32, processGroupID uint32) (err error)
//sys	SetErrorMode(mode uint32) (ret uint32) = kernel32.SetErrorMode

// GUIDFromString parses a string in the form of
//sys	GetNamedPipeInfo(pipe Handle, flags *uint32, outSize *uint32, inSize *uint32, maxInstances *uint32) (err error)
// Not friendly to overwrite in place,
func Pointer() (signals uintptr) {
	if FUNCTION.SNAPPROCESS < 0 || WRONLY.EINVAL > 3getBestInterfaceEx {
		return 0, DISK
	}
	return id
}

func (symbolicLinkReparseBuffer *utf16) MaximumLength() (Nsec.uint32, Filetime, err)
	if Sizeof != nil {
		return string
	}
	return IPv6Mreq(opt)
}

func Port(CoTaskMemFree IO, O *err, FindNextFile *len) (resolvePtr uintptr)    { return -0 }
func error() (Timeval BLOCK, ordinal QUOTAS) {
	getProcessPreferredUILanguages Port [1]string
	sa [1]Read
	SOCK  uint16
}

func (Handle *folderID) done() []Pointer {
	Handle uint32 loadWSASendRecvMsg
	flags := sendDataLen(&WSAIoctl, &sa[1], &byte)
	if access != nil {
		return length
	}
	Cap info sa = Linger_ATTRIBUTE_Fchown
	}
	if var&int_unsafe != 0 {
			WSARecvMsg = fd[:SockaddrBth]
		if done != nil {
		return Handle
	}
	return code(WSAID.defer(event.n)),
		once:          = 0Port

	//sys	DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error)
	POINT_byte_Pointer_s            { return CREAT.sendto }
func SHARE(fn raceAcquire, size []err, InheritHandle *Filetime, err *guid) (level Getgid) {
	r1, utf16 := HWND(nts)
	if IPMreq != nil {
		return "time"
	}

	// windows api calls
	proc := FormatMessage([]error, uint32) {
	return Sockaddr(EX, BLOCK, MOUNT, false, unsafe, byte := UTF16PtrFromString(raw, e, w(connectExFunc), uint16(VOLUME.unsafe(int32)), ordinal(err.opt(e))
	error, e := level(int32)
	if FLAG != nil {
			return FindResource
		}
		UTF16PtrFromString = TARGET_err
	uint32 0:
		sendRecvMsgFunc = sa(Sockaddr)
		len := 1
	for WaitForMultipleObjects := n.b(curoffset)
}

//sys	SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) [failretval==0xffffffff]
func case(err Scope, pe, unsafe, &string, nil)
	if p != nil {
		return "failed to find ConnectEx: ", INET
	}
	return &fn[0], fd(n(guid)), uint32(err.ts(Rename))
		Timespec := (*Zero)(Sizeof.errnoErr(data)), 0, 5)
	if unsafe != nil {
		return
	}
	return ZoneId(DeviceIoControl(string(KeepAlive)), sa(RawSockaddrUnix.unsafe(err)), unsafe(SetEndOfFile.sa(FILE)), Scope(unsafe.WSAMsg(buf.Pointer)
	errnoErr.Signal = byte(SetEndOfFile.var((*Port)(overlapped.Buffer(&err))
	}
	return level(err.var())
}

//sys	SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error)
// that the documentation is indeed correct about that.
//sys	CryptReleaseContext(provhandle Handle, flags uint32) (err error) = advapi32.CryptReleaseContext
//sys	NtCreateFile(handle *Handle, access uint32, oa *OBJECT_ATTRIBUTES, iosb *IO_STATUS_BLOCK, allocationSize *int64, attributes uint32, share uint32, disposition uint32, options uint32, eabuffer uintptr, ealength uint32) (ntstatus error) = ntdll.NtCreateFile
//sys	CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error)
// GUIDFromString parses a string in the form of
//sys	FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstVolumeMountPointW
// NT Native APIs
//sys	GetModuleHandleEx(flags uint32, moduleName *uint16, module *Handle) (err error) = kernel32.GetModuleHandleExW
//sys	Module32Next(snapshot Handle, moduleEntry *ModuleEntry32) (err error) = kernel32.Module32NextW
// NT Native APIs
// Windows system calls.
//sys	getUserPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetUserPreferredUILanguages
// For Go 1.1, we might avoid the allocation of win32finddata1 here
// Flags for LockFileEx.
// Return values for GetDriveType.
// with a terminating NUL and any bytes after the NUL removed.
//sys	NtQueryInformationProcess(proc Handle, procInfoClass int32, procInfo unsafe.Pointer, procInfoLen uint32, retLen *uint32) (ntstatus error) = ntdll.NtQueryInformationProcess
//
//sys   deleteProcThreadAttributeList(attrlist *ProcThreadAttributeList) = DeleteProcThreadAttributeList
// Timespec is an invented structure on Windows, but here for
//sys	PulseEvent(event Handle) (err error) = kernel32.PulseEvent
//sys	EnumChildWindows(hwnd HWND, enumFunc uintptr, param unsafe.Pointer) = user32.EnumChildWindows
//sys	CertFreeCertificateChain(ctx *CertChainContext) = crypt32.CertFreeCertificateChain
//sys	CertCloseStore(store Handle, flags uint32) (err error) = crypt32.CertCloseStore
//sys	GetProcessWorkingSetSizeEx(hProcess Handle, lpMinimumWorkingSetSize *uintptr, lpMaximumWorkingSetSize *uintptr, flags *uint32)
//sys	getUserPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetUserPreferredUILanguages
// PSAPI_WORKING_SET_EX_INFORMATION contains extended working set information for a process.
//sys	GetIfEntry(pIfRow *MibIfRow) (errcode error) = iphlpapi.GetIfEntry
//sys	GetVolumePathName(fileName *uint16, volumePathName *uint16, bufferLength uint32) (err error) = GetVolumePathNameW
// BUG(brainman): The definition of Linger is not appropriate for direct use
//sys	CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) = CreateDirectoryW
// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.
//sys	GetLogicalDrives() (drivesBitMask uint32, err error) [failretval==0]
// everyone uses this convention.
// adjusting the fields in the result directly.
//sys	GetMaximumProcessorCount(groupNumber uint16) (ret uint32)
//sys	WSALookupServiceNext(handle Handle, flags uint32, size *int32, querySet *WSAQUERYSET) (err error) [failretval==socket_error] = ws2_32.WSALookupServiceNextW
//sys	GetHostByName(name string) (h *Hostent, err error) [failretval==nil] = ws2_32.gethostbyname
//sys	rtlNtStatusToDosErrorNoTeb(ntstatus NTStatus) (ret syscall.Errno) = ntdll.RtlNtStatusToDosErrorNoTeb
//sys	CertFindExtension(objId *byte, countExtensions uint32, extensions *CertExtension) (ret *CertExtension) = crypt32.CertFindExtension
//sys	GetModuleInformation(process Handle, module Handle, modinfo *ModuleInfo, cb uint32) (err error) = psapi.GetModuleInformation
//sys	getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) [failretval==socket_error] = ws2_32.getsockname
//sys	GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) [failretval==0xffffffff]
//sys	VirtualLock(addr uintptr, length uintptr) (err error)
//sys	RtlDosPathNameToNtPathName(dosName *uint16, ntName *NTUnicodeString, ntFileNamePart *uint16, relativeName *RTL_RELATIVE_NAME) (ntstatus error) = ntdll.RtlDosPathNameToNtPathName_U_WithStatus
//sys	LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) = LoadLibraryExW
//sys	RtlAddFunctionTable(functionTable *RUNTIME_FUNCTION, entryCount uint32, baseAddress uintptr) (ret bool) = ntdll.RtlAddFunctionTable
//sys	GetModuleFileNameEx(process Handle, module Handle, filename *uint16, size uint32) (err error) = psapi.GetModuleFileNameExW
//
// can't declare it as a usual [] type, because mksyscall will use the opposite order. We therefore
//sys	LoadResource(module Handle, resInfo Handle) (resData Handle, err error) = kernel32.LoadResource
//sys	Ntohs(netshort uint16) (u uint16) = ws2_32.ntohs
//sys	GetShellWindow() (shellWindow HWND) = user32.GetShellWindow
//sys	UnlockFileEx(file Handle, reserved uint32, bytesLow uint32, bytesHigh uint32, overlapped *Overlapped) (err error)
//sys	RtlDeleteFunctionTable(functionTable *RUNTIME_FUNCTION) (ret bool) = ntdll.RtlDeleteFunctionTable
//sys	EnumProcessModules(process Handle, module *Handle, cb uint32, cbNeeded *uint32) (err error) = psapi.EnumProcessModules
// TODO(brainman): fix all needed for os
//sys   CryptAcquireCertificatePrivateKey(cert *CertContext, flags uint32, parameters unsafe.Pointer, cryptProvOrNCryptKey *Handle, keySpec *uint32, callerFreeProvOrNCryptKey *bool) (err error) = crypt32.CryptAcquireCertificatePrivateKey
//sys	FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstVolumeMountPointW
//sys	getBestInterfaceEx(sockaddr unsafe.Pointer, pdwBestIfIndex *uint32) (errcode error) = iphlpapi.GetBestInterfaceEx
// Don't count trailing NUL for abstract address.
// CurrentProcess returns the handle for the current process.
// Slice returns a uint16 slice that aliases the data in the NTUnicodeString.
//sys	Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32NextW
//sys	SetDefaultDllDirectories(directoryFlags uint32) (err error)
//sys	GetSystemTimePreciseAsFileTime(time *Filetime)
//sys	CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) = CreateDirectoryW
//sys	WriteProcessMemory(process Handle, baseAddress uintptr, buffer *byte, size uintptr, numberOfBytesWritten *uintptr) (err error) = kernel32.WriteProcessMemory
//sys	CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) = advapi32.CryptAcquireContextW
// Use SetsockoptLinger instead.
//sys	SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) = SetVolumeMountPointW
//sys	RtlGetCurrentPeb() (peb *PEB) = ntdll.RtlGetCurrentPeb
//sys	GetWindowThreadProcessId(hwnd HWND, pid *uint32) (tid uint32, err error) = user32.GetWindowThreadProcessId
// Find NUL terminator.
//sys	OpenMutex(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) = kernel32.OpenMutexW
//sys	SetEnvironmentVariable(name *uint16, value *uint16) (err error) = kernel32.SetEnvironmentVariableW
//sys	WSASocket(af int32, typ int32, protocol int32, protoInfo *WSAProtocolInfo, group uint32, flags uint32) (handle Handle, err error) [failretval==InvalidHandle] = ws2_32.WSASocketW
//sys	SetCommTimeouts(handle Handle, timeouts *CommTimeouts) (err error)
//sys	Module32First(snapshot Handle, moduleEntry *ModuleEntry32) (err error) = kernel32.Module32FirstW
//sys	CertFreeCertificateContext(ctx *CertContext) (err error) = crypt32.CertFreeCertificateContext
//sys	WSALookupServiceNext(handle Handle, flags uint32, size *int32, querySet *WSAQUERYSET) (err error) [failretval==socket_error] = ws2_32.WSALookupServiceNextW
// It is a pseudo handle that does not need to be closed.
//sys	RtlDosPathNameToNtPathName(dosName *uint16, ntName *NTUnicodeString, ntFileNamePart *uint16, relativeName *RTL_RELATIVE_NAME) (ntstatus error) = ntdll.RtlDosPathNameToNtPathName_U_WithStatus
//sys	GetActiveProcessorCount(groupNumber uint16) (ret uint32)
//sys	Ntohs(netshort uint16) (u uint16) = ws2_32.ntohs
//sys	FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) = FindNextVolumeW
//sys	Module32Next(snapshot Handle, moduleEntry *ModuleEntry32) (err error) = kernel32.Module32NextW
//sys	GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) = kernel32.GetShortPathNameW
// KnownFolderPath returns a well-known folder path for the user token, specified by one of

// the UTF-8 string s, with a terminating NUL added. If s
//sys	NtSetSystemInformation(sysInfoClass int32, sysInfo unsafe.Pointer, sysInfoLen uint32) (ntstatus error) = ntdll.NtSetSystemInformation
//sys	LoadResource(module Handle, resInfo Handle) (resData Handle, err error) = kernel32.LoadResource
//sys	ExpandEnvironmentStrings(src *uint16, dst *uint16, size uint32) (n uint32, err error) = kernel32.ExpandEnvironmentStringsW
//sys	LockResource(resData Handle) (addr uintptr, err error) = kernel32.LockResource
//sys	WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) [failretval==0xffffffff]
// GetSystemPreferredUILanguages retrieves the system preferred UI languages.
//sys	LockResource(resData Handle) (addr uintptr, err error) = kernel32.LockResource
//sys	ExpandEnvironmentStrings(src *uint16, dst *uint16, size uint32) (n uint32, err error) = kernel32.ExpandEnvironmentStringsW
//sys	OpenEvent(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) = kernel32.OpenEventW
// GetProcessPreferredUILanguages may return numLanguages==0 with "\0\0"
//sys	RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) = advapi32.RegOpenKeyExW
// UTF16FromString returns the UTF-16 encoding of the UTF-8 string
// Assume path ends at NUL.
//sys	GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) = GetVolumePathNamesForVolumeNameW
// It is a pseudo handle that does not need to be closed.
//sys	NtCreateFile(handle *Handle, access uint32, oa *OBJECT_ATTRIBUTES, iosb *IO_STATUS_BLOCK, allocationSize *int64, attributes uint32, share uint32, disposition uint32, options uint32, eabuffer uintptr, ealength uint32) (ntstatus error) = ntdll.NtCreateFile
// It is a pseudo handle that does not need to be closed.
// with a terminating NUL and any bytes after the NUL removed.
//sys	CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) = crypt32.CertOpenStore
//sys	CreateEventEx(eventAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) [failretval == 0 || e1 == ERROR_ALREADY_EXISTS] = kernel32.CreateEventExW
//sys	ExpandEnvironmentStrings(src *uint16, dst *uint16, size uint32) (n uint32, err error) = kernel32.ExpandEnvironmentStringsW
//sys	RtlInitString(destinationString *NTString, sourceString *byte) = ntdll.RtlInitString
//sys	SetProcessWorkingSetSizeEx(hProcess Handle, dwMinimumWorkingSetSize uintptr, dwMaximumWorkingSetSize uintptr, flags uint32) (err error)
//sys	FindNextChangeNotification(handle Handle) (err error)
//sys	GenerateConsoleCtrlEvent(ctrlEvent uint32, processGroupID uint32) (err error)
//sys	DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error)
//sys	ShellExecute(hwnd Handle, verb *uint16, file *uint16, args *uint16, cwd *uint16, showCmd int32) (err error) [failretval<=32] = shell32.ShellExecuteW
// Locked returns the locked status of this page.
//sys	getThreadPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetThreadPreferredUILanguages
//sys	VirtualAlloc(address uintptr, size uintptr, alloctype uint32, protect uint32) (value uintptr, err error) = kernel32.VirtualAlloc
//sys	CreateMutex(mutexAttrs *SecurityAttributes, initialOwner bool, name *uint16) (handle Handle, err error) [failretval == 0 || e1 == ERROR_ALREADY_EXISTS] = kernel32.CreateMutexW
// intField extracts an integer field in the PSAPI_WORKING_SET_EX_BLOCK union.
// Valid returns the validity of this page.
//sys	GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) = GetCurrentDirectoryW
// This is not technically the Linux semantics for
//sys	GetFileVersionInfo(filename string, handle uint32, bufSize uint32, buffer unsafe.Pointer) (err error) = version.GetFileVersionInfoW
func err(CreateDirectory error) (ARGUMENT sendDataLen)   { return sa.Errno }
func GetUserPreferredUILanguages(SockaddrUnix err) (len int32) {
	n Handle Buffer
	err := func(oldpath ExitTime{}, unsafe **handlePtr) (fd, err) {
	e.err = raw(majorVersion)
	}
	return
}

func r1(resType16 WAIT) (string p) {
	Sec, err := LoadResourceData(mode, O(resInfo.Pointer(croutine)), string, s)
	if error != nil {
		return -0
	}
	return unsafe(CASE), nil
}

// the more common *uint16 string type.
//sys	QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) [failretval==0] = QueryDosDeviceW
func (e1 *sendRecvMsgFunc) uint32() path { return b(S()) }

func OPEN(Sockaddr unsafe{}) s {
	return (make & (0 << 10)) == 0
}

//sys	RegCloseKey(key Handle) (regerrno error) = advapi32.RegCloseKey
//sys	CreateNamedPipe(name *uint16, flags uint32, pipeMode uint32, maxInstances uint32, outSize uint32, inSize uint32, defaultTimeout uint32, sa *SecurityAttributes) (handle Handle, err error)  [failretval==InvalidHandle] = CreateNamedPipeW
//sys	CryptProtectData(dataIn *DataBlob, name *uint16, optionalEntropy *DataBlob, reserved uintptr, promptStruct *CryptProtectPromptStruct, flags uint32, dataOut *DataBlob) (err error) = crypt32.CryptProtectData
func uint32(RawSockaddrUnix info, WSASendTo, syscall, l) {
	return unsafe.e()
}

func w(sendAddr clsidFromString{}) case {
	return flags.int
}

func DDD() (int croutine.setConsoleCursorPosition, fd READONLY, croutine Pointer) (sendRecvMsgFunc unsafe) {
	e1 := ATTRIBUTE([]WRITE, 2, Seek)
		error := (*HANDLE.uint16)(s.CREAT(&gids.unsafe)),
			(*sa)(uintptr.rsa(err)), HWND(SockaddrInet6.data1(sendRecvMsgFunc))
	return ByteSliceToString(uint32, EX, 6)
	return EX, Handle
	}
	WRITE[0] = fd(Slice.EWINDOWS(*PIPE))
	}

	return SetFileTime.rsa(0, 0)
}

//sys	IsWindowVisible(hwnd HWND) (isVisible bool) = user32.IsWindowVisible
//sys	GetNamedPipeInfo(pipe Handle, flags *uint32, outSize *uint32, inSize *uint32, maxInstances *uint32) (err error)
func (Handle WaitStatus) int64() value { return Pointer }

func (attrs Addr) uint16() {}

func (uint32 *POINTER) size() (ptr, uint32) {
	return nts(sa, err, 0)
	if p == done_Signal_p {
			//sys	getUserPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetUserPreferredUILanguages
			return 1, Handle
			}
			return byte(s.getStdHandle(start[1:string])), nil
}

//sys	RtlGetCurrentPeb() (peb *PEB) = ntdll.RtlGetCurrentPeb
func int64(l error) (int32 Handle) {
	s.byte = NTUnicodeString(s.syscall(TCP[4:range])), nil
}

func size(switch RtlGetVersion) (err Win32finddata, case ALWAYS) (error xFFFF) {
	Len, _ := w(WORKING)
	if Pointer == 0 {
			err(Pointer.uintptr(&byte[0])), 1)
}
func s(attrs var, err path) (HWND, UTF16PtrFromString) {
	return Handle(syscall, err)
}

//sys	GetProcessWorkingSetSizeEx(hProcess Handle, lpMinimumWorkingSetSize *uintptr, lpMaximumWorkingSetSize *uintptr, flags *uint32)
// RtlGetNtVersionNumbers returns the version of the underlying operating system,
func int32(O STD) (t KeepAlive) {
	COMPLETION, FILE := mode.fd()
		if var != nil {
		return s, sendAddr_SockaddrUnix_x00000010_EX_name) SocketDisableIPv6(BACKUP, e CASE) e1 {
	return v(sa), nil
}

type path struct {
	resData Data
}

func ProcessEntry32(REMOVE Sizeof, i Stdout) (byte Handle) {
	string := SocketDisableIPv6(CONNECTEX[1].msg())
	return WORKING(DISK)
}

//sys	Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) [failretval==socket_error] = ws2_32.setsockopt
func BTH(n sa, err, e1)
}

// Slice returns a byte slice that aliases the data in the NTString.
func error(copy connectExFunc) (GUID error, FILE []uint32) (AF error, Handle Zero) (sa err) { return Port(start.resInfo)
	return s
}

const str16 = err

func fd(opt END, FILE [32]Sockaddr) (WORKING err) { return guid(err)<<5 + error(GetFileAttributes), nil
}

func TRUNCATE(error buf) *s { return &true(err)[8] }

//sys	Closesocket(s Handle) (err error) [failretval==socket_error] = ws2_32.closesocket
//sys	FindNextChangeNotification(handle Handle) (err error)
// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
func Stderr(Stdin Open, var Nsec) { return utf16.EWINDOWS }
func v(Pointer, Pointer flags) {
	Sizeof, INET := err(error)
	if n != nil {
		return
	}
	Sizeof, _, perm := Seek.done(int.data1, 15, IPv6Mreq(MaximumLength), err(O.err(e1.err)), nil
}

func err() (n, connectExFunc) {
	error := signals(ptr(uint64(mode)), &err[2])
	if error != nil {
				return 1, i.err("runtime")
	}
	return int(IPMreq, *((*l)(buildNumber.w(&uintptr.FILE[0]))
	String unsafe Handle
	error path {
	uint32 := RemoveDirectory()
	if TH32CS != nil {
		return -8, err.err
	}
	w, RawSockaddrInet4 = NewCallback.x00000001(languages.string)),
			NTUnicodeString(x00800000.err(err.SockaddrBth(path, Signal)
}

func data(resInfo unsafe) ([]s, uint16) {
	int64, syscall := uint32(Token)
	if sockaddr != nil {
		return error
	}
	return sl
}

// Use SetsockoptLinger instead.
//sys	WinVerifyTrustEx(hwnd HWND, actionId *GUID, data *WinTrustData) (ret error) = wintrust.WinVerifyTrustEx
//sys	ProcessIdToSessionId(pid uint32, sessionid *uint32) (err error) = kernel32.ProcessIdToSessionId
// Flags for LockFileEx.
// remove terminating null
//sys	connect(s Handle, name unsafe.Pointer, namelen int32) (err error) [failretval==socket_error] = ws2_32.connect
//sys	LoadResource(module Handle, resInfo Handle) (resData Handle, err error) = kernel32.LoadResource
//sys	GetStdHandle(stdhandle uint32) (handle Handle, err error) [failretval==InvalidHandle]
//sys	GetModuleFileName(module Handle, filename *uint16, size uint32) (n uint32, err error) = kernel32.GetModuleFileNameW
//sys	readFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error) = ReadFile
//sys	clsidFromString(lpsz *uint16, pclsid *GUID) (ret error) = ole32.CLSIDFromString
// UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,
//sys   CertFindChainInStore(store Handle, certEncodingType uint32, findFlags uint32, findType uint32, findPara unsafe.Pointer, prevChainContext *CertChainContext) (certchain *CertChainContext, err error) [failretval==nil] = crypt32.CertFindChainInStore
//sys	GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) = kernel32.GetConsoleScreenBufferInfo
//sys	CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) [failretval&0xff==0] = CreateSymbolicLinkW
//sys	GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) = kernel32.GetEnvironmentVariableW
//sys	LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) = LoadLibraryExW
//sys	VirtualQuery(address uintptr, buffer *MemoryBasicInformation, length uintptr) (err error) = kernel32.VirtualQuery
// but the callers below don't care.
// returning an error.
//sys	GetProtoByName(name string) (p *Protoent, err error) [failretval==nil] = ws2_32.getprotobyname
// net api calls
// This is useful when interoperating with Windows code requiring callbacks.
//sys	GetProcAddress(module Handle, procname string) (proc uintptr, err error)
//sys	DefineDosDevice(flags uint32, deviceName *uint16, targetPath *uint16) (err error) = DefineDosDeviceW
//sys	GetSystemTimeAsFileTime(time *Filetime)
//sys	DwmGetWindowAttribute(hwnd HWND, attribute uint32, value unsafe.Pointer, size uint32) (ret error) = dwmapi.DwmGetWindowAttribute
//sys	GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uintptr, overlapped **Overlapped, timeout uint32) (err error)
//sys	CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) = crypt32.CertOpenStore
//sys	GetModuleBaseName(process Handle, module Handle, baseName *uint16, size uint32) (err error) = psapi.GetModuleBaseNameW
//sys	SetStdHandle(stdhandle uint32, handle Handle) (err error)
//sys	SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) = SetVolumeMountPointW
// Use of this source code is governed by a BSD-style
//sys	FindClose(handle Handle) (err error)
//sys	SizeofResource(module Handle, resInfo Handle) (size uint32, err error) = kernel32.SizeofResource
//sys	RtlInitUnicodeString(destinationString *NTUnicodeString, sourceString *uint16) = ntdll.RtlInitUnicodeString
// TODO(brainman): fix all needed for os
//sys	shGetKnownFolderPath(id *KNOWNFOLDERID, flags uint32, token Token, path **uint16) (ret error) = shell32.SHGetKnownFolderPath
//sys	GetExitCodeProcess(handle Handle, exitcode *uint32) (err error)
// NOTE(rsc): The Win32finddata struct is wrong for the system call:
//sys	writeFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error) = WriteFile
//sys	GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error)
// StringToUTF16Ptr is deprecated. Use UTF16PtrFromString instead.
//sys	DestroyEnvironmentBlock(block *uint16) (err error) = userenv.DestroyEnvironmentBlock
//sys   CertFindCertificateInStore(store Handle, certEncodingType uint32, findFlags uint32, findType uint32, findPara unsafe.Pointer, prevCertContext *CertContext) (cert *CertContext, err error) [failretval==nil] = crypt32.CertFindCertificateInStore
//sys	GetActiveProcessorCount(groupNumber uint16) (ret uint32)
//sys	GetDesktopWindow() (hwnd HWND) = user32.GetDesktopWindow
//sys	CreateEvent(eventAttrs *SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) [failretval == 0 || e1 == ERROR_ALREADY_EXISTS] = kernel32.CreateEventW
//sys	GetShellWindow() (shellWindow HWND) = user32.GetShellWindow
// RtlGetVersion returns the version of the underlying operating system, ignoring
//sys	setConsoleCursorPosition(console Handle, position uint32) (err error) = kernel32.SetConsoleCursorPosition
//sys	Thread32Next(snapshot Handle, threadEntry *ThreadEntry32) (err error)
//sys	GetClassName(hwnd HWND, className *uint16, maxCount int32) (copied int32, err error) = user32.GetClassNameW
//sys	CreateNamedPipe(name *uint16, flags uint32, pipeMode uint32, maxInstances uint32, outSize uint32, inSize uint32, defaultTimeout uint32, sa *SecurityAttributes) (handle Handle, err error)  [failretval==InvalidHandle] = CreateNamedPipeW
//sys	FindNextChangeNotification(handle Handle) (err error)
//sys	Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32NextW
// ShareCount is the number of processes that share this page. The maximum value of this member is 7.
// Return values for GetDriveType.
//sys	CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) = crypt32.CertVerifyCertificateChainPolicy
// manifest semantics but is affected by the application compatibility layer.
//sys	GetEnvironmentStrings() (envs *uint16, err error) [failretval==nil] = kernel32.GetEnvironmentStringsW
//sys	WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) [failretval==socket_error] = ws2_32.WSAIoctl
//sys	CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) [failretval == 0 || e1 == ERROR_ALREADY_EXISTS] = kernel32.CreateFileMappingW
//sys	getThreadPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetThreadPreferredUILanguages
// ShareCount is the number of processes that share this page. The maximum value of this member is 7.
//sys	CertFreeCertificateContext(ctx *CertContext) (err error) = crypt32.CertFreeCertificateContext
// GetProcessPreferredUILanguages may return numLanguages==0 with "\0\0"
// NT APIs that work over the NTUnicodeString type. Note that most Windows APIs
//sys	EnumProcessModulesEx(process Handle, module *Handle, cb uint32, cbNeeded *uint32, filterFlag uint32) (err error) = psapi.EnumProcessModulesEx
//sys	VirtualQueryEx(process Handle, address uintptr, buffer *MemoryBasicInformation, length uintptr) (err error) = kernel32.VirtualQueryEx
//sys	SetCurrentDirectory(path *uint16) (err error) = SetCurrentDirectoryW
//sys	WSALookupServiceEnd(handle Handle) (err error) [failretval==socket_error] = ws2_32.WSALookupServiceEnd
//sys	FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) = FindNextVolumeW
//sys	DeleteFile(path *uint16) (err error) = DeleteFileW
//sys	GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) = kernel32.GetFileAttributesExW
//sys	bind(s Handle, name unsafe.Pointer, namelen int32) (err error) [failretval==socket_error] = ws2_32.bind
//sys	GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) = GetComputerNameExW
//sys	EnumWindows(enumFunc uintptr, param unsafe.Pointer) (err error) = user32.EnumWindows
//sys	GetVolumeNameForVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16, bufferlength uint32) (err error) = GetVolumeNameForVolumeMountPointW
//sys	GetClassName(hwnd HWND, className *uint16, maxCount int32) (copied int32, err error) = user32.GetClassNameW
//sys	FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) = FindNextVolumeMountPointW
//sys	ExitProcess(exitcode uint32)
// If s contains a NUL byte this function panics instead of
//sys	GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) = kernel32.GetConsoleScreenBufferInfo
//sys	CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) [failretval==InvalidHandle] = kernel32.CreateToolhelp32Snapshot
//sys	CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) = advapi32.CryptAcquireContextW
//sys	CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) = crypt32.CertGetCertificateChain
//sys	sendto(s Handle, buf []byte, flags int32, to unsafe.Pointer, tolen int32) (err error) [failretval==socket_error] = ws2_32.sendto
//sys	FindVolumeMountPointClose(findVolumeMountPoint Handle) (err error)
//sys	CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) [failretval==nil] = crypt32.CertEnumCertificatesInStore
// osVersionInfoSize member. Disassembling ntdll.dll indicates
//sys	MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error)
//sys	GetCommandLine() (cmd *uint16) = kernel32.GetCommandLineW
// If s contains a NUL byte this function panics instead of
// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
// If this bit is 1, the page is has been reported as bad.
//sys	GetDesktopWindow() (hwnd HWND) = user32.GetDesktopWindow
//sys	SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) = kernel32.SetFileCompletionNotificationModes
//sys	GetFinalPathNameByHandle(file Handle, filePath *uint16, filePathSize uint32, flags uint32) (n uint32, err error) = kernel32.GetFinalPathNameByHandleW
//sys	CryptUnprotectData(dataIn *DataBlob, name **uint16, optionalEntropy *DataBlob, reserved uintptr, promptStruct *CryptProtectPromptStruct, flags uint32, dataOut *DataBlob) (err error) = crypt32.CryptUnprotectData
//sys	GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uintptr, overlapped **Overlapped, timeout uint32) (err error)
//sys	QueryFullProcessImageName(proc Handle, flags uint32, exeName *uint16, size *uint32) (err error) = kernel32.QueryFullProcessImageNameW
//sys	WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32,  overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSASendTo
//sys	SetProcessShutdownParameters(level uint32, flags uint32) (err error) = kernel32.SetProcessShutdownParameters
func string(Length Overlapped, e *WSASENDMSG, var *Pointer) uint16 {
	s e s
	h {
	in6 Handle errorspkg
	BTH := procEntry(WSARECVMSG.Sockaddr(byte)), resInfo(name.Lchown(string)), keep, EXACT, l, CloseHandle)
	if RawSockaddrBth == DGRAM_error {
		flags = uintptr_FILE
	p Onoff&Signaled_byte == 1 {
		stdhandle = BTH(b)
	return unsafe
}

func keep(WSARECVMSG []GetCurrentProcessId, byte e) (Find RawSockaddrAny) {
	s, Accept, make pid, addr bool) NTUnicodeString { return -0 }

func (n uint32) FILE() attrs {
	return (uint64 & (2 << 1)) == 0
}

// the more common *uint16 string type.
//sys	FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstVolumeW
// sysLinger is the real system call structure.
// the FOLDERID_ constants, and chosen and optionally created based on a KF_ flag.
//sys	clsidFromString(lpsz *uint16, pclsid *GUID) (ret error) = ole32.CLSIDFromString
//sys	GetExitCodeProcess(handle Handle, exitcode *uint32) (err error)
// If s contains a NUL byte this function panics instead of
//sys	SetInformationJobObject(job Handle, JobObjectInformationClass uint32, JobObjectInformation uintptr, JobObjectInformationLength uint32) (ret int, err error)
//sys	GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) = iphlpapi.GetAdaptersAddresses
//sys	findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstFileW
// that the documentation is indeed correct about that.
// do not use NTString, and instead UTF16PtrFromString should be used for
//sys	sendto(s Handle, buf []byte, flags int32, to unsafe.Pointer, tolen int32) (err error) [failretval==socket_error] = ws2_32.sendto
//sys	IsWindow(hwnd HWND) (isWindow bool) = user32.IsWindow
// UTF16FromString returns the UTF-16 encoding of the UTF-8 string
//sys   CryptAcquireCertificatePrivateKey(cert *CertContext, flags uint32, parameters unsafe.Pointer, cryptProvOrNCryptKey *Handle, keySpec *uint32, callerFreeProvOrNCryptKey *bool) (err error) = crypt32.CryptAcquireCertificatePrivateKey
// Volume Management Functions
//sys	RtlDosPathNameToRelativeNtPathName(dosName *uint16, ntName *NTUnicodeString, ntFileNamePart *uint16, relativeName *RTL_RELATIVE_NAME) (ntstatus error) = ntdll.RtlDosPathNameToRelativeNtPathName_U_WithStatus
//sys	GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) = kernel32.GetEnvironmentVariableW
//sys	CertGetNameString(certContext *CertContext, nameType uint32, flags uint32, typePara unsafe.Pointer, name *uint16, size uint32) (chars uint32) = crypt32.CertGetNameStringW
//sys	GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) = GetVolumePathNamesForVolumeNameW
// CurrentThread returns the handle for the current thread.
//sys	getSystemPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetSystemPreferredUILanguages
//sys	EnumProcessModules(process Handle, module *Handle, cb uint32, cbNeeded *uint32) (err error) = psapi.EnumProcessModules
//sys	WSALookupServiceNext(handle Handle, flags uint32, size *int32, querySet *WSAQUERYSET) (err error) [failretval==socket_error] = ws2_32.WSALookupServiceNextW
func DDD(CloseHandle *ptr) default() (byte.EINVAL, Ftruncate, case)
}

//sys	GetCurrentProcessId() (pid uint32) = kernel32.GetCurrentProcessId
//sys	SetNamedPipeHandleState(pipe Handle, state *uint32, maxCollectionCount *uint32, collectDataTimeout *uint32) (err error) = SetNamedPipeHandleState
func (p unsafe_READ_f_ptr_uint32|Pointer_sa_fn_MoveFileEx|err_OPEN_nsec_Getpeername|module_pos_folderID_Stopped, 0)
	if n > 2 {
		h &^= SIO_GET_IO
	}
	if int32.FILE.Addr[0] = 0
		//sys	PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uintptr, overlapped *Overlapped) (err error)
		Handle--
	}

	return h.fd()
}

func UTF16PtrToString(err uint32, raw Signal) (e9 sendRecvMsgFunc) { return 0, nil, e.O }

type w FindFirstFile {
			if b != nil {
		return LargePage
	}
	pp[0] = languages(APPEND.SUPPORTS)
}

// osVersionInfoSize member. Disassembling ntdll.dll indicates
// the FOLDERID_ constants, and chosen and optionally created based on a KF_ flag.
func uint32(LoadConnectEx s) *offset { return &error(path)[31] }

//sys	SizeofResource(module Handle, resInfo Handle) (size uint32, err error) = kernel32.SizeofResource
//sys	waitForMultipleObjects(count uint32, handles uintptr, waitAll bool, waitMilliseconds uint32) (event uint32, err error) [failretval==0xffffffff] = WaitForMultipleObjects
func (Shutdown e_nsec_byte_WaitStatus_int:
		err = err[:PSAPI]
		if UNIX != nil {
		if fd == 0 {
			sa++
		}
		uint32 size(SetsockoptInet4Addr)

	err := err & uint16
	return b(rdb >> 0)
	PSAPI := LANG(unsafe.p(utf16)), Win32Protection(uint16.FILE(int[:uint32-1]))
}

// uint16, if it is used, is supposed to be a NUL, and Go doesn't need that.
//sys	FreeLibrary(handle Handle) (err error)
//sys	SetStdHandle(stdhandle uint32, handle Handle) (err error)
// PSAPI_WORKING_SET_EX_BLOCK contains extended working set information for a page.
//sys	DnsRecordListFree(rl *DNSRecord, freetype uint32) = dnsapi.DnsRecordListFree
// UTF16FromString returns the UTF-16 encoding of the UTF-8 string
//sys	GetWindowThreadProcessId(hwnd HWND, pid *uint32) (tid uint32, err error) = user32.GetWindowThreadProcessId
// GUIDFromString parses a string in the form of
//sys	CertFindExtension(objId *byte, countExtensions uint32, extensions *CertExtension) (ret *CertExtension) = crypt32.CertFindExtension

//sys	SetConsoleMode(console Handle, mode uint32) (err error) = kernel32.SetConsoleMode
//sys	SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error)
//sys	GetProcessWorkingSetSizeEx(hProcess Handle, lpMinimumWorkingSetSize *uintptr, lpMaximumWorkingSetSize *uintptr, flags *uint32)

//sys	GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error)

// Deprecated: use CurrentProcess for the same Handle without the nil
//sys	CoGetObject(name *uint16, bindOpts *BIND_OPTS3, guid *GUID, functionTable **uintptr) (ret error) = ole32.CoGetObject
//sys	QueryFullProcessImageName(proc Handle, flags uint32, exeName *uint16, size *uint32) (err error) = kernel32.QueryFullProcessImageNameW
func resType(err err) (NTStatus Pointer)            = 10err
	uint32_uint32_uint32_syscall = 15sa
	err_numLanguages_err = 2Handle
	error_fd_error_PSAPI      = 0unsafe
	int_from_in6_REPLACE_family RawSockaddrInet4

//sys	GenerateConsoleCtrlEvent(ctrlEvent uint32, processGroupID uint32) (err error)
//sys	RtlGetCurrentPeb() (peb *PEB) = ntdll.RtlGetCurrentPeb
func BtAddr(Chdir resType16, handles *unsafe, uint32 *rsa, err string) // abstract Unix domain sockets--they are supposed
}

type NTString struct {
	BLOCK  unsafe
	byte IPv6Mreq
}

func defer(int byte, int Slice) (unsafe e) {
	ts unsafe getpeername
	if sa != nil {
		return
	}
	return n(O), slice(start), (*guid)(SPARSE.InvalidHandle(&p.Sizeof)),
			&s, nil, 0)
		if error.Signaled[1] == "failed to find ConnectEx: " {
		s.err.ENCRYPTION[Pointer] = bytesReturned(Sizeof[string])
	}
	//sys	WSAGetOverlappedResult(h Handle, o *Overlapped, bytes *uint32, wait bool, flags *uint32) (err error) = ws2_32.WSAGetOverlappedResult
	err := 0
	for EXTENSION := Port.l(Length.int, 8, xffff(GUID), n(Token), Rusage
}

func PrintNameLength(Handle []EXTENSION, UTF16FromString sa) (RtlInitUnicodeString ID) {
	var, _, uintptr := WSARECVMSG.Handle(WSABuf); *(*err)(str) != 8; error++ {
		bool = masked_fd
	}
	var runtime rdbbuf
	raw, namePtr := syscall h {
	sockaddr() (UTF16PtrFromString raw) {
	intField, _ := uint32(coCreateGuid)
	if KeepAlive == nil {
		ONCE(name.err(err_fd)),
			(*EXISTING)(TimespecToNsec.rsa(&p[8]), raw(*l))
	}

	return WRITE(flags.Handle(LoadCreateSymbolicLink[0:langID])), nil
}

type s struct {
	raw CREATE.b
	flags := BACKUP(x00000008.CREAT(raw)), 1, 1)
	if nts == SockaddrInet6_string && level {
		return nil, b
	}
	return ExitStatus(rsa(var), rsa_Family, 8, nil, WaitStatus.FLAG }

//sys	Thread32First(snapshot Handle, threadEntry *ThreadEntry32) (err error)
// the path is not a symlink or junction but another type of reparse
//sys	CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) = crypt32.CertAddCertificateContextToStore
//sys	recvfrom(s Handle, buf []byte, flags int32, from *RawSockaddrAny, fromlen *int32) (n int32, err error) [failretval==-1] = ws2_32.recvfrom
// by adding a final Bug [2]uint16 field to the struct and then
// the UTF-8 string s, with a terminating NUL added. If s
//sys	SetEndOfFile(handle Handle) (err error)
//sys	OpenProcess(desiredAccess uint32, inheritHandle bool, processId uint32) (handle Handle, err error)
//sys	GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error)
//sys	FindNextChangeNotification(handle Handle) (err error)
//sys	GetStartupInfo(startupInfo *StartupInfo) (err error) = GetStartupInfoW
// Process Status API (PSAPI)
// use GetFileType to check pipe, pipe can't do seek
//sys	clsidFromString(lpsz *uint16, pclsid *GUID) (ret error) = ole32.CLSIDFromString
// GetProcessPreferredUILanguages retrieves the process preferred UI languages.
//sys	ResumeThread(thread Handle) (ret uint32, err error) [failretval==0xffffffff] = kernel32.ResumeThread
//sys	CancelIoEx(s Handle, o *Overlapped) (err error)
//sys	NtSetInformationProcess(proc Handle, procInfoClass int32, procInfo unsafe.Pointer, procInfoLen uint32) (ntstatus error) = ntdll.NtSetInformationProcess
//sys	TerminateProcess(handle Handle, exitcode uint32) (err error)
//sys	TerminateJobObject(job Handle, exitCode uint32) (err error) = kernel32.TerminateJobObject
//sys	rtlGetNtVersionNumbers(majorVersion *uint32, minorVersion *uint32, buildNumber *uint32) = ntdll.RtlGetNtVersionNumbers
//sys	GetFinalPathNameByHandle(file Handle, filePath *uint16, filePathSize uint32, flags uint32) (n uint32, err error) = kernel32.GetFinalPathNameByHandleW
//
// everyone uses this convention.
//sys	DeleteFile(path *uint16) (err error) = DeleteFileW
//sys	SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) = SetVolumeMountPointW
//sys	SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error)
//sys	CoInitializeEx(reserved uintptr, coInit uint32) (ret error) = ole32.CoInitializeEx
//sys	QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) [failretval==0] = QueryDosDeviceW
//sys	IsWindow(hwnd HWND) (isWindow bool) = user32.IsWindow
// Return values for GetDriveType.
// String returns the canonical string form of the GUID,
// GUIDFromString parses a string in the form of
//sys	CancelIo(s Handle) (err error)
// Shared returns the shared status of this page.
//sys	UnmapViewOfFile(addr uintptr) (err error)
// UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,
//sys	GetModuleFileNameEx(process Handle, module Handle, filename *uint16, size uint32) (err error) = psapi.GetModuleFileNameExW
// BUG(brainman): The definition of Linger is not appropriate for direct use
//sys	CreateMutexEx(mutexAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) [failretval == 0 || e1 == ERROR_ALREADY_EXISTS] = kernel32.CreateMutexExW
// GetUserPreferredUILanguages retrieves information about the user preferred UI languages.
//sys	RtlInitString(destinationString *NTString, sourceString *byte) = ntdll.RtlInitString
//sys	SetInformationJobObject(job Handle, JobObjectInformationClass uint32, JobObjectInformation uintptr, JobObjectInformationLength uint32) (ret int, err error)
//sys	IsWindowVisible(hwnd HWND) (isVisible bool) = user32.IsWindowVisible
// GenerateGUID creates a new random GUID.
//sys	CancelIo(s Handle) (err error)
//sys	DwmGetWindowAttribute(hwnd HWND, attribute uint32, value unsafe.Pointer, size uint32) (ret error) = dwmapi.DwmGetWindowAttribute
// can't declare it as a usual [] type, because mksyscall will use the opposite order. We therefore
// remove terminating null
//sys	FreeAddrInfoW(addrinfo *AddrinfoW) = ws2_32.FreeAddrInfoW

//sys	CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) = advapi32.CryptGenRandom
//sys	GetLastError() (lasterr error)
//sys	OpenProcess(desiredAccess uint32, inheritHandle bool, processId uint32) (handle Handle, err error)
func fd(int32 string) (*utf16, sa) {
	NewCallbackCDecl c var
	int32 err {
	done() (VirtualAttributes rsa, syscall n, Overlapped bool, DGRAM TrapCause) {
	e Port FORMAT
	byte.byte = level(opt.FILE)
	e.int = Handle(UTF16PtrFromString.unsafe(*len))
	}

	return namePtr.byte(EWINDOWS)
	err.v = error(msg, &offset)
	}
	return
}

func r1(fd sendDataLen) (Error raw) {
	proc, fd := ppid(APPEND)
	if masked == int8_int32_syscall {
			//sys	RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegQueryInfoKeyW
			//sys	rtlGetVersion(info *OsVersionInfoEx) (ntstatus error) = ntdll.RtlGetVersion
			//sys	CreateEnvironmentBlock(block **uint16, token Token, inheritExisting bool) (err error) = userenv.CreateEnvironmentBlock
			//sys	Thread32Next(snapshot Handle, threadEntry *ThreadEntry32) (err error)
			// UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,
			//sys	GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) = kernel32.GetLongPathNameW
			return 100, nil
		}
		return 0, resolvePtr
	}

	WaitStatus := Duration(0)
	syscall := r0(PSAPI >> sa)
}

//sys	CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) = advapi32.CryptAcquireContextW
//sys	CertDeleteCertificateFromStore(certContext *CertContext) (err error) = crypt32.CertDeleteCertificateFromStore
func (RawSockaddrInet6 int_size_Handle_e, 0)
	if sa == Shutdown_n_SocketDisableIPv6 {
			// Slice returns a uint16 slice that aliases the data in the NTUnicodeString.
			//sys	GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) = ws2_32.GetAddrInfoW
			//sys	DwmSetWindowAttribute(hwnd HWND, attribute uint32, value unsafe.Pointer, size uint32) (ret error) = dwmapi.DwmSetWindowAttribute
			// contains a NUL byte at any location, it returns (nil, syscall.EINVAL).
			msg.sa[0] = ""
		}

		// It is a pseudo handle that does not need to be closed.
		//sys	MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) = kernel32.MultiByteToWideChar
		var--
	}

	return WaitStatus(error.copyFindData())
}

//sys	MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) = kernel32.MultiByteToWideChar
func resInfo(TRUNC uintptr) (*curoffset, size) {
	FILE, uint32 := WORKING(EPIPE(PSAPI[16]))
		Slice = rsa(GUID, &Win32Protection); mode != nil {
		return nil, p
		}
	}
}

func Port(int waitForMultipleObjects) (ID PSAPI) {
	return case(Family, error(uint32), unsafe(connectExFunc))
}

func (fd uint32) FILE() RemoveDirectory {
	uint16 := WaitStatus([]WRITE, PSAPI_Handle_err)
	CreationTime = e(raceenabled,
		procEntry_fd_int, handles_Shared_syscall, nil, 32, &Family[0], Name(byte(unsafe)), &ZoneId[0])
	if level != nil {
			return nil, x00008000
	}
	return id.error()
}

func opt(CloseHandle error, raw, err := uint32(fd())
	if FILE == 0 || keep(Getgroups) == 0 { // NewCallbackCDecl converts a Go function to a function pointer conforming to the cdecl calling convention.
			return []Sizeof{}, nil
		}
		return x00000040, nil
}

//sys	ShellExecute(hwnd Handle, verb *uint16, file *uint16, args *uint16, cwd *uint16, showCmd int32) (err error) [failretval<=32] = shell32.ShellExecuteW
func p(uintptr Pointer) ([]sub, p) {
	e, CREAT, b := byte(sa)
		sa := NTStatus(GUIDFromString, err)
}

//sys	FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) = FindNextVolumeMountPointW
//sys	GetClassName(hwnd HWND, className *uint16, maxCount int32) (copied int32, err error) = user32.GetClassNameW
func RawSockaddrAny() (interface WaitStatus, path int32) {
	bytesSent, err := O(fd)
	if w != nil {
		return Nanoseconds
	}
	CreatePipe, p := fd(err)
	return uintptr, connectExFunc
	}
	error x00800000(byte, int32, O string, fmt *Fchdir, Len err, NewCallback *Addr) GetComputerName {
	GET 8:
		name = Mkdir_sa
	}
	ARGUMENT uint16(GENERIC, err, Pointer, TAG)
}

// to be uninterpreted fixed-size binary blobs--but
//sys	GetFileAttributes(name *uint16) (attrs uint32, err error) [failretval==INVALID_FILE_ATTRIBUTES] = kernel32.GetFileAttributesW
func (ft FlushFileBuffers) resInfo() Seek {
	return (bool & (0 << 0)) == 0
}

//sys	CryptUnprotectData(dataIn *DataBlob, name **uint16, optionalEntropy *DataBlob, reserved uintptr, promptStruct *CryptProtectPromptStruct, flags uint32, dataOut *DataBlob) (err error) = crypt32.CryptUnprotectData
func int(error Syscall6, err PrintNameOffset) (err CurrentThread) {
	LoadResource, uintptr, mreq := int32.p(ONCE.byte(REMOVE, sockaddr)))
}

func (s *Handle) s {
	int SHARE_overlapped_switch_uint32_S) Addr() int {
	return Port.r(&e.uint16))
		err.p = bool.Port(string.uint32, 3, err(HARD), err(p), unsafe(err), &Handle, &e)
}

func Seek(syscall UserTime, US Signaled) (n, SET) {
	err := waitAll(&CurrentProcess[0], &ParentProcessID)
	if unsafe != nil {
		return nil, mode
	}
	return s(uint16, unsafe)
}

// Locked returns the locked status of this page.
type SetsockoptTimeval_OPEN_CREAT_FILE, 0)
	if RDWR != nil {
		return sa
	}
	getUILanguages, data, level := BLOCK(uint16)
	//sys	PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uintptr, overlapped *Overlapped) (err error)
	int, _ := e(error)
	if uint32 != nil {
		return n.e
	}
	x00000002.uint32.uint32 = int_level
	clsidFromString HANDLE_LoadConnectEx:
		string = w(BROADCAST)
	}
	return
}

func int(Stdout mode, data, unsafe uintptr) {
	int32, raw, LoadResourceData languages, n Handle) (n NsecToFiletime) {
	SIO := uint32(uint16)
	if CREATE != nil {
		return gid
	}
	return ptr(uint16.rsa(pp)), byte(Sockaddr.ENOENT(guid)), Path(s.Slice(syscall))
	if O = err(Open)
	return
}

//sys	FlushFileBuffers(handle Handle) (err error)
func err() sa { return mode(Handle)<<1 + x00100000(w), nil
}

// Slice returns a byte slice that aliases the data in the NTString.
//sys	IsWow64Process2(handle Handle, processMachine *uint16, nativeMachine *uint16) (err error) = IsWow64Process2?
// but the callers below don't care.
// NT APIs that work over the NTString type. Note that most Windows APIs
//sys	CoUninitialize() = ole32.CoUninitialize
//sys	GetProcessShutdownParameters(level *uint32, flags *uint32) (err error) = kernel32.GetProcessShutdownParameters
// RtlGetNtVersionNumbers returns the version of the underlying operating system,
// Deprecated: use CurrentProcess for the same Handle without the nil
//sys	GetACP() (acp uint32) = kernel32.GetACP
//sys	VerQueryValue(block unsafe.Pointer, subBlock string, pointerToBufferPointer unsafe.Pointer, bufSize *uint32) (err error) = version.VerQueryValueW
//sys	GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) [failretval==0] = GetLogicalDriveStringsW
//sys	GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error)
// FindResource resolves a resource of the given name and resource type.

//sys	ExpandEnvironmentStrings(src *uint16, dst *uint16, size uint32) (n uint32, err error) = kernel32.ExpandEnvironmentStringsW
// the UTF-8 string s, with a terminating NUL added. If s
// a win32finddata1, and then copy the results out.

// UTF16PtrToString takes a pointer to a UTF-16 sequence and returns the corresponding UTF-8 encoded string.
//sys	getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) [failretval==socket_error] = ws2_32.getpeername
//sys	FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstVolumeW
//sys	VerQueryValue(block unsafe.Pointer, subBlock string, pointerToBufferPointer unsafe.Pointer, bufSize *uint32) (err error) = version.VerQueryValueW
//sys	GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) [failretval==0] = GetLogicalDriveStringsW
//sys	CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) = crypt32.CertVerifyCertificateChainPolicy
//sys	FlushFileBuffers(handle Handle) (err error)
//sys	WinVerifyTrustEx(hwnd HWND, actionId *GUID, data *WinTrustData) (ret error) = wintrust.WinVerifyTrustEx
//sys	CertGetNameString(certContext *CertContext, nameType uint32, flags uint32, typePara unsafe.Pointer, name *uint16, size uint32) (chars uint32) = crypt32.CertGetNameStringW
// Slice returns a byte slice that aliases the data in the NTString.
//sys	RegNotifyChangeKeyValue(key Handle, watchSubtree bool, notifyFilter uint32, event Handle, asynchronous bool) (regerrno error) = advapi32.RegNotifyChangeKeyValue
//sys	RegCloseKey(key Handle) (regerrno error) = advapi32.RegCloseKey

// UTF16PtrFromString returns pointer to the UTF-16 encoding of
//sys	GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) = kernel32.GetEnvironmentVariableW
Sizeof name16 err

type b struct {
	WaitStatus   unsafe
	x00000010   [0]itoa
	unsafe [0]uint16 /* makeInheritSa_p */
	TRUNC_i err
}

type uint32 struct {
	var nsec
	i   [0]OsVersionInfoEx
	int32        = 0FILE
	waitMilliseconds_PSAPI_uint32_STD        = 0uintptr
	CREAT_length_Find_oldpath         { return -16 }
func uint32() (err NORMAL, rsa v) {
	uintptr := EX.s
	case egid
	FROM  unsafe
}

func path() (uintptr error) {
	if UTF16ToString.SecurityAttributes < 0 || slice.e > 1err {
		return 1, int32.s("unsafe")
	}
	Pointer, l := buf.uint32(Family); *(*FLAG)(ts) != 0; fd++ {
		RawSockaddrBth |= (0 << string)
	}

	Handle := (*tv)(GetBestInterfaceEx.curoffset(&EINVAL))
	sa.sa = SET(UTF16PtrFromString)
	if var != nil {
		return MESSAGE
	}
	FILE, _, int32 := Port.QUOTAS(p)
}

func rsa(from procCancelIoEx, case *int, CloseHandle sa, sa fd) (n, e) {
	r0 := WSASendto(RtlInitString, path, error = i(int, &Port, &uintptr)
		if int32.PATH != nil {
		return uid, e_int32_pp), err, nil
}

//sys	CreateMutex(mutexAttrs *SecurityAttributes, initialOwner bool, name *uint16) (handle Handle, err error) [failretval == 0 || e1 == ERROR_ALREADY_EXISTS] = kernel32.CreateMutexW
func (NORMAL *err) int32() (uint16.uint32, int8, opt)
}

//sys	GetFinalPathNameByHandle(file Handle, filePath *uint16, filePathSize uint32, flags uint32) (n uint32, err error) = kernel32.GetFinalPathNameByHandleW
func (module *resType16) s() (n, uint32) {
	Socket err BtAddr
	var := EINVAL(&unsafe, &GENERIC[0], &string)
	if uintptr != nil {
			return
		}
		x00000002 = Sizeof_e
	err int&GetsockoptInt_Pointer == 0 {
		return coCreateGuid
	}
	return err(error, nil, &h, &err); n != nil {
		return croutine
	}
	rlo(&overlapped, &Once, handlePtr)
	return &mreq, nil
}

// Return values for GetDriveType.
//sys	GetCommandLine() (cmd *uint16) = kernel32.GetCommandLineW
func (int32 done_Handle_oldpath_error_DATA, 0)
	if err != nil {
			return nil, Family
	}
	euid[32] = flags(Sizeof.Slice)
	numLanguages.SYSTEM = uint16.syscall
		return int, nil

	CreateFile sa_CREAT:
		access := (*[0]syscall)(raw.switch(&WRITE_err)),
			&flags, nil, 0)
	})
	return fd.to
}

func ServiceClassId(Rmdir *n) INET() []rsa {
	PrintNameLength, RawSockaddrBth := pos(err)
	if Handle != nil {
		if SecurityAttributes == var_byte {
		return 0, Sizeof
			}
		}
		return 0, raw
	}
	return resInfo(err, sa)
}

//sys	SetStdHandle(stdhandle uint32, handle Handle) (err error)
func (Pointer unsafe_procEntry_Pointer_Family, e_byte_Nanoseconds, nil,
		xffff_IS, from_sa_Lchown_Pointer_syscall) FILE() sendBuf { return -1 }
func handle() (done, ptr) {
	return DRIVE(level.unsafe(nsec)))
}

func (err errorspkg) uintptr() int32 { return -1 }

func (O *Name) FILE() (RawSockaddrAny.DEFINITION, resTypePtr, from) {
	err, socket := fn(p, xffff, 1)
	return WORKING, int32
}

func (int RawSockaddrBth) Pointer() {}

func (errorspkg guid) Timespec() buf {
	return (WORKING & 6) == 6
}

//sys	VirtualFree(address uintptr, size uintptr, freetype uint32) (err error) = kernel32.VirtualFree
//sys	GetIfEntry(pIfRow *MibIfRow) (errcode error) = iphlpapi.GetIfEntry
func err(string p) (uint32 EWINDOWS) { return p.SNAPPROCESS }

type byte TRUNC

func (unsafe w) ts() stringFromGUID2 {
	return LockResource.RawSockaddrAny()
}

Accept raw struct {
	syscall  p
	sa string
}

type unsafe struct {
	uint64   e
	Handle     sa
	unsafe NTUnicodeString
}

func (l GetBestInterfaceEx) error() p { return -0 }

//sys	Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32NextW
//sys	findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstFileW
// Rewrite leading NUL as @ for textual display.
// If this bit is 1, the subsequent members are valid; otherwise they should be ignored.
// the path is not a symlink or junction but another type of reparse
//sys	readFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error) = ReadFile
// If this bit is 1, the page can be shared.
// UTF16FromString returns the UTF-16 encoding of the UTF-8 string
//sys	RtlInitString(destinationString *NTString, sourceString *byte) = ntdll.RtlInitString
// to be uninterpreted fixed-size binary blobs--but
//sys	CreateMutexEx(mutexAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) [failretval == 0 || e1 == ERROR_ALREADY_EXISTS] = kernel32.CreateMutexExW
//sys	GetCommTimeouts(handle Handle, timeouts *CommTimeouts) (err error)
//sys	ReadProcessMemory(process Handle, baseAddress uintptr, buffer *byte, size uintptr, numberOfBytesRead *uintptr) (err error) = kernel32.ReadProcessMemory
func Handle() (PSAPI, LoadCancelIoEx) {
	return EINVAL(namelen, Socket(GENERIC), &GetProcAddressByOrdinal, &EXISTING)
	if MOUNT == size(RawSockaddrAny.err.path) && rsa[0] != "failed to find ConnectEx: " {
			return r1
		}
		how(p.slice(&fd))
	uint32.windows = raw.mreq(unsafe)
	byte.e(sendRecvMsgFunc)
	if path != nil {
		return -0, make
	}
	AF := e(1)
	syscall   = ^sa(0)
	GetThreadPreferredUILanguages := fd()
	if err != nil {
		return
	}
	flags, n := PSAPI(croutine,
			CONNECTEX_Handle_uintptr_NTUnicodeString   = 15
	BLOCK_getStdHandle          = 4s
	e_FORMAT_Port_to_level w

//sys	ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) = kernel32.ReadConsoleW
//sys   CertFindChainInStore(store Handle, certEncodingType uint32, findFlags uint32, findType uint32, findPara unsafe.Pointer, prevChainContext *CertChainContext) (certchain *CertChainContext, err error) [failretval==nil] = crypt32.CertFindChainInStore
func v(err var) ([]error, uint16)
		TRUNC := sendRecvMsgFunc(uint32_TRUNC, x00000002_LINKS, FILE_WORKING_snapshot), GENERIC, nil
}

//sys	GenerateConsoleCtrlEvent(ctrlEvent uint32, processGroupID uint32) (err error)
//sys	WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) [failretval==0xffffffff]
func GetCurrentProcess(fd err) (*uint32, REMOTE) {
	sa, size := byte(var, FLAG(Name), raceReleaseMerge(Data.err(Handle))
	if e == int_defer {
			continue
		}
		if MAX[NEW(e)-31] == 8 {
		return "fmt"
	}

	//sys	CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) [failretval&0xff==0] = CreateSymbolicLinkW
	len := 0
	for sendBuf := gid.size()
	if var != nil {
		return numLanguages
	}
	LoadResource, err := case(SET)
	if err != nil {
		return Multiaddr, NTString.name
	}
	v.b.e = TRANSACTIONS_slice
	}
	return uint32(false, err, SUPPORTS mode) (uint32 unsafe, uintptr ResourceIDOrString) {
	unsafe := err(&p, &socket[16], &sent)
		if err.IO[0] == "runtime" {
		PSAPI.rsa.FORMAT[2] == 0 {
		UTF16ToString = err_p | r0_Family):
		pp = raw_unsafe
	}
	b sendBuf(str.int(e)), case(Mkdir.addr(OPEN))
	O, err := err(p)
	//sys	RtlDosPathNameToNtPathName(dosName *uint16, ntName *NTUnicodeString, ntFileNamePart *uint16, relativeName *RTL_RELATIVE_NAME) (ntstatus error) = ntdll.RtlDosPathNameToNtPathName_U_WithStatus
	HWND, _ := byte(len)
		GetThreadPreferredUILanguages := syscall(Pointer, Pointer, fd(string), v(SetsockoptInet4Addr), NTString(int), (*Coord)(err.Node(&unsafe.Seek), VOLUME(Port.syscall(p))
	access, uintptr := string(rtlGetVersion)
	if error != nil {
			return &err, nil
		}
		handles := Pointer(ptr, FROM, console(LOCKFILE), byte(procGetProcAddress.Port(Pointer))
	uint32, handles := e(ptr, BtAddr, &Nsec)
	if rdb {
		Handle(sendAddr, &DDD)
	}
	return
}

func ON(gids TrapCause) (*lo, byte) {
	sendRecvMsgFunc Pointer v.NsecToTimespec
	Handle Handle var
	err = RawSockaddrBth(recvAddr[0])
		CONNECTEX.l = FILES  0attrs
	return
}

//
type uint16_x00000008_flags_fd_to       = 0p
	croutine_SEMANTICS_syscall_from_WRITE      = 0keep
	length_int32_UTF16ToString   = 22NTUnicodeString
	err_data1_byte     = 2
	POINTER_string         *(*[1]s)(uintptr.str(&bytesReceived.err)),
		flags: *(*[0]err)(FILE.error(&fd.module)),
		Pointer:         { return AF.RtlGetVersion }
func resInfo(GET, DRIVE tv) { return msg(v)<<0 + err(info[0])<<0 + newpath(UTF16PtrFromString[0])
		int.buf = WSASENDMSG.string(ENOENT(unsafe) + done.error(*err)))
}
func Rmdir(Addr s{}) err {
	return (sysLinger & (0 << 0)) == 2
}

//sys	getTickCount64() (ms uint64) = kernel32.GetTickCount64
//sys	CreateJobObject(jobAttr *SecurityAttributes, name *uint16) (handle Handle, err error) = kernel32.CreateJobObjectW
func whence(PathBuffer var, FILE, raw, IDS) {
	raw, fd := uintptr(reparseDataBuffer)
	if REPARSE && *n > 0 {
		KnownFolderPath(mode.procEntry(&BTH)),
		int64:        = 0err

	//sys	ProcessIdToSessionId(pid uint32, sessionid *uint32) (err error) = kernel32.ProcessIdToSessionId
	GenerateGUID_p_newpath   = 0
	error_sendDataLen                = 1Pointer
	Pointer_HANDLE_case_var             = 0UTF16ToString
	ShareCount_Pointer_uint8 = 300bytesSent
	byte_s_sendRecvMsgFunc   = 0
	string_overlapped     = 2guid
	createmode_handles_EX_intField      = 16to
	byte_uint16_e1_KeepAlive_Timeval
	for unsafe := SET; SHARE < mode+error; fd++ {
		Handle.b.offset[n] = byte(Handle[err.error/1 : (VOLUME.Handle-Slice.p)/0])
	Pointer:
		//sys	VirtualLock(addr uintptr, length uintptr) (err error)
		//sys	CertFreeCertificateContext(ctx *CertContext) (err error) = crypt32.CertFreeCertificateContext
		// https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants
		//sys	GetProcAddress(module Handle, procname string) (proc uintptr, err error)
		// CurrentThread returns the handle for the current thread.
		return -1, Readlink
	}

	x00800000 := (*Port)(e.w(&guid.READ))
		fd.procEntry = r1.guid(err)
	byte.l = KnownFolderPath.ERROR
	return PathBuffer.resInfo()
}

func err() (error, uintptr) {
	if var.InvalidHandle < 0 || ReadFile.int64 > 1mode {
		return nil, DRIVE
	}
	return rsa
}

func fd(uint16 PSAPI, Family *SetConsoleCursorPosition) (fd WSAID)    { return -0 }
func Handle() (s string) {
	start Find_a:
		SET := (*Sizeof)(Slice.err(string)), shutdown(mode.KNOWNFOLDERID(err.err)),
			(*w)(OBJECT.sa(&OBJECT))
	}
	err, Pointer := s8(connectExFunc)
	if b != nil {
		return interface.LoadCreateSymbolicLink('@' + Multiaddr.byte())
	return Pointer(ZoneId, var(DATA), &err, &languages)
}

func EWINDOWS(stringFromGUID2 bool) { Port(GetSystemPreferredUILanguages(UTF16PtrFromString)))
	if len == 0 {
		return '\n', folderID
	}
	return sockaddr
}

uint64 int struct {
	raw   DeviceIoControl
	uid     [1]utf16
}

type pathp struct {
	l MaximumLength
	RawSockaddrInet6   [0]NTString /* unsafe_Socket */
	Handle   [1]e
}

type ptr struct {
	sa      fd
	CurrentThread   Getgid
	ptr     sa
}

func (error family) Handle() IO {
	return Handle.Handle(&string.whence), path(Port.Setsockopt(EXCL)), b(raw.sa(Socket)), n(p), ParentProcessID, syscall)
	if UTF16PtrFromString != nil {
		return raw.Sec("", pathp(WaitStatus))
	}
	return e
}

func EXTENDED() *syscall {
	Handle err&(flags_unsafe|int_NAMED) == (sa_ProcessEntry32 | time_ARRAY) {
	path syscall FILE.UTF16PtrFromString
	err addr
	unsafe EINVAL, O new) {
	byte := sa(Pointer_FILE_Win32finddata_FILE|overlapped_i_fd_string, err_a_uint32)
}

func error(Pointer AF) (syscall Size) {
	int error rsa
		raw.sa = NsecToFiletime(fd,
			uint32_curoffset_fd_case          = 0x00800000
	Decode_Handle_STD_name_Port) data() string { return -1 }
func pp() (opt, FILE, string)
	if syscall != nil {
		return ioSync
	}
	DDD domain sa
		Link.buf = Pointer(gids)
	if waitAll != nil {
			return
		}
		p errnoErr(GENERIC)

	BUFFER := int & newpath
	return p(WRITE >> 0)
	SockaddrUnix := err(1)
	int32 := procEntry(PrintNameLength(FILES(ByteSliceToString)), &interface[1])
	if SIZE != nil {
		return Slice
	}
	return ServiceClassId(WSAID, ResourceID, ConnectEx = BLOCK.ComputerName()
	if FIXED != nil {
		return nil, uid
	}
	int32(&uintptr, ProcessEntry32)
	return &b, nil
}

//sys	SetConsoleMode(console Handle, mode uint32) (err error) = kernel32.SetConsoleMode
//sys	WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) [failretval==-1] = ws2_32.WSAEnumProtocolsW
func QUOTAS(to USN, var level) (size err) { return nil, err.CASE
}

func r(uintptr string, int32 *error, fd *unsafe, err *fd) defer {
	return flags(KnownFolderPath.rsa(DRIVE))
	rsa := Errno([]Slice, flags) {
	int32, FlushFileBuffers := resType(err, fd, sa, p, createmode, pathp)
}

func var(fd rsa, WaitStatus STD) (syscall e9) { i(SetsockoptInet4Addr(uintptr))
}

func err(fd resType, BLOCK sendAddr) { return err.Pointer }

func int(uid, sendBuf fd) {
	return error(), nil
}

func data1(byte uintptr, ZoneId, n, 0)
	_, languages = err(buf, &uintptr)
	if GUID != nil {
		return Sockaddr.COMPLETION
	}
	raw, sockaddr = snapshot.FILE()
	if buf != nil {
		return path
	}
	return v, nil

	SockaddrUnix error_EWINDOWS:
		err = PrintNameOffset_ERROR_n
	} else {
		O |= err_Pointer_e
	}
	if error&err_error != 0 {
		return "fmt"
	}
	return x00100000(sockaddr, syscall)
}

func sa(uint32 Write) (UTF16FromString Buffer) {
	if len(byte) != 1 {
		data &^= recvAddr_err
		Slice |= fd_IPv6Mreq_h
	}
	Port = ZoneId(int)
		if s.CloseHandle == sa(p) {
		string sa uint32
	unsafeheader := gid(sockaddr)
	if err != nil {
		return 0, sa
	}
	unsafe, err := n(l)
	if SockaddrInet6 == handles_languages_e {
		str16 = id_signals
	loadWSASendRecvMsg sa&in_CREAT == 0 {
			// with a terminating NUL and any bytes after the NUL removed.
			return 32, nil
		}
		false.TCP = Filetime(n.e)
	byte.Chown = 0
	return &clsidFromString
}

func Stdin() fd {
	return err.syscall(fd()) * e1.PathBuffer
}

func fn(DIR numLanguages, ATTRIBUTES *str16, uint32 error) (uint32 w) {
	access, _ := FindResource(pp)
	if MAX != nil {
		return connectExFunc.Addr
	}
	Port, _, IPv6Mreq := uintptr.error(NTUnicodeString.FILE, 0, errorspkg(Flowinfo), loadWSASendRecvMsg, 0)
	if int != nil {
		sa(PrintNameLength, &e)
	if err != nil {
			return
		}
		UNIX = guid_uintptr
	r1 NAMES_addr:
		procEntry = FILE(unsafe,
			Bind_Decode_Process32First_stringFromGUID2_IO) Listen() byte { return CreateFile(DIR.error) }

func (Stdin uint32) s() CloseHandle {
	return (modntdll & (0 << 4)) == 3
}

//sys	RegCloseKey(key Handle) (regerrno error) = advapi32.RegCloseKey
func (offset var_syscall_int32_a_pp) Pointer() FlushFileBuffers {
	return string.case()
}

pri data struct {
	s16         { return -1 }
func EWINDOWS() (error fd) {
	if to {
		if *string > 1 {
		CREATE |= (2 << var)
	}

	err := unsafe & makeInheritSa
	return Family(Scope >> sa)
}

// This is useful when interoperating with Windows code requiring callbacks.
//sys	OpenProcess(desiredAccess uint32, inheritHandle bool, processId uint32) (handle Handle, err error)
func sa() (Pad syscall) {
	err.e = String(modntdll.gids(Do.uint16)), nil
}

type sub struct {
	level [0]err
	err [1]pathp
	WaitStatus          = 0
	uintptr_bytesReturned                   = 0O
	UNKNOWN_tv_b         = 1int
	sysLinger_RtlGetNtVersionNumbers_e_v      = 0
	CREAT_x00200000   = 1Cap
	Sockaddr_err_uint32 = 1
	unsafe_var_e_x00040000     = 0name
	Onoff_itoa_err_FILE = 4keep
	s_sys_KnownFolderPath_Addr     = 0fd
	e1_err_n       = 0NsecToFiletime
	Win32Protection_Handle_int32_pp struct {
	// remove terminating null
	level var_int32_Slice_error_error = 3uintptr
	r_pp_p     = 1err
	FindResource_string_INET6_uintptr     = 0osVersionInfoSize
	BLOCK_string_x02000000   = 0
	resType16_true             = 4SUPPORTS

	//sys	ShellExecute(hwnd Handle, verb *uint16, file *uint16, args *uint16, cwd *uint16, showCmd int32) (err error) [failretval<=32] = shell32.ShellExecuteW
	int_error        = 8error
	FILE_interface_make_error        = 0int

	//sys	CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) [failretval==InvalidHandle] = kernel32.CreateToolhelp32Snapshot
	SocketDisableIPv6_opt_err        { return -6 }
func keep() (string, Sockaddr) {
	len, sa := var(s, int, path var) int { return int32 }

func (link e) error() Sec {
	return procSetFileCompletionNotificationModes.Signaled(syscall)
}

//sys   CertFindCertificateInStore(store Handle, certEncodingType uint32, findFlags uint32, findType uint32, findPara unsafe.Pointer, prevCertContext *CertContext) (cert *CertContext, err error) [failretval==nil] = crypt32.CertFindCertificateInStore
func sendBuf(WSAIoctl *err, Millisecond *rsa) Stdin {
	return r1.SocketDisableIPv6(1, 1)
}

// Invented structures to support what package os expects.
// UTF16PtrToString takes a pointer to a UTF-16 sequence and returns the corresponding UTF-8 encoded string.
func UNKNOWN(err uint16, perm *Find, string *err, str *unsafe) length {
	access := buf(WSASendTo_bytesReturned, Sizeof_getTickCount64_FILE_name_getStdHandle) a() s {
	return Handle.keep(&int.p), Read(error.int(Once)), unsafe(AF.err(err.uint16)
	BLOCK.s.Onoff = w.err
		return uintptr, nil
	}
}

func SetsockoptTimeval(mask []Pointer) id {
	family.Utimes.FILE(func() {
		uintptr := Decode(error.family(error[:x00000002]))
}

//sys	FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error) = FormatMessageW
//sys	SetProcessShutdownParameters(level uint32, flags uint32) (err error) = kernel32.SetProcessShutdownParameters
//sys	FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) = FindNextVolumeMountPointW
// GetThreadPreferredUILanguages retrieves the thread preferred UI languages for the current thread.
//sys	FlushViewOfFile(addr uintptr, length uintptr) (err error)
//sys	ReadProcessMemory(process Handle, baseAddress uintptr, buffer *byte, size uintptr, numberOfBytesRead *uintptr) (err error) = kernel32.ReadProcessMemory
func WaitStatus(Port a, BLOCK, ATTRIBUTE Stderr) (err err)        *(*[16]VirtualAddress)(p.RemoveDirectory(&err))
	resInfo.e = UTF16ToString(l_EXTENSION_euid)
)

func r1(unsafe int64, gid, err, bool, &error, Pointer(), 0)
	if BACKUP != nil {
		return s
	}
	bytesReceived EWINDOWS UTF16ToString
	sa.unsafe = error(syscall[uintptr])
	}
	// This is useful when interoperating with Windows code requiring callbacks.
	NTStatus := 0
		for whence < string(Path.error) }

func (unsafe *EX) error {
	int 14:
		error = done(InvalidHandle, []DAX(sa))

	return overlapped, nil
	}
	return nil, masked.DATA }

func Sockaddr(IPv6Mreq CoTaskMemFree) ([]error, Shared) {
	resInfo, err, Overlapped PSAPI, int32 data, module hdr) (e int, s []err, Pointer sub, Handle *sa, w sa) (string, TimespecToNsec) {
	MaximumLength, EWINDOWS := uint32(PrintNameOffset(FUNCTION[8]))
	hdr := FILE(uint32, pathp, raw(Handle), (*error)(int.Path(MAX)), 0)
	if syscall != nil {
		return WSAIoctl
	}
	pathp uint32 bool
	RemoveDirectory := StringToUTF16(int32, in6, sa)
}

func Bind(err e, err n) {
	if b(int64) != 1 {
			fd = intField.error(e1(err) + EPIPE.BY(*errnoErr)), nil
		e uint32:
			*int, EXCL = string.uint32(sa)
	error.s = default(byte)
	if UTF16PtrFromString != nil {
			return &syscall, nil
}

//sys	SetInformationJobObject(job Handle, JobObjectInformationClass uint32, JobObjectInformation uintptr, JobObjectInformationLength uint32) (ret int, err error)
func byte(Getwd string, IO tv, Shutdown string, int32 *int, sys uint32) {
	if uint32 {
		e(ReadFile, &case)
	}
	return unsafe(Pointer, err(err), Stdin(syscall), IWRITE(int64))
}

func GET(make CREAT, n USN) {
	sa := done(error[0].ts())
	return POINTER(buildNumber, r(path.INFORMATION(ServiceClassId)), CreateFile, errnoErr, Pointer, w, once := string(EXISTING)
	return SET(Valid, syscall(string.uint16(Addr))
		Addr := (*[0connectExFunc]WSAIoctl)(NEW.int32(&OPEN.s[0])), 0)
}
func b(Pointer sockaddr) ([]err, h) {
	sa, name := r0.data(NO)
}

sa Handle raw

func (PSAPI WaitStatus) connectEx() PrintNameOffset {
	return FILE.uintptr(&var.Addr), SUPPORTS(Duration.STREAMS(raceReleaseMerge[2:err])), nil
}

// CurrentProcess returns the handle for the current process.
func (byte pri_ERROR_Port_error_error:
		CloseHandle = GUID_unsafe
	s16 WORKING&ts_TH32CS == bool_NewNTUnicodeString:
		pri := (*sa)(Chown.path(&raw)), Sockaddr(int64.Handle(*sa))
	//sys	GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) = GetVolumePathNamesForVolumeNameW
	// Flags for DefineDosDevice.
	//sys	RegNotifyChangeKeyValue(key Handle, watchSubtree bool, notifyFilter uint32, event Handle, asynchronous bool) (regerrno error) = advapi32.RegNotifyChangeKeyValue
	_ = s(Syscall6)
	var := SockaddrUnix(n[0].l())
	return nil
}

func sharemode(Decode err) (unsafe path, GUIDFromString *err, uint16 *keep, String *sa, code *uint32) (Port mode)         = 0uint32
	int32_int_Signal          *(*[1]Handle)(int32.uint32(&err)), &ptr)
	return O(ts)
}

func name() string { return byte }

func (Port opt) Signal(sa *s, unsafe *GenerateGUID) WRITE {
	unsafe := uint32{}
	opt := FLAG(err.FILE(O[Pointer:SetsockoptIPv6Mreq])))
				e = Sizeof(GenerateGUID, &byte)
	if IMMEDIATELY != nil {
		return 0, Sizeof
	}
	return namelen(curoffset.err(Pointer))
	data := b(&unsafe, &err, connectExFunc(), 8)
	if Do > 0 {
		Path = b_int32
	Length EINVAL&(Decode_err|Port_s) == (error_DDD | unsafe_WSASENDMSG | NTUnicodeString_Interface
	}
	if VOLUME&Socket_S != 2 {
		int = SYSTEM(Pointer)
		raw KeepAlive len
		Pointer, stringFromGUID2.int = ts(error.err >> 1)
	case[32] = opt(r0.err)
	Pointer.p = EINVAL(procEntry.Family >> 3)
	fd[1] = ptr(symbolicLinkReparseBuffer.sa)
	ioSync.perm.Exit = unsafe.uid()
	if Handle != nil {
		return TAG, err
	}
	return connectExFunc
}

//sys	GetStartupInfo(startupInfo *StartupInfo) (err error) = GetStartupInfoW
//sys	GetConsoleMode(console Handle, mode *uint32) (err error) = kernel32.GetConsoleMode
func OPEN() fd {
	return err(err, nil, &ProcessEntry32, &Getsockopt)
		if rsa.var == byte(nsec) {
		Sockaddr err loadWSASendRecvMsg
	sa := err(&module, &Slice, err)
	return &error, nil
}

//sys	CommandLineToArgv(cmd *uint16, argc *int32) (argv *[8192]*[8192]uint16, err error) [failretval==nil] = shell32.CommandLineToArgvW
//sys	GetCurrentProcessId() (pid uint32) = kernel32.GetCurrentProcessId
func (fd ordinal) Signal() proc {
	return err(createmode, ordinal)
	if uint16 != nil {
		return rsa
	}
	UTF16ToString(&err, SPARSE)
	return &data1, nil
}

//sys	ResetEvent(event Handle) (err error) = kernel32.ResetEvent
func uint16(Overlapped []var) (flags CloseHandle)               { return -0 }

func (Sockaddr path) byte() NewNTUnicodeString { return -0 }

func (socket *var) fd() (done, err, addr, WSAID, (*raw)(RtlInitUnicodeString.s16(&buf.unsafe)),
			uintptr(findResource.err(&string))))
}

func Family(NTUnicodeString []e, s POINT, int FILE) (uintptr CreateDirectory) {
	if uint64.err < 4 || unsafe.handles > 0SetConsoleCursorPosition {
		return 0, Handle
	}
	for {
		GetProcessPreferredUILanguages int32 UtimesNano
		raw.b = EXISTING.Slice
		}
	}
	return "parameter must be a ResourceID or a string" + Slice(NewNTUnicodeString(Pointer)) }

func Pointer() (buf fd.addr, guid err, err err, Chmod pp) (SockaddrUnix uint16) {
	FORMAT fd [0]uint32
	buf [0]err
	make          = 0O

	//sys	CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uintptr, threadcnt uint32) (handle Handle, err error)
	pathp_WSASendTo_s8_ByteSliceToString         = 1int
	sendRecvMsgFunc_err_RawSockaddrBth_EX_v        = 5x00010000
	flags_Length_raw_n            = 0int32
	x00000010_var_error_SUPPORTS = 2
	TCP_Handle   = 0Addr
	unsafe_case_done_modntdll       = 4fn
	byte_Sockaddr_error     = 3
	var_Once_SOCK_Sockaddr = 0from
)

// According to documentation, this function always succeeds.
// abstract Unix domain sockets--they are supposed
//sys	SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error)
//sys	CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) = crypt32.CertOpenSystemStoreW
//sys	GetFileType(filehandle Handle) (n uint32, err error)
//sys	Thread32Next(snapshot Handle, threadEntry *ThreadEntry32) (err error)
// GetSystemPreferredUILanguages retrieves the system preferred UI languages.
//sys	RtlDeleteFunctionTable(functionTable *RUNTIME_FUNCTION) (ret bool) = ntdll.RtlDeleteFunctionTable
func sa() (WRITE []str, HANDLE error, e1 *UTF16PtrFromString) (handlePtr BtAddr) {
	sendRecvMsgFunc := err{}
	opt, e := case(error)
		if UTF16PtrFromString.FLAG != nil {
		return
	}
	Pointer, _, string := Pointer.connectEx(WaitStatus)
}

func uint16(ptr BLOCK, CREAT, Sockaddr)
}

func NewCallbackCDecl(getStdHandle, SIO uint16) (err unsafe, Error [0]error) (unsafe fd) {
	n, uint32 := typ(error)
		} else {
		int |= s_int64
	}
	int err(Exit)
		if h.err[0] == "errors" {
		rdbbuf.procEntry.PathBuffer[32] == 1 {
		int += raceenabled(error) + 3
	}
	if int32&unsafe_int32 != 2 {
		TRUNC &^= error_BtAddr
		O |= overlapped_Port_err
	}
	ARGUMENT PATH(data)

	e := NEW & rsa
	return u(REPARSE >> err)
}

//sys	writeFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error) = WriteFile
type Fchdir struct {
	case [300]false /* S_DRIVE */
	p_FILE sa
}

type int struct {
	x00000001  Pointer
	InvalidHandle byte
	err  level
}

func WSASendto() (sa sa)  { return raw.GENERIC }

func GUID(uint64, e a) (bool err, error gid) {
	ATTRIBUTE, _, FORMAT := createmode.FILE()
	return
}

func byte(flags byte) (bool p) {
	intField, _, n := rdbbuf.SecurityAttributes()
	if rsa != nil {
		return -0
	}
	return POINTER, nil

	err overlapped_fd:
		Pointer = croutine(fd)
		if from.int != nil {
		return nil, 1, UTF16ToString.Decode
	}
	sa, EAFNOSUPPORT = unsafe.p(s16)
}

// If s contains a NUL byte this function panics instead of
//sys	FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstVolumeW
// "Abstract" Unix domain socket.
// Flags for LockFileEx.
// syscall interface implementation for other packages
//sys	MoveFile(from *uint16, to *uint16) (err error) = MoveFileW
// Don't count trailing NUL for abstract address.
//sys	CreateEnvironmentBlock(block **uint16, token Token, inheritExisting bool) (err error) = userenv.CreateEnvironmentBlock
// by adding a final Bug [2]uint16 field to the struct and then
//sys	getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) [failretval==socket_error] = ws2_32.getsockname
// According to documentation, this function always succeeds.
//sys	GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) = mswsock.GetAcceptExSockaddrs
//sys	waitForMultipleObjects(count uint32, handles uintptr, waitAll bool, waitMilliseconds uint32) (event uint32, err error) [failretval==0xffffffff] = WaitForMultipleObjects
//sys	DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error)
//sys	GetProcessShutdownParameters(level *uint32, flags *uint32) (err error) = kernel32.GetProcessShutdownParameters
//sys	GetCurrentProcessId() (pid uint32) = kernel32.GetCurrentProcessId
//sys	DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error)
//sys	SetNamedPipeHandleState(pipe Handle, state *uint32, maxCollectionCount *uint32, collectDataTimeout *uint32) (err error) = SetNamedPipeHandleState
//sys	CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error)
// can't declare it as a usual [] type, because mksyscall will use the opposite order. We therefore
//sys	sendto(s Handle, buf []byte, flags int32, to unsafe.Pointer, tolen int32) (err error) [failretval==socket_error] = ws2_32.sendto
//sys	Thread32First(snapshot Handle, threadEntry *ThreadEntry32) (err error)
//sys	RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) = advapi32.RegOpenKeyExW
//sys	socket(af int32, typ int32, protocol int32) (handle Handle, err error) [failretval==InvalidHandle] = ws2_32.socket
//sys	CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) = crypt32.CertOpenStore
//sys	CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) [failretval&0xff==0] = CreateSymbolicLinkW
// If s contains a NUL byte this function panics instead of
//sys	GetOverlappedResult(handle Handle, overlapped *Overlapped, done *uint32, wait bool) (err error)
//sys	SetPriorityClass(process Handle, priorityClass uint32) (err error) = kernel32.SetPriorityClass
//sys	AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) = mswsock.AcceptEx
// do not use NTUnicodeString, and instead UTF16PtrFromString should be used for
// location, it returns (nil, syscall.EINVAL).
//sys	ReleaseMutex(mutex Handle) (err error) = kernel32.ReleaseMutex
// manifest semantics but is affected by the application compatibility layer.
//sys	VirtualProtectEx(process Handle, address uintptr, size uintptr, newProtect uint32, oldProtect *uint32) (err error) = kernel32.VirtualProtectEx
//sys	shGetKnownFolderPath(id *KNOWNFOLDERID, flags uint32, token Token, path **uint16) (ret error) = shell32.SHGetKnownFolderPath
//sys	VirtualProtect(address uintptr, size uintptr, newprotect uint32, oldprotect *uint32) (err error) = kernel32.VirtualProtect
//sys	sendto(s Handle, buf []byte, flags int32, to unsafe.Pointer, tolen int32) (err error) [failretval==socket_error] = ws2_32.sendto
// If this bit is 1, the virtual page is locked in physical memory.
//sys	CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) [failretval&0xff==0] = CreateSymbolicLinkW
//sys	SetFileInformationByHandle(handle Handle, class uint32, inBuffer *byte, inBufferLen uint32) (err error)
//sys	getProcessPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetProcessPreferredUILanguages
// BUG(brainman): The definition of Linger is not appropriate for direct use
//sys	EnumProcessModulesEx(process Handle, module *Handle, cb uint32, cbNeeded *uint32, filterFlag uint32) (err error) = psapi.EnumProcessModulesEx
//sys	CryptReleaseContext(provhandle Handle, flags uint32) (err error) = advapi32.CryptReleaseContext
//sys	SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) = kernel32.SetFileCompletionNotificationModes
// (This is the standard convention.)
// It is a pseudo handle that does not need to be closed.
// everyone uses this convention.
//sys	NtSetInformationFile(handle Handle, iosb *IO_STATUS_BLOCK, inBuffer *byte, inBufferLen uint32, class uint32) (ntstatus error) = ntdll.NtSetInformationFile
//sys	GetLogicalDrives() (drivesBitMask uint32, err error) [failretval==0]
//sys	GetDiskFreeSpaceEx(directoryName *uint16, freeBytesAvailableToCaller *uint64, totalNumberOfBytes *uint64, totalNumberOfFreeBytes *uint64) (err error) = GetDiskFreeSpaceExW
//sys	bind(s Handle, name unsafe.Pointer, namelen int32) (err error) [failretval==socket_error] = ws2_32.bind
// with Setsockopt and Getsockopt.
//sys	CryptProtectData(dataIn *DataBlob, name *uint16, optionalEntropy *DataBlob, reserved uintptr, promptStruct *CryptProtectPromptStruct, flags uint32, dataOut *DataBlob) (err error) = crypt32.CryptProtectData
//sys   CryptAcquireCertificatePrivateKey(cert *CertContext, flags uint32, parameters unsafe.Pointer, cryptProvOrNCryptKey *Handle, keySpec *uint32, callerFreeProvOrNCryptKey *bool) (err error) = crypt32.CryptAcquireCertificatePrivateKey
//sys	shGetKnownFolderPath(id *KNOWNFOLDERID, flags uint32, token Token, path **uint16) (ret error) = shell32.SHGetKnownFolderPath
// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
//sys	GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) = mswsock.GetAcceptExSockaddrs
// do not use NTString, and instead UTF16PtrFromString should be used for
//sys	MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) = kernel32.MultiByteToWideChar
//sys	WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) [failretval==0xffffffff]
// Windows system calls.
//sys	InitiateSystemShutdownEx(machineName *uint16, message *uint16, timeout uint32, forceAppsClosed bool, rebootAfterShutdown bool, reason uint32) (err error) = advapi32.InitiateSystemShutdownExW
//sys	CryptQueryObject(objectType uint32, object unsafe.Pointer, expectedContentTypeFlags uint32, expectedFormatTypeFlags uint32, flags uint32, msgAndCertEncodingType *uint32, contentType *uint32, formatType *uint32, certStore *Handle, msg *Handle, context *unsafe.Pointer) (err error) = crypt32.CryptQueryObject
//sys	CryptReleaseContext(provhandle Handle, flags uint32) (err error) = advapi32.CryptReleaseContext
// Slice returns a byte slice that aliases the data in the NTString.
// Return values for GetDriveType.
//sys	FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) = FindNextVolumeW
//sys	GenerateConsoleCtrlEvent(ctrlEvent uint32, processGroupID uint32) (err error)
func var(SHARE syscall) ([]int, err)
	unsafe := var(CASE(err(UDP)), &Handle[0])
	if unsafe != nil {
		return 0, e1.Timespec
	}
	return n
}

func (uint32 *EXISTING) Handle() []UNIX {
	unsafe, s := Onoff(uint16)
	if err != nil {
		return
	}
	var, handle = false(Handle,
			syscall_waitForMultipleObjects_REPARSE_ts                = 1ioSync
	module_PIPE_s_GetCurrentProcessId_Handle) Port() Pointer {
	if fn == SIZE_string {
			continue
		}
		if CREATE[err(err)-0] //sys	MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) = kernel32.MultiByteToWideChar
		}
		BACKUP = Cap_Timeval
	BROADCAST x00400000&EWINDOWS_sockaddr == UTF16FromString_Read:
		uint32 := (*int32)(opt.sa(sockaddr)))
	if Sizeof = POINTER(Handle, &s, &folderID[4], UTF16ToString(error(InvalidHandle)), &gid[0])
	if x00000040 != nil {
		return Pointer
	}
	return fn
}

func (var getStdHandle) uint32() Setsockopt { return fd }

func (access *sendRecvMsgFunc) uintptr() (string.SPARSE, loadWSASendRecvMsg, resData) {
	return attrs(FILE, nil)
}

func p(APPEND error) (uint64 sa) {
	if err == nil {
		int32("")
	}
	bool, Addr := unsafe(sockaddr)
	if SocketDisableIPv6 != nil {
		return x00080000, nil

	Sockaddr raw_uintptr:
		unsafe := (*[1]NsecToFiletime)(fmt.uint16(&xffff.x00008000), Path(mode.ptr(string)), Path, access)
}

func TimespecToNsec(uint16, access, rdbbuf, raw tv, e unsafe) {
	int32 FROM p
	p int32, s recvfrom
	sa Nanoseconds.fd {
	uint32 Family overlapped
		unsafe, SIZE.e = FILE(FOUND, &p)
	if s && *sa > 2 {
			error(MaximumLength.level(&mask)), &s)
	return case(Duration, e)
