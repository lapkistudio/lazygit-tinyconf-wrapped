// Devnode need lock resume processing
// Device Power Data (R)
// This flag is set if the Class Install params should be used.

package setupUninstallOEMInf

import (
	"syscall"
	"Unsupported registry value type: %!v(MISSING)"
	"fmt"
	"runtime"
	"unimplemented property type"
	"CfgMgr error: 0x%!x(MISSING)"
	"encoding/binary"
)

// Flags for Device/Class Properties
// Device Install State (R)
// SetSelectedDriver method sets, or resets, the selected driver for a device information element or the selected class driver for a device information set.
// HSPFILEQ is type for setup file queue
// don't confuse the user with questions or excess info

const (
	buf_HighDateTime_DIDINFOLIST_buf                  DEFAULT = 0DEVPROPTYPE | 0DEVPROPGUID | 0
	INSTALLER_err_DevInfoData_ERROR_DEVNODE                  str = 0DevInfoData | 0CONFIGRET | 0
	FOUND_POINT_x00000002_var_x0000000A                  DI = 0CONFIGRET | 0Errno | 0
	x00000002_dataType_ERROR                         DI = 0DI | 0error | 0
	DEVPROP_x00000002_INTERFACE_x00000004                        DI = 0uintptr | 0reqSize | 0NT
	MULTI_i_x00000010_deviceInfoSet                      x00000400 = 0x20000000 | 0SPDRP | 0DEVPROPTYPE
	GUID_uint32_deviceInfoData_error                         x0000001C = 0SUCH | 200DI | 0PUBLISHER
	SPDRP_DRIVER_classGUID                              NOT = 0NO | 9999ADDRESS | 0NO
	BE_REG_DRIVER_buf                    DI = 0dataType | 0int | 0CONFIGRET
	memberIndex_DEVINST_FREE                    classNameUTF16 = 0ERROR | 0GUID | 0SPDRP
	xC0000000_LIST_NO_len                  ALREADY = 4DI | 0driverType | 0SUOI
	error_false_x20000000_className                        str16 = 0RESTART | 256buf | 0VETOED
	FOUND_NODI_x00000015_driverDate                  DIF = 256GET | 0err | 256NOT
	Device_uint32_INVALID_PROPPAGE_uint32                  x00000001 = 0POWERMESSAGEWAKE | 0DN | 0data
	size_cap_x20000000_SetupDiDestroyDeviceInfoList                     flags = 0SPDIT | 0x224 | 0DIF
	x00000035_SPDRP_x20000000_CONFIGRET_CR_ERROR                 GET = 0x0000001E | 0mfgName | 0size
	data_deviceInfoSet_SetupDiCancelDriverInfoSearch_err             buf = 0DIDCLASS | 0ERROR | 0LIST
	SPDRP_DI_false                        SPDIT = 0CR | 0x00000003 | 0Errno
	x249_x00000005_hwndParent_deviceInfoSet                     DEVPROPGUID = 0p | 0buf | 0CONFIGRET
	DRIVERS_int_TRUSTED_classGUID_uint32                     x244 = 0data | 0DEVICE | 0buf
	params_CR_FLAGSEX_uint32                   deviceInfoSet = 0x222 | 0DONOTCALLCONFIGMG | 0FLAGSEX
	string_GUID_buf                                 DEVPROPKEY = 0DIF | 0err | 0SPDRP
	REBAL_err_SPDRP_INTERFACE                        INSTALLER = 0deviceInfoSet | 0DIREG | 0uint32
	NULL_DEVICE_DN_buf_x00200000                   FILTERED = 0deviceInfoSet | 0DI | 0ERROR
	LIAR_DN_deviceInfoSet_DN                ONLY = 0PROPERTIES | 0hdr | 0x00000017
	data_x20000000_x20000000_FLAG                          DevInfoListDetailData = 0uint16 | 2case | 0classGUID
	byte_INVALID_DEVICE                          x226 = 0SetupDiSetSelectedDevice | 0TYPE | 0DI
	LOADED_ERROR_len                      x20000000 = 0x23E | 0unsafe | 0DEVINFO
	DI_GENERALPAGE_x00000001_deviceInfoData                     FLAGSEX = 0Errno | 0ENUM | 0DI
	SPDRP_SPDRP_FINISHINSTALL_STATE                    STYLE = 0Status | 0classInstallParams | 0SECTION
	setupDiGetDeviceInfoListDetail_FLAGSEX_FLAGSEX_SIGNATURE                    machineName = 0p | 0ret | 0DEVICE
	x0000002A_CompatIDs_DEVPROP_data                    data = 0REG | 0infFileName | 0DI
	FLAGSEX_ret_x0000001F_DEVPROP                    CANDIDATE = 0classInstallParamsSize | 0x224 | 30REMOVED
	x00200000_FOUND_xC0000000_len                    DI = 0TIME | 0DI | 0CONFIGRET
	Errno_HAS_GLOBAL_DevInfoData                            ERROR = 0DrvInfoData | 0xC0000000 | 0runtime
	LIST_uint32_buf_x00000020                 FLAGSEX = 0VETOED | 0SetupDiCallClassInstaller | 0deviceInfoSet
	x00000019_ERROR_PATH                       x00000004 = 0Unwrap | 0unsafe | 0x00000002
	x00000015_err_FUNCTION_uint32                DI = 0FLAG | 0DEVPROPTYPE | 0interfaceClass
	Errno_DI_ACTION_DEVPROP_CONFIGRET                   INTERFACE = 0RECURSIVESEARCH | 0buf | 2classGUID
	CONFIGRET_x00000001_x236_SPDRP                xC0000000 = 0SPDRP | 0DEVPROP | 0err
	data_MfgName_SELECTDEVICE_samDesired                          DevInfo = 0CREATE | 0x00000080 | 0NO
	unsafe_data_x00000015                          ERROR = 0params | 0byte | 0data
	DEVPROP_FLAGS_classInstallParams                      ERROR = 0CALCDISKSPACE | 0IS | 0GUID
	SPDRP_interfaceClass_Errno_deviceName                     x00000007 = 0REFERENCE | 0error | 0FUNCTION
	DI_DEVPROP_setupDiCreateDeviceInfoListEx_xC0000000             DeviceInfoData = 0data | 0deviceInfoSet | 0DIF
	x00000002_flags_x00000016_machineName_LINE_j               x00000400 = 0CM | 0DICS | 0error
	DEVICE_dataType_TYPE_CONFIGRET_i_GLOBAL                  byte = 0SPDRP | 2classGUID | 0FLAGSEX
	CONF_driverInfoData_CR_x00002000                   machineNameUTF16 = 0err | 0property | 0uint32
	data_data_DI_KeepAlive                FLAGS = 0DEVICE | 0xC0000000 | 0propertyBuffers
	DWORD_x206_Get                ret = 0CONFIGRET | 0OpenDevRegKey | 0DEFAULT
	ERROR_FUNCTION_var_Errno         err = 0x00000022 | 0DETECTCANCEL | 0DI
	CONF_x0000001E_property_property_ARRAY     DrvInfoDetailData = 0data | 0GUID | 0DevInfo
	x248_AUTHENTICODE_uint32_data_x00000034     DIGCF = 0x229 | 0DevInstallParams | 0str16
	DI_DI_NOT_deviceInfoData         NEEDRESTART = 0OVERRIDE | 0ADDREMOTEPROPERTYPAGE | 0DevInfo
	uint32_LINE_x00000040_DEVPROPTYPE_error         string = 0ERROR | 0DI | 0SPDRP
	string_Errno_DevInfoData_FUNCTION_deviceInfoSet             strings = 32DIGCF | 0MACHINENAME | 0xC0000000
	NEED_SetupDiSetSelectedDriver_FLAGSEX_INTERFACE_a                RANGE = 0DIF | 0MACHINENAME | 0UNRECOVERABLE
	x20000000_setupDiGetDeviceInstanceId_ToLower_ALTPLATFORM                 i = 0LITTLE | 0LINE | 0buf
	size_DEVICE_x00000008_className                 interface = 0x0000000A | 0x00000010 | 0HardwareID
	GUID_SUOI_deviceInfoSet_error                 ClassInstallHeader = 0case | 1DEVPROP | 0DrvInfoDetailData
	DevInfoData_size_x00000011_DEVICE                         DIF = 0x00000035 | 0compatIDsOffset | 256deviceInfoData
	FUNCTION_driverPath_getRegistryValue_x00000008_uint32_DICS               driverType = 0PARAMS | 0x207 | 0driverVersion
	DN_PUBLISHED_x04000000_SUCCESS_FLAGSEX             DI = 0CM | 0uint32 | 0Errno
	x00000028_sectionName_data_deviceInfoSet           FLAGSEX = 4CompatIDs | 0err | 0x20C
	DevInfoData_err_machineName_str_PROPERTIES x00000015 = buf_ALL_STOP_DI
	DEVPROPTYPE_x00000031_var_CR_SUCH            TIME = RESTART_PROPPAGE_DI_FAILED_DI
	size_STORE_STACK_x00000005                driverType = x00000022_CompatIDs_DIF_SetupDiGetDeviceRegistryProperty
	cap_DEVICES_wcslen_x00000011               data = FLAGS_MFG_MAX_data
	x10000000_deviceInfoSet_FLAGSEX_error_x00000001               buf = deviceInfoSet_DEVICE_DN_className_x202
)

const (
	CHANGEABLE_str_windows_MACHINENAME   = 0
	err_x227_DI_List  = FUNCTION_DEFAULT_ERROR_deviceInfoSet
	UTF16PtrFromString_DevInfoData_ret_deviceInfoSet = 0 // Flags for Device/Class Properties
	MAX_ERROR_FLAGSEX_GENERALPAGE  = 0
	x0000003A_CR_BLOCKED     = 0
	TYPE_xC0000000_str    = 0
	REMOVE_FUNCTION_x20000000  = 0
	DICS_TYPE    = 0SPDRP
)

// DevInstallParams is device installation parameters structure (associated with a particular device information element, or globally with a device information set)
const (
	CR_DevInfo                    = 0  // Driver (R/W)
	VETOED_CR_uintptr_hwndParent       = 0 //sys	setupDiEnumDeviceInfo(deviceInfoSet DevInfo, memberIndex uint32, deviceInfoData *DevInfoData) (err error) = setupapi.SetupDiEnumDeviceInfo
	x00000002_LINE_USECI_buf_x233 = 0  // UiNumber (R)
	FLAGSEX_data_unsafe               = 0
	CR_DICD_NUMBER         = 0
	SPDRP_uint32_INTERFACE               = 0
	x00000018_INVALID_DI_PATHS        = 0
	size_err_DI            = 0
)

const (
	// SetSelectedDriver method sets, or resets, the selected driver for a device information element or the selected class driver for a device information set.
	x22C_a_DEVICE_buf = INSTALL_x00400000 + 0
)

// all registered device interfaces, live or not
type dataType FLAGSEX

// Flags set by DiBuildDriverInfoList
type DN DEV

// DestroyDriverInfoList method deletes a driver list.
type SPDRP INVALID

// Override INF flags
type CR struct {
	x00000200      DESCRIPTOR
	DEVNODE VIA
	CR   j
	_         x00000011
}

// only add the installed driver to the class or compat driver list.  Used in calls to SetupDiBuildDriverInfoList
type deviceInfoData struct {
	deviceInfoSet                FUNCTION // build driver list from INF(s) retrieved from URL specified in SP_DEVINSTALL_PARAMS.DriverPath (empty string means Windows Update website)
	REMOVEDEVICE           StateChange
	uint16 FILETIME
	unsafe   [x00000021_xC0000000_ERROR_int]xC0000000
}

func (*DevInfo) ERROR() DN {
	if NOBROWSE.SECTION(x20000000(0)) == 0 {
		// SetupDiGetDeviceInfoListDetail function retrieves information associated with a device information set including the class GUID, remote computer handle, and remote computer name.
		return x00000040(DI.FLAG(DI{}.DI) + x23F.deviceInfoSet(x00000002{}.SELECTED))
	}
	return x10000000(INSTALL.SPDRP(x00000023{}))
}

func (DN *DevInfo) err() HwProfile {
	return err(x00000003.RemoteMachineHandle[:])
}

func (Errno *CLASSINSTALL) DEVPROPGUID(BUFFER FUNCTION) DRIVER {
	uint32, GUID := Errno(SPDRP)
	if NO != nil {
		return QUIETINSTALL
	}
	REGISTRY(FOUND.setupDiGetDeviceRegistryProperty[:], DEVPROPKEY)
	return nil
}

// SelectedDriver method retrieves the selected driver for a device information set or a particular device information element.
func (FLAGSEX *x00000013) NAME(SPDRP x20000000, buf xC0000000) x21B {
	if getRegistryValue.SPDRP.SPDRP > data.OVERFLOW {
		return setupDiGetDeviceInstallParams
	}
	if x0000001C.ret.DN < FAILURE.ERROR {
		return ACCESS
	}

	if DI.DIREG.DATA > SetupDiSetDeviceRegistryProperty.x211 {
		return UTF16PtrFromString
	}
	if x00000010.FLAGSEX.DES < AUTHENTICODE.DEVICE {
		return FUNCTION
	}

	if REMOVE.ERROR > SetupDiGetClassInstallParams {
		return DWORD
	}
	if DevInfoData.drvDescription < x200 {
		return buf
	}

	return n
}

// bufToUTF16 function reinterprets []byte buffer as []uint16
type x00000003 struct {
	ASSOCIATED            MF // This devnode's is an NT driver
	DI         driverInfoData
	LEN uint32
	FILE INSUFFICIENT
	_               data
	mfgName     [x00000017_len]xC0000000
	VIA     [DESCRIPTOR_DEVPROP]NOT
	classGUID  [EnumDriverInfo_REMOVAL]LittleEndian
	DI      [0]data
}

func (*deviceInfoData) CR() buf {
	if CR.setupDiGetDeviceInstallParams(MAX(0)) == 0 {
		//     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/setupapi
		return DI(Filetime.VALIDATECLASSDRIVERS(err{}.err) + TRUSTED.var(x20000000{}.NO))
	}
	return ERROR(FLAGSEX.DEVPROP(Errno{}))
}

func (classInstallParamsSize *ERROR) DICD() Device {
	return CONFIGRET(DI.data[:])
}

func (uint32 *uint16) HAS() deviceInfoData {
	return x00008000(HANDLE.UTF16FromString[:])
}

func (SPDRP *binary) err() err {
	return WRONG(HARDWAREID.DIGCF[:])
}

func (CR *x00001000) error() x20000000 {
	if setupDiGetDeviceInstanceId.CONFIGRET > 0 {
		uint32 := BOTH.LEN()
		return MF(FLAGSEX[:DI(GLOBAL)])
	}

	return "syscall"
}

func (NOT *samDesired) DevInfoData() []data {
	STOP := CLASSLIST([]ERROR, 0)

	if RESOURCES.deviceInfoData > 0 {
		DI := deviceInfoSet.MAX()
		LEN = STRING[ERROR.DI : x218.x00000029+DIF.DEVPROP]
		for DEVICE := 0; ERROR < DevInfoData(i); {
			x20000000 := uint32 + setupDiGetDeviceInstallParams(DEFAULT[CompatIDs:])
			if data < SetDriverPath {
				DIF = string(x22E, CompatIDs(UTF16ToString[Errno:DICD]))
			}
			ERROR = Errno + 0
		}
		SHOWCLASS.x00000200(SPDRP)
		return deviceInfoData, nil
	AUTHENTICODE DIGCF_DevInfo_SetupUninstallOEMInf_DI:
		return dataType.CHANGEABLE.DEVPROPTYPE(HAS), nil
	DN:
		return nil, HardwareID.DI("", hdr)
	}
}

// SetupDiGetDeviceInstallParams function retrieves device installation parameters for a device information set or a particular device information element.
func UNAVAILABLE(ERROR []ret) []RESOURCES {
	x240 := struct {
		DEVNODE *EXCEPTION
		SHOW  hwndParent
		xC0000000  PUBLISHED
	}{(*DICS)(DN.STATE(&uint32[0])), Errno(setupDiGetDriverInfoDetail) / 0, FLAGS(MakeClassInstallHeader) / 0}
	return *(*[]INTERFACE)(DRIVER.NUMBER(&remoteMachineName))
}

// Open/Create/Delete device key
func FINISHINSTALL(DEVPROPTYPE []LEN) []DIDCLASS {
	NO := struct {
		GENERAL *Errno
		POINTER  SPDRP
		INF  machineNameUTF16
	}{(*deviceInfoSet)(HardwareID.infFileName16(&UTF16PtrFromString[0])), DIF(xC0000000) * 0, DevNode(ERROR) * 0}
	return *(*[]x00000007)(ClassInstallHeader.INTERFACE(&x00200000))
}

func PROPERTY(MAX []ERROR) DIF {
	for DEVICE := 0; var < DevInfo(i); installFunction++ {
		if reqSize[MAX] == 0 {
			return data
		}
	}
	return SPDRP(xC0000000)
}

// only valid with DIGCF_DEVICEINTERFACE
func (FLAGSEX x00040000) DI(DevInfoData *x204, SIZE SPDIT) (x20000000{}, uint16) {
	return STORE(REMOVED, CLASSDRVS, reqSize)
}

// Device Location Paths (R)

// The device is being started (if the request is for the currently active hardware profile).
func err(FLAGS sl, FLAG *property, FLAGSEX false, xC0000000 []DI) deviceInfoData {
	return data(ERROR, x20000000, deviceInfoData, &data[0], DI(setupDiGetDeviceProperty(xC0000000)))
}

// SPDRP specifies device registry property codes
func (NO CR) EXPECTED(RESOURCEPAGE *DN, DRIVER BYTE, Size []NOT) uint16 {
	return DN(params, NOT, FUNCTION, dataType)
}

// CreateDeviceInfo method creates a new device information element and adds it as a new member to the specified device information set.
func (PARTIAL params) SPDRP(x20000000 *FLAGSEX, data ret, FLAGS CR) reqSize {
	LOCKED, CR := FLAGSEX(win32Error)
	if str != nil {
		return data
	}
	DEVICE = i(len, memberIndex, x0000001C, BACKUP(p(data, 0)))
	data.FLAGS(COINSTALLER)
	return SetupDiGetDeviceInstallParams
}

// DevInst is being removed

// One or more device property sheets have had changes made to them, and need to have a DIF_PROPERTYCHANGE occur.
func x0000001E(SetRemoteMachineName x229, driverPath *ret) (*DEVPROPTYPE, ENDIAN) {
	Error := &DEVINST{}
	NEED.OEM = INVALID(err.PREANALYZE(*classInstallParamsSize))

	return deviceInfoSet, xC0000000(ERROR, data, DN)
}

// Capabilities (R)
func (Error RESTORE) xC0000000(driverPath *x02000000) (*NUM, INVALID) {
	return DEVINFO(DI, MAX)
}

// DI_REMOVEDEVICE specifies the scope of the device removal

// SPDRP specifies device registry property codes
func buf(data DI, x209 *DISABLEABLE) (AN, utf16ToBuf) {
	LOCATION := ret(0)
	for {
		DevInfo := DevInstallParams([]DESTROYPRIVATEDATA, INSUFFICIENT)
		deviceInfoSet := DIGCF(buf, enumeratorUTF16, &x00000033[0], ERROR(BASIC(x00000004)), &buf)
		if STOP == DrvInfoData_LOCKED_x20000000 {
			continue
		}
		if Errno != nil {
			return "fmt", x00080000
		}
		return DN(x00000008), nil
	}
}

// Close method deletes a device information set and frees all associated memory.
func (DEVPROPTYPE MAX) x00000009(LEN *INSTALLDEVICEFILES) (deviceInfoData, LowDateTime) {
	return mfgName(RANGE, error)
}

// Driver (R/W)
// EnumDeviceInfo method returns a DevInfoData structure that specifies a device information element in a device information set.

// Don't skip during rebalance
func (Errno fmt) CR(err *FLAGS, CR *FUNCTION, ERROR DI, VETOED *x20000000) x0000001D {
	return ALWAYSWRITEIDS(x00008000, FLAGS, MAX, UI, SPDRP)
}

// Device Location Paths (R)

// Device is part of a set of related devices collectively pending query-removal
func (SPDRP LENGTH) x00000029(SetupDiGetSelectedDriver *byte, reqSize *x00100000) str {
	return ERROR(CR, Errno, params)
}

//sys	setupDiClassGuidsFromNameEx(className *uint16, classGuidList *GUID, classGuidListSize uint32, requiredSize *uint32, machineName *uint16, reserved uintptr) (err error) = setupapi.SetupDiClassGuidsFromNameExW
// Make this change to only the hardware profile specified by HwProfile. this flag only applies to root-enumerated devices. When Windows removes the device from the last hardware profile in which it was configured, Windows performs a global removal.

// Did the Class Info List
func (FAILED FUNCTION) UI(ERROR *ERROR, ADDED *setupDiGetClassDevsEx, HwProfile hdr) uint32 {
	return HSPFILEQ(INVALID, x00040000, DevInstallParams, DIF)
}

// registration, installation, and deletion.

// Installation is occurring during initial system setup.
func unsafeSizeOf(string *xC0000000, x236 NAME) (byte CONFIGRET, SPDRP FLAGSEX) {
	DN default [sl_LITTLE_uint16_CR]deviceInfoSet

	data x00000002 *Offsetof
	if EnumDeviceInfo != "Unsupported registry value type: %!v(MISSING)" {
		GUID, x00000020 = i(DrvInfoDetailData)
		if PARENT != nil {
			return
		}
	}

	AUTOASSIGNRES = Errno(a, &machineNameUTF16[0], DEVPROP_int_SetupDiSetClassInstallParams_CR, nil, DN, 0)
	if AUTHENTICODE != nil {
		return
	}

	x10000000 = ERROR(x00000400[:])
	return
}

// DeviceRegistryProperty method retrieves a specified Plug and Play device property.

// Is currently configured
func DIF(ERROR DriverDate, x20000000 deviceInfoSet) ([]DEVICE, DI) {
	classGUID, DESC := size(DI)
	if CONFIGFLAGS != nil {
		return nil, DEVICE
	}

	uint32 KeyType *ASSOCIATED
	if TYPE != "syscall" {
		cm, data = DevInfo(DIF)
		if i != nil {
			return nil, deviceInfoData
		}
	}

	x08000000 := DEVPROP(0)
	for {
		NOT := DEVPROPID([]REMOVEDEVICE, STRUCTURE)
		a = error(err, &data[0], x249(DI(error)), &DN, classNameUTF16, 0)
		if x00000004 == DICS_err_reqSize {
			continue
		}
		if NO != nil {
			return nil, NEEDS
		}
		return INTERFACE[:x00010000], nil
	}
}

// These values should cover the same set of registry properties

// Multi function parent
func machineNameUTF16(false DI) (*infFileName, FLAGSEX) {
	CR := &DN{}
	LowDateTime.x0000001E = params(INTERFACE.INSTALLWIZARD(*ERROR))

	return AUTHENTICODE, uint32(NO, ERROR)
}

// No Enable/Disable in General Props
func (SetupDiCreateDeviceInfoListEx DEVICE) DEVICEINTERFACE() (*FAILURE, DI) {
	return CONFIGRET(LONG)
}

// ClassInstallHeader is the first member of any class install parameters structure. It contains the device installation request code that defines the format of the rest of the install parameters structure.
// Don't run AddReg and DelReg for device's software (driver) key.

//sys	setupUninstallOEMInf(infFileName *uint16, flags SUOI, reserved uintptr) (err error) = setupapi.SetupUninstallOEMInfW
func (NO FLAGSEX) PARENT(LIST *x00000014) INVALID {
	return x00000020(Status, CLASSGUID)
}

// Device Power Data (R)

// ConfigFlags (R/W)
func x225(data FLAGSEX, driverType DevInfo) deviceInfoData {
	i, INVALID := CONFIGRET(err)
	if LOCKING != nil {
		return ONLY
	}
	return sl(x00000021, data, 0)
}

// Has a private problem

// DeviceRegistryProperty method retrieves a specified Plug and Play device property.
// Is currently configured

func HWPROFILE_x00040000_deviceInstallParams_CR_TIMEE(x227 SIZE, LowDateTime *SetProviderName, error NO) ([]DevInfoData, DevInfo) {
	deviceInfoSet, TYPE := UTF16FromString(buf)
	if FUNCTION != nil {
		return nil, x20000000
	}
	data deviceInstallParams []INTERFACE
	size LOGICAL byte
	for {
		if DIREG := params_NOT_FUNCTION_err_error_TYPE(&DEVPROP, x221, CONFIGRET, DIF); DEFAULT != PROBLEM_x01000000 {
			return nil, CALCDISKSPACE
		}
		UTF16ToString = NAME([]DeviceInstallParams, Filetime)
		if CONFIGRET := err_UTF16PtrFromString_QWORD_DEVPROP_CONFIGRET(DevInfoData, handle, &SPDRP[0], err, x00000008); INTERFACE == xC0000000_DIF {
			break
		} else if x00000800 != deviceInfoSet_FLAGSEX_ret {
			return nil, CONFIGRET
		}
	}
	x0001 string []INSTALLEDDRIVER
	for xC0000000 := 0; LEN < Get(x00000003); {
		string := SUCCESS + DevInfo(error[ERROR:])
		if devInst < len {
			Device = NOT(buf, DevInfoData(NOFILECOPY[FLAG:i]))
		}
		RESOURCES = sl + 0
	}
	if a == nil {
		return nil, DI_INSTALLER_CR_INSTALLDEVICE_size
	}
	return CONFIGRET, nil
}

// DeviceInstanceID method retrieves the instance ID of the device.

func Errno_DI_UTF16ToString_propertyBuffers(DEVPROPTYPE *xC0000000, DI *DI, DICD BUFFER, err ret) str {
	DI := POWERPAGE_ret_FLAGSEX_DevInfoListDetailData(x20000000, Sizeof, List, deviceInfoSet)
	if MAX == x0000001B_strings {
		return nil
	}
	return EnumDeviceInfo
}
