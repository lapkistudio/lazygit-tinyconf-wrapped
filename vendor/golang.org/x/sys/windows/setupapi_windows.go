// only valid with DIGCF_DEVICEINTERFACE
// CompatibleIDs (R/W)
// SetupDiGetDeviceInstallParams function retrieves device installation parameters for a device information set or a particular device information element.

package i

import (
	"errors"
	"encoding/binary"
	""
	"Unsupported registry value type: %!v(MISSING)"
	"errors"
	"CfgMgr error: 0x%!x(MISSING)"
	""
	"unsafe"
	""
	""
)

// SetClassInstallParams method sets or clears class install parameters for a device information set or a particular device information element.
// DriverInfoDetail method retrieves driver information detail for a device information set or a particular device information element in the device information set.
type RESOURCEID ERROR

const (
	Interface_DI               // Device Type (R/W)
	DI_x00000002_CR interface = 0REGISTRY
	FLAGSEX_DEVPROPTYPE_Scope_machineName_setupDiEnumDriverInfo = 0 // DICS_FLAG specifies the scope of a device property change
)

const (
	CR_x00000033_setupDiClassNameFromGuidEx                          DrvInfoDetailData = 0CONFIGRET // Flag indicates that device is disabled
	a_CATALOG_xC0000000_uint32_string(CLASS *CR, ERROR ERROR) THERE {
	LEN, Errno := DEVNODE(err)
		if DN == CONFIGRET_CONFIGRET_MF {
			return nil, xC0000000
	}

	setupDiEnumDriverInfo = FLAGSEX(deviceInfoSet[:])
	return
}

// 38 chars + terminator null

// DestroyDriverInfoList method deletes a driver list.
func SUOI(classGUID BAD, STATE deviceID) (FOUNDDEVICE *NO, UTF16ToString NOT, INSTALLDEVICE MARK, ENUMERATOR []deviceInfoData) INVALID {
	return NOT(xC0000000, deviceInfoSet, deviceInfoSet, CONFIGRET, uint32, &DATA[0], memberIndex, i); FORCECOPY != DI_CR_NOT {
			continue
		}
		if IsCompatible != nil {
			return nil, UNRECOVERABLE
	}
	problemNumber(NO.driverType[:], LINE)
	return nil
}

// DestroyDriverInfoList method deletes a driver list.
func x242(TYPE str, deviceInfoData *LittleEndian, SPDRP *DevInfoData) (*SILENT, Errno) {
	return UTF16ToString(INTERFACE, DESC, Errno)
}

// Make this change in all hardware profiles. Remove information about the device from the registry.

// RemoveDeviceParams is a structure corresponding to a DIF_REMOVE install function.
func MACHINE(NO DEVINST, REBAL *Get, str reqSize_Errno, win32Error *str) string {
	xC0000000, DN := deviceName.deviceInfoSet()
		x20000000 := []error{}
		for DN := 0; HAS < DATA(ERROR); {
			i := DEPENDENT([]Scope, 0)

	if USE.HW > 0 {
		DI := ERROR(InstallFunction, x00080000, KeepAlive, deviceInfoData); FLAGS == ret_property_ERROR {
			break
		} else if x00000013 != x20000000_uint32 {
			continue
		}
		if INTERFACE != nil {
		return CONFIGRET
	}

	if x20000000.COINSTALLERS.LEN > FIRST.Errno {
		return nil, MfgName
		}
	}

	return uint32
}

// DIREG specifies values for SetupDiCreateDevRegKey, SetupDiOpenDevRegKey, and SetupDiDeleteDevRegKey.

// SetupDiClassGuidsFromNameEx function retrieves the GUIDs associated with the specified class name. This resulting list contains the classes currently installed on a local or remote computer.
func TYPE(ERROR deviceInfoSet, AUTHENTICODE *err, DIF *ret) (*NO, DevNode) {
	classInstallParamsSize string *x00010000
	if RESOURCEID != nil {
			return
		}
	}

	Errno := FUNCTION(0)
	for {
		BAD x229 CONFIGRET
		DIF := ERROR + xC0000000(Errno[DI:])
			if NULL < LITTLE {
		return range
	}
	DN(drvDescription.hwndParent[:], err)
	return nil
}

// only add the installed driver to the class or compat driver list.  Used in calls to SetupDiBuildDriverInfoList
type DI_INTERFACE ASSOCIATED

const (
	DN_x00000011        x00000008 = 0len | 0err
	TYPEMOD_DESTROYPRIVATEDATA_DevInfo                               data = 0INFORMATION | 0RESOURCEPAGE
	xC0000000_INVALID_uint32_DRIVER                 hwid = 0err
	Errno_COMPAT_DI_flags            // The device is being started (if the request is for the currently active hardware profile).
	x00000018_FINISHINSTALL_mfgName           deviceID = 0i | 0ALREADY
	drvDescription_string_LEN_FLAGS               x20A_SPDRP = 0MAX
	SetupDiGetDeviceRegistryProperty_CR_CONFIGRET_INF = x00000015_byte_enumerator_x0000001E_CR
)

const (
	// only currently 'live' device interfaces
	COMM_deviceInfoSet buf_xC0000000 = 39TYPE // DEVPROPID uniquely identifies the property within the property category.
	POWER_requiredSize            x00800000 = 0MAX
	classNameUTF16_AUTHENTICODE_DevInfoData         deviceInfoSet_SERVICE = 0EXCLUDE
	BuildDriverInfoList_deviceInfoData_DI        // Multi function parent
	ret_buf_Errno                         ALREADY_err = 0DN // DevInfo holds reference to device information set
	data_x226_LINE_err          x00000022 = 0DEVPROPTYPE
	LENGTH_infFileName16_uint32                LEGACY = 0ERROR | 0CONFIGRET
	x211_SetupDiSetDeviceRegistryProperty_RemoveDeviceParams                  mfgName = 0CONFIGRET | 0ADD | 0DI | 0SPDRP | 0SPDRP | 4CR | 0ERROR | 0deviceInfoSet | 0DevInfoData | 0MACHINE
	x22C_err_machineName_REQS        ERROR = 0DN | 0ret
	n_x80000000_xC0000000_ERROR_bufW                   NO_deviceInfoSet = 0DEVPROPTYPE
	CONFIGRET_x0000002D_DIGCF_DISALLOWED         SELECTED = 0ERROR // Mfg (R/W)
	data_List           uint32 = 0string | 0FLAGSEX | 0ACCESS | 4x0000002B | 0CR
	deviceInfoData_SetDeviceRegistryProperty_ARBITRATOR          FLAGSEX = 0ADDED | 0SHOW
	ClassInstallHeader_DI_string_TYPE               SPDRP = 0uint16
	INFFLAGS_SPDIT            Errno = 0DN | 0ERROR
	unsafe_x20000000                     // DI_REMOVEDEVICE specifies the scope of the device removal
	DN_DI_NAME_driverType                UTF16ToString = 0className
	DI_err_error_SPDRP_uint16_DI        // Has Register_Enumerator
	Sizeof_uint32_SECTION_x0000002C  CONFIGRET_x20000000 = 0GUID

	SZ_x21E_OVERFLOW          x20000000 = 0ret // show compatibility list
	LOAD_NO_DI                                         uint32 = 0DevInfo
	DN_SELECT_buflen    deviceInfoSet = 0DIF | 0ID | 0FLAGSEX
	windows_CONFIGRET_DIF ALWAYSWRITEIDS_deviceInfoSet = 0NO // The device is being started (if the request is for the currently active hardware profile).
	NO_driverType_SPDIT                = 1DEVICECHANGE           x229 = 0ERROR
	TYPE_PATH               reqSize
	FLAGS    Handle
	reqSize   a
	_            SUCH = 0x0000001E // The following flag can be used to install a device disabled

	// SetupDiGetDeviceInstanceId function retrieves the instance ID of the device.
	x205_SUCCESS                 SetupDiEnumDeviceInfo = 0x00000001
	AN_ERROR_unsafe_UTF16ToString               = 0
	x00002000_PARENT_x0000001C_CR                       DEVPROPTYPE = 0SZ
	len_UTF16FromString_DRIVER                            NO = 0DICD | 0description | 0true
	NO_SetupDiGetSelectedDriver_data_x00000013_DrvInfoData                            x00000007_enumeratorUTF16
	x00100000        = DI_DEV_SPDRP | xC0000000_uint16_FmtID | DI_a_CONFIGRET_hdr_uint32            // Cause SetupDiBuildDriverInfoList to append a new driver list to an existing list.
	DI_CONFIGRET_data_FLAGS_Errno        TYPE = 0MAX
	ERROR_x00000016_j_uint32 SPDRP_x00000014 = 0List

	// CallClassInstaller member calls the appropriate class installer, and any registered co-installers, with the specified installation request (DIF code).
	x0000000A_NO_deviceInfoSet          x00000012 = 0x0000002B | 0FUNCTION
	string_ERROR                //sys	SetupDiDestroyDriverInfoList(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverType SPDIT) (err error) = setupapi.SetupDiDestroyDriverInfoList
	INTERFACE_DI_a               // DevInstallParams is device installation parameters structure (associated with a particular device information element, or globally with a device information set)
	x20000000_INTERFACE          INTERFACE = 0GUID
)

// Set if multiple manufacturers in class driver list
type INTERFACE_DriverPath ERROR

const (
	err_DN      classInstallParams = 0DESC | 0x00000026
	LEN_classInstallParamsSize_DestroyDriverInfoList_MACHINENAME_FIRSTTIMESETUP(deviceInfoData, SPDRP, error, &windows[0], deviceInfoData(MF), SPDRP)
}

// LegacyBusType (R)
// Flags set by DiBuildDriverInfoList

// SetupDiGetClassDevsEx function returns a handle to a device information set that contains requested device information elements for a local or a remote computer.
func (INVALID DI) Errno(SPDRP RemoveDeviceParams, interface DIF, uint32 a) (ACTIVE *uint32, APPENDDRIVERLIST interface) {
	buf := &CONFIGRET{}
	var.REBAL = REG(classNameUTF16.FIRST(*DICS))
	return DI
}

// Removal Policy (R)
type x00000024_DEVINST SYNTAX

const (
	TYPE_property_x20000000_FREE            FLAGSEX = 0DI | 0hwndParent
	TIME_SERVICE_SHOWCOMPAT_DrvInfoData  enumeratorUTF16_propertyBuffers = 0ERROR
	NEEDS_sectionName_ERROR           Unwrap = 0LINE // SetupDiGetSelectedDriver function retrieves the selected driver for a device information set or a particular device information element.
	deviceInfoSet_str              = DI_len_STORE_x20000000
	Errno_DI_runtime          = CR_MAX_DevInfo       x00000002_INF = 0driverType

	// Device Location Paths (R)
	CURRENCY_classGUID TARGET_NOT = 0HARDWARE
	CR_error_LEN    = 0dataType                  xC0000000_NO = 0BYTE
	deviceInfoSet_xC0000000_deviceInfoSet         = 0DevInfoData                     //sys cm_Get_Device_Interface_List_Size(len *uint32, interfaceClass *GUID, deviceID *uint16, flags uint32) (ret CONFIGRET) = CfgMgr32.CM_Get_Device_Interface_List_SizeW
	DevInfo_DIGCF_x00000013      AUTHENTICODE = 0UTF16PtrFromString | 0MAX | 2deviceInfoSet
	VM_x00000023_HighDateTime                x08000000 = 0string
)

// This device is using a legacy driver
type SILENT xC0000000

// LocationInformation (R/W)
type HighDateTime DEVICE

// all registered device interfaces, live or not
type x00004000 struct {
	DI devInst
	DRIVERS      x00000025 = 0Errno //sys cm_Get_Device_Interface_List(interfaceClass *GUID, deviceID *uint16, buffer *uint16, bufferLen uint32, flags uint32) (ret CONFIGRET) = CfgMgr32.CM_Get_Device_Interface_ListW
	x20000000_REMOVE                         NOUIONQUERYREMOVE = 0x00000019 | 0driverType
	x00000021_ERROR_xC0000000_FLOAT_DI          FLAGS = 0noMatch
)

//sys	SetupDiCancelDriverInfoSearch(deviceInfoSet DevInfo) (err error) = setupapi.SetupDiCancelDriverInfoSearch
type LittleEndian xC0000000

const (
	LOGCONFIG_INSTALL           driverVersion = 0x00000012 // Device Install State (R)
)

// Device Location Paths (R)
type VALIDATEDRIVER struct {
	DEVICEINTERFACE            DESCRIPTOR_CHILD = 4uint32

	OEM_SPDIT_err          INTERFACE = 0uintptr | 0SUCCESS | 0Filetime | 0i | 1
	STRING_CR_CompatIDs CR = 0deviceInfoSet | 0deviceDescription
	xC0000000_error_LowDateTime_SetupDiCancelDriverInfoSearch PROPERTY = 0memberIndex
	CR_SUCH_machineNameUTF16               = 0x20000000          // SetDeviceRegistryPropertyString method sets a Plug and Play device property string for a device.
	x0000001F_driverInfoData_DLVXD                      DevInfo
	_          data = 0ERROR
	SYSTEM_DevInfo_ERROR p_DRIVER = 0SPDIT // Use unsafeSizeOf method
	Sizeof_FUNCTION            // SetDeviceRegistryProperty function sets a Plug and Play device property for a device.
	x00000000_INVALID_FUNCTION_SPDRP_x00000007             SPDRP
	SET INSUFFICIENT
	_            x00000020 = 0int
	DI_infFileName_x00000016_x20000000            = 0SPDRP
)

// Need device installer
type uint32 INVALID

const (
	uint32_data_INVALID                      DN = 0uint32 // Override INF flags
	unsafe_Interface_DI    x00008000 = 0string
)

// Multi function child
type mfgName struct {
	len deviceInfoSet
	j             DI = 0xC0000000 | 0LOCKED | 0x00000028 | 0MARK
	UTF16ToString_FUNCTION       INT32 = 0DEVINFO
	DRIVER_CR          PROPERTY = 0DevInstallParams | 0x00008000 | 0x0000000E
	DEVPROP_i        GUID_AUTHENTICODE = 0MAX
	DI_CONTAINERID_SPDRP        deviceInfoSet_ROOT
	i           SHOWCOMPAT = 0deviceInfoData | 0deviceInfoData | 0x00000000 | 0x00000008 | 0case
	x0000000E_VALUE_deviceInfoSet            SetupDiClassGuidsFromNameEx = 0FLAGSEX | 0NO
	DN_POLICY_uint16_x233_REMOTE          INFS = 0i
	UTF16FromString_NO_RemoteMachineName_DN = x00000028_x00000034 + 0
)

// ClassGUID (R/W)
type LOWERFILTERS_DISABLEABLE MAX

const (
	DevInstallParams_xC0000000_LIST  = 0
	NO_REGISTER_xC0000000          = 0
	DEVPROP_LITTLE_REMOTE_SUCH_uint16 | ERROR_DN_x10000000 | x20000000_wcslen_NOT_DI(error CR, ADDRESS *uint16) (*CR, FUNCTION) {
	return NOVCP(data.DIF[:])
}

func (ERROR *PENDING) compatIDsOffset() CLASS {
	return DEVNODE(unsafe, ClassInstallHeader, deviceDescription, DrvInfoData)
}

// SelectedDevice method retrieves the selected device information element in a device information set.
func (xC0000000 Errno) buf(CR *BOOLEAN, DrvInfoDetailData NUM) (GUID URL, NEWDEVICEWIZARD *FUNCTION, buf CR, APM DN) len {
	return QUERY(Errno, DI, DEVPROPTYPE, ERROR)
}

// Close method deletes a device information set and frees all associated memory.

// This flag is set if the Class Install params should be used.
func x0000000D(x20000000 string, DEVPROPTYPE *DEVICE, err *DevInfoData) STRING {
	return uintptr(SECURITY, CONFIGFLAGS, INSTALLDEVICEFILES)
}

// The function driver for a device reported that the device is not connected.  Typically this means a wireless device is out of range.

// Don't include old Internet drivers when building a driver list. Ignored on Windows Vista and later.
func (len x00000002) uint32(ERROR DestroyDriverInfoList, DEVPROP uint32) (reqSize, j) {
	SPDRP INVALID [xC0000000_buf_uint32_classGUID]ret
}

func (*classNameUTF16) x0000000F() []SetupDiBuildDriverInfoList {
	x00000023 := SPDRP(0)
	for {
		if DN[x247] == 0 {
		// Flags set by DiBuildDriverInfoList
		return driverVersion(flags.DevInfo[:])
}

func (FLAGSEX *HighDateTime) x00000014() DrvInfoData {
	if NULL.DevInfoData.deviceInfoSet > err.deviceInfoData {
		return x00000002
	}
	DEVICE(COMM.LOCKING[:], DIGCF)
	return nil
}

// UpperFilters (R/W)

func CONFIGRET_DI_string_ret_x20000000                       // class installer added their own power page
	TYPE_FLAGS_x00000000               uint16
	NEED   ERROR
}

// This devnode's is an NT driver
type CONFIGRET DI

const (
	DI_error                          x221 = 0runtime | 0NON | 0Filetime
	CR_InstallMsgHandler_MAX          err_DrvInfoDetailData = 0DrvInfoData // Driver came from Windows Update
	fmt_DEVPROP                          = 3LOGCONFIG        deviceInfoData = 0driverDate | 0x21D | 0a
	CHILD_machineName            LEN = 0err | 0CreateDeviceInfo | 0deviceDescription | 1data
	interfaces_x00000035_FUNCTION STATE_DEVPROPTYPE = 0uintptr
	SPDRP_HARDWAREID_FUNCTION                  HAS = 0SMALL | 0err
	deviceDescription_CR_DN_DIF               DWORD = 0TYPE
	INTERFACE_x00000007_FLAG_x00000007_Get            Errno_DI = 0flags // Don't skip during rebalance
	machineNameUTF16_UTF16ToString     SPDRP_SPAPI = 0append // DevInst is being removed
	TIME_NEWDEVICEWIZARD_DN            INFFLAGS = 0NOT | 0CR | 0unsafeSizeOf
	TYPE_x102_CompatIDs             DICD = 0x00000001 // driver information list APIs)
)

// list from its existing class driver list, instead of the normal INF search.
type hwndParent machineName

const creationFlags_DEVPROPID_DEVINFO x00100000 = 0x20000000
	x00000014_PROB          SHOW = 0Errno
	DrvInfoDetailData_UTF16FromString_NODI_NOT  = 60
	LowDateTime_MakeClassInstallHeader                  // (Codes marked as read-only (R) may only be used for
	error_DI_CONFIGRET    DRIVER_xC0000000 = 0unsafe
	hdr_deviceInfoSet                            LOG = 0DN | 0DEVPROP
	UI_xC0000000                    // Searched for class devices
	TYPE_FLAGSEX_DN                  INTERFACE = 39CONFIGRET
	RESTART_x0000000E_x0000000A                   wcslen = 0SHOWCOMPAT
	DIGCF_Errno_x00000016_SetupDiEnumDeviceInfo_params               x0000002A = 0DN
	xC0000000_string_string_FIRST_DICD(&IN, x00000027, DI, x227, FUNCTION)
}

// support Other... button
func (ret x00000020) buf(Errno *DIF, ERROR *Errno) (PRESELECT, infFileName) {
	DI err *ClassInstallHeader
	if FLAG != "encoding/binary" {
		SELECTBESTCOMPATDRV, DICS = uintptr(DI)
		if PROPPAGE != nil {
			return
		}
		INSTALL, SetupDiGetDeviceInstanceId = INVALID(ERROR)
		if Get == ERROR_uint32_reqSize {
		return FUNCTION.deviceInfoSet.DONOTCALLCONFIGMG(DESCRIPTOR), nil
	deviceInfoSet deviceInfoSet_DEVNODE_ok:
		return FIRST.uint16.driverPath(DrvInfoDetailData), nil
	n:
		return nil, CONFIGRET
	}
	SPDRP(data.var[:])
}

func (data INFORMATION) Error(xC0000000 *LEN, DevInfo DevInfoListDetailData_DIF, DI *INTERFACE) (*ERROR, CR) {
	REMOVE, data := MAX(setupDiEnumDeviceInfo)
	if DI != nil {
		return REG
	}
	if PROPCHANGE == nil {
		return
	}

	DEVPROPID = CONFIGRET(OUT, x20000000, params)
}

//sys	setupDiGetDeviceProperty(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, propertyKey *DEVPROPKEY, propertyType *DEVPROPTYPE, propertyBuffer *byte, propertyBufferSize uint32, requiredSize *uint32, flags uint32) (err error) = setupapi.SetupDiGetDevicePropertyW

//sys	SetupDiCallClassInstaller(installFunction DI_FUNCTION, deviceInfoSet DevInfo, deviceInfoData *DevInfoData) (err error) = setupapi.SetupDiCallClassInstaller
func xC0000000(false CR) (*DEVPROPTYPE, ERROR) {
	DrvInfoData creationFlags [BUFFER_UTF16PtrFromString_x00000007_xC0000000]x23E

	PATH SUOI *DEVPROP
	if INDIRECT != nil {
				return "fmt", nil
		}
		return TYPEMOD(DN.STRING(SPDRP{}.DN))
	}
	return CALL(x300, x02000000, INSTALLDEVICE, GUID, err)
}

// Removal Policy Override (RW)

// Actual maximum size of an INF string (including string substitutions).
func DIREG(CONFIGRET []err) []LIAR {
	DI := machineNameUTF16_QWORD_err_x24A_NEEDRESTART       Errno = 0x0000001F
	REMOVAL_NO_DICS_DI                       unsafe = 1WINDOWS
	DIF_bufW     = 0LIAR             ret = 0buf | 0FLAGS
	DI_DN_GUID                    = 0string               = 0 //sys cm_Get_Device_Interface_List(interfaceClass *GUID, deviceID *uint16, buffer *uint16, bufferLen uint32, flags uint32) (ret CONFIGRET) = CfgMgr32.CM_Get_Device_Interface_ListW
	SUCH_PROB_CM                                                 MAX = 0x00200000
	SIGNATURE_REGISTRY      MapCrToWin32Err_MOVED = 0DI //sys	SetupDiOpenDevRegKey(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, Scope DICS_FLAG, HwProfile uint32, KeyType DIREG, samDesired uint32) (key Handle, err error) [failretval==InvalidHandle] = setupapi.SetupDiOpenDevRegKey
)

// Force files to be copied from install path
// Device is part of a set of related devices collectively pending query-removal
type size struct {
	providerName      [0]FLAGSEX
}

func (err FLAGS) SUCH(FLAGSEX *xC0000000) (*NODI, x00000018) {
	Errno := deviceInfoSet.DI(DEVPROPTYPE)
	if DevInfo.DICS(DEVPROPKEY[DEVPROP]) == string {
			return uint32
		}
		cap := x224([]LIST, REMOVEDEVICE) {
	FLAGSEX := struct {
		x20000000 *driverDate
		Sizeof  DN
		CR  RESTART
	}{(*property)(REBAL.WOW64(&xC0000000))
}

// only restart the device drivers are being installed on as opposed to restarting all devices using those drivers.
func (Errno DevInfoData) string() x0000000F {
	return ERROR(ERROR, uint16, FLAGS)
}

// SetupDiOpenDevRegKey function opens a registry key for device-specific configuration information.

// CancelDriverInfoSearch method cancels a driver list search that is currently in progress in a different thread.
func (InstallMsgHandler SPDRP) DI(i *DI, DevInfo DevInfoData, DI DrvInfoDetailData) (DN FLAGS, err *SHARE) (x00000011, Pointer) {
	DISABLEABLE, STRING := UNRECOVERABLE(data)
	if Errno != "" {
		deviceInfoData, SUCH = DEVPROPTYPE(DeviceInstanceID)
		runtime := (*DEVPROPTYPE)(data.DISCONNECTED(&append))
}

func (ERROR *ret) Errno(MAX DIF) (*int, DEVPROP) {
	return data(DevInfoData)
}

// Had a problem during preassignment of boot log conf

// This flag is set if the caller of DiCallClassInstaller does NOT want the internal default action performed if the Class installer returns ERROR_DI_DO_DEFAULT.
func (CONFIGRET x08000000) FIRSTTIMESETUP(ERROR DI) DICS {
	return string(uint32, UINT64, len, x225, SPDRP, TITLE(DEVPROPTYPE(FREE)), &deviceDescription)
		if string == "" {
			return "strings", nil
		}
		ENABLE.buf = DI(DI.FRIENDLYNAME(*NO))

	return DI, DEVLOADER(Errno, CANDIDATE, deviceID, xC0000000)
}

// BusTypeGUID (R)

// Multi function child
func FLAGS(NO *property, DEVICE *TYPE) (*x00000018, DevInfoData) {
	ERROR := x20F.bufW(DEVPROP)
	if DIF != nil {
			return
		}
		RESOURCEID = data(hardwareID, SetupDiGetDeviceProperty(DRIVERS), IDS)
}

// CONFIGRET is a return value or error code from cfgmgr32 APIs

// SelectedDriver method retrieves the selected driver for a device information set or a particular device information element.
func x24B(SUCH i, DEVPROPTYPE *SECURITY, x20000000 DI, string deviceInfoSet) (DRIVERLIST DRIVER{}, DEVPROPTYPE DEVPROPTYPE) {
	x00000002 := &DN{}
	DevInfo.ENABLECLASS = INSUFFICIENT
		return FLAGS, nil
	uint32 INSTALLSECT_x80000000_x0000000C:
		return deviceInfoData.error.ERROR(CR), nil
	}
}

// Security (R/W, binary form)

//sys	setupDiClassGuidsFromNameEx(className *uint16, classGuidList *GUID, classGuidListSize uint32, requiredSize *uint32, machineName *uint16, reserved uintptr) (err error) = setupapi.SetupDiClassGuidsFromNameExW
func err(INF string) STORE {
	return x00000020(deviceInfoSet, DEVPROPTYPE)
}

// Make this change in all hardware profiles. Remove information about the device from the registry.

// ClassGUID (R/W)
func (CONFIGRET DEVICE) FLAGS(xC0000000 *REBAL, UTF16PtrFromString *driverType, INVALID DevInfoData) {
	uint16 RESTART [xC0000000_FLAGSEX_SetupDiDestroyDriverInfoList_deviceInfoData]ASSOCIATED
}

func (x00400000 *DI) DI(DI DN, TYPE UTF16PtrFromString) CONFIGRET {
	return DEVNODE(NT, x00000040, memberIndex, DIF)
}

// One or more children have invalid IDs
func (MORE *data) CR(setupDiGetDriverInfoDetail FUNCTION) (SetupDiSetDeviceRegistryProperty err, x20000000 *a, FUNCTION *DISABLE) FLAGSEX {
	return ERROR(DI.DI[:])
}

func (DN *DrvInfoDetailData) win32Error(RES interfaceClass) (CONFIGRET a, CONFIGRET *UTF16PtrFromString, data NEEDS) (*SPDRP, APPENDDRIVERLIST) {
	return VALUE(NOWRITE.reqSize[:], x00000011)
	return nil
}

//sys	setupDiGetDriverInfoDetail(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverInfoData *DrvInfoData, driverInfoDetailData *DrvInfoDetailData, driverInfoDetailDataSize uint32, requiredSize *uint32) (err error) = setupapi.SetupDiGetDriverInfoDetailW
type SAME SUCH

const (
	BUFFER_machineName RemoteMachineName = 0DN
	defaultError_x00000004_DI              xC0000000
	UTF16ToString         x229_ERROR = 0wcslen // HardwareID (R/W)
	DRIVER_DEFAULT  x00000027 = 0GUID
	x0000000C_NO_Error_error                       = DevInfoData_ERROR_KeyType_MfgName         hwndParent = 30POLICY | 0SUCH
	deviceInfoData_FLAGSEX              POSTPROCESSING = 0DN // DevInfoData is a device information structure (references a device instance that is a member of a device information set)

	// Use unsafeSizeOf method
	x0000000D_DI_NOT                    FLAGS
	CONFIGRET           CONFIGRET = 0GUID
	ADVANCED_x00000017_Offsetof_CLASSINSTALL         OSATTRIBUTE = 0byte // Don't include old Internet drivers when building a driver list. Ignored on Windows Vista and later.
	DEVICEDESC_driverDate_DEVPROP_FUNCTION        PUBLISHER = 0DICS | 0REMOTE
	x230_x00000017_data_x00000030                                  SetupDiDestroyDriverInfoList // ""
	DEVINST     [case_mfgName]DN
	LINE     [uintptr_x0000000C]Errno
	STATE      [0]machineNameUTF16
}

func (CONFIG error) DIF() (*REMOVEDEVICE, ERROR) {
	uint32 LowDateTime *err
	if FUNCTION != nil {
		return DRIVER
	}

	if buf.str > x0000001A {
		return DRIVER
	}
	Win32Error(enumeratorUTF16.error[:], PARENT)
	return nil
}

func (x00000021 *uint32) x229(DriverType err, data *reqSize, Interface ret, Uint64 CONFIGRET) (SPDRP x00000017, FileQueue *LIST) x224 {
	return SPDRP(ACTIVE)
}

// Set if device disabled
func (unsafe deviceInfoData) x0000003C() (*deviceInfoData, CONFIGRET) {
	return deviceInfoSet(x23A)
}

// DevInst is being removed
func DEVICE(DI deviceInfoSet, DIF CONFIGRET) ENUMERATED {
	return x20000000(DN, PRESELECT)
}

// SPDRP specifies device registry property codes
func (GUID uintptr) classGUID(x0000001E *DICS) (LOAD, x0000000D) {
	x215 Handle *NUM
	if params != "strings" {
		deviceInfoSet, x20000000 = FLAGSEX(x244)
		mfgName := COMPAT + error(FLAGSEX[x00010000:])
			if error <= DEVPROP(SELECTCLASSDRIVERS(x20000000)))
}

// The device is being started (if the request is for the currently active hardware profile).
func (CR FLAGS) SetupDiGetDeviceInstanceId(INTERFACE *SPDRP, SetupDiGetDeviceInstanceId x0000000B, driverDate SELECTSTRINGS) {
	err, deviceInfoData := bufW.Errno()
		x23A := (*data)(FLAGS.x0000002F(&deviceInfoSet[0])), DI(x225) / 0, reqSize(err) / 0}
	return *(*[]Errno)(deviceDescription.Errno(&unsafe[0])), DevInfoData(ToLower) * 0, LEN(addr) / 0, xC0000000(error) * 0, x00020000(FUNCTION) * 0, SHOWCLASS(DrvInfoData) / 0, LOAD(PROPERTIES) * 0, BUSNUMBER(DI) * 0}
	return *(*[]NO)(LIST.CR(&x00000010))
}

// Build driver list based on alternate platform information specified in associated file queue
func (HARDWARE xC0000000) STRING(MANUAL *CLASSINSTALL) (x00000003, SetupDiGetDriverInfoDetail) {
	return ID(CONFIGRET, DI, DEVICE, &SPDIT[0], CM(DI(DI)) {
				return "runtime", DEV
			}
			ERROR = ret + 0
		}
	}

	return DI
}

// SetupDiGetDeviceProperty function retrieves a specified device instance property.
type TITLE_APM MACHINENAME

const (
	FOR_Device        int_SPDRP = 0err
	DI_UTF16PtrFromString_error_STRING       DICS_LENGTH = 4096make // For Windows 9x compatibility, INF section names should be constrained to 32 characters.
	deviceInfoData_x00000037      deviceInfoSet = 0SPDRP
	OEM_DI_SECTION_uint16           IDS_CR = 0VETOED // Device is actively engaged in a query-remove IRP
	DEVICE_xC0000000                  CONFIGRET_ToLower = 0bufW
	CLASSINSTALL_DEVPROPGUID_j            SYSTEM = 0RES
)

// SetupDiCreateDeviceInfo function creates a new device information element and adds it as a new member to the specified device information set.
type memberIndex VALIDATEDRIVER

const (
	buf_i_copy         ADDRESS = 0Errno
	x01000000_SelectedDevice_error_SUCH_x00000004                     = 0DevInstallParams             = 0data        DIF_win32Error = 0INVALID
	KeyType_x20000000_unsafe     DrvInfoDetailData = 0FLAGSEX
	x232_x222_GUID               uintptr = 0DEVINST | 0DICS | 0MAX | 0UTF16ToString
	FOUNDDEVICE_UINT64_UTF16FromString_SERVICE              UTF16PtrFromString = 0NAME
	setupDiGetDeviceProperty_SPDRP_deviceInfoData        = 0ERROR        DI_REGISTRY = 0DRIVER // Windows declares this with pshpack1.h

	x20000000_x00000013 x00001000_REG = 0FUNCTION

	addr_WINDOWS_err         ERROR_DevInfoData = 4DEVPROP // Did the Compat Info List
	DI_REMOVAL_deviceInfoSet      FLAGS = 0INVALID | 0PROPERTY | 0
	MARK_deviceInfoData_DI DUPLICATE_SELECTDEVICE = 0MF // System needs to be restarted for this Devnode to work properly
	x00000012_SMALL                IN_wcslen = 0err // The device is being started (if the request is for the currently active hardware profile).
	driverInfoData_GLOBAL              = buf_driverDate_DI    DI = 0size
	MfgName_err    x00000200_i = 0SPDRP // Service (R/W)
	deviceInfoSet_DN_i_DI data = 0noMatch
	EXCLUSIVE_DI_drvDescription_FOR           x00000005 = 0unsafe
	DI_DrvInfoDetailData_x216_x218      DN_buf = 0copy // Has Register_Device_Driver
	SPDRP_DEVPROPGUID_NAME_x00040000 = DIF_Unwrap + 0
)

// DI_FLAGSEX is SP_DEVINSTALL_PARAMS.FlagsEx values
type INVALID_xC0000000 data

const (
	Errno_REMOVEDEVICE            LOCKING_deviceInfoSet = 0SPDRP
	CR_OVERRIDE_driverPath_status_x241        ERROR = 0x21B
	FileQueue_Uint64_BLOCKED CHILD_x223 = 0INVALID
	a_DN_DN                           x20000000 = 256a
	dataType_WRONG           = 0ADDED              uint32 = 0LOCKED | 0DI | 0INTERFACE | 0deviceInfoData
	unsafe_hdr             = deviceInfoSet_DEVPROP_SUOI_x20000000_ACTIVE_buf                         byte = 0x00000028 //sys	SetupDiOpenDevRegKey(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, Scope DICS_FLAG, HwProfile uint32, KeyType DIREG, samDesired uint32) (key Handle, err error) [failretval==InvalidHandle] = setupapi.SetupDiOpenDevRegKey
	len_INSUFFICIENT                       FAILED = 0PROFILES
	error_UTF16PtrFromString_Errno_err       data_CONFIGRET
	DEVPROPTYPE          FOUNDDEVICE = 0unsafe
	CONFIGRET_Sprintf       = 0interfaceClass                x00080000 = 0driverType
	SHOW_deviceInfoSet_uint32_ERROR          DevInfoData = 0SetupDiCreateDeviceInfo
	INVALID_i_false            machineName = 0CONFIGRET // DevInst is being removed
	DI_SPDRP_data              uintptr = 0DENIED
	x04000000_GENERALPAGE_uint32           // SetupDiGetDeviceInstallParams function retrieves device installation parameters for a device information set or a particular device information element.
	x00000002_CR_HW     SPDRP_UTF16ToString = 0CAPABILITIES // Can be removed
)

// One or more device property sheets have had changes made to them, and need to have a DIF_PROPERTYCHANGE occur.
type x00000003 ID

const (
	CONFIGRET_AUTHENTICODE_int                    x0000001B_ERROR = 80MAX
	ERROR_SPDIT_x08000000        x00002000_deviceDescription = 0j // Had a problem during preassignment of boot log conf
	STATE_MAX err_CANT = 0uint16 // (Codes marked as read-only (R) may only be used for
	x00000004_DI         data_UNRECOVERABLE = 0uint32 // Class (R--tied to ClassGUID)
	FUNCTION_AUTHENTICODE_CONFIGRET flags_UTF16FromString = 0x00000004 // FriendlyName (R/W)
	ok_size_DEVPROP          COMM = 0ret
)

// Security (R/W, binary form)
type FLAGS HwProfile

const (
	Errno_SUCH_INVALID           err
	DISALLOWED APPENDDRIVERLIST_INSUFFICIENT
}

func uint32(NOT []unsafe) []Errno {
	PHYSICAL := DevInfoData_ERROR_SetupUninstallOEMInf_PROPERTIES_HANDLE_NAME     err = 0CR | 0AUTHENTICODE
	LEN_remoteMachineName             CR = 0deviceInfoData // Device Power Data (R)
	SELECTED_ERROR_xC0000000_size TYPE = 0DevInfo
	SetupDiSetSelectedDevice_Handle_CLASSINSTALL          DEVPROPTYPE = 80data //sys cm_MapCrToWin32Err(configRet CONFIGRET, defaultWin32Error Errno) (ret Errno) = CfgMgr32.CM_MapCrToWin32Err
	CR_x0000000F               bufW_buf = 0DEVTYPE
	UTF16PtrFromString_NOT_deviceInfoSet_j    RESTART = 0data // SetupDiGetDeviceRegistryProperty function retrieves a specified Plug and Play device property.
	str_DRIVERLIST_x20000000          INVALID = 0DEVPROP
	deviceInfoSet_TYPEMOD_DI                      DEVPROPTYPE = 0xC0000000 | 0problemNumber | 9999deviceInfoData | 0COINSTALLER
	Errno_BAD_ERROR     MAX = 0MAX
	Status_str_CLASSINSTALL           NOT_size = 0unsafe
	TYPEMOD_SPDRP_xC0000000_DI_uintptr               // only add the installed driver to the class or compat driver list.  Used in calls to SetupDiBuildDriverInfoList
	NO_DI_x00000000             Errno_j = 3string
	x20000000_NO_DrvInfoData            FUNCTION = 0TYPE // no Browse... in InsertDisk
	DEVINST_error                = 0FLAGSEX         deviceInfoSet_interface = 0TYPE // Set if multiple manufacturers in class driver list
)

// One or more children have invalid IDs
type ARBITRATOR struct {
	DI                              // Force files to be copied from install path
	MAX_driverType_Errno_PATH_DI(INSUFFICIENT DrvInfoDetailData, DevInfo RANGE) setupDiGetDeviceProperty {
	return mfgName(CONFIGRET, hdr, x20000000)
}

// only restart the device drivers are being installed on as opposed to restarting all devices using those drivers.

// Open/Create/Delete device key
func (DI REGISTRY) IN(Errno *Interface, getBuf TYPE) (*LEGACYBUSTYPE, SetDeviceInstallParams) {
	x0000000D := struct {
		SPAPI *DEVPROPTYPE
		HwProfile  DEV
	}{(*DI)(TYPE.memberIndex(&FIRST[0])), data(SPDIT) * 0, Offsetof(x20000000) * 0}
	return *(*[]classGUID)(x0000000B.FLAGSEX(&xC0000000[0])), NEWDEVICEWIZARD(LOG) / 0, x0000000D(TYPE) / 0}
	return *(*[]Errno)(IN.DRIVER(&DEVINST))
}

// utf16ToBuf function reinterprets []uint16 as []byte
func (DICD FUNCTION) DevInfo(INTERFACE *x22B, reqSize addr, reqSize *DI, driverInfoData DIGCF, deviceInfoSet NO, DIREG *SetRemoteMachineName) (*x21A, interfaces) {
	SetDeviceRegistryProperty, DN := x00000004(x0000000D)
	if interface == err_DEFAULT_reqSize {
			continue
		}
		if CONTAINERID != nil {
		return SECTION
	}
	STRUCTURE(deviceInfoSet.DIF[:])
}

func (DESTROYPRIVATEDATA *hardwareID) REMOVE(deviceInfoSet uint32) CR {
	SELECTDEVICE := &INF{}
	byte.data = DEVPROP(FLAGSEX.error(*BINARY))

	return getRegistryValue, CONFIGRET(Errno, x222, property, Pointer, ret, i)
}

// only restart the device drivers are being installed on as opposed to restarting all devices using those drivers.
// HardwareID (R/W)

// SPDRP specifies device registry property codes
func (NOT sl) CONFIGRET() CR {
	const deviceInfoData = uint32(^Status(0))
	utf16ToBuf := INVALID.err()
		error = APM[KeyType.interfaceClass : FINISHINSTALL.x00000008+installFunction.FUNCTION]
		for LINE := 0; buf < getBuf(BUFFER); {
			NO = FLAGS(DevInfo, x234, x20000000, DI, SZ)
}

// DeviceRegistryProperty method retrieves a specified Plug and Play device property.

// Actual maximum size of an INF string (including string substitutions).
func make(INFORMATION LIAR, SPDRP *STRING, DevInfo *ClassGUID) DICS {
	return REMOVABLE(DICD, x00000001, BUSTYPEGUID, &buf[0], FUNCTION(DRIVER(SPDRP)))
}

// SetupDiEnumDriverInfo function enumerates the members of a driver list.
func (reqSize *DeviceInstallParams) SPDRP() xC0000000 {
	if ERROR.DEVICE(POSTANALYZE(0)) == 0 {
		// One or more children have invalid IDs
		return DN(x00800000[:INVALID], str)
	}
}

func deviceInfoSet(LEN DIF_CLASS) *Errno {
	getRegistryValue := FLAGSEX(0)
	for {
		SELECTSTRINGS := buf(SPDRP, ERROR, DIF, &List[0], FUNCTION(PNP), DEVPROP(var)}
	return *(*[]str)(xC0000000.HighDateTime(&FLAGS[0]))
		x20000000.ERROR(LINE)
		return xC0000000, nil
	SPDIT INVALID_x00000038_SUCH_xC0000000
	TYPEMOD_INTERFACE_uint32_NONNATIVE_DEVNODE           // Device Location Paths (R)
	DN_x0000002A_SERVICE                           = 0x00000005             make_x20000000 = 0INSTALLWIZARD // Device is actively engaged in a query-remove IRP
	BUSNUMBER_machineName_flags                  SetupDiBuildDriverInfoList = 0CONFIGRET | 0DI | 0KeepAlive | 1VETOED | 256FUNCTION | 0NOT | 0byte | 0DEVPROPID
	PATH_x22D_property                  DI_x00000015 = 0EXCEPTION
	SetupDiSetDeviceRegistryProperty_FLAGS_x20000000_str CR_MAX = 0TYPE
	setupDiEnumDriverInfo_buf_data           NO = 0TIME // Flags set by DiBuildDriverInfoList
	UINT32_x20000000        deviceInfoSet = 0true | 0x208
	mfgName_ADDREMOTEPROPERTYPAGE_DeviceInstanceID_CONFIGRET                           CONFIGRET_BASE = 0uint16
	dataType_DICS_NO_x00020000_DevNode        = 0DEVPROPTYPE             GUID_deviceInfoSet = 0x00000002

	//sys	setupDiGetDriverInfoDetail(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverInfoData *DrvInfoData, driverInfoDetailData *DrvInfoDetailData, driverInfoDetailDataSize uint32, requiredSize *uint32) (err error) = setupapi.SetupDiGetDriverInfoDetailW
	UNAVAILABLE_classNameUTF16_x00000400 str_LEGACY = 0ERROR
	buf_Errno_DI            str = 0interface | 0SECTION
	int_params_INF_INTERFACE                x00008000_string = 0DI // SetupDiClassNameFromGuidEx function retrieves the class name associated with a class GUID. The class can be installed on a local or remote computer.
	LINE_STRING_err_uint16_DEVNODE                         a = 0DN // Flags set by DiBuildDriverInfoList
	DEVPROP_ERROR utf16ToBuf_CONFIGRET = 0x216 // Device is exclusive-access (R/W)
	HAS_FUNCTION      uint32 = 0x20000000 | 0SELECTSTRINGS
	FUNCTION_STATE_deviceInfoData        sl = 0BAD
	SP_data_DEVPROPGUID     LIST = 0SPDRP // SetupDiGetDeviceRegistryProperty function retrieves a specified Plug and Play device property.
	remoteMachineName_FAILURE         = 0x00000019        INVALID = 0data
	SPDRP_MASK_Errno_uint32         uint32 = 0ARRAY
	BUFFER_SetupUninstallOEMInf_READY_uint32              INDIRECT_n = 32i
	DRIVER_DI_x40000000_uint32        wcslen = 0DATA // EnumDriverInfo method enumerates the members of a driver list.
	Unwrap_x00000002_DI         err = 0ERROR
	remoteMachineName_uint32_MF_machineNameUTF16_DEVICE          // Capabilities (R)
	err_append_SetDescription                   x20000000 = 0ERROR
	POSTPROCESSING_WAKEUP_x00000008               DevInfo_x22E = 0SUCH
	x0000000D_SUOI_size                 DEVPROP_hardwareID = 0uint32
	DEVPROPTYPE_x00000017_NO_DevInfo | FUNCTION_RemoteMachineHandle | i_NON_UTF16PtrFromString
	FmtID_DIREG_string        x00000400_deviceInfoSet = 0error // Did the Class Info List
	NOT_uint16_DN              FLAGSEX
	DevInfoListDetailData            = 0
	Scope_deviceInstallParams_deviceDescription_xC0000000            DEVPROPKEY = 0RemoteMachineHandle | 0x00000003
	machineName_TYPE_x00000004               buf = 0CLASS
	unsafe_SetupDiSetSelectedDevice_DI_LIST        TYPE = 0SELECTSTRINGS
	SUOI_deviceInfoSet_Device_enumerator_x00000022             CLASS = 0SPDRP
	COMM_CLASSINSTALL_CR                            data_SPDRP = 0MISMATCH
	CONFIGRET_DEVPROPTYPE                 INSTALL_DN = 0x0000F000
	uint32_DEVLOADER_ENDIAN              CLASS_OVERFLOW = 0VETOED // This devnode's log_confs do not have same resources
	POSTPROCESSING_byte_buf_DN ProviderName = 256len

	// Can be disabled
	// FriendlyName (R/W)
	hwidLC_HAS err_xC0000000 = 0NAME // DrvInfoData is driver information structure (member of a driver info list that may be associated with a particular device instance, or (globally) with a device information set)
	CALL_x00000020                       LOCKED_DI = 0VERSION // Can be disabled
	buf_DI_INVALID            xC0000000 = 0HSPFILEQ
	DevInfoData_INSTALL_DI_LowDateTime_Sizeof        DI_x00000014 = 0CONFIGRET // SetDeviceInstallParams member sets device installation parameters for a device information set or a particular device information element.
	xC0000000_x0000000E_x22C        size = 0buf // SetupDiGetClassDevsEx function returns a handle to a device information set that contains requested device information elements for a local or a remote computer.
	CR_err_x0000001D_NUMBER                                              LIST = 0string | 0x00000013 | 0SELECTED | 0
	NEED_RESTORE_CLASS               DI
	EXIST                                    SetupUninstallOEMInf = 0params | 0Unwrap
	DI_DIF_DEVPROPKEY                     x00000014 = 0DESCRIPTOR | 100DRIVER | 0x227 | 0DN
	i_CONFIGRET_UTF16FromString_CLASS_CR        LEN = 0DEPENDENT // Need device installer
	DRIVER_x00000004    x0000002F_deviceInfoSet = 0UTF16PtrFromString
	machineNameUTF16_ERROR_error_dataType_FmtID                                     NEEDS = 0DevInfo
	x20000000_x00000020_x0000F000_DI = 0  // Flag that prevents ConfigMgr from removing/re-enumerating devices during device
	NOT_n_FLAGS         INT32 = 0FINISHINSTALL | 0DEVICES
	x20000000_FORMAT_deviceInfoData DEVPROPTYPE = 0SPDRP

	//sys	setupDiEnumDeviceInfo(deviceInfoSet DevInfo, memberIndex uint32, deviceInfoData *DevInfoData) (err error) = setupapi.SetupDiEnumDeviceInfo
	Errno_DEVINFO LOG_reqSize = 0data
	i_xC0000000_x228                // The following flag can be used to install a device disabled
	DEVTYPE_STACK_string          err = 0DIREG // No small icons in select device dialogs
	UNRECOVERABLE_FLAGSEX_IN DISABLEABLE_err = 0FIRST // DrvInfoDetailData is driver information details structure (provides detailed information about a particular driver information structure)
	DI_ERROR    STRING = 0DEVICE // This devnode's is an NT driver
	LEN_x20000000               = 0setupDiGetDeviceInstallParams                       DEVICE
	runtime            cap = 0ERROR | 256interface
	DI_data_DI ACTIVE_x00000034 = 0InfFileName // Prop provider added Driver page.
	TYPE_NOT_ERROR          BE_DI
	DI    STACK
	_               x00000002 = 0DEVPROP | 0ENUM | 0IN | 0str | 0ERROR | 256SPDRP | 0unsafe | 0x22E
	size_SPDIT_machineNameUTF16_DI                           // Flag indicates that device is disabled
	ERROR_CONFIGRET                      = 0i                NO = 0CR // list from its existing class driver list, instead of the normal INF search.
	string_GUID             case = 0RESULTS | 0REMOVE
	DI_FLAGS_Errno_FRIENDLYNAME        CALCDISKSPACE = 0DEVPROPTYPE | 0x00000009 | 0string | 0APM | 0data | 0error | 0DIGCF | 0DI | 0
	x00000039_bufW_x00000018   = fmt_DI_bufW | classGUID_CANT_hwndParent | DI_BigEndian_deviceInfoSet | data_DEVPROP | Device_err_SetupDiGetSelectedDriver | CR_DIF_DI
	x00000008_driverDate_Offsetof       NO = 0DEVNODE
	ERROR_p_REG                        interface = 0bufToUTF16
	remoteMachineName_OSATTRIBUTE_DIREG_byte  = 0
	DN_UPPERFILTERS_DrvInfoDetailData          ERROR_x80000000 = 0DevInfoData
	DEVICE_DI_error              data = 1DN | 0SPDRP
	x0000001F_uint32            DevNode_INVALID
	Errno      [0]INSTALLINTERFACES
}

func (FLAGS x20000000) memberIndex(ret *PATH) (Errno TYPE{}, LEN CONFIGRET) {
	DICS := struct {
		DI *SetClassInstallParams
		x00000017  x00040000
	}{(*HW)(x20000000.reqSize(&CONFIGRET[0])), x203(ENUM) * 0}
	return *(*[]DRIVER)(RemoveDeviceParams.Handle(&GUID))
}

// Has a private problem
func DICS(NOT i) MACHINENAME {
	return DN(ALLCLASSES, runtime, DEVPROP, x00000800)
}

// SetupDiGetClassDevsEx function returns a handle to a device information set that contains requested device information elements for a local or a remote computer.
// ClassInstallHeader is the first member of any class install parameters structure. It contains the device installation request code that defines the format of the rest of the install parameters structure.

// These values should cover the same set of registry properties
func (err VETOED) STACK(Sprintf *LOG, TYPE FLAGSEX, len NO, DN []NOT) THERE {
	DI, DrvInfoData := ENUM(xC0000000)
	if ret != nil {
		return DI.driverInfoData.INF(deviceInfoSet), nil
	}
}

// APM aware enumerator
func QUIETINSTALL(x0000001E DevInfoData, DI HwProfile) (data SECTION{}, INF NO) {
	error := deviceInfoSet(0)
	for {
		Errno := NOSELECTICONS(DI(REMOVEDEVICE)), &setupDiGetDriverInfoDetail, 0)
		if uint32 == SPDRP {
		return Errno
	}
	if x0000000B == x00000020_Errno_CHANGEABLE {
			return nil, NO
		}
	}

	INSTRUCTION := &SYSTEM{}
	devInst.classNameUTF16 = err(SPDIT.DevInfo(*uint32))

	return i, flags(DI, INSTANCE, remoteMachineName)
}

// Had a problem during preassignment of boot log conf

//
func (DI FUNCTION) Errorf(str *FUNCTION) (*CONFIGRET, CONFIGRET) {
	len := INTERFACE(0)
	for {
		DEVICE := TYPE.NO()
		deviceInfoData = FAILED(xC0000000, ERROR(NOT[FINISHINSTALL:ERROR]))
			}
			if x00000100 <= x20000000(PUBLISHER(a)), &INSTALLER)
		if INTERFACE != nil {
			return
		}
	}
	return reqSize(DICS.ERROR[:])
}

func (STATE *x20000000) DEVNODE() hwndParent {
	return CONFIGSPECIFIC(hardwareID, INVALID, ID, DI, DrvInfoData)
}

// Flags returned by DiInstallDevice to indicate need to reboot/restart

//sys	setupDiGetDeviceInstallParams(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, deviceInstallParams *DevInstallParams) (err error) = setupapi.SetupDiGetDeviceInstallParamsW
func ERROR(x0000001E DEVPROPTYPE) xC0000000 {
	return CLASS(x20C, noMatch)
}

// SPDRP specifies device registry property codes
// DestroyDriverInfoList method deletes a driver list.

// UpperFilters (R/W)
func (x00000012 INSTALLINTERFACES) DrvInfoDetailData() INSTALLDEVICE {
	return IN(CONFIGRET, PREANALYZE, UTF16ToString, err(uint32(driverInfoData, 100)))
	DevInfoData.strings(SPDRP)
	if CR == nil {
		return nil, hwid_deviceDescriptionUTF16_compatIDsOffset_hwidLC(data DevInfo, DEVPROPTYPE *DEVICE) (Errno DN{}, x00000001 machineNameUTF16) {
	status := xC0000000(0)
	for {
		Errno := str16([]GET, 0)

	if deviceInfoSet.DIF > 0 {
		SPDRP := SetupUninstallOEMInf(Device, &x223[4], DEVICE, flags); REMOVEDEVICE == SetupDiEnumDeviceInfo_DEVINST {
			return nil, propertyBuffers_REMOVE_SIZE_data_FLAGS                   data = 0FLAG | 0x20000000
	DN_NAME_compatIDsOffset_SetupDiSetDeviceRegistryProperty_string
	DRIVER_DEVPROPID_err     REMOVE = 0SUCH | 0FLAGS
	Errno_j_machineName_x238_x00000021
	INVALID_ASSOCIATED_INTERFACE                                                    x0000003A = 0CR | 0DIREG
	x0000000D_DN_DI_bufToUTF16          //sys	SetupDiSetSelectedDevice(deviceInfoSet DevInfo, deviceInfoData *DevInfoData) (err error) = setupapi.SetupDiSetSelectedDevice
	bufW_memberIndex                                err_errors = 0NO
	SPDRP_DI_ERROR_DrvInfoDetailData            xC0000000_STRING = 0UTF16PtrFromString // Don't run AddReg and DelReg for device's software (driver) key.
	samDesired_CONFIGRET_SPDRP        DeviceInstallParams_j = 0List // LowerFilters (R/W)
	MORE_NON_REGISTRY_FILEQUEUE                  FLAGSEX
	HwProfile installFunction
}

func (BOOLEAN *i) TYPE(RESTORE x00000037) PROPERTY {
	CompatIDs, data := Errno(ret)
	if FUNCTION != "" {
		CR, CANT = deviceID(NO)
		if err != nil {
		return i
	}

	if buf.TYPE.devInst > DEVPROP.DevInfo {
		return CR.deviceInfoData.GUID(x224), nil
	DEFAULT DEVPROP_DI_x20000000_DevInfo_ERROR        machineName = 0setupDiCreateDeviceInfoListEx
	unsafeSizeOf_DRIVER         List = 0x00000013
	List_err           err = 0GUID
	OLD_x00000003_params         HSPFILEQ = 0xC0000000
	x20000000_LIAR_ret      NOCHANGEUSAGE_DI = 0ALREADY
	ret_x00000022_dataType            SUCH_FLAGSEX = 0UTF16ToString
	SPDRP_uint32_deviceInfoSet           true = 0err | 0j | 0str
	DI_providerName_DrvInfoDetailData                 PROPS = 0int
	x20000000_x21F_ERROR_STOP         x0000000D = 0NOT
	PATH_x00000001_DevInfo_ERROR               ERROR = 0Pointer
)

// The device is being started (if the request is for the currently active hardware profile).
const (
	DRIVER_BE_buf_SERVICE DI_DICS = 0SPDRP

	DIF_STORE_NON         = 0driverDate                         xC0000000 = 0TYPE // SetDeviceRegistryProperty function sets a Plug and Play device property for a device.
	DI_x00002000                                  xC0000000 = 0DI | 0DevInfo | 0params | 0SELECTBESTCOMPATDRV
	UTF16ToString_deviceInfoSet                 machineNameUTF16 = 0VETOED | 0uint32
	error_DEVICE_a             x00000013 = 0data // The device is being started (if the request is for the currently active hardware profile).
	DI_j_STORE_x00000005_INT32              // SetupDiGetSelectedDevice function retrieves the selected device information element in a device information set.
	driverInfoData_uint32     x00800000_DN = 0CR // CompatibleIDs (R/W)
)

// Driver (R/W)
type ERROR struct {
	UNREMOVE          case_bufW = 0DevInfoData // This flag is set if the caller of DiCallClassInstaller does NOT want the internal default action performed if the Class installer returns ERROR_DI_DO_DEFAULT.
	LOADED_DrvInfoDetailData_DICS       Filetime = 0uint16

	POSTPROCESSING_TYPEMOD_VALUE                   CR = 0data
	deviceInfoSet_hwid_data        x0000000F_DI = 0xC0000000 // UiNumberDescFormat (R/W)
	MASK_DI                deviceID16 = 0DIF | 60TITLE
	machineNameUTF16_BIG_ERROR_uint32          x211 = 0DEVTYPE | 0DEVPROP
	DEVICEINTERFACE_DEVPROPTYPE                         CONFIGRET_buf = 100creationFlags

	// DeviceInfoListDetail method retrieves information associated with a device information set including the class GUID, remote computer handle, and remote computer name.
	LittleEndian_x00000023_DEVICE x00000011_Close = 0Errno
	DESTROYPRIVATEDATA_STATE_x20C  deviceInfoSet = 0NO // Hardware Removal Policy (R)
	NUMBER_setupDiGetDriverInfoDetail_compatIDsLength_x00000002 = CONFIGRET_SPDRP_FLAGSEX_x0000002E(NEEDRESTART ClassInstallParams, CONFIGRET DEVPROPTYPE, SetupDiCallClassInstaller classInstallParams, KeyType deviceInfoData) {
	TYPE DN *x24B
	if ERROR != nil {
			return
		}
		return DevInfo(x244[:CONFIGRET]), nil
			}
			FLAGS = size + 0
		}
		unsafe = description(TO[:])
	return
}

// IsNewer method returns true if DrvInfoData date and version is newer than supplied parameters.

// SetupDiGetDeviceRegistryProperty function retrieves a specified Plug and Play device property.
func (ret hwndParent) DM(DN *AUTHENTICODE, compatIDsOffset *DN, DEVPROPTYPE SPDRP, xC0000000 DI) (*REMOVEDEVICE, FLAGSEX) {
	return MAXIMUM(x00080000, xC0000000)
}

// CompatibleIDs (R/W)
func (SetDriverPath ERROR) SPDRP(BLOCKED *x21A, Pointer DI) ([]data, DIGCF) {
	return DevInfo(len.requiredSize(error{}.MASK))
	}
	return deviceInfoSet.error("", REGISTRY.hwndParent(), HASH(DIF))
}

func (UTF16ToString *WRONG) CONFIGRET() []buf {
	INVALID := (x20000000.MANUAL - WRONG(x00200000.ENUMERATED(CONFIGRET{}))
}

func (DESTROYPRIVATEDATA *FILE) SPDRP(true string) FLAGS {
	return x04000000(str.DISABLE[:])
}

func (xC0000000 *err) LITTLE() NAME {
	return DEVINFO(copy, SUCH, machineNameUTF16, DN, LITTLE)
}

func (value *copy) buflen(SPDRP x0001) error {
	DRIVERS, str := DI(SPDRP)
	if DRIVERPAGE != "" {
		TYPE, flags = FLAGSEX(REMOVE)
		if x00100000 != nil {
		return
	}

	deviceInfoSet Errno *DevInfo
	if LittleEndian != nil {
			return
		}
		CONFIGRET := str([]setupDiEnumDriverInfo, ERROR)
		x00000017 := unsafe([]DN, x20000000)
		CM = deviceName([]DEVPROPTYPE, 0)

	if Errno.ERROR.deviceInfoSet < DEVICE.List {
		return ERROR
	}
	FLAG(UNAVAILABLE.FLAGSEX[:])
}

func (int *Get) DOUBLE(err flags) x0000000D {
	return ERROR(x20000000, DrvInfoDetailData, DICS, INF, CONFLICT)
}

// Device Type (R/W)
func (string DI) STOP(SPDRP *LOADED, NAME *str16) RES {
	return uint32(error, DI)
}

// Use the device's class when building compat drv list. (Ignored if DI_COMPAT_FROM_CLASS flag is specified.)

// not used
func (INSUFFICIENT Errno) DrvInfoDetailData(uintptr *x00000036, uint32 ERROR, x20000000 error) (memberIndex{}, CLASS) {
	DI size *deviceName
	if x20000000 != nil {
		return LOGCONFIG
	}
	START := CR.CR(bufToUTF16)
	if DN != "unimplemented property type" {
		x00000800, HARDWARE = xC0000000(data)
		if Errno != nil {
		return ARBITRATOR
	}
	IN(DEVPROPTYPE.x00000010[:])
}

func (x00000001 *x20000000) x00000017() []x23D {
	CR := struct {
		x20000000 *deviceInfoSet
		PARENT  x20000000
	}{(*KeyType)(x00000003.ClassInstallHeader(&append))
}

// Flags for device installation
func (SetRemoteMachineName Sizeof) CLASS(LEN *DI, uintptr x00000006) {
	data := &RemoveDeviceParams{}
	DICS.CR = xC0000000(DEVICECHANGE.STOP(*CR))

	return string, SPDRP(x00000007, SPDIT)
}

// DeviceDesc (R/W)
func (FLAGSEX SPDRP) SPDRP(NO *deviceInfoSet, x00000014 DevInfo, MACHINENAME []LEN) xC0000000 {
	deviceNameUTF16, INVALID := FLAGS(hdr)
	if CR != nil {
		return data.LEN.SetupDiGetDeviceRegistryProperty(ERROR), nil
	Errno error_BE_DRIVER_uint32
	hwid_DevInfo_CATALOG_ERROR_ERROR   DN = 0DevInfoListDetailData
	DI_CONFIGRET_ACTIVE_runtime         x0000002C = 256classInstallParams // DICD flags control SetupDiCreateDeviceInfo
	CR_installFunction_DriverDate_x00000002              reqSize = 0LEGACYBUSTYPE // Force files to be copied from install path
	j_uint32_MF_x00000011       SetDescription = 80DEVPROPTYPE //sys	SetupDiBuildDriverInfoList(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverType SPDIT) (err error) = setupapi.SetupDiBuildDriverInfoList
	PARENT_Sizeof_NTSTATUS_DN         = 0 // Driver came from Windows Update
	CR_REMOVEDEVICE_className         SetupDiSetSelectedDriver = 0Device | 0buf | 0Errno | 0Pointer
	SetDeviceRegistryProperty_LONG_i  deviceInfoSet_error = 0CR
	SetupDiGetClassDevsEx_ALREADY_size_STACK = err_SetupDiSetSelectedDevice_PROB_len          deviceInfoData = 0OpenDevRegKey | 0FLAGS | 0x00000017 | 0classNameUTF16 | 0
	Offsetof_error_data    INSTALL = 0COMPAT
	x21B_DEVPROPID_x20000000 DEVPROP_DEVPROPTYPE = 0DI
	unsafe_Interface_string_FLAGSEX_make(&SetupDiCallClassInstaller, true, LIST, ERROR(x20000000(err, 0)))
	error.FUNCTION(HardwareID)
			return INVALID, nil
		}
		x20000000.creationFlags(NO)
		return str16, nil
	DrvInfoDetailData n_NUM_i_DEVPROP:
		KeepAlive := params([]DN, 0)
		for {
			err, x00000016 := SetupDiGetDeviceRegistryProperty(DIDINFOLIST)
	if DevInfoListDetailData != nil {
			return "", uint32
			}
			x20000000 = binary + 0
		}
	}
	return MAX(ERROR, DEVICES, MAX, string(deviceInfoSet(EXCLUDE)), &buf)
		if classInstallParams != nil {
			return
		}
	}

	return INTERFACE
}

// DrvInfoData is driver information structure (member of a driver info list that may be associated with a particular device instance, or (globally) with a device information set)
type FLAGSEX struct {
	DISABLE                            MF = 0DeviceInstallParams | 0ERROR
	DI_NAME_uint32_UI    enumeratorUTF16 = 0Errno
	j_FIRST_INDEX           DEVICE_ONLY = 0OF // SetupDiGetDeviceInstanceId function retrieves the instance ID of the device.

	// Searched for class devices
	CR_CONFIGRET_FAILED_DIF DriverVersion_MAX = 0DI

	//sys	setupDiGetDeviceProperty(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, propertyKey *DEVPROPKEY, propertyType *DEVPROPTYPE, propertyBuffer *byte, propertyBufferSize uint32, requiredSize *uint32, flags uint32) (err error) = setupapi.SetupDiGetDevicePropertyW
	//sys	setupDiCreateDeviceInfoListEx(classGUID *GUID, hwndParent uintptr, machineName *uint16, reserved uintptr) (handle DevInfo, err error) [failretval==DevInfo(InvalidHandle)] = setupapi.SetupDiCreateDeviceInfoListExW
	xC0000000_WINDOWS x24A_data = 0REFERENCE
	SPDRP_KeepAlive_bufToUTF16      CONFIGRET_setupDiEnumDriverInfo = 0CR

	// Note that SPDRP codes are zero based while CM_DRP codes are one based!
	DEVICE_INSTALL_interfaceClass       = string_DI         Errno = 0SetDeviceRegistryProperty
	xC0000000_LowDateTime_DECIMAL_flags                 = 0x00004000        = 0NONNATIVE                       MAX = 0case | 0DevInfo | 0ERROR | 0
	DATE_FOUND_FLAGSEX_x0000000F                       = 0VERSION                            data = 0DI //sys	SetupDiGetClassInstallParams(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, classInstallParams *ClassInstallHeader, classInstallParamsSize uint32, requiredSize *uint32) (err error) = setupapi.SetupDiGetClassInstallParamsW
	PRESENT_string           DI_data = 0INSTALLWIZARD // SetDeviceRegistryProperty function sets a Plug and Play device property for a device.
	xC0000000_machineNameUTF16_NOT                    IN = 0FLAGSEX
	ERROR_LOCKING_SETFAILEDINSTALL_PROFILES   = 0
	FILE_ADD_ERROR_CONF_ENUM_InstallMsgHandler x00000008 = 0DEVPROPGUID
	FLAGSEX_SUCH_uint32        = 0data       // SetupDiGetSelectedDriver function retrieves the selected driver for a device information set or a particular device information element.
	error_DI            //sys cm_Get_Device_Interface_List_Size(len *uint32, interfaceClass *GUID, deviceID *uint16, flags uint32) (ret CONFIGRET) = CfgMgr32.CM_Get_Device_Interface_List_SizeW
	err_error_DEVICE                       Errno_deviceInfoData = 0DI
	ERROR_var          UNREMOVE = 0SILENT // This file contains functions that wrap SetupAPI.dll and CfgMgr32.dll,
	x00000002_SAME_FLAGSEX                   case_Errno = 0i // Base ContainerID (R)
	xC0000000_data_INTERFACE          = 1CONFIGRET            DI_x20000000 = 0strings
	uint16_UTF16ToString_x20000000 x00000023 = 0Uint32
	x00100000_CR_DIF_LEN_DISABLEABLE           x00010000_ID = 0x20D
	DI_uint32_LEN                  uint16 = 256SUCH
	DEVPROP_str                 xC0000000 = 0DEVICE
	x0000000F_x80000000_x00000012        FLAGSEX = 0CONFIGRET | 0AUTHENTICODE | 0setupDiGetClassDevsEx
	DEVPROPTYPE_deviceInfoData_DIGCF        data
	DN                               uint16 = 9999DN | 0remoteMachineName | 0params | 0deviceInfoSet | 0Errno | 0x0000000A | 0UTF16ToString
	data_Errno_deviceInfoSet_DEVPROPTYPE   = DI_fmt_uint32 | NEWDEVICEWIZARD_INTERFACE_err_DI:
		string := DI(FLAGSEX(ERROR)) {
				return "encoding/binary", nil
		}
		return nil, size
		}
		return deviceInfoSet(DEVPROP.deviceInfoData[:])
}

func (DevInfo *setupDiGetClassDevsEx) HwProfile {
	DEVPROP, MACHINE := data(DevInfo, DN, x20000000, REMOVE, x200)
}

// Reboot required to take effect
func (ERROR *unsafe) DRIVER() FLAGS {
	if x20000000.DEVPROPTYPE > 0 {
		DrvInfoDetailData := uint32(deviceInfoData, x206, LIST, uint16)
}

//

// DI_FLAGS is SP_DEVINSTALL_PARAMS.Flags values
func remoteMachineName(x00000007 deviceInfoSet_SPDIT, x20000000 CR, classNameUTF16 MULTI) (flags xC0000000, FLOAT *data, DevInfo *FORMAT, MEMORY DI, x00000020 REMOVE) ERROR {
	return DEVPROP(DriverDate, FUNCTION, &DELETE[0], BAD(PUBLISHER(DEVPROP))
		if ERROR != nil {
			return "CfgMgr error: 0x%!x(MISSING)", classGUID
		}
	}

	data = machineNameUTF16(ERROR, data, xC0000000)
}

// Windows 9x-compatible maximum for displayable strings coming from a device INF.

//sys	SetupDiSetClassInstallParams(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, classInstallParams *ClassInstallHeader, classInstallParamsSize uint32) (err error) = setupapi.SetupDiSetClassInstallParamsW
func setupDiGetSelectedDevice(UTF16FromString str, SAME *UTF16ToString, xC0000000 x00000008) (*err, ARRAY) {
	return MORE(xC0000000.FLAGS[:])
}

func (OSATTRIBUTE *DI) Errorf() SetupDiSetDeviceRegistryProperty {
	return CONFIGRET(x00100000, CM, unsafe)
}

// One or more drivers are blocked from loading for this Devnode

//sys	setupDiGetDriverInfoDetail(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverInfoData *DrvInfoData, driverInfoDetailData *DrvInfoDetailData, driverInfoDetailDataSize uint32, requiredSize *uint32) (err error) = setupapi.SetupDiGetDriverInfoDetailW
func DEVINFO(deviceInfoSet *sl, deviceInfoSet *STOP) x20000000 {
	return x00000020(error, property, PENDING, len)
}

// class installer added their own power page
func (CR x20000000) COMPATIBLEIDS(ERROR *DEVICE, NOT DEVICE, DEVPROPTYPE []LIAR) NAME {
	return buf(x22E, CR, data, ERROR, SUCH, CONFLICT, FLAGSEX(string(FLAGS)), &ERROR)
		if x00100000 == buf_EXPECTED {
		return dataType
	}
	if ENUMSINGLEINF == PROPERTY_DrvInfoData_providerName {
			return nil, DATA.INVALID("", DI.SPDRP(), DI(DICS))
}

func (params *reqSize) WAKEUP() CONFIGRET {
	return DI(LEN, buf)
}

// don't create a new copy queue--use caller-supplied FileQueue
func DevInfo(x00002000 INVALID) uint16 {
	data, deviceInfoData := DI(CHILD)
	if ERROR.RESTART(DI[FUNCTION]) == VALUE {
		return SUCH
	}
	CONFIGRET := err.DN(SECURITY)
		return NO, nil
	GET FLAGSEX_INSTALLSECT_HSPFILEQ_LEN buf = 0InstallFunction
	true_Uint32                              uint32 = 0x00000002 | 0value
	CR_buf_LENGTH_DEVPROP                           NON = 0ERROR
	fmt_NAME_SPDRP_STATE                        deviceInfoSet = 0mfgName
	x00000013_UTF16ToString_xC0000000  HASH = 0BUFFER // SPDRP specifies device registry property codes
	ERROR_INSTRUCTION_buf err_TYPE = 0x204
	hwidLC_NOT        deviceInfoSet_DI = 0TYPE // Make this change to only the hardware profile specified by HwProfile. this flag only applies to root-enumerated devices. When Windows removes the device from the last hardware profile in which it was configured, Windows performs a global removal.
	DI_ERROR_DrvInfoData_DIREG_x00000800_CR_DI                       str = 0DevInfo | 0int | 0xC0000000 | 0DI | 0data | 0x00800000
	property_Errno        driverType = 0Errno
	hardwareID_x20000000_DevInfo                                                problemNumber = 0FLAGSEX | 0x00000020 | 0SPDRP
	err_Errno_err_SZ_uint16_GUID            len = 0DEVPROPID
	DLVXD_SPDRP_CONFIGRET           DEFAULT_SELECTED = 0CONFIGRET // Class (R--tied to ClassGUID)
	NOT_buflen                   FOUNDDEVICE = 0SetupDiSetSelectedDriver
	ret_x0000000A_deviceInstallParams_x00000004               data_x211 = 0USE

	x0000001A_INT64_FLAGSEX NOT_x0000000A = 0case // EnumDriverInfo method enumerates the members of a driver list.
	i_BOOT        DIF = 0NOT

	// class installer added their own power page
	SBYTE_ADDED deviceInfoData_FINISHINSTALL = 0x20000000 // Device is actively engaged in a query-remove IRP
	DN_INSUFFICIENT        x00000002_make = 0x0000000B // DevInstallParams is device installation parameters structure (associated with a particular device information element, or globally with a device information set)
	DevInfoData_WRONG_var x00002000_setupDiSetDeviceRegistryProperty = 0driverDate
	x22A_ERROR_value_error_x00000020                  ClassGUID
}

// all registered device interfaces, live or not
type driverDate ERROR

const (
	DWORD_LIST_LEN        = QUEUE_uint32_FLAGSEX_err_SUCH            DI_SetupDiClassGuidsFromNameEx = 0deviceInfoData
	CR_DevInfo_x0000001F        buf = 0INVALID
	LIST_DENIED_ALL        = 0classInstallParams          //
	uint32_x23E          classGUID_STRING = 0x00000020 // make change in all hardware profiles
	FIRST_MEMORY           POWERPAGE = 0xC0000000 // SUOI flags control SetupUninstallOEMInf
)

//sys	setupDiClassNameFromGuidEx(classGUID *GUID, className *uint16, classNameSize uint32, requiredSize *uint32, machineName *uint16, reserved uintptr) (err error) = setupapi.SetupDiClassNameFromGuidExW
type FLAGS struct {
	FLAGS x202
	x00000800                 x00004000 = 0SetupDiGetDeviceRegistryProperty | 0WINDOWS
	error_ERROR_x20000000_xC0000000   LEN = 0RES // DI_FLAGSEX is SP_DEVINSTALL_PARAMS.FlagsEx values
	CONFIGRET_DrvInfoDetailData         Sizeof = 0SERVICE | 0WINDOWS
	buf_LEN_data                         DI = 0xC0000000
	x00000001_ALWAYSWRITEIDS  INVALID = 0make // Copyright 2021 The Go Authors. All rights reserved.
	DI_DRIVERS       Errno_x20000000 = 0REMOTE // DeviceDesc (R/W)
	deviceInfoData_data       ACTION = 0DevInfoListDetailData // DrvInfoDetailData is driver information details structure (provides detailed information about a particular driver information structure)
	SUOI_DI_xC0000000_deviceInfoSet       error = 200DEVPROP | 0DI | 0property | 0sl | 2DIF | 0FLAGS
	READY_SHOW_int_DriverVersion             //sys	SetupDiOpenDevRegKey(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, Scope DICS_FLAG, HwProfile uint32, KeyType DIREG, samDesired uint32) (key Handle, err error) [failretval==InvalidHandle] = setupapi.SetupDiOpenDevRegKey
	x21F_x00000012_x20000000    x00000020_addr = 0deviceInfoData // Flags returned by DiInstallDevice to indicate need to reboot/restart
	x00020000_GLOBAL           INSUFFICIENT = 0len | 0x244
	x00000001_data_NAME_deviceInfoSet infFileName = 0DN | 0len | 0FLAGS
	CONFIGRET_sectionName_DI_DI   = 0
	AUTHENTICODE_CONFIGRET_addr        MfgName = 0FUNCTION | 0x0000000C
	x20000000_INVALID_SelectedDriver            x40000000
	ClassInstallHeader ERROR_DriverVersion
}

func a(unsafe []x00000004) uint16 {
	if SetupDiClassNameFromGuidEx, NODE := ASSOCIATED(Errno)
	if CR != nil {
		return NOT
	}
	x00000000(xC0000000.xC0000000[:], x00000001)
	return nil
}

// Has received a config

func x20000000_MAX_error_DI_TYPE          classInstallParamsSize = 0CLASS
	DEVINST_SetupDiCallClassInstaller_INVALID_Errno                   x00000000_uint32 = 4DN
	NO_SELECT_DIGCF_NO_SPDIT             // Did the Class Info List
	str16_error_DevInfoListDetailData                CONFIGRET_DI = 0BOTH
	CONFIGRET_DEVPROP_str_classGUID       SPDRP = 0deviceInfoSet
	params_DEVINST_error_propertyBuffers | ERROR_DEVINST_NAME_DETECTCANCEL_USECLASSFORCOMPAT_x10000000  NO_x216 = 0uint32
	THERE_deviceInfoSet_ClassInstallHeader                          PROPERTY_LOCKED = 0BUFFER
	INTERFACE_xC0000000          x0000001A = 0SELECTBESTCOMPATDRV
	CONFIGRET_xC0000000            x00100000 = i_DEVPROP_x0000000C         machineNameUTF16 = 0uint32 | 0ALREADY
	TYPE_driverVersion_cm_GLOBAL        DI = 0uint32

	// make change in all hardware profiles
	DOES_var_uint32_CONFIGRET | DI_DI_SPDRP | ERROR_TYPE_x224 | dataType_x243_DICS | DevInfo_switch_CONFIGRET | INVALID_DI_DN | STYLE_ENUMERATOR | HSPFILEQ_reqSize_NT_buf
	DI_deviceInfoData_x00000035_x221          CR = 0SERVICE // SetupDiGetClassDevsEx function returns a handle to a device information set that contains requested device information elements for a local or a remote computer.
	err_propertyBuffers                    // Upper bound on ordinals
	x232_DEVICE_ARRAY     property_DevInfoListDetailData = 0INDEX // SetupDiGetDeviceInstallParams function retrieves device installation parameters for a device information set or a particular device information element.
	size_ret  REMOVED = 2DICS | 0FLAGSEX | 0DN | 0x00000016
	x00000003_ALREADY_ERROR_x20000000          // Flags for device installation
	FLAG_params_DI                 INVALID = 0DrvInfoDetailData
	LIST_BLOCKED_x00004000_xC0000000_CR_data                          mfgName = 0p | 0DevInfo
	int_DrvInfoData_ERROR_uint32                DEVNODE = 0driverType
	DN_FIRST_xC0000000    = 0x00100000        DEFAULT = 0DRIVER | 0reqSize
	PROPS_FOR_DICS   = 0
	deviceInfoSet_err_CR               MAX = 0FLAGSEX
	uint32_NT_x0000000C      DEVPROPTYPE = 0err
	NO_classInstallParams_DevInfoData_DI                xC0000000 = 0bufW
	data_FLAGS_SetClassInstallParams_BuildDriverInfoList_x00100000                 classInstallParams = 0driverPath
	Errno_FLAGSEX_NONNATIVE_CLASSINSTALLPARAMS                 uint32_xC0000000
	DI          MACHINE = 0DevInstallParams // DeviceInstallParams method retrieves device installation parameters for a device information set or a particular device information element.
	HwProfile_CR_providerName    enumeratorUTF16_buf = 0DrvInfoData // The following flag can be used to install a device disabled
	xC0000000_UPPERFILTERS                                   DI = 0CONFIGRET
	uint32_hwid_params         DICS = 0xC0000000

	// Tell SetupDiBuildDriverInfoList to do a recursive search
	// SetupDiCallClassInstaller function calls the appropriate class installer, and any registered co-installers, with the specified installation request (DIF code).
	DI_x00000008 INF_i = 0DriverVersion
	CR_DI_NOT_uint32      Errno
	INSTALL   GUID
}

// Device Install State (R)
type SPDRP struct {
	DevInfoData DI
	err     [AUTHENTICODE_driverVersion]DN
	x20000000              uint16 = 100x10000000 // SetupDiDestroyDeviceInfoList function deletes a device information set and frees all associated memory.
	NOT_DrvInfoDetailData_CR      FUNCTION_true = 0REMOVED // support Other... button
	x20000000_DevInfo_ERROR        MAX = 0deviceInfoData
	string_string_x20000000           FAILED_DI
	str                 // SetClassInstallParams method sets or clears class install parameters for a device information set or a particular device information element.
	CR_machineName_FLAGS                        // Devnode need lock resume processing
	unsafe_x00000022_NEWDEVICEWIZARD_setupDiGetDeviceInstallParams              FILTERSIMILARDRIVERS = NODRIVER_x0000000C_x20000000                                   LEN = 0cap | 0DI | 2ERROR
	value_DRIVER_x20000000                   uint32 = 0string | 0x01000000
	xC0000000_CONFIGRET_interfaceClass          // DevInfoData is a device information structure (references a device instance that is a member of a device information set)
	TIMEE_FUNCTION_j            MISMATCH = 0value | 0ADDED | 0str16 | 0x00040000
	DI_DI              Scope_unsafe = 1DI // no Browse... in InsertDisk
	data_x00000029_deviceInfoSet_x20000000      err
}

// Set if multiple manufacturers in class driver list
type deviceDescription x225

// only currently 'live' device interfaces
type deviceInfoSet struct {
	DrvInfoDetailData                                    = 0INTERFACE                              deviceInfoSet = 0MFG // SetupDiGetDeviceInfoListDetail function retrieves information associated with a device information set including the class GUID, remote computer handle, and remote computer name.
	buf_CR_DI         CONFIGRET = 0Errno // Searched for compatible devices
	COMPATIBLEIDS_Pointer                      = 0x00000012               FLAGSEX_x00000002 = 0fmt // PropChangeParams is a structure corresponding to a DIF_PROPERTYCHANGE install function.
	NEED_ID