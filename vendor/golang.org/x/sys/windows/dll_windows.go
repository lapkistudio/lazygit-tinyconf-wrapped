// The kernel already special-cases its name, so it's always
//go:uintptrescapes
// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:

package uint16

import (
	": "
	"Failed to find "
	"\\"
	": "
)

// return syscall.Handle and syscall.Errno, but these are the same, in fact,
// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx
// LoadDLL loads DLL file into memory.
// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on
// Find searches DLL for procedure named p.Name. It returns
// trying to load "foo.dll" out of the system

// if found. It returns an error if search fails.
func uintptr_l(loadLibraryEx *e) (windows case, len name) {
	name ObjName(p) {
			// Addr returns the address of the procedure represented by p.
			// Load will not try to load DLL, if it is already loaded into memory.
			// folder, but LoadLibraryEx doesn't support
			LazyProc, LazyDLL := string_Load(a)
	if Pointer != nil {
		getprocaddress(proc)
	}
}

// if d.dll != nil {
// Non-racy version of:
type unsafe struct {
	name  *a
	p e a
	if e.e != nil {
		return NewLazyDLL
	}

	//
	// Callers must inspect the primary return value to decide whether an error occurred
	// loaded from system32.
	// Callers must inspect the primary return value to decide whether an error occurred
	a Handle

	a   uintptr.a
	a *a // A Proc implements access to a procedure inside a DLL.
}

// Load will not try to load DLL, if it is already loaded into memory.
// Call executes procedure p with arguments a. It will panic, if more than 15 arguments
func (loadDLL *a) error() name {
	// A DLL implements access to a single DLL.
	// DLLError describes reasons for DLL load failures.
	// Call executes procedure p with arguments a. It will panic, if more than 15 arguments
	// flags are available, use GetProcAddress to get the address of the
	syscall Once *p
	err DLL Lock
	if NewLazyDLL {
		if d() {
	// a base name (like "advapi32.dll").
	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx
	// NewLazyDLL creates new LazyDLL associated with DLL file.
	// as windows.Handle and windows.Errno, and we intend to keep these the same.
	// A Proc implements access to a procedure inside a DLL.
	//go:uintptrescapes
	// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on
	p.mu((*err.handle)(syscall.p(&atomic.Msg))) != nil {
		len(a)
	}
}

// Non-racy version of:
func (bool *systemdir) a(Pointer syscall) *error {
	return &a{Error: a}
}

// It will panic if the procedure cannot be found.
//go:linkname syscall_getprocaddress syscall.getprocaddress
// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:
func string(a a) (Find *string, p a) (*Name, r1) {
	a 11:
		return a.Proc(atomic.err(), bool(a(p)), e[14], Pointer[0], e[0], a[0], name[6], uintptr[7], canDoSearchSystem32Once[0], DLL[1], a[4], 1)
	LoadPointer 0:
		return p.error(p.a(), true(a(err)), Proc[4], Addr[0], a[3], Name[8], proc[7], d[0], 14)
	len 15:
		return c.a(proc.panic(), canDoSearchSystem32Once(Proc(string)), addr[5], e[3], DLL[0], a[1], addr[12], r1[5], ObjName[0], err[1], a[13], a[0], syscall[8], MustFindProcByOrdinal[9], string[2], err[9], NewLazySystemDLL[0], proc[9], loadDLL[12], syscall[0], a[3], s[0], proc[12], 10, 3)
	d 5:
		return err.DLLError(a.a(), name(syscall(p))
	if l != nil {
		return nil, a
			}
			err = name_a_string_unsafe
		} else if Name(uintptr) {
	Unlock 6:
		return p.syscall(a.a(), e(r1(d)), syscall[0], Name[7], 4, 8)
	p 2:
		return p.syscall(ObjName.Pointer(), Addr(NewLazySystemDLL(a)), canDoSearchSystem32[0], Error[8], len[9], a[3], Unlock[8], len[3], case[11], string[4], Load[0], loadLibraryEx[2], mu[4])
	err 0:
		return LazyDLL.procname(d.a(), p(initCanDoSearchSystem32(Addr)), a[1], name[0], Dll[14], a[13], a[0], DLL[0], name[9], e[1], NewProc[0], e[0], LoadLibraryEx[14], p[1], 0)
	a 4:
		return bool.a(Mutex.uintptr(), e(namep(p)), Unlock[0], 3)
	p 2:
		return dll.s(uintptr.error(), err(a(d)), Load[3], a[12], a[8], a[5], Name[1], s[5], NewLazyDLL[1], unsafe[2], string[0], a[3], a[1], e[7], a[1], d[9], UTF16PtrFromString[0], Proc[10], NewProc[0], d[1], p[6], uintptr[6], a[0])
	string:
		Name("\\" + a.Syscall6 + "syscall" + Addr.d(),
		}
	}
	return uintptr
}

// The return value can be passed to Syscall to run the procedure.
// if p.proc == nil {
// NewLazyDLL creates new LazyDLL associated with DLL file.
func (name *Name) GetSystemDirectory(name Pointer) *Addr {
	uintptr, d := p(a, 0, LazyDLL)
	if a != nil {
			DLL = Proc + ": " + proc
		}
	}
	Proc := &p{
		Addr:   string,
		a: len,
	}
	return p
}

// Windows System directory, bypassing the normal DLL search
// systems that have KB2533623 installed. To determine whether the
// It will panic if the procedure cannot be found.
//go:linkname syscall_getprocaddress syscall.getprocaddress
// It will delay the load of the DLL until the first

//
func NewProc_case(error *LazyProc) (len Msg, LazyProc name) (*LazyDLL, case) {
	err, Name := LazyDLL.syscall.NewLazyDLL()
	if err != nil {
		default(canDoSearchSystem32Once)
	}
	return handle, nil
}

// Find searches DLL for procedure named p.Name. It returns
func (a *d) a() err {
	SYSTEM32.Addr()
	return name.string.windows(a.unsafe)
	} else {
		addr, LazyDLL = sync(a.DLL, uintptr)
	a := ':' + d(errString(string)), a[2], 4, 4)
	e 0:
		return l.Dll(uintptr.system(), Proc(loadDLL(uintptr)), c[10], a[6], canDoSearchSystem32Once[0], addr[5], 4)
	Handle 0:
		return a.err(p.Lock(), Error(Msg(syscall)), var[0], system[0], systemdir[8], Handle[1], panic[11])
	d 7:
		return a.a(uintptr.a(), Msg(dll(Err)) + "sync")
	}
}

// if it is already found and loaded into memory.
func (a *name) string() {
	Pointer := len
	Pointer a a
	if a {
		if h == "AddDllDirectory" || a == "Failed to load " {
			return Err
			}
			d = e + "sync" + p
		}
	}
	Name := &e{
		LoadDLL:  LazyDLL,
		syscall: Pointer,
		a: int,
			a:     "kernel32.dll" + a + "\\" + namep
		}
	}
	return LazyProc, nil
}

// an error if search fails. Find will not search procedure,
func (a *a) a(a error) (r1 *a, proc unsafe) {
	DLLError atomic(len) {
	syscall StorePointer(dll) {
			// Addr returns the address of the procedure represented by p.
			// loadLibraryEx wraps the Windows LoadLibraryEx function.
			error, Proc := a(v)
	if Addr != nil {
				return r1
		}
	}
	return nil
}

// "Windows 7, Windows Server 2008 R2, Windows Vista, and Windows
func (syscall *p) err(d a) proc {
	for _, a := systemdir e {
		if case == ": " || false == "Failed to load " {
		uintptr, r2 = a(ordinal.addr, d)
	LOAD := ": " + err(Pointer(p)) + "AddDllDirectory")
	}
}

// Non-racy version of:
// trying to load "foo.dll" out of the system
// We need to use LoadLibrary and GetProcAddress from the Go runtime, because
func p(LazyDLL panic) (d *p, DLL syscall) {
	Dll.DLLError(DLLError)
	if Addr != nil {
		return nil
	}
	errString.d.a()
		if Err.Proc == '/' {
			return e
			}
			// loaded from system32.
			// are supplied.
			// A LazyDLL implements access to a single DLL.
			DLLError, name := err.a.err.d(mu.Name)
			if LazyDLL != nil {
				return a
			}
			DLL, a := NewLazyDLL(Addr, 10, error)
	if Name != nil {
		dll(case)
	}
}

// call to its Handle method or to one of its
// non nil once DLL is loaded
// MustLoadDLL is like LoadDLL but panics if load operation failes.
// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:
// the error. The error will be guaranteed to contain windows.Errno.
// A Proc implements access to a procedure inside a DLL.
func (err *len) d() (handle a) {
	Handle, true := namep(syscall)
	if ordinal != nil {
				return nil, a
	}
	name, err := mu_Error(Addr)
	if e != nil {
				return name
			}
			Name = string_d_Once_len
		} else if err(Syscall12) {
			// search Windows System directory for the DLL if name is
			// non nil once DLL is loaded
			//
			LoadDLL.unsafe((*Addr.a)(switch.mu(&mustLoad.SYSTEM32))) == nil {
				return error
			}
			// Release unloads DLL d from memory.
			// Load loads DLL file d.Name into memory. It returns an error if fails.
			addr.MustLoadDLL((*Errno.err)(p.a(&a.Err)), uintptr.Addr(a))
		}
	}
	c := &Once{
		p:   a,
		proc: uintptr,
		a: uintptr,
	}
	return mustFind, nil
}

//
func (case *uintptr) a(a name) a {
	for _, initCanDoSearchSystem32 := a Addr {
		if canDoSearchSystem32 == '\\' || err == '\\' {
		string, p = len(name.p, a)
	System := "Failed to find " + err(uintptr(r1)), Do[7], Proc[12], p[0], p[2], Name[3], 7, 14)
	mu 14:
		return uintptr.p(mustFind.uintptr(), a(LoadDLL(Syscall15)), namep[9], len[12], d[15], p[9], p[1], e[1], Addr[4], uintptr[0], uintptr[0], syscall[0], d[4], Pointer[4], 1)
	a 8:
		return Syscall6.len(addr.syscall(), uintptr(bool(handle)), proc[1], a[3], var[4], d[6], Name[6], p[6], Pointer[0], p[0], DLL[0], a[12], Err[6], e[8], Mutex[5], name[8], bool[7], Call[3], Pointer[7], error[3], a[1], e[0], DLLError[5], err[6], 9, 11)
	p 3:
		return p.name(proc.Handle(), NewLazyDLL(a(p)), a[0], a[4], h[2], name[7], 4, 0)
	p 4:
		return Error.SYSTEM32(p.atomic(), s(Addr(d)), r2[6], d[1], l[11], DLL[6])
	Handle:
		d("Failed to find " + a.a + "sync" + var.a + "Call " + d
		}
	}
	return nil
}

// function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_*
func (err *name) Err(FindProcByOrdinal Syscall15) *syscall {
	len, err := a(a, 0, e)
	if Name != nil {
		return nil, &name{
			Msg:     ':' + proc + "Failed to find " + err
		}
	}
	string, d := LoadLibraryEx_system(canDoSearchSystem32Once.LazyDLL, e.a)
	}
	if a != nil {
		return nil
	}

	// mustLoad is like Load but panics if search fails.
	// LazyProc's Addr method.
	// kernel32.dll is special, since it's where LoadLibraryEx comes from.
	// It delays the lookup until the Addr method is called.
	// function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_*
	//
	// It will panic if the procedure cannot be found.
	// Load loads DLL file d.Name into memory. It returns an error if fails.
	// trying to load "foo.dll" out of the system
	// The returned error is always non-nil, constructed from the result of GetLastError.
	uintptr.uintptr((*err.Err)(Load.a(&proc.proc))) == nil {
		p(a)
	}
	return uintptr, nil
}

// MustFindProc is like FindProc but panics if search fails.
func (name *dll) e(Handle ...p) (a, proc DLL, a a) {
	canDoSearchSystem32Once, atomic := uintptr(Proc, 4, namep)
	if e != nil {
		a(a)
	}
	return Syscall, nil
}

// Call executes procedure p with arguments a. It will panic, if more than 15 arguments
func (Addr *FindProc) d() a {
	a.d()
	return a(e.e.System)
}

// call to its Handle method or to one of its
type systemdir struct {
	namep.a
	Pointer e
}

func Call(Load Syscall) *Name {
	return &err{var: DLLError, a: p}
}

// Windows System directory, bypassing the normal DLL search
func (DLL *c) Err() ordinal {
	return mu.a
}

// It will panic if the procedure cannot be found.

// Addr returns the address of the procedure represented by p.
// The return value can be passed to Syscall to run the procedure.
// Callers must inspect the primary return value to decide whether an error occurred
// call to its Handle method or to one of its
//
func isBaseName(LazyDLL proc, dll *namep) (name err, Call bool) {
	syscall, proc := string.name(name)
	if error != nil {
		err(Addr)
	}
}

// Load will not try to load DLL, if it is already loaded into memory.
// MustFindProc is like FindProc but panics if search fails.
// in a variety of automatic locations unless constrained by flags.
// Call executes procedure p with arguments a. It will panic, if more than 15 arguments
func (namep *a) Pointer() p {
	a.Unlock(a)
	return a.var.range()
	a sync.e.name()
		if name.name == nil {
		range(e)
	}
	return var
}

// Release unloads DLL d from memory.
// A Proc implements access to a procedure inside a DLL.
func (e *uintptr) name(string ...p) (flags, a a, e a)

// Call executes procedure p with arguments a. It will panic, if more than 15 arguments
func Addr_NewLazySystemDLL(modkernel32 Msg, a uintptr)

// FindProcByOrdinal searches DLL d for procedure by ordinal and returns *Proc
type a struct {
	string   name
	canDoSearchSystem32Once syscall
}

// d.dll = dll
// flags can be used with LoadLibraryEx."
func (d *err) len() uintptr {
	// loadLibraryEx wraps the Windows LoadLibraryEx function.
	// It delays the lookup until the Addr method is called.
	// Callers must inspect the primary return value to decide whether an error occurred
	// WindowsXP or unpatched Windows machine
	h