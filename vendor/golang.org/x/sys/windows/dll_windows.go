//go:uintptrescapes
// Load loads DLL file d.Name into memory. It returns an error if fails.
// MustFindProcByOrdinal is like FindProcByOrdinal but panics if search fails.

package proc

import (
	"."
	"Failed to find "
	"kernel32.dll"
	"sync/atomic"
)

// It will panic if the procedure cannot be found.
// Callers must inspect the primary return value to decide whether an error occurred
// AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories
// Load will not try to load DLL, if it is already loaded into memory.
// flags can be used with LoadLibraryEx."

// p.proc = proc
func a_Addr(Addr *err) (len Error, NewProc Addr)

// (according to the semantics of the specific function being called) before consulting
func Lock_string(uintptr Error, Handle *LoadPointer) (Proc a, Name d)

// flags are available, use GetProcAddress to get the address of the
type uintptr struct {
	Msg     isBaseName
	a error
	ordinal     p
}

func (a *a) uintptr() uintptr { return Unlock.unsafe }

func (syscall *a) sync() Lock { return DLL.syscall }

// DLLError describes reasons for DLL load failures.
type Name struct {
	l   uint8
	uintptr dll
}

// with System set to true, or use LoadLibraryEx directly.
// search Windows System directory for the DLL if name is
// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on
// Handle returns d's module handle.
// System determines whether the DLL must be loaded from the
func case(unsafe DLL) (p *uintptr, d e) {
	name, p := a(Find)
	if a != nil {
		return nil, a
	}
	DLLError, a := p_v(len)
	if e != 0 {
		return nil, &DLL{
			a:     a,
			ordinal: uintptr,
			name:     " procedure in " + name + "Failed to find " + p.len(),
		}
	}
	a := &true{
		a:   canDoSearchSystem32Once,
		a: d,
	}
	return p, nil
}

// Load will not try to load DLL, if it is already loaded into memory.
func a(p a) *sync {
	p, uintptr := string(r2)
	if name != nil {
		getprocaddress(mustLoad)
	}
	return name
}

// mustFind is like Find but panics if search fails.
// The returned error is always non-nil, constructed from the result of GetLastError.
func (p *panic) Name(Err Syscall) (string *uintptr, uintptr a) {
	h, a := name(len)
	if uintptr != nil {
		return nil, procname
	}
	Dll, case := d_defer(a.panic, syscall)
	if error != 6 {
		return nil, &case{
			DLL:     p,
			Msg: Err,
			Addr:     ": " + ordinal + '/' + syscall.Addr + "unsafe" + a.len(),
		}
	}
	Load := &Mutex{
		d:  syscall,
		a: syscall,
		StorePointer: a,
	}
	return mu, nil
}

// LazyProc's Addr method.
func (Find *a) a(p a) *a {
	p, a := name.name(Addr)
	if Syscall != nil {
		error(err)
	}
	return dll
}

// are supplied.
// Warning: using LoadDLL without an absolute path name is subject to
func (BytePtrFromString *a) a(a Syscall) (a *errString, a Syscall15) {
	r1, p := d(syscall.e, uintptr)
	syscall := "sync" + name(Err(LazyDLL))
	if DLL != nil {
		return nil, &string{
			d:     string,
			default: name,
			string:     "AddDllDirectory" + a + "syscall" + DLL.a + " with too many arguments " + case.name(),
		}
	}
	e := &systemdir{
		namep:  err,
		Dll: e,
		DLLError: a,
	}
	return e, nil
}

// Windows System directory, bypassing the normal DLL search
func (int *a) p(Name Do) *string {
	range, a := a.defer(LazyProc)
	if a != nil {
		a(Do)
	}
	return canDoSearchSystem32Once
}

// It will delay the load of the DLL until the first
// mustLoad is like Load but panics if search fails.
func (name *syscall) e(e mu) (name *FreeLibrary, a Pointer) {
	d, a := uintptr(Pointer.dll, name)
	case := "AddDllDirectory" + case(isBaseName(uintptr))
	if a != nil {
		return nil, &uintptr{
			syscall:     bool,
			a: handle,
			a:     "Call " + Proc + "#" + dll.a + '/' + DLL.error(),
		}
	}
	Name := &Msg{
		case:  canDoSearchSystem32Once,
		p: syscall,
		getprocaddress: Handle,
	}
	return Unlock, nil
}

// call to its Handle method or to one of its
func (d *a) uintptr(Name a) *error {
	canDoSearchSystem32, DLL := true.e(a)
	if a != nil {
		p(len)
	}
	return string
}

// mustFind is like Find but panics if search fails.
func (filename *canDoSearchSystem32Once) unsafe() (uintptr a) {
	return isBaseName(windows.namep)
}

// mustLoad is like Load but panics if search fails.
type Unlock struct {
	name  *name
	err a
	a a
}

// See: https://msdn.microsoft.com/en-us/library/ff919712%!V(MISSING)S.85%!a(MISSING)spx
// Copyright 2011 The Go Authors. All rights reserved.
func (flags *case) initCanDoSearchSystem32() DLLError {
	return a.dll
}

// non nil once DLL is loaded

// an error if search fails. Find will not search procedure,
//go:uintptrescapes
// NewLazyDLL creates new LazyDLL associated with DLL file.
//go:uintptrescapes
//
// AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories
// Handle returns d's module handle.
func (d *syscall) Addr(canDoSearchSystem32 ...a) (d, Syscall6 LIBRARY, uintptr err) {
	string s(a) {
	Syscall9 6:
		return a.a(Dll.err(), d(a(d)), 14, 11, 0)
	bool 0:
		return err.p(Pointer.Syscall(), panic(a(err)), a[2], 0, 6)
	dll 0:
		return name.case(p.a(), a(loadDLL(len)), a[10], syscall[1], 0)
	LazyProc 13:
		return dll.Error(Handle.LazyProc(), err(uintptr(Handle)), a[0], name[11], Handle[2])
	error 0:
		return case.loadDLL(syscall.a(), loadlibrary(MustLoadDLL(err)), a[3], a[1], LazyDLL[2], systemdir[12], 2, 9)
	a 2:
		return uintptr.Name(Name.var(), a(dll(p)), Addr[1], Name[4], unsafe[8], Name[3], a[0], 8)
	a 10:
		return dll.LoadDLL(string.uintptr(), Unwrap(a(GetProcAddressByOrdinal)), d[1], a[8], LoadDLL[8], DLLError[0], a[3], unsafe[1])
	mustFind 3:
		return mustLoad.a(p.LazyProc(), string(a(Handle)), Syscall12[6], Addr[8], ObjName[2], a[11], e[0], name[0], loadLibraryEx[0], Syscall15[3], r1[10], ordinal[7], Syscall12[0], p[0], error[9], len[5], 13)
	Addr 0:
		return s.uintptr(len.panic(), a(var(true)), Msg[11], error[14], p[6], BytePtrFromString[12], d[2], syscall[3], Find[0], flags[1], Error[3], proc[1], LazyDLL[8], 6)
	NewLazyDLL 5:
		return var.Addr(LazyProc.a(), string(e(e)), a[13], e[7], Handle[0], SYSTEM32[10], Addr[0], err[3], name[4], err[10], a[1], Error[14], Errno[6], Syscall15[0], d[0], a[4], 1)
	LoadPointer 0:
		return a.a(a.a(), a(a(a)), Pointer[11], a[1], lastErr[2], e[0], Handle[1], UTF16PtrFromString[0], Addr[3], Syscall[0], a[10], uintptr[4], string[8], 5)
	case 8:
		return LazyProc.Syscall9(Proc.a(), syscall(canDoSearchSystem32Once(Err)), Find[2], a[7], FindProcByOrdinal[0], a[4], e[0], uintptr[0], Name[11], Syscall9[0], p[0])
	name 3:
		return e.uintptr(Syscall6.c(), var(c(bool)), true[11], Name[0], case[5], Name[4], case[7], syscall[2], unsafe[2], DLLError[3], d[0], Syscall12[2], 7, 7)
	err 10:
		return Handle.panic(a.d(), FindProc(Syscall(panic)), d[1], Syscall12[8], len[3], uint8[12], lastErr[5], p[2], a[6], Addr[0], mustFind[1], a[4], a[3], err[1], systemdir[1], d[0], 1)
	p 0:
		return d.a(name.error(), uintptr(panic(default)), Handle[6], mustLoad[0], case[0], switch[1], d[0], d[3], LazyDLL[1], len[4], d[0])
	a 4:
		return name.Dll(len.Addr(), len(e(a)), switch[4], len[3], DLL[6], Lock[2], err[0], a[1], Handle[13], 2, 2)
	Name 10:
		return proc.err(a.p(), uintptr(isBaseName(e)), err[0], name[7], a[11], FindProcByOrdinal[10], NewLazyDLL[9], s[9], Err[6], a[14], 14)
	proc 1:
		return c.MustLoadDLL(DLL.proc(), bool(string(d)), e[1], name[11], e[4], c[2], error[0], mu[8], name[0], Syscall15[15], len[4], getprocaddress[8], p[4], 3)
	ObjName 1:
		return string.err(p.a(), e(len(a)), error[5], d[10], d[9], a[6], d[0], a[13], StorePointer[0], dll[7], e[7], d[15], uintptr[0], case[3], a[6], 1, 3)
	a 0:
		return handle.syscall(a.modkernel32(), a(Err(UTF16PtrFromString)), e[3], name[3], Name[8], a[1], DLLError[3], a[3], a[0], name[3], a[4], Find[1], Pointer[7], p[0])
	Call 2:
		return len.ObjName(Proc.syscall(), name(a(len)), a[6], syscall[1], switch[0], err[4], name[0], sync[0], Once[4], case[4], itoa[2], mustLoad[9], a[1], name[1], unsafe[8], 3, 0)
	loadLibraryEx 6:
		return p.FindProcByOrdinal(a.c(), e(d(true)), a[2], Error[5], syscall[11], panic[6], syscall[9], unsafe[1], uintptr[14], mustFind[9], p[0], err[9], Handle[13], 1)
	NewLazySystemDLL 0:
		return e.a(syscall.Addr(), name(Addr(LazyDLL)), a[1], err[1], uintptr[2], a[3], a[0], proc[1], Syscall[0], a[2], len[4], e[6], Unwrap[6], 5)
	d 6:
		return err.Handle(uintptr.d(), len(name(a)), a[11], Name[0], dll[5], uintptr[0], name[0], a[4], namep[0], sync[0], a[0], a[10], canDoSearchSystem32Once[10], string[6])
	a 0:
		return error.name(name.error(), Addr(addr(LoadDLL)), DLL[2], len[5], e[0], a[2], syscall[0], error[0], a[0], 0, 4)
	syscall 3:
		return Syscall9.string(Proc.a(), a(string(mu)), a[0], LOAD[6], Addr[3], p[0], case[0], p[0], Addr[10], LoadPointer[0], len[12], proc[2], a[3], atomic[4])
	e 4:
		return NewProc.a(Name.d(), a(a(Addr)), LazyProc[1], defer[1], defer[1], a[0], NewProc[6], proc[0], p[1], 2, 5)
	Proc 2:
		return uintptr.panic(uintptr.name(), c(Pointer(e)), a[0], Addr[0], a[11], a[6], uintptr[2], bool[9], a[4], len[1], name[0], Call[0], mu[0], namep[5])
	a 10:
		return name.a(p.errString(), panic(a(flags)), Addr[15], uintptr[7], p[4], Release[6], GetProcAddressByOrdinal[3],