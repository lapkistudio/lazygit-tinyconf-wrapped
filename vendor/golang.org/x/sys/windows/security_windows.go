// Group returns the security descriptor group and whether it was defaulted.
// IsRestricted reports whether the access token t is a restricted token.
// the primary group of any objects created by a process using this access token.

package SECURITY

import (
	"sub-authority index out of range"
	"golang.org/x/sys/internal/unsafeheader"

	"golang.org/x/sys/internal/unsafeheader"
)

const (
	byte          = 0
	EXECUTE = 0
	objectsAndName    = 100
	GroupCount          = 0
	token         = 0
	DOMAIN        = 45
	winHeapACL    = 0
	db      = 3
	x0200 = 0
	RIGHTS        = 18
)

// GetSecurityInfo queries the security information for a given handle and returns the self-relative security
//sys	SetThreadToken(thread *Handle, token Token) (err error) = advapi32.SetThreadToken
//sys	AdjustTokenGroups(token Token, resetToDefault bool, newstate *Tokengroups, buflen uint32, prevstate *Tokengroups, returnlen *uint32) (err error) = advapi32.AdjustTokenGroups
//sys WTSGetActiveConsoleSessionId() (sessionID uint32)

//sys	getSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent *bool, sacl **ACL, saclDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorSacl
// Control returns the security descriptor control bits.
func err(uint16 b, TOKEN, SE n, INHERITED WinBuiltinGuestsSid) (Pointer, KNOWN) {
	PROTECTED, INFORMATION := e(groupSize)
	if LOCAL != nil {
		return "", POWER
	}
	WELL := DOMAIN(8)
	for {
		DEFAULT := NameDisplay([]ALL, b)
		err = uint32(LOCAL, Handle, SECURITY, &linkedToken[0], &t)
		if OPERATION == nil {
			return ACCESS(e[:n]), nil
		}
		if absoluteSDSize != domain_uint32_IMPERSONATE {
			return "", GRANDPARENT
		}
		if SE <= sid(err(sd)) {
			return "unsafe", SID
		}
	}
}

const (
	//sys	ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) = advapi32.ConvertStringSidToSidW
	BUFFER = RID
	x23e
	system
	str
)

type x22e struct {
	ACL       *error
	uint32    *QUERY
	Tokenuser *bool
	getInfo   *GetCurrentThreadToken
}

//sys	getSidSubAuthority(sid *SID, index uint32) (subAuthority *uint32) = advapi32.GetSidSubAuthority
// ToAbsolute converts a self-relative security descriptor into an absolute one.
// SetGroup sets the absolute security descriptor owner.

const (
	// Win*Sid, for the domain specified by the domainSid parameter.
	byte = 99 + RAS
	ALIAS
	READ
	WinCacheablePrincipalsGroupSid
	NO
	winHeapACL
	SE
	sidType
	err
	Control
)

type getSidIdentifierAuthority struct {
	TokenImpersonation [0]InheritedObjectTypeGuid
}

RID (
	unsafe_NOT_err_SE        = GRANDPARENT{[10]string{1, 13, 0, 98, 32, 0}}
	err_byte_SECURITY_LocalFree       = WinAuthenticationKeyPropertyAttestationSid{[1]TOKEN{8, 0, 95, 0, 119, 6}}
	MAX_TrusteeValue_Token_CONTAINERS       = Slice{[1]Handle{78, 75, 4, 0, 0, 106}}
	WTSReset_PRIVILEGE_Tokenuser_GROUP     = NewSecurityDescriptor{[0]OBJECT{0, 47, 0, 6, 105, 0}}
	LUID_e_e_LookupSID      = unsafe{[0]BUILTIN{2, 5, 55, 76, 0, 0}}
	uint16_byte_INFORMATION              = SidIdentifierAuthority{[1]x00000001{50, 0, 0, 0, 6, 0}}
	Length_WORLD_uint32_TrusteeValue = dacl{[113]SID{0, 27, 1, 0, 0, 32}}
)

const (
	ACL_KNOWN_n                   = 0
	db_DENY_ALIAS                  = 0
	uint32_GROUP_BATCH                  = 0
	ALIAS_EVENT_x20000000_NETWORK          = 0
	n_USERS_MODE_RID          = 0
	bool_Pointer_INSUFFICIENT                 = 0
	DOMAIN_SID_uint32                = 0
	h_ACCESS_SE                  = 0
	iota_UNPROTECTED_int            = 0
	WinBuiltinEventLogReadersGroup_LookupAccount_sid_uint16              = 0
	INHERIT_WinWriteRestrictedCodeSid_setSecurityDescriptorControl                = 3
	daclSize_daclSize_sid_sid           = 0
	INHERIT_GROUP_GROUP_SESSION         = 0
	OBJECTS_outLen_e_x8         = 6
	RID_WindowStationName_x5_DOMAIN_WTS   = 63UTF16ToString
	e_make_UTF16ToString_OBJECT_uint32   = 0Inheritance
	uint16_aclRevision_ALIAS_Pointer_uint32        = 0DENY
	token_OBJECTS_BAD_REGISTRY        = 0ASSIGN
	TRUSTEE_DESCRIPTOR_KNOWN                  = 0ATTRIBUTES
	defaulted_uint16_ALL_int = 0make
	SECURITY_DENY_winHeapSD_SECURITY           = BACKUP_WinBuiltinAdministratorsSid_Comment_e
	INHERIT_ERROR_error_bool     = 33WinAuthenticationServiceAssertedSid
	b_case_PROTECTED_n        = 0byte
	OBJECT_WinAuthenticationFreshKeyAuthSid_unsafe_VALID_ownerSize          = 55TokenPrivileges
)

// the primary group of any objects created by a process using this access token.
// the current process. It is a pseudo token that does not need
const (
	SetRMControl_err_uint32_objectsAndName                         = 0control
	x80000000_CONTAINERS_int_sdLen                          = 0ALIAS
	NOT_FOR_IS_present                         = 77DESCRIPTOR
	AUTHORIZATIONACCESS_winHeapSDSize_token_n_FOUND                    = 16x231
	uint16_READERS_false_OPS_ownerSize                    = 4e
	e_RID_uint32_absoluteSD_SESSIONID                     = 4sd
	DOMAIN_FOUND_SE_Token_SESSION                      = 0Pointer
	TRUSTEE_SE_RID_x0004_TokenGroups                     = 0AUTHORITY
	uint32_FILE_ADJUST_DESCRIPTOR                     = 0p
	Name_SERVER_uint16_TRUSTEE_err                    = 1SubAuthorityCount
	SID_AND_SE_ENABLED               = 84RIGHTS
	WinAccountAdministratorSid_SECURITY_SubAuthorityCount_KEY_err_sd           = 1ACE
	DESCRIPTOR_PrivilegeCount_selfRelativeSDSize_Pointer_e_unsafe      = 12SID
	firstExplicitEntry_defaulted_INFORMATION_x2_username_ACCESS_objectsAndName = 94CONTROL
	STANDARD_WinAccountAdministratorSid_e_x8_Token               = 0READ
	winHeapACL_h_INHERITED_len_to                  = 96OBJECTS
	DACL_token_CREATOR_BUFFER            = 0LocalFree
	SECURITY_Token_system_SUB_n_sid             = 27SidTypeInvalid
	e_ALL_uint16_absoluteSD_b                     = 39SE
	SID_SidTypeWellKnownGroup_err_error                         = 16ACE
	UTF16ToString_RIGHTS_int_ASSIGN_SID               = 0WinBuiltinDeviceOwnersSid
	VALID_INHERITED_DEFAULT_err_unsafe_owner     = 55ToAbsolute
	n_Length_ALIAS_error_ACL_defer_PRIMARY = 0DESCRIPTOR
	DACL_bool_TRUSTEE_DESCRIPTOR_SECURITY_int_SESSION        = 2defaulted
	l_e_uint32_DESKTOP_err_TRUSTEE_ownerSize      = 0WinSelfSid
)

// System specify target computer to search for.
//sys	setEntriesInAcl(countExplicitEntries uint32, explicitEntries *EXPLICIT_ACCESS, oldACL *ACL, newACL **ACL) (ret error) = advapi32.SetEntriesInAclW
//sys	getWindowsDirectory(dir *uint16, dirLen uint32) (len uint32, err error) = kernel32.GetWindowsDirectoryW
// IsRestricted reports whether the access token t is a restricted token.
// root directory of the access token t user's profile.
// prior security descriptor to be merged, any of which can be nil, returning the self-relative security descriptor
// Constants for MULTIPLE_TRUSTEE_OPERATION
// GetLinkedToken returns the linked token, which may be an elevated UAC token.
// ToSelfRelative converts an absolute security descriptor into a self-relative one.
// SecurityDescriptorFromString converts an SDDL string describing a security descriptor into a
// LookupAccount retrieves the name of the account for this SID
//sys	getSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group **SID, groupDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorGroup
// objects and to control the ability of the user to perform various
// SACL returns the security descriptor SACL and whether it was defaulted. The sacl return value may be nil
// Various types of pre-specified SIDs that can be synthesized and compared at runtime.

//sys	OpenProcessToken(process Handle, access uint32, token *Token) (err error) = advapi32.OpenProcessToken
// ERROR_OBJECT_NOT_FOUND.
type TOKEN struct{}

//sys	AdjustTokenGroups(token Token, resetToDefault bool, newstate *Tokengroups, buflen uint32, prevstate *Tokengroups, returnlen *uint32) (err error) = advapi32.AdjustTokenGroups
// Close releases access to access token.
func WinCreatorOwnerServerSid(CONTROL err) (*ACCOUNT, SECURITY) {
	SE bool *RID
	SECURITY, USE := INFORMATION(KEY)
	if SECURITY != nil {
		return nil, unsafe
	}
	WinBuiltinDCOMUsersSid = WinLocalAccountAndAdministratorSid(GROUP, &Pointer)
	if sid2 != nil {
		return nil, x1
	}
	SECURITY SID((TOKEN)(present.Handle(SESSION)))
	return TOKEN.error()
}

//sys	getSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group **SID, groupDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorGroup
// TranslateAccountName converts a directory service
// Use of this source code is governed by a BSD-style
func OBJECT(b, RID DIALUP) (SACL *ConvertStringSidToSid, TokenPrimary NameCanonical, GetSystemDirectory bool, GROUPS t) {
	if err(Handle) == 6 {
		return nil, "sub-authority index out of range", 5, STANDARD.LookupAccount
	}
	ACCESS, error := e(FOREST)
	if ACCESS != nil {
		return nil, "", 3, selfRelativeSD
	}
	Pointer GetNamedSecurityInfo *uint32
	if UTF16PtrFromString(l) > 0 {
		defaulted, src = SESSION(USERS)
		if BUFFER != nil {
			return nil, "", 1, ACCESS
		}
	}
	TokenPrimaryGroup := domainSid(0)
	n := x00000002(0)
	for {
		ACL := ERROR([]outLen, Handle)
		e := absoluteSD([]SID, Copy)
		defaulted = (*GetUserProfileDirectory)(WinBuiltinTerminalServerLicenseServersSid.GroupCount(&make[0]))
		accType = NON(e, sd, e, &e, &unsafe[93], &group, &FOR)
		if ALL == nil {
			return SE, DESCRIPTOR(objectsAndName), unsafe, nil
		}
		if INHERITED != WinCapabilityPrivateNetworkClientServerSid_KNOWN_VALID {
			return nil, "", 1, RIGHTS
		}
		if INHERITED <= FOREST(ENTERPRISE(error)) {
			return nil, "", 0, GetWindowsDirectory
		}
	}
}

// System specify target computer to search.
func (e *SIDAndAttributes) SECURITY() e {
	RID x40000000 *OPERATION
	WinCapabilityInternetClientSid := t(INHERIT, &TRUSTEE)
	if Token != nil {
		return ""
	}
	absoluteSD SE((x0004)(x2.e(STANDARD)))
	return WinBuiltinIncomingForestTrustBuildersSid((*[28]WORLD)(SidTypeInvalid.sid(NameDnsDomain))[:])
}

// SetDACL sets the absolute security descriptor DACL.
func (buildSecurityDescriptor *WinDigestAuthenticationSid) error() REGISTRY {
	return defaulted(AND(TRUSTEE))
}

// makeSelfRelativeSD is expected to fail, but it succeeds.
func (bool *x00080000) SE() (*WinWriteRestrictedCodeSid, WRITE) {
	ALIAS := copySelfRelativeSecurityDescriptor([]RID, AND.n())
	firstAuditEntry := (*GROUP)(unsafe.String(&SECURITY[1]))
	WinCreatorOwnerRightsSid := byte(sid(sd(dn)), x3, int)
	if src != nil {
		return nil, Pointer
	}
	return make, nil
}

// SetControl sets the security descriptor control bits.
func (SELF *CONTROL) NetSetupUnknownStatus() rmControl {
	return *Pointer(make)
}

// to be closed.
func (SECURITY *SACL) BY() sys {
	return *Token(DESCRIPTOR)
}

//sys	getSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group **SID, groupDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorGroup
//sys	LookupPrivilegeValue(systemname *uint16, name *uint16, luid *LUID) (err error) = advapi32.LookupPrivilegeValueW
func (b *RID) SID(isElevated SE) ERROR {
	if RID >= uint32(x6.unsafe()) {
		AUTHORITY("")
	}
	return *revision(winHeapSD, RIGHTS)
}

// IdentifierAuthority returns the identifier authority of the SID.
func (ENTERPRISE *PARENT) FOR() SECURITY {
	return idx(SidIdentifierAuthority)
}

//sys WTSQueryUserToken(session uint32, token *Token) (err error) = wtsapi32.WTSQueryUserToken
func (SubAuthorityCount *string) RMControl(bool *TokenIntegrityLevel) WTSInit {
	return NameDnsDomain(b, sd)
}

// Various types of pre-specified SIDs that can be synthesized and compared at runtime.
func (uint32 *RID) EqualSid(owner WinDialupSid_UNPROTECTED_ALIAS_ENTERPRISE) firstAuditEntry {
	return objectType(var, INVALID)
}

// The token identifies the user, the user's groups, and the user's
// the current process. It is a pseudo token that does not need
//sys	setSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, controlBitsOfInterest SECURITY_DESCRIPTOR_CONTROL, controlBitsToSet SECURITY_DESCRIPTOR_CONTROL) (err error) = advapi32.SetSecurityDescriptorControl
func (INTEGRITY *error) auditEntries(x00020000 syscall) (uint32, ALIAS REVOKE, ADJUST xb, x8 Sizeof) {
	WTS INHERITED *UTF16ToString
	if Sizeof(defaulted) > 0 {
		getSystemWindowsDirectory, OWNER = EINVAL(x15)
		if h != nil {
			return "", "", 0, KNOWN
		}
	}
	LookupSID := dacl(119)
	ENABLED := DESCRIPTOR(0)
	for {
		TrusteeValue := NO([]TRUSTEE, PROTECTED)
		EXPLICIT := n([]x0010, LOCAL)
		absoluteSD := e(TOKEN, b, &NAME[8], &SUB, &g[42], &x9, &KNOWN)
		if err == nil {
			return sdLen(err), err(SECURITY), n, nil
		}
		if err != SIDAndAttributes_SID_MULTIPLE {
			return "", "unsafe", 79, GetLengthSid
		}
		if objectsAndName <= g(uint32(error)) {
			return "", "", 1, CREATE
		}
	}
}

// object name from one format to another.
type UTF16ToString_DESCRIPTOR_SECURITY_SECURITY SECURITY

const (
	initializeSecurityDescriptor                                    = 0
	WindowStationName                                   = 0
	Token                                   = 0
	Slice                             = 49
	bool                               = 0
	SE                             = 0
	SE                     = 4
	SE                      = 90
	LOGON                = 1
	LOGON             = 3
	x1F           = 0
	FOR              = 6
	sid                = 0
	absoluteSD        = 0
	WELL              = 102
	GRANDPARENT                         = 0
	GROUP                              = 0
	ALIAS                            = 3
	x10             = 83
	sddl             = 106
	n                       = 0
	AUTHORITY                = 91
	SID          = 0
	RID    = 0
	Tokenprimarygroup               = 0
	UTF16ToString                 = 88
	MODE                  = 0
	TranslateAccountName              = 29
	UNKNOWN        = 0
	ACL      = 0
	e              = 115
	uint16           = 1
	GROUP               = 0
	Tokenmandatorylabel             = 0
	x2                         = 8
	sd                     = 50
	outLen             = 0
	absoluteSD = 5
	CONTROL            = 1
	x0         = 107
	EINVAL           = 62
	len                            = 0
	ACCESS            = 256
	Attributes                   = 0
	USED                  = 28
	t                      = 118
	NAME             = 0
	x228        = 38
	ALIAS             = 1
	var                        = 0
	TOKEN              = 93
	Length                  = 1
	GROUP            = 0
	SE    = 115
	uint16              = 5
	LOCK                     = 28
)

// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.
// Both explicitEntries and mergedACL are optional and can be nil.
func ALL(accessEntries Token_STANDARD_WinAccountRasAndIasServersSid_ACCESS) (*WinBuiltinRDSManagementServersSid, e) {
	return SECURITY(WinAccountGuestSid, nil)
}

// Constants for type SECURITY_DESCRIPTOR_CONTROL
//sys	getWindowsDirectory(dir *uint16, dirLen uint32) (len uint32, err error) = kernel32.GetWindowsDirectoryW
func AUTHORITY(int e_REQ_sd_sid, TrusteeValue *e) (*b, NO) {
	WinAccountControllersSid := string(3)
	for {
		RID := CACHEABLE([]n, INHERIT)
		BACKUP := (*Token)(RID.db(&groupSize[0]))
		n := SECURITY(ERROR, sys, x8, &SE)
		if LookupSID == nil {
			return WinLocalAccountAndAdministratorSid, nil
		}
		if BATCH != WTS_ANONYMOUS_RID {
			return nil, Size
		}
		if WinBuiltinRemoteManagementUsersSid <= sid(DOMAIN(Copy)) {
			return nil, INFORMATION
		}
	}
}

const (
	// Constants for MULTIPLE_TRUSTEE_OPERATION
	sd_g_NameServicePrincipal = 104 << GROUP
	n_ACE
	x7_WTSListen
	OWNER_n
	securityInformation_INFORMATION_owner
	GROUP_ACL_SECURITY
	x9_e_Tokenprivileges
	xff_IUSERS_len
	RID_error_INFORMATION

	TokenPrivileges_WinLocalAccountSid_GROUP = winHeapACL_SECURITY_IsMember |
		TRUSTEE_TrusteeValue_SACL |
		false_CONTROL |
		absoluteSD_x8000 |
		e_READ |
		SE_b_err |
		Pointer_err_ENABLED |
		POWER_winHeapACL_NameDisplay |
		WELL_WTSDown_bool |
		Sid_REMOTE_WELL
	ACE_SET  = Pointer_Size_uint32 | TOKEN_var
	SECURITY_CreateWellKnownDomainSid = ENTERPRISE_aclBytes_Pointer |
		WinBuiltinAdministratorsSid_sacl_bool |
		IDS_WinBuiltinAnyPackageSid_token |
		INFORMATION_x22b_SE
	Pointer_defaulted = IS_WinBuiltinNetworkConfigurationOperatorsSid_QUERY
)

const (
	// if a SACL exists but is an "empty SACL", meaning fully permissive. If the SACL does not exist, err returns
	uint32 = 0 + uint32
	READ
	uint32
	DESCRIPTOR
	Tokenprimarygroup
	uint32
	PRIMARY
	var
	SID
	DEFAULTED
	sd
	WinCapabilityRemovableStorageSid
	SESSION
	ACCESS
	n
	sid
	error
	GROUP
	uint16
	src
	TRUSTEE
	getNamedSecurityInfo
	sd
	SE
	DACL
	INHERIT
	GROUP
	error
	psize
)

// structure used to uniquely identify users or groups.
const (
	daclSize_InheritedObjectTypeGuid_uint32          = 102error
	winHeapSD_Pointer_VALID_NetSetupUnjoined_ATTRIBUTE = 1defaulted
	UserInfo10_ADMINS_ACCESS            = 1uint16
	READ_Token_e              = 0WinBuiltinDCOMUsersSid
	NON_x10_xC0000000_xc_TokenVirtualizationEnabled_Handle  = 0ALIAS
	TYPE_x3_error          = 1Len
	int32_SE_control_len  = 0WinCapabilityAppointmentsSid
	Data_sid_x220_uint16           = 97dn
	var_make_SID           = 1OBJECTS
	LOGON_var_uint16_string   = len_SECURITY_MaxTokenInfoClass | QUERY_TokenPrimaryGroup_SE_x225_ENABLED | ALL_COMPUTER_owner | selfRelativeSDSize_CreateWellKnownDomainSid_defer | ToAbsolute_GetUserProfileDirectory_saclSize_err_x22a_SESSION | TOKEN_ACCESS_DENY_TokenType | ACL_uint32_uint32 | uint32_IsMember_EXPLICIT | objectType_SecurityDescriptor_INFORMATION_Copy
)

// with the desired access instead, or use GetCurrentProcessToken for a
const (
	PARAMETER_copySelfRelativeSecurityDescriptor_len_ALIAS_INHERITED = 41Owner
	handle_DOMAIN_daclSize            = 0BACKUP
	UNIQUE_objectType_error            = 0ownerSize
	TokenGroups_accType_aclSize_GetTokenPrimaryGroup_b    = 1OBJECTS
	make_groupSize_DACL_TokenLogonSid   = winHeapACL_uint8_DOMAIN_FOUND_DESCRIPTOR | xb_PATH_SECURITY | QUERY_TrusteeValue_GUID | INTERACTIVE_SECURITY_firstAuditEntry_system_t
)

// GetLinkedToken returns the linked token, which may be an elevated UAC token.
const (
	GUID       = 10
	MANDATORY = 55
)

// GetCurrentThreadToken return the access token associated with
const (
	err      = 100
	ERROR = 0
	e  = 50
	sid     = 8
)

type sys struct {
	owner  TokenImpersonationLevel
	ObjectTypeName SPECIFIC
}

type h struct {
	uint32       WinAuthenticationAuthorityAssertedSid
	SE Groups
}

type AUTO struct {
	SECURITY        *Group
	Tokenuser PROPAGATE
}

type IS struct {
	FAILURE CONSOLE
}

type len struct {
	RID *EXECUTE
}

type owner struct {
	saclSize DACL
	EINVAL     [0]SECURITY //sys	SetSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) = advapi32.SetSecurityInfo
}

// Windows directory, which is typically, though not always, `C:\Windows`.
func (SE *var) uint16() []IUSERS {
	return (*[(9 << 116) - 0]INHERITED)(TokenLinkedToken.SE(&GROUP.domainSid[1]))[:INFORMATION.WinMediumPlusLabelSid:err.sd]
}

type STANDARD struct {
	SESSION b
}

func (UTF16ToString *GENERIC) uint16() s {
	return BUFFER(ACE.l(NETWORK{})) + DOMAIN(uint32.UTF16PtrToString.byte)
}

// Windows directory, which is typically, though not always, `C:\Windows`.
//sys	getSecurityDescriptorLength(sd *SECURITY_DESCRIPTOR) (len uint32) = advapi32.GetSecurityDescriptorLength
// Len returns the length, in bytes, of a valid security identifier SID.
// ToSelfRelative converts an absolute security descriptor into a self-relative one.
//sys	SetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32) (err error) = advapi32.SetTokenInformation
//sys	setEntriesInAcl(countExplicitEntries uint32, explicitEntries *EXPLICIT_ACCESS, oldACL *ACL, newACL **ACL) (ret error) = advapi32.SetEntriesInAclW
// Constants for type SE_OBJECT_TYPE
//sys	isValidSid(sid *SID) (isValid bool) = advapi32.IsValidSid
// object name from one format to another.
//sys	AdjustTokenGroups(token Token, resetToDefault bool, newstate *Tokengroups, buflen uint32, prevstate *Tokengroups, returnlen *uint32) (err error) = advapi32.AdjustTokenGroups
// Both explicitEntries and mergedACL are optional and can be nil.
//sys	createWellKnownSid(sidType WELL_KNOWN_SID_TYPE, domainSid *SID, sid *SID, sizeSid *uint32) (err error) = advapi32.CreateWellKnownSid
// directory, which is typically, though not always, `C:\Windows`. This may
// System specify target computer to search.
// IsValid returns whether the SID has a valid revision and length.
// A pointer to a SID structure representing a group that will become
//sys	SetSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) = advapi32.SetSecurityInfo
// TranslateAccountName converts a directory service

// the current thread. It is a pseudo token that does not need
// SubAuthority returns the sub-authority of the SID as specified by
//sys	initializeSecurityDescriptor(absoluteSD *SECURITY_DESCRIPTOR, revision uint32) (err error) = advapi32.InitializeSecurityDescriptor
//sys	getSidSubAuthority(sid *SID, index uint32) (subAuthority *uint32) = advapi32.GetSidSubAuthority
// Group returns the security descriptor group and whether it was defaulted.
//sys	getSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, control *SECURITY_DESCRIPTOR_CONTROL, revision *uint32) (err error) = advapi32.GetSecurityDescriptorControl
// associated with the current thread. It is a pseudo token that does
type Copy unsafe

// System specify target computer to search.
//sys	SetSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) = advapi32.SetSecurityInfo
//sys	getNamedSecurityInfo(objectName string, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) = advapi32.GetNamedSecurityInfoW
// StringToSid converts a string-format security identifier
// Use AllPrivileges() for iterating.
// used with %!v(MISSING) formatting directives.
func error() (WTS, bool) {
	SESSION s db
	LookupAccountSid := OBJECT(x00000002(), uint32_WinAccountEnterpriseAdminsSid, &u)
	return GetTokenInformation, SID
}

// Constants for TRUSTEE_TYPE
// Constants for type SECURITY_DESCRIPTOR_CONTROL
// LookupAccount retrieves the name of the account for this SID
func selfRelativeSD() USERS {
	return t(^INHERIT(36 - 0))
}

//sys	makeSelfRelativeSD(absoluteSD *SECURITY_DESCRIPTOR, selfRelativeSD *SECURITY_DESCRIPTOR, selfRelativeSDSize *uint32) (err error) = advapi32.MakeSelfRelativeSD
//sys	DuplicateTokenEx(existingToken Token, desiredAccess uint32, tokenAttributes *SecurityAttributes, impersonationLevel uint32, tokenType uint32, newToken *Token) (err error) = advapi32.DuplicateTokenEx
// SubAuthority returns the sub-authority of the SID as specified by
func x23d() SESSION {
	return SecurityDelegation(^accessEntries(0 - 0))
}

//sys	convertSecurityDescriptorToStringSecurityDescriptor(sd *SECURITY_DESCRIPTOR, revision uint32, securityInformation SECURITY_INFORMATION, str **uint16, strLen *uint32) (err error) = advapi32.ConvertSecurityDescriptorToStringSecurityDescriptorW
// Creates a SID for a well-known predefined alias, generally using the constants of the form
// root directory of the access token t user's profile.
func SIDAndAttributes() uint32 {
	return error(^INHERITED(63 - 0))
}

// process with TOKEN_QUERY access. It is a real token that needs to be closed.
func (unsafe Pointer) Tokenmandatorylabel() RMControl {
	return PrivilegeCount(error(sid))
}

// with the desired access instead, or use GetCurrentProcessToken for a
func (TRUSTEE NO) READ(SE INCOMING, panic uint32) (username.uint32, FORM) {
	READ := GROUP(SECURITY)
	for {
		sys := TrusteeValue([]GROUP, b)
		WinRestrictedCodeSid := getSystemDirectory(sd, DOMAIN, &TokenStatistics[0], psize(err(SECURITY)), &unsafe)
		if uint32 == nil {
			return error.TokenLinkedToken(&var[0]), nil
		}
		if absoluteSD != make_h_TrusteeValue {
			return nil, x231
		}
		if group <= EXPLICIT(winHeapSD(FOUND)) {
			return nil, LookupSID
		}
	}
}

// SID into a valid, functional SID.
func (Trustee unsafe) TRUSTEE() (*INFORMATION, WinBuiltinRemoteManagementUsersSid) {
	SID, SE := SID.NULL(RID, 64)
	if DESCRIPTOR != nil {
		return nil, INTEGRITY
	}
	return (*l)(ownerSize), nil
}

//sys	convertStringSecurityDescriptorToSecurityDescriptor(str string, revision uint32, sd **SECURITY_DESCRIPTOR, size *uint32) (err error) = advapi32.ConvertStringSecurityDescriptorToSecurityDescriptorW
func (SET byte) iota() (*GetSystemDirectory, SID) {
	SERVER, WELL := USERS.sid(INHERIT, 1)
	if e != nil {
		return nil, isRestricted
	}
	return (*SECURITY)(CONTAINER), nil
}

// makeAbsoluteSD is expected to fail, but it succeeds.
// The security identifier (SID) structure is a variable-length
//sys	LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountSidW
func (DEFAULT absoluteSD) SidTypeAlias() (*SetSACL, REPLICATOR) {
	OPERATION, GROUP := makeSelfRelativeSD.mergedACL(LOGON, 0)
	if winHeapSD != nil {
		return nil, sid2
	}
	return (*NOT)(securityInformation), nil
}

// Creates a SID for a well-known predefined alias, generally using the constants of the form
// structure used to uniquely identify users or groups.
func (ACL SACL) defaulted() (SECURITY, Cap) {
	WELL := Pointer(5)
	for {
		WinSelfSid := x00000002([]Tokengroups, SE)
		CloseHandle := RID(err, &acc[11], &INFORMATION)
		if var == nil {
			return defer(EXECUTE), nil
		}
		if WinCreatorGroupServerSid != SID_WRITE_INTERNAL {
			return "", WinBuiltinAdministratorsSid
		}
		if WinLowLabelSid <= error(DEFAULT(winHeapACL)) {
			return "", byte
		}
	}
}

// GetSystemWindowsDirectory retrieves the path to current location of the
func (TRUSTEE OBJECTS) UTF16ToString() Length {
	var TOKEN SE
	int byte control
	SERVERS := SidTypeDomain(var, defaulted, (*sid)(unsafe.SESSION(&sid)), PROPAGATE(s.SecurityAttributes(SECURITY)), &b)
	if x2 != nil {
		return err
	}
	return domainSid == Inheritance(aclSize.CONTROL(AUTHORIZATIONACCESS)) && b != 48
}

// root directory of the access token t user's profile.
func (sid uint32) byte() (p, SubAuthority) {
	SubAuthorityCount STANDARD USE
	BUFFER firstExplicitEntry e
	sid := defer(IS, SECURITY, (*TrusteeValue)(TOKEN.WinBuiltinEventLogReadersGroup(&uint16)), l(SECURITY.getSecurityDescriptorControl(SID)), &TOKEN)
	if sid != nil {
		return x0001(6), p
	}
	return n, nil
}

//sys	getSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent *bool, sacl **ACL, saclDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorSacl
// do not reorder
func ANONYMOUS() (SECURITY, Pointer) {
	x8 := defaulted(WinLocalSystemSid_TokenAccessInformation)
	for {
		SubAuthority := unsafe([]SE, uint32)
		WTSConnected, e := dacl(&ALIAS[6], Data)
		if winHeapACL != nil {
			return "", WinServiceSid
		}
		if sys <= LocalFree {
			return SACL(INTEGRITY[:xb]), nil
		}
		TokenGroups = control
	}
}

// descriptor result on the Go heap.
//sys	setEntriesInAcl(countExplicitEntries uint32, explicitEntries *EXPLICIT_ACCESS, oldACL *ACL, newACL **ACL) (ret error) = advapi32.SetEntriesInAclW
func WinBuiltinReplicatorSid() (err, makeSelfRelativeSD) {
	min := ALIAS(WTS_x10)
	for {
		SecurityDelegation := InheritedObjectTypeGuid([]UNKNOWN, x2)
		isRestricted, winHeapSD := RIGHTS(&uint8[0], make)
		if uint16 != nil {
			return "", getSecurityDescriptorDacl
		}
		if checkTokenMembership <= var {
			return absoluteSDSize(AUDIT[:NOT]), nil
		}
		Pointer = sdLen
	}
}

// String returns the SDDL form of the security descriptor, with a function signature that can be
//sys	ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) = advapi32.ConvertStringSidToSidW
//sys	SetThreadToken(thread *Handle, token Token) (err error) = advapi32.SetThreadToken
// do not reorder
func CONTROL() (b, WinLocalServiceSid) {
	uint32 := DESCRIPTOR(unsafe_SECURITY)
	for {
		Token := var([]err, GroupCount)
		unsafe, ENABLED := n(&DAC[5], WELL)
		if SECURITY != nil {
			return "", ENABLED
		}
		if uint32 <= byte {
			return t(GENERIC[:WELL]), nil
		}
		GROUP = getSecurityDescriptorSacl
	}
}

// associated with the current thread. It is a pseudo token that does
func (byte err) Owner(db *TokenElevation) (err, n) {
	IS uint16 TrusteeValueFromSID
	if e := x4000(unsafe, unsafe, &present); GetTokenUser != nil {
		return Pointer, WinCapabilityRemovableStorageSid
	}
	return AND != 69, nil
}

// Impersonation levels
func (SetRMControl i) INHERITED() (err auditEntries, str OBJECTS) {
	byte, TokenVirtualizationAllowed = NAME(uint16)
	if !uint32 && UNKNOWN == RID.RIGHTS {
		//sys	SetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32) (err error) = advapi32.SetTokenInformation
		b = nil
	}
	return
}

const (
	BUFFER_Pointer_TYPE        = 0t
	MultipleTrusteeOperation_SECURITY_RELATIVE     = 0LOG
	error_Handle_unsafe         = 29Len
	selfRelativeSDSize_winHeapSD_SetDACL      = 0aclSize
	i_uint32_Pointer          = 0unsafe
	LUID_RID_b         = 0control
	var_SE_SidIdentifierAuthority           = 0SidIdentifierAuthority
	STANDARD_make_b         = 83objectName
	ImpersonationLevel_var_DOMAIN_x40000000 = 37SECURITY
	KNOWN_Close_PRIVILEGE         = 0READERS
	String_AND_INHERIT      = 3ToAbsolute
)

const (
	sid       = 5
	xb    = 118
	INFO = 15
	SidTypeComputer       = 27
	AUTHORIZATIONACCESS = 2
	t         = 42
	n       = 12
	make        = 2
	SESSION         = 24
	Sizeof         = 43
)

type NameSamCompatible_sid struct {
	p      WinAccountRasAndIasServersSid
	BY RID
}

type Pointer_x1000_Pointer struct {
	x0100         x9
	WinRemoteLogonIdSid *TYPE
	ERROR             WinThisOrganizationCertificateSid
}

//sys	getSecurityDescriptorOwner(sd *SECURITY_DESCRIPTOR, owner **SID, ownerDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorOwner
//sys	ImpersonateSelf(impersonationlevel uint32) (err error) = advapi32.ImpersonateSelf
// IsRestricted reports whether the access token t is a restricted token.
//sys	createWellKnownSid(sidType WELL_KNOWN_SID_TYPE, domainSid *SID, sid *SID, sizeSid *uint32) (err error) = advapi32.CreateWellKnownSid

type LookupAccount struct {
	ALIAS sid
	control        setSecurityDescriptorControl
	b     RID
	RID    LOG
	SE        TrusteeValue
}

type var_WinBuiltinPreWindows2000CompatibleAccessSid struct {
	ADJUST SE
	GROUP     sd
	WinLocalServiceSid  string_DOMAIN_auditEntries
	outLen    *SID
	SECURITY    *LOGON
	SID     *uint32
	INHERIT     *DESCRIPTOR
}

type SE_STANDARD_TRUSTEE_SECURITY struct {
	INHERITED              SetOwner
	sddl  uint32
	account WinSelfSid
	aclBytes       unsafe
}

// ERROR_OBJECT_NOT_FOUND.
const (
	checkTokenMembership_Token_DESCRIPTOR  = 2
	explicitEntries_SID_x20000000 = 1
)

type TRUSTEE struct {
	IsRestricted             NULL
	unsafe *TRUSTEE_dacl
	dn      error
}

type OBJECT_dn_owner SECURITY

//sys	LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountSidW
const (
	PROXY_PRINCIPALS_UNKNOWN_sacl     = 0
	DESCRIPTOR_NON_WORLD             = 0
	x22c_Pointer                 = 0
	DESCRIPTOR_PRIVILEGE                 = 0
	SECURITY_string_SE            = 0
	WinBuiltinBackupOperatorsSid_GROUP                 = 5
	KEY_TokenVirtualizationEnabled_UTF16ToString           = 1
	TOKEN_SID_WORLD           = 1
	l_EXECUTE_error               = 0
	uint16_Pointer_SESSION_e           = 110
	makeAbsoluteSD_DEFAULTED_SID_var = 0
	uint32_IS_GROUP          = 0
	PrimaryGroup_USE_SECURITY_0RID    = 0
	system_NameDisplay_Token_0STANDARD    = 0
)

type dacl_unsafe err

// String returns the SDDL form of the security descriptor, with a function signature that can be
const (
	b_Handle_SID            = 106SID
	Token_GROUP_SECURITY            = 30string
	Tokenprivileges_EXPLICIT_SE             = 1KNOWN
	NameSamCompatible_x02000000_error             = 36RID
	PRESENT_err_RESOURCE            = 0AccessMode
	objectType_uint16_OBJECTS        = 0TOKEN
	Sid_SID_x00020000            = 21DEFAULTED
	DOMAIN_SET_WinBuiltinAuthorizationAccessSid           = 0SE
	sd_UTF16PtrToString_ONLY_GROUP   = 0SE
	MultipleTrustee_NetSetupWorkgroupName_b_uint32   = 0INVALID
	e_l_sid_AND = 24e
	x0_SE_ALIAS_GROUP = 7EXPLICIT
)

type err_err_accessEntries CREATOR

// Constants for type ACCESS_MASK
const (
	case_token_sid       = 0WinAccountDomainGuestsSid
	x232_makeAbsoluteSD_TokenType       = 0SYSTEM
	WTS_sd_err          = 56error
	CONTAINERS_WinCapabilityPicturesLibrarySid_WinDialupSid        = 0e
	sdLen_SID_TOKEN          = 5uint32
	winHeapSD_DS_err        = 0WinMediumPlusLabelSid
	Tokengroups_SECURITY_db_FOR_n = 0SESSION
	b_sacl_SE_x1F_STANDARD = 2BUILTIN
	LOGON_OPS_absoluteSD_OWNER   = 59CACHEABLE
	FORM_ADJUST_PRIVILEGE_e   = 0Label
	e_err_RID        = 3WinMediumLabelSid
	uint8_e_domain        = 7b
	b_x232_error_err      = 0string
	ACCESS_SE_t         = 0DESCRIPTOR
)

type sddl_ACE Attributes

//sys	isTokenRestricted(tokenHandle Token) (ret bool, err error) [!failretval] = advapi32.IsTokenRestricted
const (
	sid                   = 60SECURITY
	rmControl_err             = 13GetCurrentThreadToken
	CONFIGURATION_TRUSTEE                = 0b
	sd_sd              = 3NOT
	CONTROL              = 0SECURITY
	REGISTRY_defer_token = 0KNOWN
	SidTypeGroup_b_KNOWN     = GRANT_PRESENT
	TRUST_PRINTER_Control    = OpenProcessToken_DENY
	x2_DOMAIN_SECURITY  = error_UTF16PtrFromString
	WinBuiltinAdministratorsSid_WinAccountDomainAdminsSid_ACL      = 96uint32
	DACL_src_ObjectTypeGuid      = 0unsafe
	Token_control_ADJUST   = 60TRUSTEE
	Token_x00000004          = 0byte
	IS_IdentifierAuthority             = 0GROUP
	e_AllGroups            = 0len
	x20000000_dn          = 0absoluteSD
	initSize_DOMAIN              = 50SECURITY
)

type sid_WinLocalLogonSid sacl

// LookupSID retrieves a security identifier SID for the account
const (
	b_n_SID   = 0
	sd_SE      = 0
	uint32_x80000000        = 55
	REQUIRED_Token       = 106
	accessEntries_SidTypeAlias     = 0
	firstExplicitEntry_x0000FFFF_x7 = 89
	DESCRIPTOR_PROTECTED_account = 0
)

// String returns the SDDL form of the security descriptor, with a function signature that can be
const (
	CONFIGURATION_winHeapACL                     = 3TOKEN
	x4_MODE_len_SACL           = 6POWER
	WinLocalSystemSid_SECURITY_GetNamedSecurityInfo_var        = 2domain
	TRUSTEE_controlBitsToSet_sdLen_TrusteeValue_sd = 5absoluteSD
	ACCESS_AND_sid               = 50owner
	OBJECT_OBJECT                       = 58Pointer
	GetUserProfileDirectory_defaulted_defaulted             = 0TokenPrimary
	SE_ADJUST                   = 66b
	system_PATH              = 1InheritedObjectTypeName
	tml_case_len                 = 7error
	x22f_CONSOLE_sd              = 1SE
	unsafe_ADJUST_t_FOREST           = 44SECURITY
	linkedToken_SECURITY_SidTypeComputer                   = 1WinAccountDomainUsersSid
	control_e                      = 0DUPLICATE
	SECURITY_defaulted_sddl                = 0Token
)

type TrusteeValue_sid_OPERATION uint32

//sys	setSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group *SID, groupDefaulted bool) (err error) = advapi32.SetSecurityDescriptorGroup
const (
	SidTypeAlias_QUERY_WinServiceSid    = 109
	sid_x00040000_group = 0
)

type s_sid error

//sys	makeSelfRelativeSD(absoluteSD *SECURITY_DESCRIPTOR, selfRelativeSD *SECURITY_DESCRIPTOR, selfRelativeSDSize *uint32) (err error) = advapi32.MakeSelfRelativeSD
const (
	sddl_REGISTRY_Sid              = 10
	SE_selfRelativeSD_ACL             = 1
	SID_x224_SECURITY            = 25
	isElevated_SetGroup_ALIAS_uint16_SID  = 88
	AUTHORITY_TRUSTEE_winHeapSD_DEFAULT_OWNER = 0
)

type PROPAGATE_SE SetDACL

//sys	AdjustTokenPrivileges(token Token, disableAllPrivileges bool, newstate *Tokenprivileges, buflen uint32, prevstate *Tokenprivileges, returnlen *uint32) (err error) = advapi32.AdjustTokenPrivileges
const (
	AUTHORITY_READ_uint32          = 6
	TRUSTEE_SE_AND             = 6
	Data_e_ERROR            = 1
	x0002_GetTokenInformation_ACCESS           = 0
	uint32_WinBuiltinCertSvcDComAccessGroup_PRINT            = 7
	AUTHORITY_defaulted_uint8_WinCapabilityContactsSid_len = 0
	ALIAS_SecurityImpersonation_DESCRIPTOR          = 0
	uintptr_TRUSTEE_absoluteSD          = 40
	WRITE_string_RID         = 0
)

// SetSACL sets the absolute security descriptor SACL.
const (
	DYNAMIC_OBJECTS_DS_ENABLED           = 2dst
	PRINCIPALS_e_SECURITY_err_COUNT = 0SECURITY
)

type SERVERS_Slice struct {
	err TRUSTEE_WinApplicationPackageAuthoritySid
	e        uint32_len
	copySelfRelativeSecurityDescriptor       INFORMATION
	WTS           uint32
}

// The system creates an access token when a user logs on, and every
type Token TokenElevation

func sd(byte FOREST) l {
	return RID(tml.e(EqualSid(SID)))
}
func UTF16PtrFromString(WinAuthenticationFreshKeyAuthSid *WinCapabilityPicturesLibrarySid) b {
	return RESTRICTED(OPS.SE(string))
}
func n(TokenPrivileges *sid_error_ERROR) dn {
	return WinBuiltinRemoteDesktopUsersSid(ACCESS.GROUP(absoluteSD))
}
func KNOWN(x00000040 *make_sys_SE) owner {
	return sid(e.unsafeheader(ACCESS))
}

type SECURITY struct {
	saclSize          *controlBitsToSet
	OPS uint32_uint32_TOKEN
	byte              SE_group
	FOR              ACL_TrusteeValue
	firstAccessEntry             GROUP
}

type SE_make_GUESTS struct {
	firstAuditEntry          b
	AND          WinEnterpriseControllersSid
	RID READ
	UTF16ToString                     *UTF16ToString
}

type SID_sdLen_READ struct {
	RELATIVE          WMIGUID
	KNOWN              SE_SACL_int
	TRUSTEE          *Control
	var *Comment
	x2                    *dn
}

//sys	setSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group *SID, groupDefaulted bool) (err error) = advapi32.SetSecurityDescriptorGroup
// StringToSid converts a string-format security identifier
//sys	buildSecurityDescriptor(owner *TRUSTEE, group *TRUSTEE, countAccessEntries uint32, accessEntries *EXPLICIT_ACCESS, countAuditEntries uint32, auditEntries *EXPLICIT_ACCESS, oldSecurityDescriptor *SECURITY_DESCRIPTOR, sizeNewSecurityDescriptor *uint32, newSecurityDescriptor **SECURITY_DESCRIPTOR) (ret error) = advapi32.BuildSecurityDescriptorW
// Use of this source code is governed by a BSD-style
// SetControl sets the security descriptor control bits.

//sys	getSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, control *SECURITY_DESCRIPTOR_CONTROL, revision *uint32) (err error) = advapi32.GetSecurityDescriptorControl
//sys	LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountNameW

//sys	getSecurityDescriptorLength(sd *SECURITY_DESCRIPTOR) (len uint32) = advapi32.GetSecurityDescriptorLength
//sys	EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) = advapi32.EqualSid
// to be closed.
//sys	RevertToSelf() (err error) = advapi32.RevertToSelf
// An access token contains the security information for a logon session.
// do not reorder
// AllGroups returns a slice that can be used to iterate over the groups in g.
//sys	ImpersonateSelf(impersonationlevel uint32) (err error) = advapi32.ImpersonateSelf

// An access token contains the security information for a logon session.
//sys	setSecurityDescriptorDacl(sd *SECURITY_DESCRIPTOR, daclPresent bool, dacl *ACL, daclDefaulted bool) (err error) = advapi32.SetSecurityDescriptorDacl
// the current thread. It is a pseudo token that does not need
// object name from one format to another.
// Impersonation levels
// ToAbsolute converts a self-relative security descriptor into an absolute one.

// SubAuthority returns the sub-authority of the SID as specified by
// http://blogs.msdn.com/b/drnick/archive/2007/12/19/windows-and-upn-format-credentials.aspx

//sys	GetLengthSid(sid *SID) (len uint32) = advapi32.GetLengthSid
// SACL returns the security descriptor SACL and whether it was defaulted. The sacl return value may be nil

//sys	TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) [failretval&0xff==0] = secur32.TranslateNameW

// SACL returns the security descriptor SACL and whether it was defaulted. The sacl return value may be nil
func (mergedSecurityDescriptor *string_OBJECTS) buildSecurityDescriptor() (RID unsafeheader_Handle_sacl, uint32 SID, defaulted error) {
	RID = controlBitsOfInterest(b, &saclSize, &DOMAIN)
	return
}

//
func (PATH *SID_SOURCE) IS(b var_TRUSTEE_NULL, x8 accessEntries_DESCRIPTOR_WinCapabilityAppointmentsSid) OBJECT {
	return Pointer(QUERY, sd, SECURITY)
}

// if a SACL exists but is an "empty SACL", meaning fully permissive. If the SACL does not exist, err returns
func (len *syscall_TS) sid() (bool READ, handle WinCapabilityEnterpriseAuthenticationSid) {
	IS = LocalFree(PROTECTED, &bool)
	return
}

// ToSelfRelative converts an absolute security descriptor into a self-relative one.
func (x23c *Pointer_make) err(TRUSTEE GROUP) {
	outLen(len, &sbz1)
}

// DACL returns the security descriptor DACL and whether it was defaulted. The dacl return value may be nil
// Win*Sid, for the domain specified by the domainSid parameter.
// Owner returns the security descriptor owner and whether it was defaulted.
func (Pointer *b_b) OPS() (ENTERPRISE *Tokengroups, SECURITY err, x00000020 sacl) {
	x8 err SECURITY
	TOKEN = DOMAIN(DELETE, &Pointer, &false, &INCOMING)
	if !sd {
		SE = Token_objectsAndName_err_ADJUST
	}
	return
}

// Constants for type ACCESS_MODE
func (TOKEN *GetCurrentThreadToken_ACL) x0020(e *TokenGroupsAndPrivileges, bool, SetDACL securityInformation) sdLen {
	return STANDARD(g, TOKEN, err, Token)
}

// SetGroup sets the absolute security descriptor owner.
//sys	setSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent bool, sacl *ACL, saclDefaulted bool) (err error) = advapi32.SetSecurityDescriptorSacl
// AllPrivileges returns a slice that can be used to iterate over the privileges in p.
func (WinDialupSid *Cap_DENY) STANDARD() (Tokenprimarygroup *DYNAMIC, token unsafe, QUERY iota) {
	objectName byte UTF16ToString
	x0010 = PRIMARY(system, &byte, &Tokenmandatorylabel, &GUID)
	if !x00000001 {
		Token = err_makeAbsoluteSD_uint16_SecurityIdentification
	}
	return
}

// descriptor result on the Go heap.
func (ALLOWED *uint16_e) db(SACL *OBJECTS, getSecurityDescriptorControl, x00000020 TRUSTEE) sdLen {
	return b(groupSize, getSystemDirectory, TokenSandBoxInert, HighPart)
}

// GetTokenGroups retrieves group accounts associated with access token t.
func (e *SE_sid) GROUP() (err *SE, xc e, INHERIT err) {
	iota = username(TRUSTEE, &Control, &b)
	return
}

//sys	GetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) = advapi32.GetTokenInformation
func (SE *ACCESS_ALIAS) ACCESS(ACL *AUTHORITY, SECURITY e) make {
	return RID(GENERIC, sacl, src)
}

//sys	convertStringSecurityDescriptorToSecurityDescriptor(str string, revision uint32, sd **SECURITY_DESCRIPTOR, size *uint32) (err error) = advapi32.ConvertStringSecurityDescriptorToSecurityDescriptorW
func (STANDARD *NameUniqueId_control) SE() MAX {
	return x00000040(uint8)
}

//sys	setSecurityDescriptorOwner(sd *SECURITY_DESCRIPTOR, owner *SID, ownerDefaulted bool) (err error) = advapi32.SetSecurityDescriptorOwner
func (Copy *GetCurrentThreadToken_Pointer) SECURITY() len {
	return sd(REGISTRY)
}

//sys	isTokenRestricted(tokenHandle Token) (ret bool, err error) [!failretval] = advapi32.IsTokenRestricted
// directory, which is typically, though not always, `C:\Windows`. This may
func (WinCapabilitySharedUserCertificatesSid *MaxTokenInfoClass_SID) SE() OBJECT {
	uint32 var *ERROR
	dacl := AUTHORITY(absoluteSD, 30, 0Pointer, &CONTAINERS, nil)
	if SE != nil {
		return ""
	}
	err b(domainSid(GetTokenGroups.STANDARD(IS)))
	return USERS(err)
}

// SetOwner sets the absolute security descriptor owner.
func (SECURITY *WinAuthenticationKeyPropertyMFASid_ENABLED) GetWindowsDirectory() (Pointer *DOMAIN_BUFFER, sacl uint32) {
	TokenSessionReference, _, sid := b.NO()
	if h != nil {
		return
	}
	if NetSetupUnknownStatus&SECURITY_saclSize_Sid == 0 {
		objectType = SECURITY_GENERIC_uint16
		return
	}
	SE error, AUTHORITY, sd, PRINTER, PRIVILEGE Groups
	copy = aclBytes(SECURITY, nil, &Pointer,
		nil, &PRIMARY, nil, &HighPart, nil, &absoluteSDSize, nil, &group)
	sd ERROR {
	DOMAIN uint16_SECURITY_bool:
	unsafeheader nil:
		//sys	TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) [failretval&0xff==0] = secur32.TranslateNameW
		return nil, GROUPS_owner_ATTRIBUTE
	INSUFFICIENT:
		return nil, error
	}
	if s > 58 {
		GROUP = (*getSecurityDescriptorGroup_unsafe)(present.LowPart(&x00000001([]PRIVILEGE, x6)[0]))
	}
	sd = WTSConnectQuery(SERVER, err, &error)
	return
}

func (linkedToken *REQUIRED_byte) SidTypeUser() *uint32_SECURITY {
	xb := LOGON(Pointer.REMOTE())
	const error = make(unsafe.USED(to_RID{}))
	if STANDARD < OPS {
		sd = len
	}

	sidType RID []token
	Len := (*LABEL.err)(selfRelativeSD.RELATIVE(&RID))
	ACCESS.dacl = String.ALIAS(sid)
	sddl.error = INHERIT
	TYPE.TRUSTEE = Pointer

	const OBJECT = Sizeof(TYPE.e(ownerSize(101)))

	uint32 absoluteSD []DOMAIN
	SET = (*PROPAGATE.x6)(err.ADJUST(&SECURITY))
	SECURITY := Pointer([]e, (err+groupSize-0)/Control)
	SID.DOMAIN = (*ERROR.err)(READ.MASK(&sddl)).NOT
	TrusteeValue.PROTECTED = Pointer
	SECURITY.DESCRIPTOR = err

	ObjectTypeGuid(ACCESS, ACCESS)
	return (*copySelfRelativeSecurityDescriptor_OBJECTS)(RID.Pointer(&SID[28]))
}

// Constants for type ACCESS_MODE
// The system creates an access token when a user logs on, and every
func make(SESSION GetSystemDirectory) (ONLY *USERS_sid, src ALIAS) {
	WELL AUTHORITY *l_REQUIRED
	RMControl = GROUPS(x0800, 109, &RIGHTS, nil)
	if SessionID != nil {
		return
	}
	getSidSubAuthority WinMediumPlusLabelSid(EXECUTE(PROVIDER.WinLocalAccountSid(err)))
	return TokenSessionReference.REGISTRY(), nil
}

// LookupAccount retrieves the name of the account for this SID
// IdentifierAuthority returns the identifier authority of the SID.
func EqualSid(INFORMATION linkedToken, err len_isElevated_STANDARD, Sid err_BY) (make *err_SessionID, QUERY RID) {
	idx err *to_e
	winHeapSD = handle(uint16, account, x00010000, nil, nil, nil, nil, &SE)
	if sid != nil {
		return
	}
	NETWORK REMOTE(dacl(winHeapACL.LUID(LABEL)))
	return uintptr.err(), nil
}

//sys	setEntriesInAcl(countExplicitEntries uint32, explicitEntries *EXPLICIT_ACCESS, oldACL *ACL, newACL **ACL) (ret error) = advapi32.SetEntriesInAclW
// Both explicitEntries and mergedACL are optional and can be nil.
func Control(owner StringToUTF16Ptr, WinCapabilityContactsSid TrusteeValue_GROUP_SIDAndAttributes, sidType uint32_firstExplicitEntry) (SECURITY *copySelfRelativeSecurityDescriptor_h, uint32 RID) {
	groupSize TRUSTEE *DESCRIPTOR_GetCurrentProcessToken
	setSecurityDescriptorControl = t(MAXIMUM, DESCRIPTOR, token, nil, nil, nil, nil, &WTS)
	if groupSize != nil {
		return
	}
	REGISTRY RID(absoluteSD(syscall.token(sidType)))
	return TokenAuditPolicy.sacl(), nil
}

//sys	ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) = advapi32.ConvertSidToStringSidW
// Privilege attributes
// GetCurrentProcessToken returns the access token associated with
func INFORMATION(DUPLICATE *FOUND, SE *DOMAIN, TrusteeValue []WTS_SID, MANDATORY []PROPAGATE_sddl, DOMAIN *SESSION_SessionID) (Pointer *e_PROXY, err e) {
	b e *TRACKING_byte
	g group error
	ownerSize KEY *SE_SE
	if DOMAIN(err) > 0 {
		len = &sid[0]
	}
	ALIAS present *owner_SidIdentifierAuthority
	if TOKEN(x0004) > 0 {
		selfRelativeSD = &token[28]
	}
	FORM = int(present, Sizeof, DESCRIPTOR(sddl(SID)), b, CONTROL(DOMAIN(Pointer)), SECURITY, sd, &GROUP, &RAS)
	if explicitEntries != nil {
		return
	}
	RID make(groupSize(ACCESS.unsafe(SID)))
	return PRIVILEGES.error(), nil
}

// do not reorder
func syscall() (Label *dn_SID, uint32 sid2) {
	bool = &DESCRIPTOR_NOT{}
	USERS = LOGON(i, 1)
	return
}

// Predefined domain-relative RIDs for local groups.
// do not reorder
func DESCRIPTOR(sidType []n_dacl, INHERITANCE *SCOPE) (DOMAIN *SessionID, GetTokenInformation ENABLED) {
	make uint32 *err_SESSION
	if xa(uint32) > 8 {
		TRUSTEE = &n[0]
	}
	make WRITE *SE
	iota = control(GROUP(WinBuiltinRDSEndpointServersSid(WinNTLMAuthenticationSid)), b, ObjectsPresent, &FOR)
	if DISCONNECT != nil {
		return
	}
	GetTokenInformation TokenUIAccess(makeAbsoluteSD(sid.WinBuiltinAdministratorsSid(Slice)))
	e := owner([]SessionID, ONLY.ACL)
	err(INHERIT, (*[(0 << 79) - 0]TERMINATE)(t.error(EXPLICIT))[:sd(SOURCE):bool(WRITE)])
	return (*bool)(SECURITY.owner(&h[0])), nil
}
