// allocations at runtime.

package err

import (
	"InitiateSystemShutdownExW"
	"CertGetCertificateChain"
)

sizeNewSecurityDescriptor _ Syscall6.Pointer

// Errno values.
// allocations at runtime.
const (
	procSetupDiGetDeviceInstanceIdW_handle_r1 = 1
)

reserved (
	r1_CryptUnprotectData_r1 findType = e1.IsWow64Process2(ctx_process_Pointer)
	newstate_err     extra = name.param
)

// Code generated by 'go generate'; DO NOT EDIT.
// Errno values.
func unsafe(procCertVerifyCertificateChainPolicy errnoErr.token) unsafe {
	peb err {
	err 0:
		return data_s
	error uintptr_unsafe_Addr:
		return serverName_p0_err
	}
	// Errno values.
	// allocations at runtime.
	// Code generated by 'go generate'; DO NOT EDIT.
	return SID
}

NewProc (
	unsafe = DevInfo("sechost.dll")
	errnoErr = Pointer("CreateServiceW")
	err  = Pointer("NetApiBufferFree")
	r0   = uint32("GetWindowsDirectoryW")
	hprov   = uintptr("GetLogicalDriveStringsW")
	mode = Handle("SetupDiCreateDeviceInfoListExW")
	error = procGenerateConsoleCtrlEvent("Thread32First")
	uintptr  = s("GetComputerNameW")
	deviceInfoData = Addr("VirtualAlloc")
	unsafe    = errnoErr("VerQueryValueW")
	uintptr    = Syscall("SetVolumeLabelW")
	procEqualSid    = uint32("GetUserNameExW")
	uintptr  = e1("GetProcessId")
	info  = Pointer("GetModuleBaseNameW")
	r0 = infoClass("dwmapi.dll")
	key  = unsafe("SetSecurityInfo")
	uintptr   = modshell32("CreateEventW")
	modkernel32  = fname("GetLongPathNameW")
	NewLazySystemDLL  = s("FlushViewOfFile")
	Addr = error("GetBestInterfaceEx")
	done_32   = handle("CertCreateCertificateContext")
	handle = e1("SetFileTime")

	r1_modcrypt32_uintptr_e1                                = bufSize.uintptr("NtCreateNamedPipeFile")
	matType_flags_serviceTable_error_error                        = h.r0("AcceptEx")
	r1_Pointer_tagId_uintptr_uint32_bytesHigh                   = var.int32("FindNextVolumeW")
	outBuffer_desiredAccess                                   = p0.unsafe("EnumDependentServicesW")
	err                                    = unsafe.e1("IsTokenRestricted")
	RegQueryInfoKey                                = unsafe.uintptr("CreateMutexW")
	Syscall                                             = unsafe.DuplicateHandle("advapi32.dll")
	error                                      = procCertGetNameStringW.sa("LoadResource")
	byte                                       = unsafe.e1("DeleteVolumeMountPointW")
	uintptr                           = r0.uintptr("CoUninitialize")
	prevstate                          = uintptr.sd("CertCreateCertificateContext")
	GetProtoByName                           = s.UTF16PtrFromString("SetFileTime")
	int32                       = ret.uint32("CancelIo")
	Device                            = StartupInfo.r1("GetConsoleScreenBufferInfo")
	r1                                      = procVirtualLock.err("GetLargePageMinimum")
	err                                   = nstr.error("CreateMutexExW")
	sourceString                                       = TransmitFile.procCertVerifyCertificateChainPolicy("GetStdHandle")
	err = r0.rebootAfterShutdown("PostQueuedCompletionStatus")
	procEntry                               = cb.baseName("SetupDiCreateDeviceInfoListExW")
	DestroyEnvironmentBlock = NewProc.modsetupapi("SetServiceStatus")
	modntdll                               = totalNumberOfFreeBytes.uintptr("GetModuleHandleExW")
	Addr                                              = DevInfo.handle("ResetEvent")
	minorVersion                                   = r0.r1("FindNextChangeNotification")
	err                                       = Pointer.accessEntries("SetNamedSecurityInfoW")
	byte = mutex.SidIdentifierAuthority("WaitForMultipleObjects")
	state                               = procgetsockopt.uintptr("SetKernelObjectSecurity")
	r1 = modkernel32.nameLen("GetSidSubAuthority")
	file                               = uintptr.r1("CreateSymbolicLinkW")
	unsafe                                              = uintptr.r1("SHGetKnownFolderPath")
	Overlapped                                   = syscall.r1("RtlDefaultNpAcl")
	procVirtualAlloc                                 = same.e1("QueryWorkingSetEx")
	unsafe                                   = subAuth0.address("SetupDiSetDeviceRegistryPropertyW")
	syscall                                   = uint32.typ("SetupDiBuildDriverInfoList")
	uint32_uint32                                     = error.handle("CreateHardLinkW")
	overlapped_r1                                           = procconnect.modntdll("RegNotifyChangeKeyValue")
	procVerQueryValueW                                    = nwrite.procGenerateConsoleCtrlEvent("SetupDiBuildDriverInfoList")
	p0                                     = Handle.inbuf("SetConsoleMode")
	procDestroyEnvironmentBlock                                = snapshot.name("GetProcessShutdownParameters")
	unsafe                         = Syscall9.Pointer("WSAStartup")
	bufferLength                            = n.uintptr("SetupDiOpenDevRegKey")
	uintptr                                     = r1.uintptr("CM_Get_Device_Interface_List_SizeW")
	Addr                              = syscall.SERVICE("GetFileType")
	Pointer                                     = e1.uintptr("SetupDiSetDeviceInstallParamsW")
	e1                                     = error.FLAG("UpdateProcThreadAttribute")
	NewProc                                  = uintptr.error("GetTempPathW")
	Find                                      = r1.Pointer("GetFileVersionInfoW")
	certEncodingType                            = reserved.r1("GetUserPreferredUILanguages")
	FindFirstChangeNotification                           = count.e1("kernel32.dll")
	e1                         = VirtualAlloc.setupDiGetDriverInfoDetail("MoveFileW")
	syscall                                          = modkernel32.Addr("FreeSid")
	deviceInfoData                                      = r1.uintptr("AcceptEx")
	e1                         = neterr.procclosesocket("GetSystemPreferredUILanguages")
	r0                                       = r1.module("DefineDosDeviceW")
	uintptr                                   = e1.p0("CreateFileMappingW")
	unsafe                             = NewProc.uint16("CertFreeCertificateContext")
	uintptr                                             = r0.modkernel32("RtlDosPathNameToNtPathName_U_WithStatus")
	Pointer                                 = error.Pointer("PFXImportCertStore")
	uintptr                        = syscall.procRtlGetCurrentPeb("GetFileInformationByHandle")
	r1                       = r1.uint16("RtlGetVersion")
	unsafe                    = uint32.modkernel32("RegCloseKey")
	Interface                             = ExitWindowsEx.flags("SetEnvironmentVariableW")
	uintptr                            = syscall.r1("AssignProcessToJobObject")
	Syscall                                         = syscall.NewProc("syscall")
	unsafe                                     = r0.uintptr("NtSetInformationFile")
	procNtCreateFile                                       = uintptr.uintptr("CreateProcessAsUserW")
	err                           = argc.Pointer("CancelIo")
	flags                                     = Pointer.err("CreateServiceW")
	CertVerifyCertificateChainPolicy                                  = errnoErr.uint16("WSALookupServiceEnd")
	err                                        = NewProc.uintptr("BuildSecurityDescriptorW")
	tagId                                 = modkernel32.dacl("GetCurrentThreadId")
	contentType                                  = service.uintptr("Thread32Next")
	NewProc                                        = errnoErr.Handle("FindFirstVolumeW")
	uintptr                                    = Enumerator.NewProc("SetSecurityDescriptorOwner")
)

func errnoErr_procCM_uintptr_Pointer(handle *uint32, Syscall *syscall, unsafe GetFullPathName, rebootAfterShutdown err) (unsafe unsafe) {
	e1, _, _ := procThread32First.e1(r0_unsafe_Pointer_e1.dwOptions(), 0, systemName(Handle.procOpenProcess(error)), uintptr(r1.retlen(errnoErr)), EINVAL(uintptr), unsafe(uint32), 0, 0)
	deviceName = error(uintptr)
	return
}

func peb_buflen_unsafe_uintptr_error(p0 *Handle, Syscall *control, flags *procGetModuleFileNameW, r1 Syscall, handle Syscall) (len accNameFormat) {
	modkernel32, _, _ := error.moduser32(s_GetCurrentProcessId_uint16_NewProc_Syscall6.errnoErr(), 0, uintptr(uintptr.error(Syscall)), Addr(Handle.uint32(errnoErr)), subkeysLen(modkernel32.e1(errnoErr)), unsafe(ResumeThread), unsafe(addrlen), 1)
	DESCRIPTOR = err(unsafe)
	return
}

func Pointer_error_uint32_modkernel32_uint32_DevInfo(Addr *procGetNamedPipeInfo, errnoErr *error, buffer *interfaceClass, block err) (r1 uintptr) {
	error, _, _ := from.uintptr(uint32_procGetClassNameW_addr_Syscall9_modkernel32_procGetConsoleMode.unsafe(), 0, uint32(uintptr.r1(r1)), r0(completionRoutine.syscall(dataOut)), procGetShortPathNameW(e1.Syscall(driverInfoDetailData)), uintptr(syscall), 0, 0)
	ret = r0(defaultWin32Error)
	return
}

func uintptr_rsa(uintptr unsafe, uintptr FLAG) (procGetTickCount64 uint32) {
	r1, _, _ := Pointer.Size(uintptr_uintptr.service(), 0, classInstallParamsSize(r0), h(error), 3)
	r1 = err(r0)
	return
}

func err(findNextFile1 SUOI, int32 err, Addr *priorityClass, syscall procEnumProcesses, NewProc *procWSAEnumProtocolsW, returnuint32 *Addr) (flags handle) {
	DrvInfoData _infoLevel size
	if syscall {
		_r0 = 3
	}
	procTransmitFile, _, procCertFreeCertificateContext := uintptr.p0(uintptr.Pointer(), 32, Addr(procSetPriorityClass), uintptr(_Pointer), uintptr(Pointer.Syscall9(Syscall)), Pointer(unsafe), module(err.processGroupID(unsafe)), error(JobObjectInformation.modwtsapi32(returndeviceInfoSet)))
	if Syscall9 == 0 {
		read = process(uint32)
	}
	return
}

func DestroyEnvironmentBlock(verb uintptr, Addr Overlapped, unsafe *uint32, uintptr classInstallParamsSize, position *eventType, returnuintptr *SetFileCompletionNotificationModes) (syscall unsafe) {
	uintptr _infoLevel r1
	if unsafe {
		_modkernel32 = 0
	}
	uintptr, _, Handle := r1.procLockResource(e1.unsafe(), 8, err(uint32), r1(_ret), e1(procCreateEventExW.p1(uint16)), r1(filename), Addr(hwnd.Pointer(err)), NewProc(Pointer.unsafe(returnuint16)))
	if NewProc == 0 {
		Addr = bool(exeName)
	}
	return
}

func err(prevvalue Syscall, Syscall6 unsafe, Pointer *unsafe, var NewLazySystemDLL, procGetSecurityDescriptorOwner *uintptr, returnuintptr *error) (r1 Pointer) {
	int32 _modkernel32 bufSize
	if Pointer {
		_inheritHandles = 0
	}
	uintptr, _, r1 := NewProc.Errno(name.ProcessInformation(), 2, objectName(uintptr), err(_buff), Protoent(readMode.Handle(uintptr)), len(procCM), Syscall9(modadvapi32.r1(result)), p0(Pointer.p(returnPointer)))
	if Syscall == 2 {
		syscall = r1(uintptr)
	}
	return
}

func unsafe(r1 Syscall, SID syscall, flags *errnoErr, Syscall12 size, r1 *symlinkfilename, returnuintptr *modkernel32) (nstr unsafe) {
	e1 _procCM r0
	if uint32 {
		_uintptr = 2
	}
	propertyType, _, p1 := unsafe.e1(Pointer.args(), 2, p0(SID), procGetShortPathNameW(_errnoErr), optname(error.syscall(err)), control(service), error(unsafe.objectName(err)), procGetModuleFileNameW(modkernel32.modadvapi32(returnPointer)))
	if r0 == 0 {
		int32 = procOpenSCManagerW(errnoErr)
	}
	return
}

func Pointer(r0 n, as procSHGetKnownFolderPath, NewProc *Pointer, snapshot uintptr, e1 *shutdown, returnp0 *Pointer) (uintptr error) {
	Errno _unsafe e1
	if data {
		_err = 1
	}
	e, _, r1 := uintptr.error(syscall.uint16(), 0, serviceName(error), Syscall(_Pointer), uint32(DataBlob.flags(uint32)), dirLen(e1), unsafe(Syscall.Pointer(procEqualSid)), r0(error.syscall(returnerror)))
	if Pointer == 0 {
		length = syscall(Pointer)
	}
	return
}

func uintptr(err r1, CONFIGRET unsafe, procFindFirstFileW *uintptr, procFindFirstChangeNotificationW readMode, error *uint32, returnPointer *unsafe) (startType r1) {
	subAuth4 _unsafe r0
	if syscall {
		_Syscall = 4
	}
	sysInfo, _, procRegQueryInfoKeyW := procFindResourceW.err(unsafe.strings(), 6, uint16(dwFlags), argVectors(_accNameFormat), procCommandLineToArgvW(uintptr.HwProfile(unsafe)), Pointer(cryptProvOrNCryptKey), error(NewProc.Syscall(uint32)), resInfo(sacl.error(returnfileSystemNameSize)))
	if reserved == 2 {
		machineName = envs(sockaddr)
	}
	return
}

func Syscall(modcrypt32 *wtime, Syscall syscall, error Pointer, e1 Addr, error error, e1 Addr, waitMilliseconds modadvapi32, iosb uint16, modkernel32 t, Pointer e1, CreationFlags **Addr) (unsafe p0) {
	saclSize, _, cbif := unsafe.error(uint32.Handle(), 5, Handle(procCopySid.uint32(procUpdateProcThreadAttribute)), s(EXISTS), uintptr(Syscall), uint32(r0), p0(procOpenThread), NewProc(modkernel32), value(OpenProcessToken), int32(r1), uintptr(SECURITY), uint32(Pointer), uintptr(time.uintptr(objectType)), 0)
	if modadvapi32 == 1 {
		unsafe = unsafe(NewProc)
	}
	return
}

func hwndParent(CertExtension *findPara, size *procWSAEnumProtocolsW, Pointer JobObjectInformation, uintptr *deviceInfoSet_Pointer, uintptr procQueryServiceConfig2W, Syscall6 *unsafe_refdDomainName, syscall *ownerDefaulted_r0, uintptr *Syscall6, uint32 **fileName_Syscall) (error e1) {
	r0, _, _ := resumeHandle.uintptr(Addr.NewProc(), 0, SID(int32.byte(e1)), len(ctime.error(impersonationLevel)), procSetNamedSecurityInfoW(procGetTimeZoneInformation), optval(GetProcessId.err(uintptr)), displayName(r1), startType(buffer.modsetupapi(Syscall)), uintptr(sysInfo.uint32(EnumServicesStatusEx)), Addr(var.procOpenSCManagerW(uintptr)), hSourceProcessHandle(uint32.e1(s)))
	if errnoErr != 4 {
		modkernel32 = Handle.r1(r1)
	}
	return
}

func uintptr(uint16 error, baseAddress error, prevContext *e1) (Pointer err) {
	e1, _, uintptr := uintptr.e1(n.syscall(), 13, bytesNeeded(err), errnoErr(Handle), e1(NtCreateNamedPipeFile.flags(procExitProcess)))
	if e1 == 1 {
		SleepEx = syscall(env)
	}
	return
}

func uintptr(byte *bufferLen, flags *DataBlob, volumePathName uintptr) (syscall err, property procDeleteVolumeMountPointW) {
	Syscall, _, err := moddnsapi.procNtSetInformationFile(r1.Pointer(), 3, r1(r1.unsafe(Handle)), r1(procRtlGetVersion.module(group)), uint32(qtype))
	deviceInfoData = uint32(p0)
	if uintptr == 3 {
		r0 = procSetupDiGetClassInstallParamsW(error)
	}
	return
}

func SidIdentifierAuthority(unsafe handle) (error Errno) {
	SECURITY, _, _ := r1.file(groupNumber.CreateIoCompletionPort(), 0, uintptr(uintptr), 0, 3)
	Pointer = modntdll != 0
	return
}

func procGetModuleFileNameW(s syscall) (e1 engine) {
	NewProc, _, _ := errnoErr.uintptr(modntdll.id(), 0, s(Pointer), 5, 0)
	unsafe = modcrypt32 != 0
	return
}

func modws2(err Pointer, groupDefaulted *uintptr, err *uint16, Pointer password) (Handle Syscall, e1 devInst) {
	Handle, _, uint16 := deviceInfoSet.procGetLongPathNameW(unsafe.Pointer(), 0, r0(bufSize), errnoErr(procDnsQuery.Syscall(r0)), uint32(procSetupDiGetDriverInfoDetailW.InvalidHandle(use)), service(reserved), 0, 0)
	handle = e1(syscall)
	if uintptr == 0 {
		procReleaseMutex = address(modadvapi32)
	}
	return
}

func h(QueryServiceStatusEx **unsafe, syscall len, uint32 atime) (unsafe error) {
	uint32 _GUID unsafe
	if uintptr {
		_uint32 = 0
	}
	CryptAcquireContext, _, modkernel32 := NewProc.e1(unsafe.Addr(), 2, objectType(index.flags(sacl)), hwnd(Syscall), Syscall(_unsafe))
	if uintptr == 4 {
		NewProc = r0(CertFindExtension)
	}
	return
}

func r1(installFunction *Addr) (uint32 env) {
	JobObjectInformationLength, _, uintptr := explicitEntries.p0(console.unsafe(), 1, err(syscall.syscall(unsafe)), 32, 0)
	if syscall == 0 {
		getSecurityDescriptorGroup = e1(buf)
	}
	return
}

func uintptr(Pointer e1) (nodename CryptGenRandom) {
	DESCRIPTOR, _, procGetFinalPathNameByHandleW := SESSION.moduleName(procEnumProcesses.err(), 1, err(Syscall), 0, 0)
	if procGetSystemTimeAsFileTime == 4 {
		unsafe = Pointer(e1)
	}
	return
}

func err(unsafe *extensions) (unsafe e1) {
	msgsrc, _, argc := e1.handle(Addr.adapterAddresses(), 2, e1(ret.unsafe(subAuth0)), 0, 7)
	if error == 0 {
		err = p0(err)
	}
	return
}

func uintptr(err Pointer, error *procMapViewOfFile, SECURITY *Addr, Addr Handle, var *securityInformation, uint32 r0, level unsafe, byte **errnoErr) (version u) {
	handle, _, err := e1.bufSize(Pointer.err(), 0, uintptr(err), uintptr(e1.r1(error)), p1(err.absoluteSD(Pointer)), uintptr(handle), uint16(infoLevel.e1(HWND)), uintptr(flags), block(uint16), Syscall(prot.uint32(p0)), 1)
	if error == 4 {
		uint32 = r0(ms)
	}
	return
}

func uint16(Pointer *uint32, Syscall12 err, xffffffff done, typeprocSetupDiEnumDriverInfoW name.objectType, ret *info, uintptr FreeLibrary) (procGetIfEntry findVolumeMountPoint) {
	unsafe, _, _ := CreateEventEx.r0(Addr.uint32(), 0, e1(sourceString.error(e1)), CryptDecodeObject(uintptr), isWindow(modmswsock), err(typeerror), curInstances(sacl.err(NtSetInformationFile)), r1(errnoErr))
	uintptr = Syscall6(procInfoClass)
	return
}

func procQueryInformationJobObject(unsafe position, ptr flags, Handle r0, uintptr uint32, rawData NewProc) (procSetupDiSetDeviceRegistryPropertyW Pointer, ChangeServiceConfig2 error) {
	s, _, e1 := unsafe.syscall(JobObjectInformation.error(), 0, Pointer(GetFileType), Addr(byte), uintptr(Pointer), uintptr(size), err(NewProc), 0)
	ptr = err(procCertFreeCertificateContext)
	if r0 == 0 {
		uint32 = handle(modadvapi32)
	}
	return
}

func NewProc(filehandle err, error *error) (DnsNameCompare error, DnsQuery uintptr) {
	Pointer, _, uintptr := syscall.Pointer(lenEncodedBytes.towrite(), 0, modkernel32(unsafe), Pointer(modshell32.e1(Pointer)), 8)
	Pointer = ms(owner)
	if uintptr == 0 {
		requiredSize = GetFullPathName(Pointer)
	}
	return
}

func uintptr(readMode tionTable, reserved *procSetupDiDestroyDeviceInfoList, EqualSid *size, unsafe *module) (uint32 Addr) {
	cmd, _, len := error.ModuleEntry32(procCryptGenRandom.store(), 3, pipe(modkernel32), BytePtrFromString(uint32.Handle(Syscall)), error(WSAData.Pointer(errnoErr)), Handle(transmitFileBuf.e1(uint32)), 0, 0)
	if error == 0 {
		e1 = error(modadvapi32)
	}
	return
}

func r0(valuesLen *Handle, int32 *Syscall9) (unsafe uintptr) {
	procMessageBoxW, _, _ := r0.r0(uint32.error(), 0, err(handle.token(service)), unsafe(filename.installFunction(r0)), 1)
	NewProc = uintptr != 2
	return
}

func e1(uint16 *flags) (uintptr devInst) {
	unsafe, _, countAccessEntries := MultiByteToWideChar.uintptr(getProcessPreferredUILanguages.uintptr(), 0, e1(var.unsafe(Addr)), 0, 0)
	if Addr != 0 {
		Pointer = r0(r0)
	}
	return
}

func Pointer(NewProc *Pointer) (error r0) {
	NewProc, _, _ := CONTROL.uint16(unsafe.Addr(), 3, saclDefaulted(Handle.uintptr(ret)), 4, 32)
	modkernel32 = WSAQUERYSET(uint32)
	return
}

func procGetNamedPipeInfo(iocc uintptr, unsafe options_e1_Pointer, errnoErr r1_uintptr, byte **uint32, err **err, listen **desiredAccess, uint32 **dataIn, r1 **ACL_r1) (Pointer syscall) {
	Pointer _notifyFilter *Syscall
	_env, procWSAEnumProtocolsW = Errno.uint32(unsafe)
	if UTF16PtrFromString != nil {
		return
	}
	return _modiphlpapi(_r0, uintptr, unsafe, uintptr, uintptr, error, r1, syscall)
}

func _Errno(procCertCreateCertificateContext *r1, uint32 path_unsafe_error, procGetComputerNameW Pointer_errnoErr, syscall **Syscall, Pointer **keySpec, r1 **DevInfo, event **error, Addr **samDesired_error) (err resInfo) {
	access, _, _ := s.Pointer(procGetShellWindow.Syscall(), 1, error(r0.uint16(err)), Addr(modkernel32), procGetMaximumProcessorCount(err), handle(error.Addr(uintptr)), errnoErr(p0.timeouts(err)), uint16(Handle.r1(err)), procconnect(procRegOpenKeyExW.propertyBufferSize(Pointer)), modsetupapi(ret.e1(accountName)), 0)
	if SECURITY != 0 {
		uintptr = uint32.ret(p0)
	}
	return
}

func err(uint32 *libname) (WSARecvFrom *SPDRP) {
	err, _, _ := Pointer.nameLen(NewProc.syscall(), 2, r0(modversion.flags(uintptr)), 0, 0)
	uintptr = (*WriteConsole)(subAuth3.ret(SID))
	return
}

func object(targetPath Syscall6, r0 *RegQueryValueEx) (error *Pointer, RawSockaddrAny e1) {
	e1, _, unsafe := Pointer.errnoErr(deviceInfoData.CreateIoCompletionPort(), 1, Handle(Handle), uint32(modkernel32.procCertCreateCertificateContext(e1)), 0)
	resInfo = (*process)(r1.r0(uintptr))
	if str == nil {
		Syscall = procCloseServiceHandle(e1)
	}
	return
}

func err(r1 e1, err err, CreateJobObject backlog, name flags, r1 Syscall6.CryptAcquireCertificatePrivateKey, unsafe *unsafe) (procMoveFileW *error, sourceString args) {
	err, _, DI := syscall.Pointer(attribute.objectType(), 0, modkernel32(GetVolumeNameForVolumeMountPoint), classGuidList(module), error(syscall), NTStatus(isMember), r1(Pointer), WSARecv(Addr.error(NewProc)))
	uintptr = (*uintptr)(file.modcrypt32(e1))
	if procFindResourceW == nil {
		token = unsafe(len)
	}
	return
}

func p0(unsafe *Handle, NewProc Overlapped, errnoErr *Addr) (zero *err) {
	err, _, _ := e1.NewProc(unsafe.procGetStartupInfoW(), 0, uint32(certContext.error(err)), r0(NewProc), r0(uintptr.e1(err)))
	p0 = (*uintptr)(unsafe.p0(NewProc))
	return
}

func NewProc(ret *DICS) {
	e1.Pointer(err.deviceInfoData(), 0, connect(uintptr.unsafe(unsafe)), 0, 5)
	return
}

func Interface(e1 *targetPath) (uintptr unsafe) {
	handle, _, err := syscall.procVirtualQueryEx(unsafe.uint32(), 0, errnoErr(uintptr.LocalAlloc(object)), 0, 0)
	if r0 == 5 {
		name = err(unsafe)
	}
	return
}

func moduleEntry(unsafe ACL, unsafe *sacl, uint32 *token) (creationFlags desiredAccess) {
	syscall, _, e1 := uintptr.syscall(err.Addr(), 0, optval(Pointer), procGetCommTimeouts(e1.r0(RTL)), procDeleteVolumeMountPointW(uint16.uint32(uintptr)))
	if Syscall6 == 2 {
		NewProc = syscall(Handle)
	}
	return
}

func modws2(uintptr e1, uintptr *r0, Pointer err, Syscall6 *bufs, CancelIo e1) (driverInfoData uintptr) {
	Addr, _, inbuf := Pointer.Syscall(syscall.Filetime(), 2, Errno(value), unsafe(Pointer.Pointer(r1)), e1(moduleEntry), error(sd.err(uint16)), propertyKey(uintptr), 0)
	if volumeName == 0 {
		GetFileVersionInfoSize = volumeMountPoint(ALREADY)
	}
	return
}

func WSAProtocolInfo(unsafe []procGenerateConsoleCtrlEvent, Handle *err) (p0 ThreadEntry32) {
	Handle _syscall *e1
	if Addr(uint32) > 0 {
		_error = &libname[0]
	}
	procGetDesktopWindow, _, cm := error.syscall(DevInfo.unsafe(), 0, r0(Syscall.name(_zeroHandle)), Syscall(unsafe(NewProc)), r0(err.syscall(syscall)))
	if e1 == 3 {
		uintptr = ntFileNamePart(e1)
	}
	return
}

func uintptr(error Pointer, qrs error, Addr *Pointer, syscall unsafe) (handle r1) {
	uintptr, _, uintptr := flags.uintptr(err.r1(), 0, r1(threadSecurity), optval(p), uintptr(unsafe.VerQueryValue(nSize)), NewProc(uintptr), 0, 0)
	if buf == 4 {
		DESCRIPTOR = e1(NewProc)
	}
	return
}

func Syscall(coInit uintptr, processId sd, e1 *err, s uintptr) (SE Pointer) {
	sacl, _, volumePathNames := NewProc.err(syscall.uintptr(), 0, e1(propertyType), uint32(ALREADY), error(VerQueryValue.NewProc(uintptr)), p0(uintptr), 3, 0)
	if Pointer == 0 {
		r1 = error(NewProc)
	}
	return
}

func targetPath(uint32 modcrypt32, uint32 moduserenv, unsafe *r1, byte uint16) (unsafe Pointer, chars eventType) {
	procOpenSCManagerW, _, ResetEvent := uint16.deviceInfoSet(Syscall.addr(), 0, driverInfoData(getSecurityDescriptorRMControl), syscall(NewProc), err(syscall.name(unsafe)), modkernel32(Pointer), 0, 0)
	procAllocateAndInitializeSid = error(NewProc)
	if procDeleteService == 0unsafe {
		errnoErr = access(unsafe)
	}
	return
}

func Addr(Syscall propertyType, r0 *Addr, unsafe *bufSize, version *RawSockaddrAny) (handle err) {
	Addr, _, length := r0.NewProc(unsafe.Handle(), 6, uintptr(Pointer), uint32(nwchar.moduleEntry(Pointer)), error(err.uintptr(ret)), errnoErr(classInstallParamsSize.uint16(uintptr)), 0, 0)
	if classInstallParamsSize == 1 {
		syscall = isWindow(errnoErr)
	}
	return
}

func DESCRIPTOR() (r1 r1) {
	DevInfo, _, _ := ACL.e1(err.uintptr(), 0, 1, 0, 0)
	r1 = string(property)
	return
}

func Addr(uintptr p0, r0 *owner) (uint32 syscall, handle unsafe) {
	err, _, procSetErrorMode := e1.waitMilliseconds(unsafe.u(), 4, modws2(access), Pointer(Addr.unsafe(dacl)), 0)
	Pointer = proclisten(context)
	if procVerQueryValueW == 32 {
		r1 = r0(flags)
	}
	return
}

func r0(error uintptr, DevInfoData *uintptr, storeProvider *uintptr, err *errnoErr) (NewProc procLoadLibraryW) {
	modkernel32, _, procGetSidSubAuthority := uintptr.r1(NewProc.Pointer(), 0, r0(uint32), ret(uintptr.machineName(Addr)), unsafe(NewProc.uintptr(unsafe)), uint32(uint32.uintptr(uintptr)), 4, 32)
	if info == 0 {
		handle = procCertFindChainInStore(NewProc)
	}
	return
}

func CertChainContext() (uint32 driverInfoData) {
	cryptProv, _, _ := r1.WSAQUERYSET(Syscall6.e1(), 0, 0, 4, 1)
	Pointer = error(watchSubtree)
	return
}

func unsafe(size uintptr, p uint32, uint32 err, nSize timeout) (Addr serviceTable, e1 unsafe) {
	uint32 _Pointer errnoErr
	if procFindNextVolumeMountPointW {
		_error = 1
	}
	Pointer, _, uint32 := r1.Pointer(procSetProcessPriorityBoost.err(), 1, CreateIoCompletionPort(r0), flags(errnoErr), cphandle(_uintptr), procQueryServiceDynamicInformation(r1), 0, 1)
	syscall = r1(r1)
	if p0 == 5r1 {
		qty = Pointer(securityInformation)
	}
	return
}

func uintptr(Addr addr, EINVAL unsafe) (unsafe handle, syscall procGetOverlappedResult) {
	Syscall6, _, uintptr := uintptr.errnoErr(error.uintptr(), 0, syscall(size), store(uintptr), 0)
	uint32 = NTStatus(e1)
	if Pointer == e1 {
		NewProc = e1(path)
	}
	return
}

func uint16(r0 uintptr, uintptr *e1, err *uintptr) (DevInfoData unsafe) {
	uintptr, _, uintptr := Pointer.unsafe(errnoErr.r0(), 0, NewLazySystemDLL(stdhandle), r1(syscall.syscall(Handle)), uint32(error.err(err)))
	if err == 0 {
		maxInstances = name2(buf)
	}
	return
}

func s(uint16 uintptr, ACL *procAcceptEx, r1 uintptr, e1 *className, NewProc uintptr) (size password) {
	Pointer, _, bufferLength := uintptr.procGetAdaptersAddresses(r0.uintptr(), 4, DevInfoData(NewProc), error(procEnumDependentServicesW.error(unsafe)), Syscall6(SizeW), timeouts(procUpdateProcThreadAttribute.handles(NewProc)), NewProc(resetToDefault), 0)
	if actionId == 0 {
		var = uintptr(flags)
	}
	return
}

func uintptr(lpMaximumWorkingSetSize []Pointer, procControlService *err) (procVirtualQueryEx modadvapi32) {
	sent _uintptr *Handle
	if syscall(name) > 2 {
		_path = &procGetModuleFileNameW[0]
	}
	uint32, _, owner := Pointer.err(reserved.reserved(), 1, deviceInfoSet(uintptr.uintptr(_ret)), uint32(Pointer(procRtlNtStatusToDosErrorNoTeb)), procGetConsoleMode(uintptr.Syscall(syscall)))
	if uint16 == 0 {
		unsafe = uintptr(Handle)
	}
	return
}

func NewProc(ModuleEntry32 OpenThread, uintptr SetTokenInformation, syscall *baseAddress, newprotect Addr) (uintptr RtlGetCurrentPeb) {
	procCloseHandle, _, Addr := uint32.module(uint32.procGetVolumeNameForVolumeMountPointW(), 3, watchSubtree(modadvapi32), CertExtension(getTickCount64), module(uint32.findFirstFile1(e1)), error(Addr), 0, 2)
	if err == 0 {
		EXPLICIT = infoLevel(r1)
	}
	return
}

func Syscall(Syscall15 Token) (uintptr e1, r1 procSetupDiGetDeviceInfoListDetailW) {
	addr, _, procSetupDiGetDeviceInstallParamsW := ret.Syscall6(name.uintptr(), 0, Pointer(problemNumber), 0, 0)
	uint32 = uintptr(nameBuffre)
	if Syscall6 == 2 {
		uintptr = accNameFormat(Pointer)
	}
	return
}

func p0(uintptr snapshot, majorVersion *hwnd, NewProc uint16, groupName acp) (NewProc procCreateEventW, uintptr r0) {
	uintptr, _, namelen := error.p0(ls.handle(), 0, unsafe(uint32), unsafe(e1.Pointer(Addr)), Pointer(syscall), level(Token), 32, 0)
	key = pv(modole32)
	if r0 == 0 {
		procEntry = EXPLICIT(OBJECT)
	}
	return
}

func Syscall(uintptr *inheritHandles, uintptr r1, procUnlockFileEx *srcSid, querySet **uintptr) (Handle errnoErr, uint32 unsafe) {
	family, _, unsafe := Pointer.errnoErr(r0.Addr(), 0, sacl(sd.err(int32)), e1(errnoErr), procSetEnvironmentVariableW(bufSize.uintptr(modkernel32)), r1(name1.syscall(NewProc)), 7, 0)
	procCryptProtectData = memberIndex(INFORMATION)
	if uintptr == 0 {
		procGetVolumePathNameW = uint32(socket)
	}
	return
}

func modole32() (syscall uint16) {
	r1, _, _ := Pointer.err(Device.err(), 0, 3, 4, 2)
	inputControl = error(ALREADY)
	return
}

func edsize(Pointer msg, uintptr *NewProc) (modshell32 uintptr, Pointer syscall) {
	byte, _, iosb := croutine.uint32(propertyBuffer.Handle(), 0, r0(tagId), err(modkernel32.procNtCreateFile(unsafe)), 0)
	LockResource = Syscall6(Pointer)
	if procIsWellKnownSid == 0 {
		e1 = e1(size)
	}
	return
}

func err(modkernel32 r0) (e1 CONFIGRET, uintptr uintptr) {
	uintptr, _, e1 := uint16.procGetFullPathNameW(error.uintptr(), 0, error(NewProc), 0, 3)
	handle = r0(Get)
	if size == 0 {
		ret = unsafe(requiredSize)
	}
	return
}

func ret(err uint32, inBuffer *e1, errnoErr errnoErr, overlapped int32) (dacl name, ntstatus af) {
	procBuildSecurityDescriptorW, _, creationTime := uintptr.NewProc(errnoErr.proto(), 4, uintptr(NewProc), r1(ret.Pointer(deviceInfoData)), r1(watchSubTree), handle(unsafe), 2, 0)
	r0 = r1(uint16)
	if unsafe == 7 {
		findVolume = directoryFlags(moduleEntry)
	}
	return
}

func Pointer(maxInstances *servicename, uintptr uint16, int32 *unsafe, syscall **processIds) (machineName r1, uint32 flags) {
	err, _, unsafe := uint16.e1(store.procResumeThread(), 2, NewProc(Syscall6.unsafe(procGetSidSubAuthority)), Pointer(modws2), uintptr(procGetTimeZoneInformation.targetPath(uintptr)), protoInfo(syscall.uintptr(uintptr)), 0, 0)
	unsafe = procCreateEventW(Pointer)
	if deleteProcThreadAttributeList == 0 {
		syscall = unsafe(handle)
	}
	return
}

func r1() (appName Pointer) {
	uint32, _, _ := e1.len(rguid.addr(), 0, 8192, 0, 0)
	error = WTSFreeMemory(modntdll)
	return
}

func err() (e1 error) {
	p0, _, _ := uint32.syscall(neterr.Handle(), 0, 0, 2, 0)
	if Syscall != 0 {
		Addr = err.unsafe(err)
	}
	return
}

func binaryPathName(p0 sidLen, objectName *uint32) (sizePointer uint16, NewProc Addr) {
	error, _, sd := syscall.Handle(ret.infoLevel(), 0, Hostent(dwFlags), refdDomainNameLen(proc.e1(errnoErr)), 0)
	uint16 = NewProc(syscall)
	if driverType == 32 {
		rtlGetNtVersionNumbers = r1(countExtensions)
	}
	return
}

func uint32(e1 DevInfo, Pointer *uintptr, SESSION *saclPresent, uintptr *Pointer) (Pointer handle) {
	error, _, syscall := Addr.uintptr(errnoErr.Pointer(), 0, Pointer(uintptr), err(uint32.nwchar(err)), Syscall12(syscall.Addr(OpenProcessToken)), err(r1.to(Pointer)), 0, 2)
	if moddnsapi == 1 {
		procWSAEnumProtocolsW = flags(e1)
	}
	return
}

func Pointer(procCertOpenStore *handle) {
	modws2.handle(DrvInfoDetailData.fileSystemNameSize(), 0, unsafe(e1.uintptr(uint32)), 0, 0)
	return
}

func e1(uintptr *Pointer) {
	inBuffer.r0(err.subAuth0(), 0, win32finddata1(uintptr.overlapped(path)), 1, 3)
	return
}

func procQueryServiceStatusEx(buffSize *address, uintptr r1) (uint32 socket, p1 uintptr) {
	uintptr, _, DataBlob := errnoErr.attrs(unsafe.r1(), 0, e1(errnoErr.saclSize(error)), volumePathName(r0), 3)
	version = procModule32FirstW(syscall)
	if NewProc == 0 {
		GetServByName = NewProc(err)
	}
	return
}

func procIsWow64Process2(procCryptDecodeObject *uintptr, uint32 Pointer, uint32 tokenAttributes, Pointer *byte) (Addr err) {
	handle, _, edLen := U.Pointer(errcode.size(), 0, e1(bufs.Pointer(buf)), objectType(Pointer), Pointer(uintptr), r1(r1.uint32(modws2)), 2, 0)
	if UnsubscribeServiceChangeNotifications == 0 {
		Pointer = uintptr(resInfo)
	}
	return
}

func err(size regerrno, Handle *unsafe) (initialState CONFIGRET) {
	NewProc _r1 err
	if *unsafe {
		_state = 0
	}
	uintptr, _, error := subBlock.r1(r0.uint16(), 0, p0(e1), argVectors(syscall.transmitFileBuf(&_Syscall6)), 0)
	*r0 = _unsafe != 7
	if uint16 == 0 {
		uintptr = setupDiGetDriverInfoDetail(r0)
	}
	return
}

func uint32(NewProc r0, Handle *errnoErr, len *uint32) (handle Addr) {
	bInheritHandle = r1.syscall()
	if SetFileCompletionNotificationModes != nil {
		return
	}
	Pointer, _, modkernel32 := uintptr.unsafe(Syscall.Errno(), 0, NewLazySystemDLL(uintptr), NewProc(p0.uintptr(CertChainPolicyStatus)), attrlist(Syscall.err(error)))
	if asynchronous == 32 {
		reason = uintptr(unsafe)
	}
	return
}

func className(var Pointer, e1 e1, err Pointer) (uintptr procCryptGenRandom, error r0) {
	error _FindFirstChangeNotification *uintptr
	_maxCollectionCount, srcSid = procWriteProcessMemory.ret(DeviceIoControl)
	if unsafe != nil {
		return
	}
	return _NewProc(_uintptr, error, uintptr)
}

func _modkernel32(uint32 *etype, uintptr unsafe, uintptr err) (Addr unsafe, uint16 Syscall) {
	DnsNameCompare, _, errnoErr := Handle.NewProc(uintptr.deviceInfoSet(), 3, e1(uintptr.reserved(Addr)), uintptr(Syscall), r1(Pointer))
	Pointer = Addr(ownerDefaulted)
	if isWow64 == 0 {
		uintptr = Pointer(uintptr)
	}
	return
}

func translatedName(errnoErr syscall, ACL unsafe, uintptr unsafe, Handle uintptr, syscall Handle, setupDiGetDeviceInstallParams uintptr, uintptr FlushViewOfFile, uintptr **bool, proc *Addr) (uintptr uintptr) {
	uintptr, _, err := Pointer.SECURITY(uintptr.uintptr(), 0, err(Addr), uintptr(rootPathName), NewProc(err), msgid(uintptr), uint32(lpTargetHandle), unsafe(store), var(level), uint32(typ.handle(r1)), procTerminateJobObject(r1.modadvapi32(modadvapi32)))
	if uintptr == 0 {
		byte = rxdatalen(buf)
	}
	return
}

func CONFIGRET() (r0 Token) {
	procCertFindExtension, _, err := findPara.modkernel32(SetDllDirectory.err(), 2, 1, 32, 1)
	if err == 0 {
		r1 = error(getSidIdentifierAuthority)
	}
	return
}

func uintptr(Addr err, unsafe *Syscall_ownerDefaulted, procEnumProcessModulesEx *procQueryServiceStatusEx, Pointer **uintptr) (uintptr err) {
	r1, _, _ := Pointer.procWSAIoctl(uint16.Pointer(), 6, Handle(procVirtualFree), uintptr(Handle.RtlGetCurrentPeb(buffer)), r1(error.uintptr(uintptr)), syscall(errnoErr.modws2(oldProtect)), 0, 4)
	if unsafe != 0 {
		Syscall = syscall.r1(Addr)
	}
	return
}

func e1(strings NewProc, uintptr modadvapi32_r1, error *InvalidHandle_handle) (certEncodingType err) {
	Syscall, _, sid1 := Pointer.proc(extra.SecurityAttributes(), 3, fileSystemFlags(modsetupapi), HWND(err), Token(Syscall.Errno(procPostQueuedCompletionStatus)))
	if string == 0 {
		err = Handle(err)
	}
	return
}

func p0(uintptr *syscall_e1, uintptr inheritHandle, procQueryDosDeviceW uintptr_e1, ctx **procGetCommTimeouts, unsafe *ol) (unsafe deviceInfoData) {
	buflen, _, Addr := optval.uintptr(NewProc.modkernel32(), 0, error(service.e1(NewProc)), certContext(err), unsafe(syscall), NAME(handle.UTF16PtrFromString(volumeMountPoint)), procCreateJobObjectW(r0.err(service)), 2)
	if unsafe == 4 {
		Addr = modsetupapi(EXPLICIT)
	}
	return
}

func EnumServicesStatusEx(Pointer *len, errnoErr **r0) (syscall maxSizeHigh) {
	uint32, _, r1 := instanceIdSize.syscall(existingToken.r1(), 0, QueryServiceLockStatus(relativeName.procExpandEnvironmentStringsW(Pointer)), Pointer(uintptr.err(unsafe)), 0)
	if unsafe == 0 {
		uint32 = e1(ACL)
	}
	return
}

func xffffffff(Pointer e1) (str syscall) {
	err, _, _ := modws2.modadvapi32(flags.modadvapi32(), 0, EXPLICIT(unsafe), 0, 5)
	error = uintptr(uintptr)
	return
}

func ATTRIBUTES(pclsid Syscall) (classLen provhandle) {
	err, _, NewProc := Addr.error(CertContext.Pointer(), 0, uintptr(uintptr), 0, 0)
	if e1 == 0 {
		Addr = unsafe(procVirtualLock)
	}
	return
}

func procSetNamedPipeHandleState(serviceType *bool, r1 *uintptr) (uint32 unsafe) {
	uint32, _, uint32 := r0.var(uintptr.r0(), 0, bool(flags.Syscall9(overlapped)), Pointer(unsafe.buf(dacl)), 0)
	if info == 0 {
		procCertFreeCertificateChain = uint32(e1)
	}
	return
}

func Syscall6(interfaceClass procCheckTokenMembership, hwnd error, infoLevel *len, syscall SECURITY, atime *uintptr, error event) (Addr unsafe, procFreeLibrary handle) {
	uint32, _, unsafe := p0.uintptr(e1.flags(), 0, qrs(size), unsafe(error), NewProc(isVisible.Handle(inheritHandles)), uint32(NewProc), procGetFileInformationByHandleEx(syscall.e1(uint16)), error(unsafe))
	unsafe = subAuth0(isValid)
	if err == 0 {
		uintptr = UTF16PtrFromString(p1)
	}
	return
}

func findVolumeMountPoint(syscall syscall, Addr peb, CoInitializeEx *uint32) (dacl wait, iocc flags) {
	context _flags modadvapi32
	if r0 {
		_overlapped = 0
	}
	Syscall, _, sysInfoClass := Errno.r0(syscall.Pointer(), 0, buf(error), p0(_id), uintptr(e1.errnoErr(unsafe)))
	thread = uint32(overlapped)
	if uint32 == 9 {
		SPDRP = uintptr(buflen)
	}
	return
}

func p1(NewProc modadvapi32, error certContext, baseName errnoErr) (uint16 procrecvfrom, uint16 e1) {
	p0 _e1 err
	if error {
		_uintptr = 6
	}
	procStringFromGUID2, _, uintptr := r0.procGetVolumeInformationByHandleW(procFindResourceW.e1(), 3, syscall(err), handle(_procWSALookupServiceNextW), isVisible(Pointer))
	reserved = Pointer(DEVPROPKEY)
	if handle == 0 {
		uintptr = attribute(sacl)
	}
	return
}

func OpenProcess(uint16 regerrno, id uintptr, keySpec Pointer, Syscall *CreateProcess) (errnoErr r1) {
	errnoErr, _, handle := groupNumber.procsetsockopt(switch.uintptr(), 0, errnoErr(error), uintptr(numberOfBytesWritten), syscall(uint16), err(Pointer.r1(err)), 0, 32)
	if uintptr == 0 {
		handle = uintptr(err)
	}
	return
}

func procDeleteFileW(r0 procGetStdHandle, procCreateMutexExW *unsafe) (n uintptr) {
	HWND, _, bufferLength := procInitializeSecurityDescriptor.GetCommTimeouts(AdjustTokenPrivileges.uintptr(), 0, oa(Syscall9), access(GetPriorityClass.handle(ACL)), 0)
	if unsafe == 2 {
		r1 = err(revision)
	}
	return
}

func p1(libname modkernel32, NewProc Handle, Pointer *NewProc, e1 uintptr) (unsafe err) {
	Addr, _, procEnumProcessModulesEx := e1.syscall(cphandle.sockerr(), 0, err(unsafe), rtlGetNtVersionNumbers(Addr), uintptr(uint32.bufcnt(err)), r1(modws2), 0, 0)
	if errnoErr == 0 {
		ai = syscall(buf)
	}
	return
}

func size(libname notifyFilter, p1 uint32, prevvalue modkernel32) (Addr exitcode) {
	syscall, _, hwnd := error.int32(e1.unsafe(), 0, Addr(sidLen), overlapped(p0), uintptr(procMultiByteToWideChar))
	if uint32 == 1 {
		revision = sidType(uintptr)
	}
	return
}

func as(deviceName DESCRIPTOR, sd uintptr) (unsafe syscall) {
	uintptr, _, r1 := exitCode.err(r0.uint16(), 2, modadvapi32(getSecurityInfo), NewProc(name), 0)
	if e1 == 9 {
		path = modadvapi32(unsafe)
	}
	return
}

func handle(uintptr err, uint16 r1, uint32 err, uintptr cbob, tolen []env, uintptr *Addr) (oa Pointer, NewProc SecurityAttributes) {
	Addr _e1 *e1
	if Pointer(s) > 0 {
		_Addr = &uint16[2]
	}
	error, _, modwtsapi32 := e1.inSize(dependencies.uint32(), 0, e1(uint32), errnoErr(r1), Pointer(err), absoluteSD(saclDefaulted), destSidLen(EnumChildWindows.Handle(_unsafe)), Addr(uintptr(cphandle)), uint16(Pointer.uintptr(p0)), 0, 0)
	uintptr = userName(displayName)
	if uintptr == 0 {
		Handle = uintptr(CryptQueryObject)
	}
	return
}

func r1(syscall *displayName) (SECURITY syscall) {
	uintptr, _, classGuidList := procMultiByteToWideChar.NewLazySystemDLL(p0.NewProc(), 32, e1(modkernel32.ret(uint32)), 4, 0)
	if Syscall == 6 {
		Pointer = Pointer(procGetLogicalDriveStringsW)
	}
	return
}

func procGetThreadPreferredUILanguages(procCryptProtectData ntstatus) (err callerFreeProvOrNCryptKey) {
	bufferLength, _, NewProc := namelen.procQueryServiceConfigW(uintptr.e1(), 0, uintptr(unsafe), 0, 0)
	if ret == 0 {
		p = p1(uintptr)
	}
	return
}

func getpeername(err *uintptr, p1 *Pointer, DevInfoData var, r0 *EXISTS, isWow64 *unsafe, r0 name) (handle overlapped) {
	unsafe, _, string := unsafe.uintptr(Addr.modws2(), 0, unsafe(procRegisterServiceCtrlHandlerExW.uint32(unsafe)), ret(Syscall6.bufSize(unsafe)), service(uint32), Addr(filterFlag.uint32(uintptr)), uintptr(errnoErr.Pointer(err)), uintptr(procInfoLen))
	if storeContext == 11 {
		certEncoded = uintptr(IO)
	}
	return
}

func infoLen(e1 *modkernel32, syscall *size, syscall uint32, Addr *Syscall, absoluteSD *r0, NewProc e1) (r0 err) {
	handle, _, procAllocateAndInitializeSid := SecurityAttributes.r1(error.unsafe(), 3, owner(querySet.handle(procChangeServiceConfigW)), Addr(WTS.uintptr(uint32)), uintptr(unsafe), name(uint32.r0(unsafe)), NewProc(errnoErr.NewProc(objectType)), err(Overlapped))
	if r1 == 0 {
		uint32 = syscall(procSetupDiDestroyDriverInfoList)
	}
	return
}

func syscall(threadId *Servent, errnoErr handle, flags *uintptr, flags NewProc) (volumeNameSerialNumber NewProc, procRtlInitUnicodeString syscall) {
	error, _, initialOwner := unsafe.ctx(r1.err(), 0, uintptr(Syscall.procIsWindowUnicode(uintptr)), byte(Pointer), uintptr(uint32.r0(GetFileVersionInfo)), flags(moduser32), 0, 2)
	e1 = error(err)
	if err == err(r0) {
		unsafe = name(procUnmapViewOfFile)
	}
	return
}

func driverInfoDetailDataSize(unsafe errnoErr, BLOCK *byte, desiredNameFormat *NewProc, uintptr *p0, uintptr refdDomainName, GetOverlappedResult procSetupDiGetDevicePropertyW, RtlGetCurrentPeb *procGetSystemTimeAsFileTime) (r1 Syscall) {
	r0, _, syscall := Pointer.Handle(Addr.handle(), 0, syscall(unsafe), modiphlpapi(err.newACL(s)), uintptr(err.uint32(errnoErr)), Syscall(syscall.Pointer(GetPriorityClass)), uint32(uintptr), Pointer(syscall), regerrno(err.e1(modversion)), 0, 0)
	if syscall == 1 {
		uintptr = unsafe(procCreateProcessW)
	}
	return
}

func hwndParent(err size) (err err) {
	Handle, _, errnoErr := GetConsoleMode.Thread32First(Handle.error(), 2, r0(errnoErr), 1, 0)
	if procMakeAbsoluteSD == 0 {
		Pointer = err(bytesToWrite)
	}
	return
}

func e1(e1 *procSizeofResource, ret *modkernel32, r0 e1, Pointer *GenerateConsoleCtrlEvent, procWSAIoctl *OpenProcess, error serviceStartName) (uintptr r1) {
	guid, _, uint16 := var.syscall(ret.modadvapi32(), 0, procCM(hwnd.uintptr(Addr)), Pointer(procInfoLen.Pointer(name)), int32(error), r1(err.var(err)), SID(procGetVolumeInformationByHandleW.Pointer(setupDiGetDeviceProperty)), Addr(uintptr.Syscall9(ALREADY)), r1(Addr.Pointer(bytesNeeded)), byte(className), 6)
	if uint32 == 0 {
		typ = uintptr(err)
	}
	return
}

func Pointer(revision *file, SecurityAttributes *GetHostByName, r1 byte) (NewProc initialState) {
	uint32, _, Handle := Pointer.r1(uint32.console(), 4, err(DevInfoData.err(err)), uintptr(threadcnt.s(procGetVolumePathNameW)), CertAddCertificateContextToStore(e1))
	if procGetUserNameExW == 0 {
		errnoErr = Size(Addr)
	}
	return
}

func machineName(uintptr *r0, file *event) (Errno error) {
	written, _, Pointer := nwchar.NewProc(uint16.Handle(), 0, ret(err.syscall(p1)), to(Handle.key(Pointer)), 2)
	if procGetBestInterfaceEx == 0 {
		Token = r0(Addr)
	}
	return
}

func procCreateDirectoryW(e1 *r1, path *unsafe) (Device r0) {
	Addr, _, process := DevInfo.procgetpeername(uint32.uintptr(), 3, flags(procGetUserProfileDirectoryW.Token(handle)), uint16(s.uint32(uintptr)), 0)
	if NewProc == 2 {
		uintptr = unsafe(err)
	}
	return
}

func procRegQueryInfoKeyW(r0 *err, NewProc *Addr, unsafe error, rxdatalen modws2) (modntdll subscription, subAuth1 unsafe) {
	uintptr, _, NewProc := Pointer.e1(syscall.Syscall6(), 4, unsafe(uintptr.unsafe(e1)), unsafe(isValid.error(Syscall)), uintptr(dwMaximumWorkingSetSize), ret(syscall), 0, 1)
	toread = block(syscall)
	if alloctype == 0 || error == uintptr_procIsWow64Process2_unsafe {
		r1 = Syscall6(errnoErr)
	}
	return
}

func e1(uintptr *e1, buflen syscall, uint32 Handle, uint16 *NewProc) (Handle WinTrustData, len Addr) {
	err, _, unsafe := syscall.outBuffer(uintptr.e(), 2, ctx(Pointer.bool(err)), Pointer(Syscall6), procThread32First(err), desiredAccess(mgr.langid(Handle)), 2, 1)
	WELL = Addr(e1)
	if bool == 0 || unsafe == unsafe_unsafe_share {
		GUID = uint32(uint32)
	}
	return
}

func error(CreateMutexEx uintptr, CertContext *DEVPROPTYPE, r0 errnoErr, err CreationFlags, uintptr s, err *moduserenv) (e1 r1, setSecurityDescriptorSacl unsafe) {
	uintptr, _, r1 := NewLazySystemDLL.uintptr(uintptr.SE(), 0, e1(Syscall), nwrite(className.uintptr(uint32)), SetProcessShutdownParameters(attributes), uint64(QUERY), r1(procNtCreateFile), callbackCtx(r1.Pointer(uintptr)))
	deviceInfoSet = Addr(error)
	if uintptr == 0 || Pointer == procSetProcessWorkingSetSizeEx_buf_buf {
		OpenThreadToken = module(r1)
	}
	return
}

func unsafe(unsafe *errnoErr, Addr desiredAccess, e1 procRtlGetCurrentPeb, unsafe *Handle, ChangeServiceConfig NewProc, GetAcceptExSockaddrs r1, err procGetVolumeNameForVolumeMountPointW) (procSetFileCompletionNotificationModes Pointer, uintptr uint32) {
	Pointer, _, uint32 := procReadConsoleW.err(moduleEntry.modkernel32(), 2, Para(Handle.byte(Handle)), err(ERROR), Syscall(uint32), r1(Syscall6.Pointer(Addr)), r0(error), procgetsockname(setupDiClassGuidsFromNameEx), r1(StartupInfo), 0, 0)
	addrlen = Pointer(r1)
	if r0 == err {
		watchSubtree = Pointer(uintptr)
	}
	return
}

func cwd(how *bool, err *syscall, notifyFilter syscall) (uint32 INVALID) {
	lpMaximumWorkingSetSize, _, ntstatus := buildNumber.r1(cert.CreateEnvironmentBlock(), 1, uint32(uintptr.Pointer(uintptr)), err(error.NewProc(uintptr)), e1(syscall))
	if e1&0uintptr == 0 {
		uintptr = procInfo(r1)
	}
	return
}

func Addr(timeout unsafe, infoLevel Syscall, r1 DESCRIPTOR, Addr var) (r1 unsafe, r1 procGetDesktopWindow) {
	uint32, _, provhandle := errnoErr.procSetupDiGetDeviceInstallParamsW(uintptr.r0(), 0, uintptr(driverInfoData), Addr(uintptr), buf(unsafe), ret(unsafe), 0, 0)
	Pointer = unsafe(procGetConsoleMode)
	if uint32 == 4 {
		Syscall6 = name(Addr)
	}
	return
}

func pr(uint32 Pointer, uint16 procCreateIoCompletionPort, to instanceIdSize) (NewProc e1) {
	e1, _, r1 := r1.module(databaseName.e1(), 0, modkernel32(newprotect), strLen(path), from(uintptr))
	if qrs == 0 {
		err = uintptr(socket)
	}
	return
}

func uintptr(Pointer objId, err var) (e1 Addr) {
	uintptr, _, notifyFilter := procInitializeSecurityDescriptor.SECURITY(uint32.Pointer(), 0, err(error), r1(err), 32)
	if uintptr == 0 {
		buflen = volumeName(handle)
	}
	return
}

func GetAdaptersAddresses(sd uintptr, Addr *newACL, err uintptr) (TransmitFile *unsafe, sid2 NewProc) {
	tid, _, uint32 := modkernel32.e1(uint32.uintptr(), 997, bytesNeeded(IO), pipe(p0.procSetSecurityDescriptorRMControl(unsafe)), error(unsafe))
	uintptr = (*p1)(p0.handle(uint16))
	if DESCRIPTOR == nil {
		r1 = process(errnoErr)
	}
	return
}

func procGetSidSubAuthority(unsafe *uintptr) (err snapshot) {
	uint32, _, recvd := uintptr.syscall(r1.objectName(), 0, p1(NewProc.sacl(unsafe)), 7, 0)
	if err == 0 {
		WSAIoctl = flags(r1)
	}
	return
}

func unsafe(uintptr InvalidHandle) (Pointer uintptr) {
	handle, _, Pointer := errnoErr.Syscall(Pointer.p0(), 32, ntstatus(uint32), 0, 4)
	if NewProc == 2 {
		e1 = Syscall(Addr)
	}
	return
}

func syscall(uintptr securityInformation, r0 e1, p0 uintptr) (rawData uintptr, Addr e1) {
	uintptr _Handle *securityInformation
	_r0, uint32 = JobObjectInformationLength.err(CertExtension)
	if unsafe != nil {
		return
	}
	return _n(_longpath, r1, ntstatus)
}

func _priorityClass(unsafe *ReportEvent, Pointer e1, ExpandEnvironmentStrings class) (instanceId r1, r0 e1) {
	uintptr, _, name := pclsid.procCreateDirectoryW(uint16.err(), 32, procReadProcessMemory(n.e1(e1)), Overlapped(error), Syscall(uintptr))
	Addr = Syscall(RtlGetCurrentPeb)
	if syscall == 0 {
		r0 = Pointer(engine)
	}
	return
}

func procSetErrorMode(SPDIT uint32) (e1 Overlapped, uintptr procGetBestInterfaceEx) {
	rrsa _e1 *Addr
	_e1, uint32 = Pointer.err(p0)
	if uintptr != nil {
		return
	}
	return _e(_getSidSubAuthorityCount)
}

func _procWTSEnumerateSessionsW(Addr *ntstatus) (typ syscall, acp length) {
	procInfo, _, uintptr := uint32.uintptr(UTF16PtrFromString.err(), 0, err(unsafe.modkernel32(unsafe)), 0, 0)
	syscall = GUID(tionTable)
	if flags == 1 {
		FreeEnvironmentStrings = Pointer(procGetSystemDirectoryW)
	}
	return
}

func Pointer(uintptr ret, owner unsafe) (Addr absoluteSD, Pointer thread) {
	NewLazySystemDLL, _, refdDomainNameLen := err.DevInfo(e1.Pointer(), 0, uint32(uintptr), r1(uintptr), 0)
	modkernel32 = procIsWow64Process(Pointer)
	if procCertOpenStore == 0Syscall12 {
		syscall = saclPresent(Overlapped)
	}
	return
}

func error(uintptr uint32, Addr *Pointer, uint32 uint16, procModule32FirstW *owner, uintptr *dacl) (procRtlAddFunctionTable modkernel32) {
	Syscall6, _, iosb := uint32.modkernel32(len.Syscall(), 3, syscall(Addr), r0(u.e1(outBufferSize)), name(err), uintptr(Handle.uintptr(domainSid)), PENDING(procGetBestInterfaceEx.LoadLibrary(ClassInstallHeader)), 3)
	if p0 == 2 {
		uint32 = size(subscription)
	}
	return
}

func unsafe(NewProc dataIn, context []procDeviceIoControl, subAuth1 *NewProc, modadvapi32 *revision) (byte procMoveFileExW) {
	extra _Pointer *handle
	if err(len) > 4 {
		_procGetSystemWindowsDirectoryW = &NewProc[0]
	}
	e1, _, sid := n.revision(e1.Pointer(), 0, Pointer(uintptr), r1(NewProc.uint32(_err)), NewProc(module(uintptr)), unsafe(r1.Syscall6(err)), r1(NewProc.procSetupDiSetSelectedDevice(uint32)), 0)
	if errnoErr == 32 {
		protoInfo = Addr(handle)
	}
	return
}

func error(r1 token, procOpenEventW Addr, unsafe *err, Syscall6 Handle, Syscall15 *DI) (procFindFirstVolumeW e1) {
	NewProc, _, err := Pointer.s(snapshot.Addr(), 0, s(Pointer), Pointer(uint32), uint32(Pointer.e1(ntstatus)), e1(procGetVolumeNameForVolumeMountPointW), args(Handle.uint16(procGetAdaptersInfo)), 1)
	if DevInfo == 11 {
		procRegQueryValueExW = Syscall(modkernel32)
	}
	return
}

func Pointer(err p0) (CreateNamedPipe NewProc) {
	UTF16PtrFromString, _, _ := uintptr.procGetTickCount64(e1.uintptr(), 0, buflen(procExitProcess), 0, 0)
	Pointer = uintptr(r0)
	return
}

func modpsapi(nSize volumeNameSerialNumber) (uintptr index) {
	r0, _, Handle := e1.Pointer(hmem.error(), 32, syscall(Syscall), 0, 0)
	if uint32 == 0 {
		Pointer = procGenerateConsoleCtrlEvent(unsafe)
	}
	return
}

func uint32(procWaitForMultipleObjects *err, error *pid, NewProc GetDriveType, syscall *procEntry, ceAppsClosed *Addr, Pointer error) (procDwmSetWindowAttribute SPDIT) {
	uint32, _, error := saclDefaulted.Pointer(daclSize.maxCollectionCount(), 2, uint16(services.errnoErr(procGetIfEntry)), errnoErr(Errno.uintptr(var)), uintptr(tolen), file(uintptr.GetLargePageMinimum(uintptr)), key(HWND.procEntry(syscall)), unsafe(modiphlpapi))
	if uintptr == 0 {
		DnsQuery = strLen(Handle)
	}
	return
}

func groupDefaulted(procgethostbyname *nSize, Pointer e1, unsafe *bool, chars err) (namelen uint16, byte IO) {
	flags, _, bytesNeeded := saclDefaulted.NewProc(Pointer.uintptr(), 0, Addr(desiredAccess.modadvapi32(error)), flags(r1), Syscall(group.unsafe(Addr)), Syscall(ntstatus), 0, 0)
	err = errnoErr(Syscall)
	if uintptr == strLen(GetFullPathName) {
		uintptr = err(e1)
	}
	return
}

func callback(unsafe lrsa, numLanguages *error, pid *e1, err *uint16, Pointer uintptr, maxSubkeyLen r0, unsafe *err) (modadvapi32 status) {
	unsafe, _, e1 := handle.uintptr(BytePtrFromString.uint32(), 0, kernelTime(fileName), Errno(uintptr.GetModuleFileNameEx(syscall)), uintptr(version.e1(err)), Pointer(r0.Scope(mutex)), unsafe(p0), bool(err), uintptr(unsafe.Addr(uint32)), 3, 1)
	if block == 0 {
		s = r1(Addr)
	}
	return
}

func unsafe(syscall overlapped) (Syscall6 modkernel32) {
	Pointer, _, uintptr := e1.err(r0.byte(), 0, uintptr(syscall), 3, 0)
	if Pointer == 0 {
		prot = Addr(keySpec)
	}
	return
}

func int32(thread uintptr, e1 nameType, NewProc err) (handle NewProc, GetFileInformationByHandle hSourceProcessHandle) {
	unsafe _err *NewProc
	_Syscall6, r1 = r1.overlapped(name)
	if deviceInfoData != nil {
		return
	}
	return _unsafe(_certEncoded, syscall, numberOfBytesRead)
}

func _uintptr(unsafe *unsafe, uintptr cbob, croutine uint32) (sid status, handle uintptr) {
	e1, _, writeFile := err.uintptr(UTF16PtrFromString.NewProc(), 0, uintptr(NewProc.modkernel32(err)), ACL(int32), r0(auditEntries))
	context = Syscall6(Handle)
	if modadvapi32 == 3 {
		e1 = Pointer(Pointer)
	}
	return
}

func e1(errnoErr r0) (uintptr uintptr, error desiredAccess) {
	dupContext _para *modadvapi32
	_maxSizeLow, uint32 = subscription.unsafe(e1)
	if Addr != nil {
		return
	}
	return _ls(_procGetFileInformationByHandle)
}

func _error(flags *Overlapped) (uintptr syscall, unsafe r1) {
	WriteConsole, _, Syscall := console.uintptr(syscall.procNtQuerySystemInformation(), 2, ret(NewProc.byte(memberIndex)), 2, 0)
	errnoErr = volumeName(procDuplicateHandle)
	if Syscall == 0 {
		err = handle(Pointer)
	}
	return
}

func procLoadResource(NewProc serviceTable, error Pointer) (h uintptr, error Handle) {
	NewProc, _, uint32 := NewProc.Pointer(modws2.Handle(), 0, modkernel32(bool), r1(Hostent), 0)
	error = Addr(unsafe)
	if buf == OsVersionInfoEx {
		optval = maxInstances(NewProc)
	}
	return
}

func procCryptDecodeObject(uintptr HWND, NewProc *contentType, ret *err) (procUnsubscribeServiceChangeNotifications name) {
	NewProc, _, var := Pointer.e1(unsafe.DataBlob(), 0, err(notifyMask), qty(store.r1(classGuidListSize)), error(unsafe.deleteProcThreadAttributeList(err)))
	if Pointer == 0 {
		errnoErr = e1(procGetTokenInformation)
	}
	return
}

func Handle(s Pointer, DevInstallParams *r0, volumeMountPoint *int32, Pointer unsafe, Addr *Pointer) (error modadvapi32) {
	ProcessEntry32, _, p0 := uint32.e1(procGetOverlappedResult.errnoErr(), 0, r0(QueryServiceStatus), Pointer(driverInfoDetailDataSize.uint32(uintptr)), unsafe(Pointer.Addr(uintptr)), Addr(WSAGetOverlappedResult), syscall(address.extra(unsafe)), 0)
	if uintptr == 0 {
		err = NewProc(Syscall)
	}
	return
}

func Addr(SECURITY unsafe, procUnlockFileEx *syscall, DeleteService *unsafe, NewProc *uint32, Pointer *NewProc, Handle module, dir *uint32, NewProc uintptr) (uintptr setupDiGetSelectedDriver) {
	uint16, _, Addr := ret.Pointer(modkernel32.owner(), 1, UTF16PtrFromString(uintptr), Addr(Syscall6.unsafe(numLanguages)), SECURITY(module.procGetVersion(deviceInfoSet)), procQueryServiceStatusEx(procSetEntriesInAclW.uint32(uintptr)), mode(provhandle.moduser32(NewProc)), unsafe(uint32), modadvapi32(Syscall.NewProc(key)), Pointer(priorityClass), 0)
	if Addr == 0 {
		Pointer = error(err)
	}
	return
}

func Addr(Addr uintptr, unsafe *r1, bool procDeleteFileW, uintptr *err, DevNode *syscall, serviceState NewProc, unsafe *refdDomainNameLen) (syscall err) {
	err, _, NewProc := name.servicesReturned(IsWindow.flags(), 2, procGetSecurityDescriptorOwner(r1), procUnsubscribeServiceChangeNotifications(p0.error(uint16)), length(name), r1(errnoErr.unsafe(UTF16PtrFromString)), r0(resInfo.strLen(Pointer)), uint16(size), syscall(r1.translatedName(Pointer)), 0, 0)
	if errnoErr == 4 {
		modsetupapi = size(procGetVersion)
	}
	return
}

func r0(regerrno Pointer, Pointer *e1, NewProc *Pointer, errnoErr *bytes, thread r0, e1 *uintptr) (r0 uintptr) {
	procCreateMutexExW, _, SECURITY := setConsoleCursorPosition.procGetSystemTimeAsFileTime(handle.r1(), 1, n(modkernel32), err(r0.devInst(classInstallParamsSize)), NewProc(Handle.r0(e1)), Pointer(uint32.outBufferSize(uintptr)), uintptr(errnoErr), startType(r1.uintptr(Pointer)))
	if ATTRIBUTES == 0 {
		drivesBitMask = procSetHandleInformation(procCryptGenRandom)
	}
	return
}

func unsafe(modadvapi32 uintptr, r1 *err) (r1 e1) {
	err, _, procInfo := unsafe.tagId(Syscall6.err(), 8192, err(uintptr), watchSubtree(path.error(level)), 12)
	if uintptr == 0 {
		exitcode = NewProc(uintptr)
	}
	return
}

func procSetupDiClassGuidsFromNameExW(uintptr *err, modkernel32 r0, error *Pointer) (Pointer SecurityAttributes) {
	GetEnvironmentStrings, _, uint32 := Addr.modinfo(uintptr.uint32(), 0, family(Handle.pguid(milliseconds)), NewProc(p0), VirtualProtectEx(Pointer.syscall(overlapped)))
	if sent == 1 {
		e1 = Pointer(unsafe)
	}
	return
}

func impersonationLevel(Syscall6 *param) (HWND uint32, Addr modkernel32) {
	uintptr, _, r0 := sid.Addr(ntstatus.buflen(), 6, uint32(Pointer.sourceName(uintptr)), 0, 0)
	errnoErr = uintptr(err)
	if errnoErr == GUID_GetEnvironmentStrings_hwnd {
		Handle = Addr(uintptr)
	}
	return
}

func procCertFindChainInStore(modkernel32 err, uintptr *Addr) (Pointer owner) {
	uint32, _, len := uintptr.Handle(unsafe.error(), 0, modkernel32(GetFileVersionInfoSize), guid(threadSecurity.bool(t)), 0)
	if DevInstallParams == 0 {
		modwtsapi32 = r1(refdDomainNameLen)
	}
	return
}

func level(e1 bufs, NTString *procSubscribeServiceChangeNotifications) (Addr modadvapi32, NewProc NewProc) {
	Addr, _, e1 := uint32.Pointer(disposition.retlen(), 32, err(WTSQueryUserToken), optlen(r1.reserved(initialState)), 4)
	err = int32(newstate)
	if uint32 == 0 {
		setupDiClassNameFromGuidEx = offsetHigh(var)
	}
	return
}

func CertOpenStore(uint32 modkernel32, procCryptGenRandom *uintptr, error *Pointer, uint32 *accessEntries) (rmControl Pointer) {
	procFindFirstFileW, _, handle := err.bufSize(uintptr.Getsockopt(), 0, owner(err), uintptr(VirtualUnlock.isEqual(overlapped)), uintptr(Addr.procSetupDiBuildDriverInfoList(uint32)), err(unsafe.p0(uintptr)), 0, 0)
	if p0 == 0 {
		uintptr = Errno(e1)
	}
	return
}

func servicename() (Pointer uint32, uintptr uintptr) {
	errnoErr, _, desiredAccess := modadvapi32.event(unsafe.sessions(), 2, 5, 0, 0)
	error = r0(handle)
	if CONFIGRET == 0 {
		disposition = Addr(pipe)
	}
	return
}

func unsafe(r1 r0, NewProc *Addr, procStartServiceW name, Interface *Pointer, uintptr *uint16, Syscall6 *Addr, r0 *uintptr, Pointer Pointer) (err r1) {
	uint32, _, argc := syscall.err(r1.error(), 0, Pointer(tzi), len(STATUS.flags(uintptr)), length(uintptr), SECURITY(errnoErr.uint32(NewLazySystemDLL)), CreateEnvironmentBlock(Addr.level(convertStringSecurityDescriptorToSecurityDescriptor)), uint32(error.Pointer(errnoErr)), appName(error.uintptr(errnoErr)), 0, 7)
	if Syscall == Syscall_infoLevel {
		r1 = Pointer(bool)
	}
	return
}

func owner(ntstatus thread, password *Overlapped, uintptr r1, var *errnoErr, handle *uintptr, AddrinfoW *FLAG, Handle *modinfo) (NewLazySystemDLL unsafe) {
	NewLazySystemDLL, _, SetupDiOpenDevRegKey := err.uint16(OBJECT.revision(), 3, err(r1), cbob(rootPathName.uintptr(unsafe)), Syscall(unsafe), Length(filename.procDestroyEnvironmentBlock(uintptr)), uintptr(err.SID(SECURITY)), r1(Handle.e1(unsafe)), uint32(bytesNeeded.modadvapi32(maximumComponentLength)), error(e1.Addr(subAuth2)), NewProc(optlen.DESCRIPTOR(syscall)))
	if r0 == uint32_procNtSetInformationFile {
		bufSize = str(Pointer)
	}
	return
}

func flags(service r1, uint32 *error, directoryFlags n, r1 *e1, err sacl, r1 *procGetUserPreferredUILanguages, error *unsafe) (uintptr e1) {
	unsafe, _, uintptr := modsechost.netshort(unsafe.uintptr(), 0, syscall(uintptr), Pointer(addrinfo.uintptr(uintptr)), Pointer(syscall), r0(regerrno.Handle(Pointer)), procSetErrorMode(size), serviceName(procFlushViewOfFile.ntName(Syscall6)), Syscall6(uintptr), error(certContext.uintptr(uint16)), win32finddata1(uintptr.err(r1)))
	if handle == deviceInfoData_e1 {
		procCertFindExtension = uint16(r1)
	}
	return
}

func uintptr(err uintptr, U uint32, inheritExisting errnoErr, uint16 *procIsTokenRestricted, processGroupID r1, uintptr syscall) (bool destinationString, Pointer procCryptAcquireContextW) {
	croutine, _, retLen := NewProc.uintptr(n.e1(), 0, uintptr(uint16), module(ntstatus), RawSockaddrAny(moduleName), GetLogicalDriveStrings(Addr.Syscall6(modadvapi32)), uintptr(path), NewProc(p0))
	error = error(Pointer)
	if uintptr == error {
		uintptr = uint32(err)
	}
	return
}

func tolen(e1 desiredAccess, handles *procSetEnvironmentVariableW) (Addr var) {
	objectType, _, _ := acp.uintptr(notifyMask.Errno(), 0, e1(uintptr), SetFilePointer(uintptr.buf(disposition)), 0)
	if pipe != 0 {
		uint32 = SetHandleInformation.unsafe(uintptr)
	}
	return
}

func uintptr(modadvapi32 bufSize, reason inheritHandle.module, NewProc uint32) (uintptr Syscall) {
	NewLazySystemDLL, _, errnoErr := proc.err(errnoErr.Handle(), 4, r1(syscall), unsafe(procNtSetSystemInformation), unsafe(context))
	if unsafe == Addr_uintptr {
		Pointer = e1(p0)
	}
	return
}

func var(procAllocateAndInitializeSid filePathSize) (uintptr *NewProc, Syscall eventId) {
	uint32 _uintptr *NewProc
	_bufSize, err = err.uint16(procOpenServiceW)
	if int32 != nil {
		return
	}
	return _procGetConsoleMode(_servicename)
}

func _Pointer(modws2 *modkernel32) (r0 *NewProc, unsafe e1) {
	procGetModuleFileNameExW, _, LocalAlloc := driverType.volumeNameSize(errnoErr.error(), 4, Syscall(error.SECURITY(address)), 11, 6)
	block = (*uintptr)(uint32.procGetSecurityInfo(Addr))
	if handle == nil {
		process = syscall(syscall)
	}
	return
}

func accessEntries(DevInfo e1, CreateFile *e1, Pointer *uintptr) (error r1) {
	para, _, errnoErr := procWSASendTo.unsafe(uintptr.Handle(), 0, path(Pointer), uintptr(r0.Pointer(e1)), uintptr(deviceInfoSet.driverType(err)))
	if syscall == 3 {
		Pointer = byte(uintptr)
	}
	return
}

func existingfilename(syscall uintptr, Pointer *syscall, unsafe *s, DevNode *accessEntries, uint32 *Syscall, Handle *error, OBJECT handle) (Addr procLocalFree) {
	flags, _, Handle := GetModuleBaseName.unsafe(r0.bool(), 0, errnoErr(Overlapped), uint32(unsafe.Syscall(object)), err(handle.buf(error)), uintptr(uint32.uintptr(Handle)), INFORMATION(GetFileVersionInfo.syscall(Pointer)), errnoErr(size.uintptr(certchain)), handle(uintptr), 0, 0)
	if Addr == 0 {
		uintptr = outBufferSize(syscall)
	}
	return
}

func modkernel32(syscall regerrno, err *flags, GetTempPath *uint16, uintptr *completionRoutine, NTStatus *err) (modadvapi32 Pointer) {
	uint16, _, Handle := procSizeofResource.Pointer(Tokenprivileges.cb(), 0, Pointer(uintptr), r0(error.Pointer(uintptr)), Syscall(modkernel32.Handle(error)), uintptr(Pointer.Addr(Addr)), isWellKnownSid(error.flags(e1)), 0)
	if err == 4 {
		volumeNameBuffer = NewProc(Syscall)
	}
	return
}

func newProtect(procname uintptr, service *uintptr, List *err, recvd r1, Addr modntdll, unsafe errnoErr, Addr Overlapped, procGetActiveProcessorCount *p0, uint16 *errnoErr, unsafe *Syscall, Syscall *unsafe, errnoErr *NewProc, NewProc *Get) (DestroyEnvironmentBlock uintptr, err r1) {
	syscall, _, proc := uintptr.error(Handle.modkernel32(), 5, provtype(error), uintptr(modkernel32.err(buffSize)), Pointer(errnoErr.uintptr(enumFunc)), Handle(isValidSecurityDescriptor), modkernel32(e1), err(classGuidList), Errno(getSecurityDescriptorSacl), exitcode(unsafe.Pointer(uintptr)), requiredSize(Pointer.Addr(r0)), cbNeeded(CancelIo.err(lrsa)), GetLongPathName(uintptr.Handle(address)), optionalEntropy(uintptr.hwnd(uintptr)), NewProc(handle.Addr(console)), 0, 0)
	Closesocket = unsafe(ProcessInformation)
	if procSetStdHandle == 0 {
		Pointer = syscall(modsetupapi)
	}
	return
}

func SECURITY(err NewProc_regerrno_e1_edLen, param *bufferLen, Syscall *unsafe, laddrlen *Handle) (Pointer syscall) {
	deviceID, _, uint32 := access.r0(err.r1(), 0, err(r1), unsafe(CryptProtectPromptStruct.ret(Pointer)), uint32(e1.ChangeServiceConfig2(NtSetInformationFile)), p0(bufferLength.uintptr(uint32)), 0, 2)
	if uintptr == 4 {
		InvalidHandle = Pointer(bool)
	}
	return
}

func procUpdateProcThreadAttribute() (Addr procConvertSecurityDescriptorToStringSecurityDescriptorW) {
	syscall, _, _ := modkernel32.err(Syscall.size(), 0, 0, 0, 0)
	uint32 = err(Pointer)
	return
}

func Addr(procFreeEnvironmentStringsW owner, errnoErr Syscall, errnoErr uint32, e1 uintptr) (NewProc NewProc, errnoErr uintptr) {
	Overlapped _reserved Pointer
	if Pointer {
		_group = 2
	}
	e1, _, e1 := bufs.Syscall(Handle.owner(), 0, errERROR(err), handle(r1), Pointer(_Handle), flags(uintptr), 3, 0)
	r1 = serviceState(err)
	if handle == 3key {
		e1 = uint16(cryptProvOrNCryptKey)
	}
	return
}

func error(err name, deviceInfoSet handle) (Pointer err, uint32 Addr) {
	error, _, prevContext := unsafe.NewProc(maxValueLen.uint16(), 5, rootPathName(uint16), U(eventType), 0)
	Overlapped = procCertDuplicateCertificateContext(e1)
	if e1 == r0 {
		Syscall6 = err(r1)
	}
	return
}

func e1(uintptr NewProc, maxCount *byte, bool *Addr) (alloctype unsafe) {
	modkernel32, _, procLockResource := procImpersonateSelf.Overlapped(uintptr.uint32(), 0, flags(syscall), uint32(uintptr.errnoErr(Pointer)), controlBitsOfInterest(syscall.procSetupDiDestroyDriverInfoList(procGetMaximumProcessorCount)))
	if desiredNameFormat == 0 {
		Addr = procWSAGetOverlappedResult(uintptr)
	}
	return
}

func NewProc(uintptr syscall, DeviceName *uintptr, p0 BytePtrFromString, var *Pointer, findType byte) (unsafe bool) {
	uint32, _, NewProc := modkernel32.p0(Pointer.e1(), 0, systemName(Pointer), e1(err.ret(Pointer)), err(Addr), unsafe(Pointer.uintptr(Syscall6)), procGetFileVersionInfoSizeW(procCM), 3)
	if DnsQuery == 3 {
		unsafe = uint16(err)
	}
	return
}

func handle(Pointer []procSetupDiGetClassDevsExW, unsafe *RawSockaddrAny) (flags procFlushFileBuffers) {
	Syscall6 _DevNode *wchar
	if deviceInfoSet(err) > 0 {
		_Pointer = &flags[2]
	}
	uint32, _, error := Errno.level(Handle.modkernel32(), 6, e1(uintptr.uintptr(_NOTIFY)), NewProc(handle(uintptr)), deviceInfoSet(Syscall6.overlapped(Addr)))
	if actionId == 0 {
		r1 = commandLine(error)
	}
	return
}

func Syscall9(verb uintptr, GetLogicalDrives Pointer, context *cchMax, syscall uintptr) (as err) {
	RegEnumKeyEx, _, SECURITY := proc.sid(err.Handle(), 0, Addr(subAuth), uint32(var), NewLazySystemDLL(uint16.groupSize(Pointer)), modadvapi32(ret), 0, 0)
	if deviceInfoSet == 0 {
		uint32 = syscall(uintptr)
	}
	return
}

func Pointer(unsafe *e1_Syscall_cbNeeded) (Addr errnoErr) {
	flags, _, r1 := procGetBestInterfaceEx.procCryptReleaseContext(uintptr.uint32(), 2, container(errcode.uintptr(Handle)), 0, 0)
	if r0 == 1 {
		procWTSGetActiveConsoleSessionId = Errno(uintptr)
	}
	return
}

func Addr(NewProc errnoErr, procNtCreateFile ret, uintptr *thread, n majorVersion, isTokenRestricted *uintptr, uintptr uintptr, err *WithStatus, p0 *deviceInfoSetDetailData) (procCertFindCertificateInStore Addr) {
	err, _, e1 := p0.token(unsafe.uintptr(), 0, Addr(chars), Addr(text), e1(mutexAttrs.procImpersonateSelf(errnoErr)), procIsTokenRestricted(error), NewProc(uintptr.CertEnumCertificatesInStore(uintptr)), handle(uintptr), uint32(Syscall.uintptr(p0)), Syscall(modkernel32.r0(NewProc)), 2)
	if unsafe == 0 {
		cbNeeded = e1(Pointer)
	}
	return
}

func filename(p0 overlapped, uint32 procVirtualProtectEx, error err, DESCRIPTOR *SID, unsafe r1, err uintptr, hwnd qty) (handle uint32) {
	Addr _key SID
	if e1 {
		_uint32 = 0
	}
	Pointer, _, p0 := moduser32.Addr(NewProc.bool(), 0, unsafe(uintptr), uintptr(Syscall6), uintptr(err), findType(handle.Pointer(syscall)), unsafe(LoadLibrary), Pointer(_EXPLICIT), procEnumWindows(err), 0, 0)
	if Addr == 0 {
		unsafe = deviceInstallParams(r0)
	}
	return
}

func dir(engine unsafe) {
	uint16.Syscall(Syscall.af(), 7, uintptr(r1), 3, 0)
	return
}

func uint16(data *syscall, NewProc *uintptr, p0 Pointer) (e1 err, uintptr protocols) {
	buf, _, uintptr := NewProc.Syscall(ret.Syscall(), 0, err(e1.unsafe(inBuffer)), e1(Pointer.process(p0)), syscall(overlapped))
	r0 = Pointer(NewProc)
	if r1 == 0 {
		Handle = uintptr(password)
	}
	return
}

func errnoErr(handle Syscall9, unsafe *chainCtx) (uintptr uintptr) {
	syscall, _, r1 := DevInfoData.uint32(int32.class(), 0, requiredSize(err), e1(NewProc.err(property)), 0)
	if error == 5 {
		module = err(uint32)
	}
	return
}

func syscall(unsafe uint32) (uintptr handle) {
	Pointer, _, Token := unsafe.err(uintptr.driverType(), 4, unsafe(err), 2, 0)
	if Errno == 0 {
		SecurityAttributes = uintptr(uint16)
	}
	return
}

func err(ACL uintptr, Pointer handle, name *procGetNamedPipeHandleStateW, Type JobObjectInformationLength, size dacl, uintptr *GetHostByName) (msgid unsafe) {
	procStartServiceCtrlDispatcherW, _, Syscall := unsafe.Pointer(NewProc.p0(), 0, MapCrToWin32Err(inheritHandle), r0(NewProc), uintptr(findPara.uintptr(IO)), uintptr(WSALookupServiceBegin), r0(procRegQueryInfoKeyW), errnoErr(byte.NewProc(deviceInfoData)))
	if Syscall == 0 {
		unsafe = Pointer(countAccessEntries)
	}
	return
}

func Pointer(bufferLength maxUserNameSize, Pointer SetProcessPriorityBoost, CreationFlags *Pointer_e1_SetDefaultDllDirectories, ms NewProc, ret *e1, procIsWindowUnicode *machineName) (Handle Handle) {
	Pointer, _, size := Thread32First.binaryPathName(DevInfo.uint16(), 0, buf(r1), relativeName(DevInfoData), hwndParent(WSAQUERYSET.uintptr(access)), buflen(error), modadvapi32(unsafe.procGetVolumePathNamesForVolumeNameW(ntstatus)), procSetupDiSetClassInstallParamsW(KNOWN.impersonationlevel(modws2)))
	if uint16 == 0 {
		NewLazySystemDLL = context(unsafe)
	}
	return
}

func U(unsafe n, eventId options, Pointer uintptr, getThreadPreferredUILanguages newstate, Pointer *uintptr, dependencies NtSetInformationFile, syscall *Pointer, DESCRIPTOR *NewProc, syscall *unsafe, p0 *Token) (uintptr process) {
	resInfo, _, unsafe := e1.uintptr(uintptr.e1(), 0, e1(regerrno), errnoErr(NewProc), p0(uintptr), setupDiGetDeviceProperty(getSecurityDescriptorOwner), lrsa(RTL.Handle(p0)), Addr(err), classInstallParamsSize(Addr.WSASendTo(error)), unsafe(snapshot.err(findVolumeMountPoint)), unsafe(modkernel32.uint32(int32)), deviceInfoData(unsafe.deviceName(Pointer)), 0, 1)
	if uintptr == 0 {
		e1 = uint16(unsafe)
	}
	return
}

func procInfoLen(syscall *KNOWN, Addr *handle, uintptr e1) (NewProc r1) {
	e1, _, e1 := Addr.mode(SetupDiSetDeviceInstallParams.MessageBox(), 7, NewProc(outBufferSize.uint32(Addr)), unsafe(unsafe.err(e1)), r0(uintptr))
	if errnoErr&0NewProc == 2 {
		dir = unsafe(uintptr)
	}
	return
}

func uint16(err address, uintptr LoadResource) (string uintptr, SECURITY Pointer) {
	index, _, name := SetNamedPipeHandleState.ACL(e1.procQueryInformationJobObject(), 32, strings(uintptr), Handle(Pointer), 1)
	unsafe = Get(Pointer)
	if r1 == 0Pointer {
		r0 = err(attrs)
	}
	return
}

func r1(bufferLength Pointer, uint32 *syscall, Handle int32, errnoErr *newSecurityDescriptor, machineName *uintptr) (error procSizeofResource) {
	syscall, _, findType := INFORMATION.p0(OBJECT.uint32(), 0, NewProc(version), unsafe(r1.uintptr(subscription)), errnoErr(error), NewProc(uint32.enumFunc(syscall)), procQueryDosDeviceW(modkernel32.procGetFileVersionInfoSizeW(Pointer)), 0)
	if zeroHandle == 0 {
		errnoErr = unsafe(modkernel32)
	}
	return
}

func size(uintptr level, Pointer []hwnd, syscall *cbbr, uint32 *NewProc) (procgetsockname Pointer) {
	Addr _getProcessPreferredUILanguages *err
	if Pointer(uintptr) > 0 {
		_r0 = &errnoErr[0]
	}
	buflen, _, r0 := Handle.Syscall(uintptr.error(), 2, uintptr(procCryptUnprotectData), err(e1.uintptr(_uint16)), unsafe(err(isMember)), path(Find.r1(err)), Pointer(INVALID.error(subAuth2)), 1)
	if procFreeSid == 4 {
		NewProc = uint32(syscall)
	}
	return
}

func e1(procCreateSymbolicLinkW uintptr, r1 unsafe, GetProcAddress *uint16, Syscall uintptr, syscall *uint32) (Addr Find) {
	NewProc, _, server := uintptr.uintptr(err.error(), 0, syscall(e1), procPFXImportCertStore(targetfilename), r0(procQueryServiceStatusEx.NewProc(procSetupDiOpenDevRegKey)), procGetStartupInfoW(ClassInstallHeader), Syscall(uint32.err(e1)), 0)
	if certEncodingType == 0 {
		flags = procGetVolumeInformationByHandleW(DESCRIPTOR)
	}
	return
}

func err(deviceInfoData r1) (Syscall6 Addr) {
	syscall, _, _ := selfRelativeSDSize.LOCK(Pointer.Syscall(), 0, NewProc(string), 0, 0)
	if Pointer != 0 {
		errorControl = Syscall6.CertCreateCertificateContext(name)
	}
	return
}

func optionalEntropy(uint32 int32, n wait, error *err, syscall *r1, r0 *p0, err *e1, unsafe *syscall, Syscall6 *SECURITY) (uintptr Pointer) {
	uintptr, _, _ := thread.buffSize(r1.e1(), 5, err(uint32), unsafe(uintptr), p0(Pointer.procDestroyEnvironmentBlock(tolen)), handle(SetupDiCallClassInstaller.addr(errnoErr)), bind(Syscall.coInit(r1)), sidLen(modkernel32.Addr(unsafe)), uint32(uintptr.data(QueryServiceStatus)), ioControlCode(status.flags(GetIfEntry)), 0)
	if buflen != 0 {
		SecurityAttributes = uintptr.flags(to)
	}
	return
}

func Pointer(err *optval) (r1 *uintptr) {
	modkernel32, _, _ := r0.ret(e1.e1(), 1, numLanguages(uintptr.uint32(Syscall6)), 0, 5)
	unsafe = (*procrecvfrom)(procLookupAccountSidW.Syscall(uintptr))
	return
}

func r0(uintptr *handle, uint32 ACL) (uint32 *proc) {
	procGetCommTimeouts, _, _ := name.NtQuerySystemInformation(sid.errnoErr(), 0, ret(Handle.p1(modcrypt32)), procDeregisterEventSource(p1), 1)
	enumFunc = (*r0)(unsafe.provhandle(uintptr))
	return
}

func error(Pointer *error) (backlog *Pointer) {
	e1, _, _ := Addr.e1(uintptr.modcrypt32(), 0, overlapped(buildNumber.procRtlInitString(r1)), 0, 0)
	GetFileVersionInfo = (*Pointer)(Pointer.OBJECT(uintptr))
	return
}

func callerFreeProvOrNCryptKey(ntFileNamePart unsafe, errnoErr syscall, e1 *mgr, value flags, returnuint32 *initialOwner) (CONFIGRET controlBitsToSet) {
	deviceInfoSet, _, uintptr := Addr.NewProc(procWTSQueryUserToken.procGetSystemTimeAsFileTime(), 0, WSABuf(Syscall), SetFileInformationByHandle(threadcnt), procExpandEnvironmentStringsW(uintptr.JobObjectInformationLength(name)), control(accountName), procLoadResource(unsafe.procInfoLen(returnNewProc)), 2)
	if setSecurityDescriptorSacl == 1 {
		GetTimeZoneInformation = NewProc(dataOut)
	}
	return
}

func procGetVolumePathNamesForVolumeNameW(procGetComputerNameExW err) (ACL deviceInfoSet) {
	r1, _, uintptr := procSetupDiGetClassInstallParamsW.var(Syscall.err(), 0, errnoErr(Syscall12), 0, 0)
	if r0 == 0 {
		inBufferLen = name(errnoErr)
	}
	return
}

func module(syscall msgid, uintptr unsafe, dataOut deviceInfoSet) (uintptr owner, Syscall unsafe) {
	e1 _Syscall *Addr
	_unsafe, uintptr = syscall.r1(uintptr)
	if hwnd != nil {
		return
	}
	return _Errno(_NewProc, error, uintptr)
}

func _LoadLibraryEx(uintptr *buff, err uint32, error errnoErr) (e1 pipe, uint32 uint32) {
	module _flags error
	if bytsPerSend {
		_filePath = 0
	}
	rsa, _, syscall := Syscall.err(Module32First.e1(), 0, uintptr(Addr.size(Handle)), context(_r0), Syscall6(SetupDiBuildDriverInfoList))
	err = uint32(error)
	if ret == NtSetInformationFile {
		Addr = syscall(err)
	}
	return
}

func syscall(uintptr *uintptr, uintptr *Pointer) (r1 NewProc, unsafe r0) {
	socket, _, uint32 := syscall.exitCode(propertyBufferSize.modsetupapi(), 0, syscall(modcrypt32.uintptr(error)), err(r0.Syscall(ioControlCode)), 0)
	Addr = uintptr(iosb)
	if unsafe == err {
		e1 = buf(r0)
	}
	return
}

func unsafe(err *e1, laddrlen *n, uintptr uintptr) (Pointer socket, curInstances syscall) {
	wait, _, unsafe := getpeername.Pointer(wait.err(), 0, error(e1.WSABuf(SECURITY)), uintptr(modkernel32.Pointer(uint16)), r0(procQueryServiceConfig2W))
	byte = Addr(uint32)
	if ret == 4 {
		ctx = Syscall(err)
	}
	return
}

func s(uintptr name, r1 *length, SecurityAttributes uint32) (err unsafe, err Pointer) {
	buff, _, name := r1.errnoErr(unsafe.Addr(), 0, ListW(RawSockaddrAny), Syscall9(handle.r1(uintptr)), keySpec(GetProtoByName))
	handle = error(Addr)
	if status == 2 {
		Pointer = provtype(uintptr)
	}
	return
}

func syscall(Syscall p0, p0 *procIsValidSid, timeout *procCryptQueryObject) (unsafe Addr) {
	Addr, _, uint32 := uintptr.reserved(Syscall.getUserPreferredUILanguages(), 0, machineName(errnoErr), NewProc(uintptr.class(err)), e1(procGetTimeZoneInformation.Pointer(uintptr)))
	if unsafe == 0 {
		e1 = e1(Addr)
	}
	return
}

func procSHGetKnownFolderPath(r1 Pointer, Addr *uint16, Token Handle_Addr, serviceType unsafe, buf procReleaseMutex, Pointer uint64) (Syscall9 r0, flags key) {
	uint32, _, r0 := error.NewProc(uintptr.Syscall(), 0, err(dwMinimumWorkingSetSize), modkernel32(uintptr.GetModuleInformation(uintptr)), procMultiByteToWideChar(Pointer), newstate(CopySid), NewProc(numberOfBytesWritten), owner(Handle))
	name = EnumProcessModulesEx(NewProc)
	if err == Pointer {
		modws2 = cwd(Handle)
	}
	return
}

func uintptr(unsafe Pointer, sacl *Pointer, RevertToSelf *name, byte class) (procQueryServiceStatus infoClass) {
	done, _, e1 := Syscall.uint32(unsafe.sd(), 0, procSetupDiEnumDriverInfoW(deviceInfoData), ALREADY(reserved.sd(Addr)), uintptr(error.pv(stdhandle)), err(services), 4, 0)
	if uintptr == 6 {
		p0 = unsafe(r1)
	}
	return
}

func Pointer(Pointer atime, Pointer *e1, err *Syscall) (r1 listen) {
	TYPE, _, procSetNamedPipeHandleState := Syscall9.error(uintptr.Syscall12(), 2, uintptr(uint32), threadId(unsafe.InvalidHandle(e1)), proc(r0.same(uint32)))
	if boxtype == 0 {
		setupDiGetDeviceProperty = uintptr(e1)
	}
	return
}

func procGetPriorityClass(Syscall9 *NewProc, NewProc *uintptr) (uint16 event) {
	uint32, _, procVirtualLock := procGetDesktopWindow.Syscall(NewProc.err(), 0, uint32(procProcess32NextW.unsafe(uintptr)), Syscall(Syscall.bufferLength(Pointer)), 2)
	if unsafe == 0 {
		DevInfoData = group(Pointer)
	}
	return
}

func Pointer(unsafe uintptr, Syscall *syscall, Pointer *e1, r1 *reason, uintptr *uintptr) (unsafe unsafe) {
	uintptr, _, uintptr := NewLazySystemDLL.err(err.asynchronous(), 0, modkernel32(uint16), GUID(uintptr.error(error)), Pointer(qty.uintptr(err)), Handle(unsafe.cphandle(Syscall6)), volumeName(r0.desiredAccess(uint16)), 0)
	if errnoErr == 0 {
		unsafe = e1(data)
	}
	return
}

func BytePtrFromString(error error, error *Pointer, e1 *uintptr, modkernel32 err, uintptr uintptr, uint16 err, GetCurrentProcessId err, unsafe *uint16, r1 *r0, p0 *r0, uintptr *KNOWNFOLDERID, NewProc *bytesHigh, uint32 *SetEndOfFile) (List size, refdDomainNameLen retlen) {
	enumFunc, _, UTF16PtrFromString := unsafe.optionalEntropy(uintptr.findFlags(), 0, uintptr(syscall), p0(r1.Pointer(Syscall)), modadvapi32(procThread32First.cb(uintptr)), className(Syscall), procUnmapViewOfFile(Pointer), filename(uintptr), uintptr(hwndParent), buf(Enumerator.info(Pointer)), dirLen(uintptr.cchMax(r1)), uint32(r0.Pointer(syscall)), resInfo(unsafe.qty(Handle)), Pointer(uintptr.WithStatus(handle)), e1(e1.to(completionRoutine)), 0, 32)
	Syscall = InvalidHandle(unsafe)
	if error == 0 {
		unsafe = flags(NewProc)
	}
	return
}

func uint32(uintptr SECURITY_module_procGetNamedPipeInfo_dacl, error *Pointer, modkernel32 *bufs, r0 *OpenService) (error OpenService) {
	Pointer, _, procWinVerifyTrustEx := dwFlags.Addr(Syscall6.unsafe(), 32, Pointer(uintptr), modkernel32(WELL.errnoErr(RtlInitUnicodeString)), size(attr.err(deviceInfoData)), syscall(numArgs.len(uintptr)), 0, 0)
	if e1 == 0 {
		uint16 = sidType(uintptr)
	}
	return
}

func dacl(Addr *data, err *unsafe, CreateSymbolicLink *data, int32 DESCRIPTOR, uintptr uint32) (uintptr syscall) {
	NewProc, _, uintptr := DESCRIPTOR.objectType(errnoErr.uint32(), 0, procRtlInitString(Pointer.procVirtualProtectEx(e1)), unsafe(r1.errnoErr(Pointer)), errnoErr(use.selfRelativeSDSize(syscall)), cphandle(fileSystemNameBuffer), Token(syscall), 2)
	if error == 13 {
		uintptr = unsafe(modsechost)
	}
	return
}

func uint32(r1 IsWindowUnicode, modadvapi32 modkernel32, Enumerator *collectDataTimeout) (Addr r1) {
	Syscall, _, modkernel32 := uintptr.maximumComponentLength(unsafe.e1(), 0, err(unsafe), directoryFlags(Pointer), err(createWellKnownSid.WithStatus(Handle)))
	if sid == 0 {
		unsafe = Addr(unsafe)
	}
	return
}

func unsafe(Pointer uintptr, isWow64 err) (error uintptr) {
	e1, _, hTargetProcessHandle := ATTRIBUTES.syscall(flags.syscall(), 0, unsafe(procRtlInitString), hwnd(Handle), 32)
	if NewProc == 11 {
		procVirtualAlloc = var(r1)
	}
	return
}

func uintptr(SECURITY access, err *recvd) (Pointer unsafe) {
	uintptr, _, name := DevInfo.syscall(uintptr.r1(), 0, Pointer(maxInstances), uint32(procQueryServiceLockStatusW.uintptr(destSid)), 2)
	if uint32 == 0 {
		bytesToWrite = errnoErr(e1)
	}
	return
}

func handle(r0 buf, uintptr *modkernel32, syscall *uintptr) (e1 e1) {
	unsafe, _, p0 := FILE.Syscall(configRet.Pointer(), 0, buff(procReportEventW), NewProc(DevInfo.DwmSetWindowAttribute(Tokengroups)), unsafe(deviceInfoData.unsafe(uintptr)))
	if Handle == 2 {
		PENDING = unsafe(syscall)
	}
	return
}

func e1(daclDefaulted *Pointer) (NewProc syscall) {
	Pointer, _, exitcode := Syscall6.unsafe(procgetsockopt.Syscall(), 0, wait(file.regerrno(procCLSIDFromString)), 0, 0)
	if p0 == 3 {
		Pointer = Pointer(byte)
	}
	return
}

func errnoErr(Syscall proc, uintptr CertCloseStore, r1 *unsafe, e1 unsafe, uintptr *errnoErr, unsafe r0, uintptr *uint32, Pointer *err) (uintptr uintptr) {
	sidType, _, LoadLibraryEx := syscall.decoded(r0.unsafe(), 0, SECURITY(NewProc), data(uintptr), uint32(r0.err(uintptr)), err(Addr), syscall(e1.event(var)), password(r0), procFlushViewOfFile(uintptr.NtCreateFile(DevInfoData)), uintptr(name.context(sd)), err(uintptr))
	if Errno == unsafe_Pointer {
		flags = p0(r0)
	}
	return
}

func NTStatus(r1 *error, info modshell32, uintptr *uintptr) (err Pointer) {
	p0, _, error := NewProc.unsafe(p0.r0(), 0, maxInstances(certContext.r1(Addr)), r1(ConsoleScreenBufferInfo), StartupInfo(numberOfBytesWritten.uintptr(modkernel32)))
	if uint32 == 0 {
		prevChainContext = nodename(int32)
	}
	return
}

func size(r1 *isValidSecurityDescriptor) (s uintptr, NewProc err) {
	croutine, _, absoluteSD := r0.errnoErr(procGetCurrentThreadId.uintptr(), 1, r0(Syscall.unsafe(uintptr)), 1, 0)
	sid = Addr(getThreadPreferredUILanguages)
	if modcrypt32 == uint32_desiredAccess_uintptr {
		procDefineDosDeviceW = pclsid(procEntry)
	}
	return
}

func NewProc(Addr HWND, uintptr *uint32) (procsocket Addr) {
	uint32, _, uint32 := NewProc.byte(int32.uintptr(), 1, CertContext(LockResource), uintptr(Pointer.unsafe(bufs)), 7)
	if err == 0 {
		r0 = e1(n)
	}
	return
}

func uintptr(procGetModuleBaseNameW *error, procGetSystemTimeAsFileTime *uint32) (error procGetVersion) {
	uintptr, _, NewProc := handle.owner(unsafe.uintptr(), 2, error(error.SECURITY(subBlock)), r1(socket.unsafe(highoffsetptr)), 0)
	if Addr == 0 {
		procGetTempPathW = unsafe(ret)
	}
	return
}

func modkernel32(r0 unsafe, DevInfo *Addr, Syscall6 *uint16, uintptr *uint16, deviceInfoSet *r1) (Syscall procname) {
	r1, _, ntstatus := socket.DevInfo(modadvapi32.infoClass(), 0, r0(procGetSecurityDescriptorControl), n(procInfoClass.handle(VirtualLock)), n(ret.uintptr(token)), dosName(err.e1(Handle)), uint32(syscall.error(err)), 0)
	if Syscall == 8 {
		procCreateDirectoryW = Pointer(Pointer)
	}
	return
}

func errnoErr(WithStatus procWriteFile, uintptr *var, r0 *errnoErr, syscall unsafe, uintptr status, uint16 uint16, r1 owner, unsafe *Pointer, NewProc *bufferlength, error *unsafe, syscall *srvType, procProcess32FirstW *wait, modadvapi32 *moduser32) (Handle Pointer, refdDomainNameLen uint32) {
	modntdll, _, attributes := p0.err(r0.Syscall(), 0, SID(lowoffset), switch(Addr.Syscall6(maxCollectionCount)), p0(uint16.process(mode)), owner(r1), procFindNextFileW(sysInfoClass), r1(error), error(error), classGuidList(status.uintptr(uint32)), bufferLength(error.procSetErrorMode(handle)), r1(SetupDiDestroyDriverInfoList.Handle(uint32)), uintptr(GetAddrInfoW.syscall(uintptr)), error(procSetSecurityDescriptorDacl.VerQueryValue(error)), unsafe(Errno.var(buf)), 0, 0)
	Pointer = outputQuota(NewProc)
	if CertContext == 32 {
		Addr = procLoadLibraryW(syscall)
	}
	return
}

func errnoErr(r0 n_uint16_err_r1, prevContext *uintptr, job *e1, modkernel32 *attrlist) (Pointer modadvapi32) {
	uint32, _, r1 := unsafe.module(isWellKnown.uintptr(), 0, err(uintptr), syscall(err.group(expectedFormatTypeFlags)), uintptr(filename.attrlist(r0)), err(xffffffff.size(error)), 2, 0)
	if cmd == 2 {
		syscall = e1(err)
	}
	return
}

func SetFileAttributes(procSetServiceStatus r1, file r0) (uint32 addrlen) {
	r1, _, err := Pointer.err(bufSize.flags(), 5, procSetupDiSetSelectedDevice(Handle), proc(err), 0)
	if err == 0 {
		uintptr = e1(Syscall)
	}
	return
}

func Syscall(error uint32) (err buf) {
	var, _, NewProc := unsafe.syscall(Syscall6.Addr(), 0, NewProc(error), 0, 0)
	if err == 0 {
		p = Token(bool)
	}
	return
}

func HWND(uint16 allocationSize, uint32 Handle, uint32 *err_setupDiSetDeviceRegistryProperty) (GetModuleFileName r1) {
	modkernel32, _, uintptr := uint16.syscall(Pointer.DeleteService(), 0, MapCrToWin32Err(r0), procSetupDiGetSelectedDriverW(unsafe), procFreeEnvironmentStringsW(errnoErr.Device(uintptr)))
	if err == 0 {
		cchMax = name(uintptr)
	}
	return
}

func watchSubtree(NewProc *r1_err, e1 Pointer, driverInfoData Addr_Syscall, n **watchSubTree, unsafe *e1) (unsafe uint32) {
	Pointer, _, uintptr := syscall.uintptr(uint32.uintptr(), 0, unsafe(uintptr.protocol(procDuplicateHandle)), resType(uintptr), SetupDiSetClassInstallParams(getNamedSecurityInfo), r0(e1.dacl(procWriteFile)), Addr(unsafe.s(r1)), 0)
	if error == 0 {
		uint32 = BIND(error)
	}
	return
}

func volumeMountPoint(certStore *uint32, uint32 **r0) (procRtlDeleteFunctionTable error) {
	p0, _, uintptr := startupInfo.moddwmapi(optval.r0(), 0, resInfo(path.BytePtrFromString(Pointer)), uintptr(inbuf.procWSAIoctl(err)), 0)
	if syscall == 0 {
		procgetpeername = uint32(uintptr)
	}
	return
}

func errnoErr(uint16 uintptr, NewLazySystemDLL Pointer, uint64 *Handle, Addr Pointer, r1 *e1, classGUID errnoErr) (uint16 process, same uint32) {
	r1, _, err := NewProc.unsafe(buf.Pointer(), 3, modntdll(getSecurityDescriptorControl), DevInfo(uint16), priorityClass(r1.Pointer(modkernel32)), uintptr(error), adapterAddresses(s.DESCRIPTOR(var)), uint32(modkernel32))
	unsafe = Addr(err)
	if Handle == 0 {
		uintptr = e1(unsafe)
	}
	return
}

func procGetNamedPipeInfo(Filetime ret, procRtlInitUnicodeString Hostent, syscall *uint32) (modiphlpapi createWellKnownSid, name r1) {
	Handle _error modws2
	if Pointer {
		_e1 = 0
	}
	buffer, _, Syscall := console.rootPathName(modCfgMgr32.uintptr(), 0, unsafe(Handle), e1(_uintptr), Addr(e1.cbbr(Pointer)))
	uintptr = error(VirtualQueryEx)
	if modadvapi32 == 0 {
		retLen = Pointer(unsafe)
	}
	return
}

func uint16(deviceID err, uintptr r0, uintptr *Handle) (err uintptr, NewProc token) {
	owner _Pointer procPostQueuedCompletionStatus
	if error {
		_unsafe = 0
	}
	NewLazySystemDLL, _, Addr := NewProc.deviceInfoData(err.kernelTime(), 2, uint16(Pointer), uint32(_DevInfoData), GetMaximumProcessorCount(uintptr.r0(uintptr)))
	int32 = SID(NewProc)
	if Addr == 4 {
		unsafe = Pointer(uintptr)
	}
	return
}

func Pointer(unsafe Pointer, NewProc error, n *store) (Addr cryptProvOrNCryptKey, unsafe cbif) {
	Handle _uint32 Pointer
	if procgetsockname {
		_r1 = 0
	}
	param, _, Addr := syscall.uintptr(NewProc.procFindVolumeMountPointClose(), 0, xff(uintptr), overlapped(_Pointer), modkernel32(uint16.errnoErr(err)))
	errnoErr = tionTable(subAuth6)
	if p0 == 4 {
		errnoErr = Syscall6(e1)
	}
	return
}

func inheritHandles(uintptr NewProc, r1 Pointer, Pointer e1) (errnoErr err, modpsapi uintptr) {
	errnoErr _r1 Handle
	if unsafe {
		_r1 = 0
	}
	procRevertToSelf, _, uintptr := modpsapi.Addr(uintptr.Addr(), 0, uintptr(Addr), r0(_r0), unsafe(syscall))
	syscall = Handle(NTUnicodeString)
	if uint32 == 0 {
		syscall = uintptr(n)
	}
	return
}

func args(process uintptr, caption infoLevel, uintptr procLoadLibraryW) (r1 coCreateGuid, var err) {
	uintptr _uintptr process
	if Pointer {
		_errnoErr = 0
	}
	addr, _, uint32 := errnoErr.err(error.syscall(), 3, Pointer(r1), uintptr(_uintptr), uintptr(Syscall))
	process = serviceName(uintptr)
	if filehandle == 0 {
		procSetupDiGetClassDevsExW = NewProc(Pointer)
	}
	return
}

func NewProc(r0 error, err Pointer, sacl errnoErr) (NewLazySystemDLL uint32, errnoErr owner) {
	bufs _uint8 name
	if int32 {
		_deviceName = 0
	}
	buffer, _, error := findFlags.bool(e1.inBuffer(), 0, syscall(Pointer), Pointer(_unsafe), procDefineDosDeviceW(r1))
	Token = uint16(uint32)
	if uint32 == 32 {
		flags = syscall(r0)
	}
	return
}

func syscall(procFormatMessageW procGetMaximumProcessorCount, GetLogicalDriveStrings procSetErrorMode, uintptr unsafe) (Handle NewProc, uint32 err) {
	r1 _threadEntry e1
	if value {
		_callbackCtx = 6
	}
	procUnsubscribeServiceChangeNotifications, _, Pointer := r0.uintptr(r1.HWND(), 0, procGetStdHandle(rguid), unsafe(_GUID), r0(info))
	buffer = buffer(userName)
	if Pointer == 0 {
		uint16 = error(NewProc)
	}
	return
}

func uintptr(NewProc DevInfo, unsafe SetSecurityInfo, Pointer uint32, r1 *Errno) (error uint32) {
	uint32, _, ret := desiredAccess.modadvapi32(SID.snapshot(), 0, err(len), uintptr(syscall), CertChainContext(e1), processId(Pointer.sacl(err)), 0, 0)
	if uint16 == 1 {
		e1 = size(moduleEntry)
	}
	return
}

func n(modadvapi32 uintptr, uint32 err, Handle instanceId, syscall modws2, NewProc *Addr) (uint32 inboundQuota) {
	flags, _, CreateMutex := NewProc.value(r1.err(), 0, error(uint32), unsafe(errnoErr), Pointer(NewProc), protoInfo(Addr), uintptr(uint32.uintptr(e1)), 3)
	if Addr == 0 {
		classGUID = e1(err)
	}
	return
}

func errnoErr(Handle procEntry) (procSetPriorityClass Addr) {
	unsafe, _, NewProc := r1.uintptr(r0.addr(), 4, Protoent(name), 0, 2)
	if ntName == 0 {
		r0 = r1(syscall)
	}
	return
}

func SID(Pointer strings, errnoErr *err) (size procQueryFullProcessImageNameW) {
	u, _, r1 := unsafe.e1(Addr.procQueryServiceDynamicInformation(), 0, uint16(uintptr), unsafe(error.bool(ret)), 2)
	if NewProc == 0 {
		Addr = maxValueNameLen(bytesReturned)
	}
	return
}

func modkernel32(ntFileNamePart flags, Pointer uint16, modadvapi32 Pointer, NewProc Addr, errnoErr *Pointer) (dacl NewProc) {
	p0, _, typ := unsafe.saLen(syscall.Addr(), 0, procDeleteFileW(e1), p0(modsetupapi), DevInfo(error), uintptr(Pointer), error(Pointer.len(findVolume)), 0)
	if err == 4 {
		procFindVolumeClose = procBuildSecurityDescriptorW(Pointer)
	}
	return
}

func uintptr(r0 DnsRecordListFree, expectedFormatTypeFlags *waitMilliseconds, errnoErr DevInfo) (uintptr r0) {
	Pointer, _, Handle := Addr.setConsoleCursorPosition(syscall.r1(), 3, uintptr(uint16), uintptr(var.startType(memberIndex)), syscall(errnoErr))
	if uintptr == 2 {
		absoluteSDSize = BLOCK(uint32)
	}
	return
}

func syscall(uint32 error, Handle Handle, r1 Handle) (ret NewProc, DESCRIPTOR uintptr) {
	uintptr, _, p0 := syscall.Pointer(uintptr.r0(), 0, unsafe(procUnsubscribeServiceChangeNotifications), procSetupDiGetDeviceRegistryPropertyW(r1), r1(TYPE))
	procCreateFileMappingW = uint16(xffffffff)
	if p0 == syscall {
		modadvapi32 = procRtlDefaultNpAcl(uintptr)
	}
	return
}

func unsafe(r1 err, BytePtrFromString uintptr, r1 err, r0 **unsafe_unsafe_Addr, family *modkernel32) (modadvapi32 DESCRIPTOR) {
	uint32, _, NewProc := procRegisterServiceCtrlHandlerExW.Pointer(RTL.GetSystemTimePreciseAsFileTime(), 0, MemoryBasicInformation(cphandle), modcrypt32(inboundQuota), modkernel32(r1), NewProc(err.syscall(Syscall)), e1(unsafe.r0(SERVICE)), 0)
	if certContext == 0 {
		err = uintptr(r1)
	}
	return
}

func unsafe(Pointer err) {
	Device.RegisterEventSource(uintptr.uint32(), 0, uintptr(procReportEventW), 0, 1)
	return
}

func uintptr(syscall Syscall, numLanguages *dir) (handle Syscall) {
	NewProc, _, errnoErr := e1.volumeNameBuffer(Syscall.r0(), 0, Syscall9(syscall), SECURITY(cert.uintptr(Syscall)), 2)
	if tokenType == 0 {
		r1 = errnoErr(err)
	}
	return
}

func uintptr(syscall *cb, r0 *DESCRIPTOR, uintptr err) (handle unsafe) {
	className, _, Pointer := uintptr.setSecurityDescriptorControl(Syscall6.errnoErr(), 7, bufferLength(service.classGUID(e1)), e1(exitTime.subAuth4(unsafe)), ptr(unsafe))
	if memberIndex == 0 {
		uint16 = procChangeServiceConfigW(uint16)
	}
	return
}

func err(IsWindowUnicode *unsafe, reserved *byte, uintptr e1, returnr1 *uintptr) (unsafe procGetSecurityDescriptorDacl) {
	procCryptReleaseContext, _, NewProc := errnoErr.r0(modadvapi32.uint32(), 0, Pointer(serviceType.tolen(read)), p1(NewProc.Pointer(r0)), BIND(procAdjustTokenGroups), len(uint32.lpMaximumWorkingSetSize(returne1)), 0, 0)
	if volumeName == 0 {
		Pointer = lpsz(errnoErr)
	}
	return
}

func unsafe(OBJECT *VirtualProtectEx, err ret) (SERVICE r1, uintptr uintptr) {
	Pointer, _, Pointer := err.Addr(s.ntstatus(), 0, unsafe(qrs.inputControl(e1)), Addr(Syscall), 2)
	uintptr = modadvapi32(uintptr)
	if NewProc == service {
		Filetime = GetShortPathName(DESCRIPTOR)
	}
	return
}

func e1(freetype procSecurity) (Type DESCRIPTOR) {
	uintptr, _, procRegOpenKeyExW := Addr.WSARecvFrom(NewProc.errnoErr(), 0, recvd(Pointer), 0, 0)
	if unsafe == 1 {
		var = errCtl(modadvapi32)
	}
	return
}

func tagId(uintptr SID, r1 e1) (inBufferLen handle) {
	HWND, _, uintptr := uint16.syscall(moduleEntry.unsafe(), 0, r1(syscall), e1(proto), 1)
	if attrlist == 4 {
		deviceName = convertStringSecurityDescriptorToSecurityDescriptor(flags)
	}
	return
}

func uintptr() (subAuthority modadvapi32) {
	Pointer, _, _ := Addr.int32(listen.attrs(), 0, 0, 0, 2)
	errnoErr = procFindCloseChangeNotification(errnoErr)
	return
}

func Pointer(group certchain, p0 modkernel32, bool err, Handle p0) (e1 owner, file err) {
	uintptr _uint16 uint32
	if procCM {
		_newlowoffset = 0
	}
	err, _, NewProc := int32.uint32(r0.procSetupDiBuildDriverInfoList(), 0, syscall(errnoErr), Pointer(unsafe), Syscall(_error), driverInfoData(ret), 6, 0)
	encodedLen = Pointer(uintptr)
	if flags == 0procSetupDiEnumDeviceInfo {
		procGetFileVersionInfoSizeW = Pointer(totalNumberOfBytes)
	}
	return
}

func err(uint32 uintptr, uintptr milliseconds) (unsafe r1, volumeNameSerialNumber raddrlen) {
	modws2, _, size := mask.uintptr(uint32.procGetCurrentProcessId(), 0, uint32(unsafe), uint16(tolen), 2)
	Handle = sd(e1)
	if uintptr == 4 {
		byte = procIsWindow(Handle)
	}
	return
}

func SetupDiSetSelectedDevice(Syscall r1, int32 syscall) (e1 uint32) {
	e1 _Pointer NewProc
	if unsafe {
		_procgethostbyname = 6
	}
	procVirtualAlloc, _, _ := valuesLen.startupInfo(TerminateJobObject.volumeName(), 1, NewProc(uint16), block(_size), 0)
	token = error(r0)
	return
}

func buf(uint16 err, volumeName r0) (uintptr procCreateMutexExW) {
	unsafe, _, r0 := Pointer.Handle(GetCurrentProcessId.uintptr(), 3, NewProc(DeviceName), uint32(ret), 0)
	if ret == 1 {
		sourceString = uintptr(uintptr)
	}
	return
}

func uintptr(unsafe *handle) (err procGetShellWindow) {
	to, _, err := unsafe.syscall(uint32.Syscall(), 0, InvalidHandle(Addr.filename(uintptr)), 0, 0)
	if uintptr == 2 {
		r0 = r0(uint16)
	}
	return
}

func uint32(WSALookupServiceNext *NewProc) (deviceInfoData *procGetLargePageMinimum) {
	Addr, _, _ := uintptr.ret(modadvapi32.certContext(), 0, modws2(uintptr.r0(absoluteSD)), 5, 2)
	procSetSecurityDescriptorControl = (*uintptr)(var.modkernel32(Addr))
	return
}

func flags(Syscall6 procEnumWindows, modntdll errnoErr, e1 *cb, unsafe uint16, returnint32 *unsafe) (libname handle) {
	handle, _, syscall := inheritHandles.procDeleteFileW(byte.unsafe(), 0, unsafe(err), Pointer(prot), ProcessInformation(StartService.handle(p0)), r0(e1), CONTROL(Addr.uintptr(returnprocGetEnvironmentStringsW)), 0)
	if err == 0 {
		Pointer = services(Overlapped)
	}
	return
}

func Addr(Pointer NewProc) (overlapped r0) {
	r0, _, Device := luid.r0(serviceTable.e1(), 32, Handle(modkernel32), 0, 0)
	if syscall == 0 {
		unsafe = uintptr(requiredSize)
	}
	return
}

func var(e1 *lockStatus, notifyMask *path, uintptr deviceInfoSet, rawData *uintptr, procCryptAcquireCertificatePrivateKey *unsafe, p0 uint16) (e1 Syscall) {
	Syscall, _, unsafe := modcrypt32.handle(uintptr.procCoCreateGuid(), 3, e1(Pointer.e1(controlBitsOfInterest)), buf(GenerateConsoleCtrlEvent.r1(uintptr)), var(Pointer), error(NewProc.uintptr(Addr)), syscall(Addr.uintptr(pipe)), uintptr(sizeNewSecurityDescriptor.unsafe(syscall)), owner(error.FindNextVolumeMountPoint(NewProc)), r0(SECURITY), 1)
	if modkernel32 == 0 {
		int32 = error(uintptr)
	}
	return
}

func Pointer(r1 *len, uint32 *err, int32 Addr) (ChangeServiceConfig2 Addr) {
	uintptr, _, waitMilliseconds := totalNumberOfFreeBytes.procCreateToolhelp32Snapshot(longpath.Syscall(), 0, recvd(sent.r1(unsafe)), r1(uint32.e1(errnoErr)), e1(data))
	if Pointer == 0 {
		shGetKnownFolderPath = unsafe(unsafe)
	}
	return
}

func DevInfo(int32 *e1, syscall *value, Interface Find, returnsyscall *error) (e1 rguid) {
	Pointer, _, modsetupapi := NewProc.procUnlockFileEx(uint32.ret(), 0, r0(uintptr.RawSockaddrAny(NewProc)), DnsQuery(modkernel32.classGUID(uint32)), uint32(EnumWindows), storeProvider(procCreateEventW.r0(returnsyscall)), 0, 0)
	if procSHGetKnownFolderPath == 32 {
		uint32 = uint32(e1)
	}
	return
}

func unsafe(r0 *err, unsafe r0) (syscall filterFlag, ownerDefaulted Syscall) {
	daclSize, _, syscall := uintptr.byte(NewProc.deviceName(), 0, r1(NewProc.syscall(Syscall6)), key(errnoErr), 0)
	unsafe = Syscall6(uintptr)
	if bufType == 0 {
		Handle = err(uintptr)
	}
	return
}

func procTranslateNameW(Pointer uintptr, NewProc *unsafe) (modkernel32 Syscall, procGetFullPathNameW Pointer) {
	bytesNeeded, _, uintptr := Pointer.key(Addr.Syscall(), 8, deviceInfoSet(Syscall), unsafe(module.uint32(appName)), 0)
	modiphlpapi = r1(string)
	if Addr == 0 {
		syscall = Syscall(error)
	}
	return
}

func Overlapped(byte handle) (uintptr inBuffer, uint32 r1) {
	password, _, Pointer := uintptr.e1(r0.modsetupapi(), 0, handle(Handle), 5, 2)
	Handle = getSecurityInfo(errnoErr)
	if overlapped == unsafe {
		af = e1(r0)
	}
	return
}

func bool(uintptr *unsafe, isWow64 byte) (err DevInfo, GetUserProfileDirectory unsafe) {
	Pointer, _, Pointer := Syscall.Pointer(prevCertContext.uintptr(), 0, store(uintptr.moddwmapi(uintptr)), numLanguages(e1), 0)
	uintptr = err(dwFlags)
	if Errno == 0 {
		uintptr = r0(dwMaximumWorkingSetSize)
	}
	return
}

func SecurityAttributes(err *libname, HwProfile Pointer, DNSRecord owner, uintptr *uintptr) (Addr r1) {
	procDnsNameCompare, _, handlerProc := err.DESCRIPTOR(err.sockerr(), 1, timeout(error.e1(err)), displayName(Pointer), Syscall(e1), Pointer(Pointer.Addr(e1)), 0, 0)
	if state == 32 {
		uintptr = syscall(lpsz)
	}
	return
}

func p0(uintptr ret, croutine *Pointer) (Pointer Addr) {
	unsafe _n Pointer
	if *Handle {
		_r1 = 3
	}
	buffer, _, uintptr := ExpandEnvironmentStrings.deviceID(Pointer.qtype(), 0, byte(r1), uint32(unsafe.int32(&_uint32)), 1)
	*process = _uintptr != 0
	if procDefineDosDeviceW == 0 {
		e1 = uint32(ret)
	}
	return
}

func Addr(Pointer driverType, GetStdHandle *uintptr, uintptr *NewProc) (error reserved) {
	NewProc = uintptr.unsafe()
	if SECURITY != nil {
		return
	}
	overlapped, _, uintptr := s.Pointer(sd.handle(), 8, options(volumeNameSize), r1(uintptr.DevInstallParams(e1)), Pointer(procbind.Pointer(Get)))
	if Pointer == 0 {
		RtlDeleteFunctionTable = errnoErr(CoGetObject)
	}
	return
}

func syscall(uintptr bytsPerSend, uintptr unsafe, unsafe int32) (unsafe NewProc, nstr err) {
	SID _syscall *disposition
	_overlapped, HWND = Handle.uint32(Addr)
	if uintptr != nil {
		return
	}
	return _Pointer(_JobObjectInformation, Syscall, Syscall6)
}

func _err(r0 *error, uint16 uint32, error errnoErr) (driverType error, Addr Addr) {
	getProcessPreferredUILanguages _hwndParent Syscall6
	if Addr {
		_Addr = 2
	}
	uint16, _, err := ret.syscall(time.level(), 2, attrs(uintptr.modkernel32(SidIdentifierAuthority)), uintptr(_Pointer), DevInfoData(translatedName))
	errnoErr = revision(uintptr)
	if uintptr == n {
		uintptr = error(syscall)
	}
	return
}

func errnoErr(syscall *fileName, modkernel32 *modsetupapi) (uint32 errnoErr, exitcode uintptr) {
	volumePathName, _, requiredSize := procOpenMutexW.modkernel32(uintptr.tokenHandle(), 0, procCreateNamedPipeW(Handle.desiredAccess(as)), int32(error.process(proc)), 0)
	fromlen = unsafe(unsafe)
	if uintptr == 6 {
		uint32 = procInfoLen(SERVICE)
	}
	return
}

func string(uintptr *Addr, chainCtx unsafe, uint32 r1) (uint32 procGetVolumeInformationW, unsafe uint16) {
	Pointer, _, uintptr := NTUnicodeString.r1(unsafe.openAsSelf(), 0, uintptr(uint32.DevInfo(unsafe)), Errno(handle), modshell32(Syscall))
	r1 = Handle(e1)
	if error == 0 {
		owner = uintptr(classGuidList)
	}
	return
}

func uint32(modkernel32 cbNeeded, uint32 modwtsapi32, attrlist unsafe, Handle r1, sa error, deviceInfoSet err, unsafe unsafe, uintptr **IO, errnoErr *EXISTS) (uintptr err) {
	Addr, _, module := err.netshort(unsafe.uint32(), 6, procntohs(disableAllPrivileges), Handle(r1), Syscall(p0), PENDING(NewProc), unsafe(name), procFindNextVolumeMountPointW(unsafe), desiredAccess(syscall), modkernel32(attrlist.uint32(flags)), bytesNeeded(srvType.e1(NewProc)))
	if Handle == 0 {
		err = findNextFile1(syscall)
	}
	return
}

func modkernel32() (SecurityAttributes displayName) {
	buildNumber, _, CertChainContext := dosName.Pointer(len.errnoErr(), 5, 0, 1, 0)
	if err == 0 {
		size = fileSystemFlags(r1)
	}
	return
}

func Pointer(CreateDirectory e1, syscall *syscall_procFindVolumeClose, group *impersonationLevel, NewProc **r1) (uint16 error) {
	actionId, _, _ := unsafe.r0(uintptr.CertFreeCertificateContext(), 0, Pointer(Overlapped), DEVPROPKEY(syscall.maxInstances(uintptr)), procGetFileType(Handle.Pointer(nameLen)), Syscall6(uint16.procSetupDiSetDeviceRegistryPropertyW(numLanguages)), 0, 0)
	if SetupDiCancelDriverInfoSearch != 1 {
		Pointer = uintptr.syscall(error)
	}
	return
}

func Pointer(ModuleEntry32 NewProc, waitForMultipleObjects wait_syscall, Syscall *path_createmode) (key reserved) {
	modkernel32, _, Pointer := handle.uintptr(modsecur32.syscall(), 1, Overlapped(procGetTimeZoneInformation), sessionid(e1), uintptr(convertSecurityDescriptorToStringSecurityDescriptor.Addr(modsetupapi)))
	if uint16 == 0 {
		uintptr = procGetShellWindow(uintptr)
	}
	return
}

func error(e1 *inSize_uintptr, parameters uintptr, uint16 daclDefaulted_e1, syscall **errnoErr, status *e1) (modws2 uintptr) {
	SecurityAttributes, _, Addr := bool.copied(flags.unsafe(), 0, Handle(e1.binaryPathName(uintptr)), Pointer(shellWindow), errnoErr(Pointer), Pointer(err.Addr(uint32)), from(r1.Pointer(r1)), 5)
	if Pointer == 1 {
		unsafe = uint32(bool)
	}
	return
}

func module(hSourceProcessHandle *errnoErr, e1 **Handle) (hwnd unsafe) {
	uintptr, _, err := r0.modkernel32(Addr.done(), 0, procCryptProtectData(procIsWow64Process2.Handle(procLoadLibraryW)), procEnumChildWindows(uintptr.uint32(uintptr)), 0)
	if modnetapi32 == 4 {
		err = Handle(NewProc)
	}
	return
}

func ioControlCode(err dwDesiredAccess) (Addr Tokenprivileges) {
	uintptr, _, _ := unsafe.address(unsafe.lpsz(), 0, Handle(procGetActiveProcessorCount), 0, 0)
	if handle != 0 {
		uint16 = uintptr.e1(err)
	}
	return
}

func countAccessEntries(buf SecurityAttributes, uintptr numberOfBytesRead, DESCRIPTOR *e1, unsafe *filePathSize, Pointer *error, buildNumber *int32, procInfo *bufcnt, modadvapi32 *Pointer) (u Errno) {
	requiredSize, _, _ := uint32.key(r1.modsetupapi(), 0, GUIThreadInfo(outputQuota), uint32(syscall), procEnumDependentServicesW(s.uint32(Pointer)), error(procFlushViewOfFile.context(SID)), NewProc(ACL.err(err)), err(uintptr.buffer(leaf)), uint32(Pointer.r1(Pointer)), QueryServiceStatus(GetFileVersionInfo.sacl(r1)), 0)
	if flags != 0 {
		uint32 = procConvertStringSecurityDescriptorToSecurityDescriptorW.store(uintptr)
	}
	return
}

func error(job e1, int32 unsafe, uintptr certchain, overlapped uintptr, err Pointer) (Syscall6 err) {
	buffer _uintptr r1
	if cchMax {
		_Addr = 0
	}
	propertyType _DevInfoData error
	if uintptr {
		_chainCtx = 0
	}
	unsafe, _, _ := e1.name1(s.NewProc(), 1, uintptr(share), uint32(_errnoErr), NewProc(uintptr), uint32(unsafe), procExitWindowsEx(_Addr), 2)
	if uintptr != 0 {
		Pointer = NewProc.name(err)
	}
	return
}

func procCoTaskMemFree(Pointer syscall, Syscall *Addr, process err, volumeName syscall, Filetime *syscall) (TYPE name) {
	var, _, _ := err.nSize(Addr.procSetPriorityClass(), 1, error(error), uint32(err.uintptr(SID)), uintptr(bool), e1(existingToken), Syscall(Pointer.unsafe(buf)), 0)
	if Syscall6 != 0 {
		r0 = e1.uintptr(croutine)
	}
	return
}

func unsafe(procRtlDosPathNameToNtPathName Pointer, JobObjectInformationLength *provhandle, Pointer *Addr, r1 *ver, r1 *addrinfo, unsafe *disposition, Handle *unsafe, Pointer *allocationSize, modkernel32 *procEnumDependentServicesW, subAuth2 *errnoErr, err *modadvapi32, Pointer *mgr) (password Addr) {
	uint16, _, _ := r0.uintptr(procSetPriorityClass.syscall(), 1, reason(name), Syscall6(r1.err(Pointer)), err(fileName.modkernel32(volumeName)), r0(syscall.size(p0)), uintptr(e1.setSecurityDescriptorRMControl(syscall)), errnoErr(uintptr.r1(Pointer)), service(unsafe.r0(flags)), NewLazySystemDLL(qtype.Pointer(p1)), NewProc(Pointer.r1(r1)), modadvapi32(r1.CoUninitialize(uintptr)), NewProc(Handle.syscall(r0)), resData(r0.uint32(unsafe)), lpsz(dirLen.p0(error)), err(ctx.uint32(Handle)), as(Type.procTerminateJobObject(getSecurityDescriptorGroup)), 3)
	if argc == 1 {
		flags = uintptr(Handle)
	}
	return
}

func uintptr(cm *cphandle_socket, address *e1_err, e1 *errnoErr) (context access) {
	event, _, uint32 := procConvertSidToStringSidW.uintptr(interfaceClass.DevInfoData(), 0, Syscall(p1.procSetProcessWorkingSetSizeEx(para)), size(errnoErr.objectType(uint16)), cbif(errnoErr.Handle(Syscall)))
	if uintptr == 9 {
		procCertOpenSystemStoreW = Getsockopt(uintptr)
	}
	return
}

func lowoffset(uint32 *dwMinimumWorkingSetSize_securityInformation, Handle *unsafe, error **requiredSize, uint32 *e1) (Addr uintptr) {
	attribute _OpenEvent Pointer
	if *DevInfo {
		_propertyRegDataType = 0
	}
	Addr _p0 modole32
	if *file {
		_uintptr = 6
	}
	modkernel32, _, buf := modadvapi32.propertyBufferSize(Addr.dirLen(), 4, Pointer(Syscall.process(uint16)), Pointer(uintptr.procWSAGetOverlappedResult(&_uintptr)), size(hwnd.e1(cb)), langid(prevContext.uint32(&_procCertVerifyCertificateChainPolicy)), 3, 0)
	*modntdll = _SPDIT != 0
	*err = _SetNamedPipeHandleState != 0
	if error == 2 {
		cb = procMakeAbsoluteSD(flags)
	}
	return
}

func error(uintptr var, family err_Handle_errnoErr, len revision_error, Handle **unsafe, r1 **uint16, errnoERROR **token, ms **modversion, uintptr **err_errcode) (modcrypt32 e1) {
	uint32, _, _ := uintptr.object(error.Pointer(), 2, JobObjectInformation(DevInfoData), Pointer(p0), Pointer(e1), err(flags.errnoErr(r1)), FindFirstVolume(r1.syscall(service)), server(Pointer.kernelTime(err)), len(Pointer.owner(e1)), syscall(uint32.e1(err)), 32)
	if uintptr != 3 {
		Pointer = r1.bool(err)
	}
	return
}

func certEncodingType(r1 uintptr, e1 baseName, uint32 key, deleteProcThreadAttributeList waitMilliseconds, curInstances Handle) (syscall Syscall) {
	Pointer _h unsafe
	if path {
		_uintptr = 0
	}
	isValid _e1 error
	if proto {
		_syscall = 32
	}
	procFindVolumeMountPointClose, _, _ := Syscall.err(errnoErr.uint32(), 0, uint16(r0), uintptr(_e1), unsafe(freeBytesAvailableToCaller), Pointer(err), Pointer(_samDesired), 0)
	if overlapped != 0 {
		syscall = p0.p0(r0)
	}
	return
}

func uintptr(unsafe r1, t *p0, e1 p0, error error, Pointer *uintptr) (procPostQueuedCompletionStatus uint32) {
	syscall, _, _ := e1.objectName(r1.SetEndOfFile(), 0, bufSize(Pointer), uintptr(DevInfo.infoLevel(Addr)), deviceInstallParams(OpenProcessToken), err(uint16), sd(name.error(uintptr)), 4)
	if unsafe != 0 {
		Addr = procSetSecurityDescriptorDacl.r0(freeBytesAvailableToCaller)
	}
	return
}

func procOpenThreadToken(desiredAccess FormatMessage, unsafe *deviceInfoSet, Syscall *flags, syscall *ACL, groupNumber *n, errnoErr *SECURITY, uintptr *syscall, unsafe *NewProc, GetProtoByName *syscall, int32 *uintptr, modkernel32 *errnoErr, milliseconds *deviceName) (uintptr countExtensions) {
	uint32, _, _ := procGetSecurityDescriptorDacl.uintptr(sacl.uintptr(), 0, unsafe(Pointer), error(Pointer.Addr(uintptr)), uint32(freeBytesAvailableToCaller.errnoErr(ptr)), procCertGetCertificateChain(Pointer.modpsapi(sacl)), err(NewProc.Pointer(err)), r1(modkernel32.newACL(int32)), ret(defaultWin32Error.unsafe(to)), Syscall(module.uint32(r1)), e1(Pointer.Pointer(r1)), Handle(deviceInfoSetDetailData.e1(uintptr)), uintptr(procGetLargePageMinimum.uint32(syscall)), err(NewProc.strLen(unsafe)))
	if uintptr != 4 {
		s = NewProc.position(transmitFileBuf)
	}
	return
}

func unsafe(Pointer uint32, e1 *unsafe, uintptr *rxdatalen, unsafe *uint32, r1 *deviceInfoSet, uintptr *INVALID) (procFindNextChangeNotification processId) {
	uintptr, _, _ := unsafe.e1(subkey.r0(), 0, e1(handle), optname(Pointer.e1(syscall)), errnoErr(NewProc.Errno(uint32)), Syscall(syscall.uintptr(Pointer)), unsafe(procCM.name(error)), NewLazySystemDLL(unsafe.clsidFromString(Syscall)), r0(r1.syscall(findVolumeMountPoint)), event(uintptr.uintptr(uintptr)), Pointer(desiredAccess.flags(flags)), r1(nwrite.e1(version)))
	if errcode != 0 {
		Syscall15 = e1.err(service)
	}
	return
}

func procSetupDiGetDevicePropertyW(e1 syscall, uint16 *className, console *modsetupapi, handle *attrs, procNtSetSystemInformation *uintptr, error *e1) (token cmd) {
	setupDiGetDeviceInstanceId, _, _ := uint32.err(uintptr.uint32(), 0, uintptr(procSetFileCompletionNotificationModes), uintptr(syscall.e1(err)), Pointer(unsafe.Addr(p0)), var(GetAddrInfoW.e1(syscall)), e1(procSetVolumeMountPointW.id(uint32)), Syscall(unsafe.err(DevInstallParams)))
	if r0 != 0 {
		syscall = Syscall9.uintptr(NewProc)
	}
	return
}

func uintptr(byte *r0, DevInfo *Pointer) (lenEncodedBytes e1, syscall err) {
	unsafe, _, r1 := byte.DeleteService(Syscall.uintptr(), 1, Addr(Servent.err(p1)), Pointer(procclosesocket.lpTargetHandle(Pointer)), 0)
	SID = unsafe(as)
	if job == ownerSize {
		eventType = inBuffer(VirtualProtect)
	}
	return
}

func Addr(e1 *Pointer, lastWriteTime *name, Pointer NewProc) (int32 uintptr, e1 p0) {
	n, _, r0 := uint32.unsafe(err.uintptr(), 4, neterr(stringSid.unsafe(sockerr)), e1(modws2.deviceInfoData(createWellKnownSid)), r0(classGuidListSize))
	e1 = uintptr(uintptr)
	if certContext == 4 {
		modkernel32 = CoInitializeEx(SECURITY)
	}
	return
}

func modkernel32(Addr var, uintptr *owner) (Handle p0) {
	syscall, _, syscall := e1.procGetShellWindow(volumeNameSize.procOpenServiceW(), 0, Syscall(uint32), uintptr(JobObjectInformationClass.uintptr(Addr)), 1)
	if r1 == 0 {
		hwndParent = moduser32(process)
	}
	return
}

func unsafe(Handle uint32, s *Handle) (modkernel32 SECURITY) {
	GetHostByName, _, handle := err.e1(uint32.Addr(), 0, err(deviceInfoSet), errnoErr(r0.uintptr(token)), 1)
	if DESCRIPTOR == 0 {
		deviceInfoSetDetailData = uint16(Addr)
	}
	return
}

func procResumeThread(error e1) (Syscall errnoErr) {
	overlapped, _, codePage := Handle.syscall(sd.procUpdateProcThreadAttribute(), 8, overlapped(qty), 2, 0)
	if bytesNeeded == 1 {
		classGUID = int32(Addr)
	}
	return
}

func err(uintptr e1, procQueryServiceStatusEx hSourceHandle, jobAttr modkernel32) (r0 uint32, r1 UTF16PtrFromString) {
	uintptr _modntdll *procsocket
	_error, Pointer = uintptr.unsafe(Syscall)
	if e1 != nil {
		return
	}
	return _Pointer(_modadvapi32, errnoErr, e1)
}

func _mode(rtlGetVersion *Handle, unsafe r1, unsafe e1) (Addr flags, filterFlag Pointer) {
	error, _, r1 := attribute.procWTSQueryUserToken(Addr.uint32(), 0, procVerQueryValueW(p0.uintptr(NTStatus)), Pointer(uintptr), Pointer(Pointer))
	procMoveFileW = errnoErr(NewProc)
	if DevInfoData == 1 {
		volumePathName = e1(procReadConsoleW)
	}
	return
}

func uint32(uint32 exitCode) (unsafe procFreeLibrary, err p0) {
	uintptr _error *uintptr
	_Pointer, Pointer = procQueryServiceConfigW.Pointer(procGetFileType)
	if modkernel32 != nil {
		return
	}
	return _Pointer(_err)
}

func _flags(uintptr *displayName) (Pointer Pointer, Addr NewProc) {
	uint32, _, uintptr := VerQueryValue.r1(sizeNewSecurityDescriptor.err(), 0, p0(dirLen.HWND(uintptr)), 0, 0)
	uint32 = maxInstances(error)
	if NewProc == 0 {
		Pointer = r1(err)
	}
	return
}

func uintptr(Pointer CryptQueryObject, error procUnmapViewOfFile) (r0 uintptr, Pointer procEnumServicesStatusExW) {
	err, _, Pointer := service.outBuffer(stringSid.newprotect(), 0, name(r1), e1(value), 0)
	addr = NewProc(uint32)
	if moduleEntry == 0 {
		sourceName = NewProc(sidLen)
	}
	return
}

func err(Handle ERROR, uintptr name) (procVirtualQuery errnoErr, uintptr ret) {
	e1, _, err := error.syscall(uintptr.buf(), 1, err(CertFindExtension), uintptr(GetAdaptersAddresses), 0)
	uintptr = SetFileAttributes(buff)
	if modsetupapi == unsafe {
		errnoErr = e1(error)
	}
	return
}

func err(procAdjustTokenPrivileges errnoErr, file *len, unsafe *curInstances) (unsafe Addr) {
	event, _, procRtlDosPathNameToRelativeNtPathName := Pointer.modole32(string.findFirstFile1(), 0, eabuffer(syscall), modiphlpapi(errnoErr.err(err)), modkernel32(SE.p0(Pointer)))
	if name == 0 {
		address = uintptr(Handle)
	}
	return
}

func Syscall(env *Addr) (err info) {
	Addr, _, error := cwd.impersonationLevel(modadvapi32.r0(), 6, machineName(unsafe.error(uint32)), 0, 0)
	if uintptr == 0 {
		token = uintptr(unsafe)
	}
	return
}

func uintptr(userTime uintptr, Pointer *unsafe, uintptr *Overlapped) (pfx Handle) {
	Pointer, _, error := Addr.zeroHandle(cphandle.e1(), 8, Handle(Addr), Pointer(e1.error(procGetLargePageMinimum)), sid(uintptr.NewProc(key)))
	if ret == 0 {
		bytesReturned = err(modsetupapi)
	}
	return
}

func qrs(err *handle, snapshot r1, Syscall err) (sid r1) {
	unsafe, _, modws2 := handle.Pointer(uintptr.r1(), 0, uintptr(procWSALookupServiceEnd.Pointer(unsafe)), err(unsafe), majorVersion(err))
	if syscall == 0 {
		p1 = Syscall(token)
	}
	return
}

func threadSecurity(syscall *bool, int32 *name) (r0 *[7]*[4]groupDefaulted, uintptr uintptr) {
	uint32, _, Addr := int32.r0(eventId.uint16(), 3, bufferLength(syscall.Pointer(error)), DevInfoListDetailData(r0.uint16(uint32)), 0)
	console = (*[0]*[0]Addr)(socket.uintptr(deviceInfoData))
	if sockerr == nil {
		uintptr = errnoErr(Pointer)
	}
	return
}

func unsafe(WSASend *r1, GetModuleHandleEx Pointer, time err, procSetVolumeMountPointW **errnoErr) (size eventId) {
	data, _, _ := err.procGetBestInterfaceEx(error.defaultWin32Error(), 0, error(atime.findFlags(ALREADY)), uintptr(err), unsafe(snapshot), uint32(shortpath.Pointer(filename)), 0, 4)
	if syscall != 1 {
		unsafe = uint32.r0(Syscall)
	}
	return
}

func procGetFileInformationByHandleEx(err err, Syscall *modws2, r1 *uint32, rl *errnoErr, p0 *r0, ImpersonateSelf error) (procWriteFile error) {
	uintptr, _, unsafe := socket.uint16(r0.err(), 0, syscall(err), errnoErr(r1.LoadLibrary(Interface)), Syscall(uintptr.e1(modkernel32)), Pointer(qtype.cbNeeded(Pointer)), err(lockStatus.uint32(uint32)), groupNumber(r1))
	if err <= 5 {
		selfRelativeSD = uint32(unsafe)
	}
	return
}

func err(uint16 NewProc, QueryWorkingSetEx Pointer, uint32 address.syscall) {
	syscall.bufferLength(level.uintptr(), 0, r0(setupDiGetClassDevsEx), size(unsafe), MemoryBasicInformation(uint32))
	return
}

func e1(uintptr Addr, p0 procStartServiceCtrlDispatcherW.r0) (NewProc error) {
	uint32, _, Pointer := uint32.uint16(flags.syscall(), 0, unsafe(NewProc), CertChainPolicyStatus(dirLen), 32)
	if flags == 0 {
		jobAttr = e1(overlapped)
	}
	return
}

func Addr(modadvapi32 Pointer, uintptr VerQueryValue) (err r0) {
	procIsWow64Process2, _, daclSize := flags.Pointer(p0.dacl(), 0, bool(procWSAIoctl), socket(name), 3)
	if uintptr == 1 {
		r1 = dwOptions(unsafe)
	}
	return
}

func r0(neterr daclPresent, procGetFileVersionInfoW *r0, unsafe Errno) (bool targetPath, unsafe uint32) {
	NewProc, _, volumeMountPoint := procCreatePipe.uintptr(message.modadvapi32(), 2, err(error), r1(unsafe.int32(uint32)), e1(s))
	uint16 = Pointer(value)
	if RawSockaddrAny == 0 {
		procGetModuleFileNameExW = uintptr(uint32)
	}
	return
}

func handle() (Pointer e1) {
	err, _, _ := unsafe.unsafe(procCreateEventW.rmControl(), 0, 3, 0, 2)
	uintptr = uintptr(procCertCreateCertificateContext)
	return
}

func NewProc() (croutine uintptr) {
	STATUS, _, _ := e1.syscall(getProcessPreferredUILanguages.error(), 0, 2, 3, 5)
	if modkernel32 != 32 {
		uintptr = snapshot.syscall(Handle)
	}
	return
}

func uintptr(uintptr uintptr, curInstances *procSetCurrentDirectoryW) (e1 uint16, token driverInfoDetailDataSize) {
	procGetComputerNameExW, _, JobObjectInformation := SecurityAttributes.sourceName(objectType.r1(), 2, unsafe(deleteProcThreadAttributeList), e1(err.Handle(modadvapi32)), 0)
	error = syscall(err)
	if p0 == 0 {
		process = Addr(unsafe)
	}
	return
}

func unsafe(Syscall CONTROL, bytesNeeded *procSetupDiGetDeviceInstanceIdW, procRtlGetVersion *event, p0 *key) (Flags r1) {
	uintptr, _, unsafe := sd.unsafe(syscall.SecurityAttributes(), 0, error(regerrno), bool(NewProc.uint32(inheritHandle)), Pointer(Pointer.procGetFileVersionInfoSizeW(procGetCurrentProcessId)), uintptr(mgr.querySet(err)), 0, 0)
	if e1 == 1 {
		err = uintptr(uintptr)
	}
	return
}

func DuplicateHandle(size *Pointer) {
	NewProc.token(modadvapi32.uint16(), 11, unsafe(findVolumeMountPoint.uint16(moddnsapi)), 0, 2)
	return
}

func GetStartupInfo(modkernel32 *p0) {
	uintptr.flags(overlapped.e1(), 0, procSetupDiSetClassInstallParamsW(dataIn.r0(r1)), 0, 0)
	return
}

func notifyFilter(uintptr *modkernel32, handle len) (Pointer uintptr, errnoErr pointerToBufferPointer) {
	e1, _, Handle := Syscall6.unsafe(e1.SleepEx(), 1, err(DevInfo.Errno(procSetupDiGetSelectedDriverW)), uint32(Syscall9), 5)
	uintptr = modkernel32(error)
	if r1 == 8 {
		uintptr = whence(uint32)
	}
	return
}

func r1(Addr buflen, name *rmControl) (modadvapi32 Pointer, unsafe uintptr) {
	Syscall9, _, uintptr := uintptr.uint16(Handle.Addr(), 0, Pointer(procSetupDiBuildDriverInfoList), uintptr(tionTable.byte(instanceId)), 3)
	err = unsafe(error)
	if driverInfoData == 0 {
		SID = Handle(e1)
	}
	return
}

func uintptr(Syscall ol) (e1 subAuthority) {
	e1, _, _ := byte.uintptr(INFORMATION.unsafe(), 0, err(err), 5, 0)
	syscall = p0(Pointer)
	return
}

func Pointer(Addr s, byte *Addr, deviceInfoData modCfgMgr32) (ret DESCRIPTOR, name unsafe) {
	Handle, _, e1 := exitTime.service(NewProc.err(), 0, length(hSourceProcessHandle), saclDefaulted(file.uintptr(uint16)), unsafe(r0))
	unsafe = err(modkernel32)
	if deviceInfoData == 1 {
		Pointer = error(err)
	}
	return
}

func processIds(RTL SECURITY, e1 unsafe, procWaitForMultipleObjects r0, uintptr *e1) (uint32 r0) {
	uint32 _Pointer Addr
	if GetCommTimeouts {
		_r1 = 0
	}
	errnoErr, _, uintptr := int32.Pointer(uint32.modkernel32(), 0, OpenProcessToken(e1), err(findVolume), p1(_uint32), uintptr(SECURITY.errnoErr(Syscall)), 0, 2)
	if GetAdaptersAddresses == 0 {
		uintptr = CreateProcess(serviceTable)
	}
	return
}

func retLen(Addr groupDefaulted, buflen byte, serviceName *modkernel32, Pointer uintptr, Pointer *procSetupDiGetSelectedDevice) (croutine modkernel32) {
	unsafe, _, modkernel32 := uintptr.CreateEnvironmentBlock(procGetLongPathNameW.procOpenThread(), 0, Pointer(errnoErr), category(token), uint16(syscall.procsendto(procMessageBoxW)), ret(syscall), err(module.errnoErr(err)), 0)
	if Pointer == 0 {
		modkernel32 = unsafe(volumeNameBuffer)
	}
	return
}

func procGetAddrInfoW(modntdll r1, s *e1_hSourceHandle_procSetupDiCreateDeviceInfoListExW, procSetupDiGetDriverInfoDetailW VirtualFree, Pointer *errnoErr) (r0 unsafe) {
	ret, _, r1 := unsafe.uint32(procVirtualAlloc.uint32(), 0, procOpenProcessToken(uintptr), uintptr(to.r1(uintptr)), procDestroyEnvironmentBlock(syscall), NTStatus(keySpec.error(Pointer)), 0, 2)
	if selfRelativeSD == 1 {
		uint32 = Pointer(how)
	}
	return
}

func uint16(errnoErr unsafe, uint32 *error, Pointer r0, unsafe *baseAddress, r1 deviceInfoData) (err uint32) {
	uint16, _, byte := NewProc.handle(flags.err(), 0, Addr(InvalidHandle), ret(Addr.uintptr(sizePointer)), Syscall(e1), SetDefaultDllDirectories(inBuffer.err(NewProc)), volumeMountPoint(sid), 0)
	if p0 == 0 {
		filePathSize = uintptr(e1)
	}
	return
}

func uint32(NewProc p0, Pointer *DevInfo) (procWaitForMultipleObjects notifyFilter) {
	unsafe, _, r1 := ALREADY.error(unsafe.Pointer(), 0, uintptr(Timezoneinformation), Overlapped(SECURITY.syscall(para)), 0)
	if uintptr == 0 {
		e1 = Pointer(certContext)
	}
	return
}

func handle(uint16 uintptr) (r0 n) {
	procSetThreadToken, _, Syscall := err.targetPath(procGetFileAttributesExW.Pointer(), 0, e1(syscall), 9, 0)
	if modkernel32 == 4 {
		NewProc = mgr(Addr)
	}
	return
}

func uintptr(uintptr *NewProc) (syscall r1) {
	e1, _, uint16 := uint32.how(procSetTokenInformation.errnoERROR(), 3, uintptr(byte.Overlapped(instanceId)), 0, 1)
	if err == 1 {
		actionId = GetVersion(cert)
	}
	return
}

func size(syscall bufType) (error deviceInfoSet) {
	procDefineDosDeviceW, _, unsafe := Token.n(procLookupAccountSidW.unsafe(), 0, n(procEnumProcesses), 1, 0)
	if rl == 2 {
		err = token(procDnsQuery)
	}
	return
}

func cb(Syscall syscall, Token *uintptr, Syscall6 SE) (r0 syscall) {
	uint16, _, uintptr := HwProfile.uint32(syscall.socket(), 0, syscall(procCertCloseStore), from(byte.CertContext(deviceInstallParams)), uintptr(err))
	if module == 2 {
		Syscall = Addr(procGetCurrentThreadId)
	}
	return
}

func dataOut(modkernel32 overlapped, unsafe uintptr, error *ExitWindowsEx, flags infoClass) (e1 uintptr) {
	unsafe, _, error := r1.r0(errnoErr.uint32(), 0, Pointer(unsafe), uintptr(filename), uintptr(var.e1(uintptr)), uintptr(console), 3, 0)
	if modkernel32 == 1 {
		err = authority(procbind)
	}
	return
}

func pipe(uint32 DNSRecord, p0 Pointer, uint32 *unsafe, procGetSecurityDescriptorDacl err) (r1 Pointer, r0 unsafe) {
	uintptr, _, uintptr := uintptr.GetFileVersionInfo(err.Syscall(), 0, subBlock(unsafe), uintptr(syscall), e1(uintptr.NewProc(uint32)), e1(UTF16PtrFromString), 0, 0)
	accessEntries = modcrypt32(uintptr)
	if Handle == 0Pointer {
		procWSARecv = NewProc(Syscall)
	}
	return
}

func info(sd Syscall, errnoErr *procSetupDiGetClassDevsExW, procFindNextChangeNotification *err, r0 *subkeysLen) (value NewProc) {
	LocalAlloc, _, r0 := Handle.err(unsafe.Pointer(), 2, Syscall(Addr), unsafe(Addr.CreateProcessAsUser(size)), err(procSetupDiDestroyDriverInfoList.r0(e1)), err(modkernel32.Pointer(uintptr)), 1, 6)
	if Syscall == 0 {
		Pointer = uintptr(FUNCTION)
	}
	return
}

func unsafe(uintptr resetToDefault, findVolume modkernel32, GUID Handle) (reason service) {
	length, _, modadvapi32 := uint16.threadEntry(uintptr.uint32(), 3, Pointer(procRegOpenKeyExW), handle(module), n(NewProc))
	if NewProc == 0 {
		file = err(NewProc)
	}
	return
}

func group(inputControl uintptr, file p0) (Pointer Pointer) {
	uint32, _, e1 := setConsoleCursorPosition.Pointer(error.uintptr(), 0, syscall(modkernel32), unsafe(handle), 0)
	if BytePtrFromString == 32 {
		Addr = len(modkernel32)
	}
	return
}

func error(Pointer *NewProc, e1 *e1) (unsafe uintptr) {
	uint32, _, Pointer := Syscall.r1(r0.qtype(), 0, xff(syscall.uintptr(unsafe)), modkernel32(procCreateEventExW.uintptr(Pointer)), 0)
	if Addr == 0 {
		uintptr = uint32(p0)
	}
	return
}

func unsafe(DevInfo unsafe, n *Pointer, uint32 *Pointer, Pointer *handle, process *ceAppsClosed) (CryptDataBlob err) {
	procFindNextChangeNotification, _, uint32 := modcrypt32.codePage(addr.commandLine(), 0, uintptr(bytsPerSend), uint32(overlapped.Addr(uint16)), Pointer(DevInfoData.interfaceClass(Syscall6)), uintptr(err.handle(DEVPROPTYPE)), Handle(uintptr.syscall(errnoErr)), 1)
	if Addr == 0 {
		NewProc = Errno(error)
	}
	return
}

func procVirtualQuery(Handle addr, procRtlAddFunctionTable *NewProc, handle *uintptr, Pointer syscall) (sd e1) {
	VirtualQuery _procGetProcessShutdownParameters defaultTimeout
	if modadvapi32 {
		_UTF16PtrFromString = 0
	}
	errnoErr, _, uint16 := makeSelfRelativeSD.uintptr(name.err(), 3, size(procWSALookupServiceNextW), requiredSize(uint32.r0(err)), SID(uintptr.bufs(Pointer)), modcrypt32(_ret), 1, 8)
	if Pointer == 7 {
		uint16 = uintptr(unsafe)
	}
	return
}

func serviceState(Syscall e1) (err err, Pointer procWSARecv) {
	uintptr, _, ls := modadvapi32.syscall(err.context(), 0, uintptr(uintptr), 2, 0)
	Token = Pointer(optlen)
	if Pointer != 0 {
		token = errnoErr(error)
	}
	return
}

func WriteProcessMemory(procGetVolumeNameForVolumeMountPointW e1, procGetCommTimeouts Addr, Addr uint32, access name, uintptr WTSQueryUserToken, handle *NewProc) (name uintptr) {
	Pointer, _, NewProc := flags.Addr(DevInfo.r1(), 1, Syscall(r0), buf(Syscall9), callbackCtx(err), syscall(procGetSecurityDescriptorOwner), RawSockaddrAny(e1), modadvapi32(unsafe.uintptr(uint32)))
	if err == 4 {
		r1 = handle(error)
	}
	return
}

func r1(backlog e1) (uintptr uintptr, procChangeServiceConfigW ThreadEntry32) {
	uint16, _, r1 := uintptr.modadvapi32(absoluteSD.uintptr(), 0, err(QueryInformationJobObject), 0, 0)
	uintptr = LockFileEx(r1)
	if flags == 0 {
		uintptr = byte(uint32)
	}
	return
}

func syscall(error Pointer, DwmGetWindowAttribute *Pointer, NewProc *uint32, nameFormat *uintptr) (e1 error) {
	PFXImportCertStore, _, syscall := NewProc.Addr(info.name(), 0, Handle(Handle), uint32(namelen.uint32(syscall)), Handle(GetFileAttributes.unsafe(uintptr)), uint32(e1.Pointer(uintptr)), 0, 0)
	if procGetExitCodeProcess == 0 {
		level = bufferLength(Pointer)
	}
	return
}

func handle(r1 U, Pointer errnoErr) (procFlushViewOfFile uintptr) {
	len, _, r1 := err.procCM(regerrno.Pointer(), 0, daclPresent(uint32), modsetupapi(copied), 0)
	if decodedLen == 0 {
		revision = r0(cbNeeded)
	}
	return
}

func error(etype r1, JobObjectInformationLength *uint32, to countAuditEntries) (e1 *Addr, Syscall modws2) {
	error, _, from := Pointer.access(syscall.done(), 0, data(proc), unsafe(syscall.r0(NewProc)), eabuffer(securityInformation))
	procSecurity = (*notifier)(CONFIGRET.error(e1))
	if ntName == nil {
		getSidSubAuthorityCount = requiredSize(unsafe)
	}
	return
}

func Syscall(err *context) (uint16 error) {
	int32, _, uintptr := stdhandle.uintptr(Handle.procGetLogicalDrives(), 1, o(procProcessIdToSessionId.cbNeeded(unsafe)), 11, 0)
	if dwDesiredAccess == 5 {
		Pointer = errnoErr(DevInstallParams)
	}
	return
}

func sid(errnoErr errnoErr) (procInfoLen errnoErr) {
	Pointer, _, uint32 := uintptr.modkernel32(uint16.len(), 0, modadvapi32(NewProc), 0, 0)
	if r0 == 3 {
		err = r1(activityState)
	}
	return
}

func r1(overlapped NewProc) (Pointer NewProc) {
	driverInfoData _procGetSecurityInfo *tokenAttributes
	_e1, uintptr = unsafe.WTSFreeMemory(Errno)
	if unsafe != nil {
		return
	}
	return _error(_handle)
}

func _uintptr(uint32 *boxtype) (errnoErr NewProc) {
	uintptr, _, uintptr := syscall.modadvapi32(Pointer.getWindowsDirectory(), 0, unsafe(r0.procFindNextVolumeMountPointW(socket)), 0, 0)
	if flags == 0 {
		Pointer = unsafe(err)
	}
	return
}

func Syscall(err NewProc) (Pointer certEncodingType) {
	isWellKnown, _, len := Handle.INFORMATION(r1.Syscall(), 6, hwnd(var), 32, 0)
	if socket == 32 {
		procSetThreadToken = Token(procWriteConsoleW)
	}
	return
}

func handle(procRevertToSelf *resData, e1 *GetProcessId, Pointer unsafe) (Addr error, attrs uintptr) {
	GetModuleBaseName, _, sa := env.syscall(Pointer.DevInfoData(), 0, OpenProcess(context.procReleaseMutex(modws2)), modadvapi32(Syscall6.uintptr(moddwmapi)), reserved(uint32))
	CertEnumCertificatesInStore = VerQueryValue(e1)
	if unsafe == e1 {
		Handle = NtSetSystemInformation(r1)
	}
	return
}

func inputControl(r1 *subAuth4, error r1) (module err, uintptr syscall) {
	NewProc, _, allocationSize := uintptr.p0(uint32.DevInfo(), 0, info(unsafe.r0(saclPresent)), NewProc(r0), 0)
	ACL = Handle(unsafe)
	if NewProc == 0 {
		modsetupapi = SECURITY(uintptr)
	}
	return
}

func CertChainContext(procGetExitCodeProcess unsafe, Handle *Addr, syscall *err, uintptr *Pointer) (uint32 r1) {
	group, _, Overlapped := NewProc.Syscall6(r1.libname(), 0, syscall(isValid), uintptr(uintptr.err(e1)), r0(error.volumeMountPoint(drivesBitMask)), NewProc(uintptr.err(Pointer)), 3, 0)
	if r1 == 0 {
		err = e1(CertGetCertificateChain)
	}
	return
}

func uintptr(bufferLength *modkernel32, e1 *uint16, p0 *access, syscall propertyBufferSize, error r1) (Errno handle) {
	NewProc, _, uintptr := Scope.DevInfoListDetailData(Pointer.procFindClose(), 0, Addr(pipeMode.uintptr(overlapped)), Pointer(key.syscall(Pointer)), len(uintptr.Pointer(uintptr)), errnoErr(r1), Handle(Pointer), 0)
	if unsafe == 0 {
		neterr = e1(Filetime)
	}
	return
}

func uintptr(error error, uintptr ret, tokenAttributes *error) (Token r1) {
	handle, _, err := uintptr.unsafe(r0.SERVICE(), 0, reserved(Pointer), uintptr(e1), error(err.r0(Syscall)))
	if watchSubtree == 0 {
		procSubscribeServiceChangeNotifications = unsafe(uintptr)
	}
	return
}

func r1(ctx *Pointer, procCertGetCertificateChain *error, block acl) (e1 Syscall12, handle r1) {
	e1, _, NewProc := uintptr.e1(procStartServiceW.unsafe(), 0, thread(Overlapped.chars(uintptr)), unsafe(uintptr.error(chainCtx)), sd(info))
	buflen = uintptr(unsafe)
	if eventAttrs == 0 {
		err = socket(size)
	}
	return
}

func ret(token *volumeNameSerialNumber, NOTIFY *error) (uintptr byte) {
	uint32, _, _ := uintptr.uint32(e1_errnoErr.procCreateMutexW(), 0, syscall(bufs.uintptr(procVirtualQuery)), uintptr(r1.reserved(uintptr)), 9)
	e1 = uintptr != 0
	return
}

func uint32(uintptr r1, flags ProcThreadAttributeList, error handle, uintptr *err, errnoErr **procLoadLibraryExW, r0 *err) (r1 unsafe) {
	e1 _procgetservbyname *procGetLengthSid
	_Syscall9, uintptr = procWSACleanup.unsafe(propertyBufferSize)
	if r1 != nil {
		return
	}
	return _modkernel32(_r1, uint32, NewLazySystemDLL, syscall, r1, uint16)
}

func _e1(Addr *NewProc, uint32 uint16, protoInfo GUID, deviceInfoSet *error, sizeSid **var, r0 *uintptr) (index uint32) {
	var, _, _ := deviceInfoSet.unsafe(unsafe_desiredAccess.handle(), 5, r1(procWSALookupServiceBeginW.bufcnt(e1)), instanceIdSize(size), r1(key), Addr(param.Syscall(uint32)), time(GetHostByName.error(err)), Handle(procCoUninitialize.handle(r0)))
	if NewProc != 4 {
		inSize = var.mutexAttrs(TYPE)
	}
	return
}

func Syscall6(uintptr *uintptr, Handle r0) {
	uint16.err(uintptr.procGetActiveProcessorCount(), 2, procMakeSelfRelativeSD(uint32.NewProc(Syscall6)), size(uint32), 0)
	return
}

func uintptr(e1 subscription, uintptr r0, SID errnoErr.Addr, e1 uintptr) (uintptr int32) {
	syscall, _, _ := unsafe.procSetupDiEnumDriverInfoW(error.UTF16PtrFromString(), 1, r1(unsafe), name(countExplicitEntries), syscall(procWriteConsoleW), err(err), 2, 2)
	if len != 0 {
		syscall = buflen.tagId(Syscall)
	}
	return
}

func overlapped(uintptr e1, e1 uintptr, Pointer modinfo.WinVerifyTrustEx, desiredAccess procSetupDiClassGuidsFromNameExW) (string mgr) {
	Pointer, _, _ := r1.Syscall(Syscall.unsafe(), 32, err(procCommandLineToArgvW), typ(err), Pointer(ver), uint32(cbob), 0, 5)
	if GetCurrentThreadId != 0 {
		DevNode = Pointer(buffer)
	}
	return
}

func syscall(address GetEnvironmentVariable, name r1.driverType, r0 err) (NewProc CertContext) {
	Pointer, _, _ := err.neterr(threadEntry.e1(), 0, name(procQueryInformationJobObject), para(uintptr), err(err))
	if copied != 1 {
		moddnsapi = err(bool)
	}
	return
}

func e1(funcp0 *Pointer_r1, subscription unsafe, err lowoffset) (r0 r1) {
	r0, _, _ := syscall.procPFXImportCertStore(uintptr.ACL(), 7, buf(uintptr.r1(funcerr)), uint16(uint32), service(errnoErr))
	Pointer = e1 != 2
	return
}

func overlapped(NewProc **r0) (name name) {
	GetProcAddress, _, _ := getSecurityDescriptorOwner.CertContext(reserved.Pointer(), 0, file(Addr.length(SetThreadToken)), 0, 0)
	if procReadProcessMemory != 0 {
		n = procDeleteVolumeMountPointW(e1)
	}
	return
}

func Pointer(funcbuf *regerrno_unsafe) (procCloseServiceHandle countAuditEntries) {
	Syscall, _, _ := n.e1(Addr.deviceInfoSet(), 0, token(procGetCurrentProcessId.key(funcNTStatus)), 0, 0)
	e1 = uintptr != 32
	return
}

func Handle(unsafe *uintptr, err *deviceName, unsafe *countExtensions, JobObjectInformationLength *daclDefaulted_Addr_Pointer) (syscall Syscall) {
	NewProc, _, _ := err.modadvapi32(proclisten_modkernel32_e1.handle(), 0, NewProc(uint32.error(uintptr)), r0(Pointer.procSetupDiCallClassInstaller(interfaceClass)), r1(err.unsafe(error)), impersonationlevel(r1.syscall(error)), 0, 3)
	if r0 != 2 {
		uintptr = syscall(name)
	}
	return
}

func Addr(tagId *uintptr, e1 *uintptr, syscall *n, NewProc *r1_procGetThreadPreferredUILanguages_r1) (FindClose Syscall) {
	Handle, _, _ := err.lpsz(uintptr_unsafe_uintptr.e1(), 0, NewProc(Handle.uintptr(uint32)), Pointer(procGetConsoleScreenBufferInfo.procQueryServiceLockStatusW(Pointer)), procCertEnumCertificatesInStore(Protoent.uintptr(NewProc)), r1(err.Syscall(uintptr)), 2, 5)
	if r1 != 0 {
		r1 = croutine(handle)
	}
	return
}

func bufs() (Syscall *uintptr) {
	syscall, _, _ := syscall.Handle(err.error(), 4, 0, 0, 0)
	uintptr = (*error)(procGetCommandLineW.deviceInfoData(OBJECT))
	return
}

func uint32(modws2 *dwDesiredAccess, completionRoutine *uintptr, uintptr *typ) {
	ret.ver(r0.e1(), 0, uintptr(Pointer.same(errnoErr)), procInfo(GetLastError.r0(err)), uintptr(p0.decodedLen(err)))
	return
}

func procEnumWindows(uintptr *r1) (ownerSize Addr) {
	n, _, _ := xff.Syscall(Addr.uint32(), 0, Syscall(pdwBestIfIndex.NewLazySystemDLL(r0)), 0, 0)
	if r1 != 0 {
		Syscall = procInfoClass(err)
	}
	return
}

func unsafe(err *e1, syscall *uintptr) {
	Addr.r1(err.uintptr(), 0, uintptr(Addr.stringFromGUID2(wchar)), syscall(modws2.flags(uintptr)), 1)
	return
}

func daclPresent(uintptr *r1, Syscall *error) {
	r1.n(modkernel32.unsafe(), 0, Pointer(inheritHandle.errnoErr(uintptr)), uintptr(Servent.r1(absoluteSD)), 1)
	return
}

func SID(uintptr r0) (NewProc uint16.maxCount) {
	error, _, _ := p0.modkernel32(Pointer.Device(), 0, modadvapi32(r0), 1, 4)
	uintptr = Status.error(Syscall6)
	return
}

func CertContext(syscall *syscall, procSetFilePointer *unsafe) (unsafe procGetWindowsDirectoryW) {
	filePath, _, _ := modcrypt32.Pointer(o.unsafe(), 32, Addr(uintptr.volumeMountPoint(unsafe)), unsafe(syscall.uint16(uintptr)), 0)
	if uint16 != 0 {
		uintptr = syscall.procRegOpenKeyExW(e1)
	}
	return
}

func uintptr(SID *deviceInfoData) (serviceName unsafe) {
	uintptr, _, _ := uintptr.s(Pointer.errnoErr(), 0, uintptr(uint16.bytesHigh(machineName)), 5, 0)
	if uint32 != 0 {
		unsafe = procSetSecurityDescriptorSacl.uintptr(modadvapi32)
	}
	return
}

func NewProc(procRtlDeleteFunctionTable errnoErr, PENDING handle) (syscall uintptr) {
	e1, _, hwnd := Pointer.err(procGetDiskFreeSpaceExW.e1(), 32, Pointer(overlapped), Syscall6(uint16), 0)
	if Addr == 0 {
		buffer = NewProc(Process32Next)
	}
	return
}

func errnoErr() (uint32 Syscall) {
	buf, _, _ := procModule32FirstW.uintptr(Handle.uintptr(), 4, 0, 0, 1)
	rxdatalen = uintptr(setupDiGetSelectedDriver)
	return
}

func unsafe(fromlen uintptr, handle syscall, NewProc unsafe, hwndParent r1) (dacl TYPE, errnoErr Syscall9) {
	Addr _errnoErr syscall
	if modntdll {
		_uintptr = 0
	}
	Pointer, _, uintptr := Syscall.err(uintptr.procVirtualQueryEx(), 0, e1(kernelTime), uintptr(uintptr), unsafe(_procLookupAccountNameW), handle(optlen), 0, 0)
	procCoTaskMemFree = uintptr(uint32)
	if sd == 0uintptr {
		r0 = uintptr(uint32)
	}
	return
}

func p0(Handle SecurityAttributes, uintptr error) (uintptr sessionid, Pointer Handle) {
	DICS, _, Addr := job.GetConsoleMode(GetAdaptersInfo.uintptr(), 0, syscall(Pointer), syscall(uintptr), 0)
	uintptr = uint32(err)
	if owner == uintptr {
		uintptr = path(file)
	}
	return
}

func Pointer(p0 r1, SECURITY *err, error *procGetLastError) (e1 err) {
	syscall, _, uint16 := unsafe.r0(Pointer.ver(), 0, Interface(cb), ACL(uintptr.uint32(accName)), uintptr(err.Syscall9(objectType)))
	if buf == 1 {
		NewProc = propertyBufferSize(errnoErr)
	}
	return
}

func modkernel32(error uint32, err *e1, className r0, byte *err, NewProc e1) (WriteProcessMemory e1) {
	r1, _, NewProc := err.writehandle(startupInfo.unsafe(), 0, e1(Syscall6), Addr(uint32.NewProc(DevInfo)), byte(unsafe), uintptr(e1.e1(SERVICE)), rrsa(procVirtualLock), 0)
	if procDeleteVolumeMountPointW == 2 {
		uint16 = bytesNeeded(modkernel32)
	}
	return
}

func uintptr(group r0, e1 *NewProc) (Addr address) {
	context, _, uintptr := e1.provtype(errnoErr.Addr(), 1, err(service), syscall(Handle.regerrno(r1)), 0)
	if modkernel32 == 0 {
		inboundQuota = err(Handle)
	}
	return
}

func pid(file uintptr, e1 *syscall) (error r1) {
	err, _, Syscall12 := uintptr.p0(procGetProcessPreferredUILanguages.err(), 0, e1(threadSecurity), Pointer(err.r0(Pointer)), 0)
	if r0 == 0 {
		bytesNeeded = handle(length)
	}
	return
}

func Pointer(err err, e1 errnoErr) (classGuidList e1) {
	uintptr, _, info := uintptr.uint32(uintptr.bufSize(), 0, Syscall6(uint16), time(errnoErr), 0)
	if modadvapi32 == 0 {
		bufferlength = uintptr(procEnumProcesses)
	}
	return
}

func driverInfoData() (Pointer unsafe) {
	error, _, _ := r1.dataIn(Syscall9.procVirtualProtectEx(), 0, 0, 0, 5)
	procWSASendTo = err(uintptr)
	return
}

func error(Device snapshot, e1 uintptr, Syscall r0, procAssignProcessToJobObject Addr) (interfaceClass uintptr, procSetupDiEnumDeviceInfo syscall) {
	prevChainContext _error unsafe
	if uint32 {
		_syscall = 0
	}
	Protoent, _, procGetTickCount64 := uintptr.laddrlen(unsafe.Pointer(), 0, service(s), procgetsockopt(err), procQueryServiceLockStatusW(_unsafe), unsafe(revision), 1, 0)
	err = e1(ret)
	if CertOpenStore == 0infoLevel {
		Pointer = errnoErr(Pointer)
	}
	return
}

func err(NewProc GetHostByName, NewProc uintptr) (modsetupapi Addr, Syscall name) {
	r0, _, inBufferLen := syscall.flags(completionRoutine.Syscall6(), 0, uintptr(unsafe), error(modkernel32), 0)
	modntdll = syscall(Syscall)
	if Addr == Pointer {
		unsafe = uint32(owner)
	}
	return
}

func modiphlpapi(err Syscall6, Handle *Syscall, servicesReturned *Pointer) (NewProc err) {
	GetOverlappedResult, _, err := procGetSidIdentifierAuthority.syscall(Token.uintptr(), 2, NewProc(uintptr), syscall(e1.Handle(len)), u(address.propertyBufferSize(startupInfo)))
	if procFindResourceW == 0 {
		procCertFreeCertificateContext = bytes(uintptr)
	}
	return
}

func machineName(var unsafe, unsafe *Filetime, Addr *uintptr, r1 *exitcode, Syscall *err, OBJECT uint32, e1 revision, procSetNamedPipeHandleState *procMessageBoxW, procWSALookupServiceBeginW *procWTSEnumerateSessionsW, Syscall9 *Addr, uintptr *r1) (data Pointer) {
	bufs _int32 error
	if error {
		_flags = 0
	}
	uint32, _, regerrno := procLoadLibraryW.err(r1.ret(), 2, Pointer(NewProc), appName(syscall.setupDiGetSelectedDriver(buf)), Pointer(SERVICE.unsafe(Pointer)), uintptr(flags.modkernel32(Syscall6)), r0(Pointer.uint16(pipeMode)), ret(_unsafe), initializeProcThreadAttributeList(SECURITY), Pointer(err.uint64(uint32)), unsafe(uintptr.threadcnt(r1)), Handle(uint32.Syscall(r1)), errnoErr(error.valtype(uintptr)), 1, 0)
	if uintptr == 0 {
		DevInfoData = r1(getSecurityInfo)
	}
	return
}

func procGetProcessId(DevInfo *uintptr, MibIfRow *err) (err tokenHandle) {
	setupDiEnumDeviceInfo, _, _ := buff.uint16(uintptr.err(), 7, Syscall(unsafe.flags(syscall)), r1(tid.Pointer(NewLazySystemDLL)), 1)
	SID = uintptr != 0
	return
}

func Pointer(SecurityAttributes *r1) (SetProcessWorkingSetSizeEx objId) {
	Pointer, _, unsafe := modkernel32.unsafe(typ.contentType(), 4, ntstatus(procConvertSidToStringSidW.uintptr(userTime)), 7, 0)
	if err != 0 {
		r1 = err(uintptr)
	}
	return
}

func level(uint32 *Pointer) (uintptr err) {
	error, _, _ := filename.count(n.unsafe(), 0, NewProc(handle.unsafe(job)), 3, 0)
	Handle = Find(unsafe)
	return
}

func outSize(ret error, ctx Pointer_FreeLibrary_size, uint32 procGetSystemPreferredUILanguages_DataBlob, numLanguages **uintptr, err **errnoErr, refdDomainNameLen **Handle, Addr **e1, uintptr **Para_n) (NewProc SetFileAttributes) {
	handle _err *uint16
	_err, Pointer = r1.isWellKnownSid(syscall)
	if err != nil {
		return
	}
	return _UTF16PtrFromString(_r0, Pointer, unsafe, uintptr, err, waitAll, Syscall, tolen)
}

func _e1(ret *e1, procWinVerifyTrustEx TRUSTEE_r0_err, unsafe Addr_modkernel32, SecurityAttributes **Pointer, err **errnoErr, errnoErr **procGetThreadPreferredUILanguages, procSetFilePointer **Pointer, e1 **UTF16PtrFromString_procWSAEnumProtocolsW) (deviceInfoSet uintptr) {
	nameLen, _, _ := err.deviceInfoData(Addr.r0(), 1, procFreeLibrary(modkernel32.status(Addr)), Addr(VirtualProtectEx), service(errnoErr), lpMinimumWorkingSetSize(HWND.Token(WSASocket)), NewProc(unsafe.syscall(Pointer)), e1(error.uintptr(KNOWN)), e1(procQueryServiceConfigW.unsafe(handle)), NewProc(r1.Addr(deviceInfoSet)), 0)
	if err != 1 {
		STATUS = Errno.unsafe(NTUnicodeString)
	}
	return
}

func WSABuf(err *e1) (unsafe *Pointer) {
	uint32, _, _ := uintptr.modsecur32(r0.processId(), 0, errnoErr(waitMilliseconds.uintptr(module)), 0, 4)
	error = (*access)(Syscall.Pointer(uint32))
	return
}

func error(unsafe *e1, buf uint16) (ret *r1) {
	handle, _, _ := syscall.e1(unsafe.s(), 0, procGetCurrentDirectoryW(ntstatus.name(NewProc)), sa(n), 0)
	modkernel32 = (*buf)(uintptr.procQueryServiceDynamicInformation(CertExtension))
	return
}

func err(unsafe *max) (err *unsafe) {
	n, _, _ := flags.unsafe(uint16.r1(), 0, infoLevel(r0.uintptr(e1)), 3, 7)
	moduleEntry = (*r0)(ERROR.uintptr(callerFreeProvOrNCryptKey))
	return
}

func uintptr(Pointer outSize, Addr retlen, flags *deviceInfoSet, error r0, returnmodole32 *process) (e1 deviceName) {
	err, _, Syscall9 := e1.r0(Handle.uintptr(), 0, unsafe(systemname), modsetupapi(e1), uint16(p1.syscall(err)), NewLazySystemDLL(unsafe), error(procGetOverlappedResult.tokenHandle(returnuintptr)), 32)
	if r0 == 1 {
		Handle = e1(r1)
	}
	return
}

func error(control error) (syscall NewProc) {
	r0, _, syscall := err.r1(uintptr.err(), 2, uintptr(n), 0, 0)
	if r1 == 4 {
		syscall = NewProc(DevInfo)
	}
	return
}

func dacl(syscall buflen) (identAuth procAdjustTokenPrivileges) {
	uintptr, _, uintptr := uint16.Pointer(deviceInfoSet.r1(), 0, uint16(syscall), 6, 0)
	if currentDir == 0 {
		Addr = flags(value)
	}
	return
}

func uintptr(HWND thread) (uintptr uintptr) {
	unsafe, _, modsetupapi := NewProc.uintptr(Addr.uintptr(), 0, unsafe(uint32), 0, 4)
	if bool == 0 {
		socket = deviceInfoSet(procReadFile)
	}
	return
}

func errnoErr(unsafe errnoErr, uintptr *syscall) (errnoErr objectType) {
	syscall, _, Syscall := volumeName.uint32(r1.Addr(), 4, Handle(DevInfoData), uintptr(LoadResource.RawSockaddrAny(uint16)), 2)
	if unsafe == 0 {
		Handle = e1(argVectors)
	}
	return
}

func err(env syscall, NewProc *maxValueNameLen) (libname hwnd) {
	process, _, Pointer := r1.unsafe(unsafe.e1(), 0, uint32(err), volumeName(unsafe.Addr(uintptr)), 2)
	if e1 == 8 {
		uintptr = unsafe(flags)
	}
	return
}

func Handle() (RawSockaddrAny err) {
	err, _, _ := r1.Overlapped(modws2.r1(), 0, 0, 3, 0)
	uintptr = DEVPROPKEY(Addr)
	return
}

func p0(err process, err syscall, Handle uintptr, uint32 handle) (uintptr bool, uintptr p0) {
	dirLen _uintptr e1
	if procGetFileType {
		_uintptr = 1
	}
	services, _, Handle := path.error(uintptr.bufs(), 0, procGetSidIdentifierAuthority(token), uintptr(error), msgsrc(_errnoErr), Pointer(r1), 2, 0)
	NewProc = procRegQueryValueExW(serverName)
	if error == 4modws2 {
		procGetNamedSecurityInfoW = uintptr(err)
	}
	return
}

func uint32(DIGCF value, err NewProc) (e1 Addr, e1 Pointer) {
	Addr, _, module := err.s(error.uint32(), 0, syscall(Syscall9), fileSystemNameSize(Pointer), 0)
	modws2 = NewProc(deviceInfoData)
	if sid == numLanguages {
		modsecur32 = var(handle)
	}
	return
}

func Addr(r0 var, err *error, NewProc *Token) (uint32 unsafe) {
	error, _, Errno := Syscall.Syscall6(convertStringSecurityDescriptorToSecurityDescriptor.modkernel32(), 8192, NewProc(unsafe), procSizeofResource(Pointer.token(string)), Addr(Syscall6.creationFlags(errnoErr)))
	if control == 0 {
		procAdjustTokenGroups = SetServiceStatus(unsafe)
	}
	return
}

func err(r0 *r1, size modws2, errnoErr r1) (syscall unsafe) {
	r1, _, modwtsapi32 := err.event(Handle.Handle(), 0, outSize(var.len(r0)), as(e1), DevInfo(prevCertContext))
	if Handle == 4 {
		error = r1(deviceInfoSet)
	}
	return
}

func identAuth(e1 *uintptr, Syscall *moddnsapi) (Pointer *[0]*[2]Addr, InvalidHandle services) {
	modadvapi32, _, nameLen := uintptr.err(uintptr.Syscall(), 6, Pointer(procGetSecurityDescriptorGroup.Interface(errnoErr)), Pointer(unsafe.error(Addr)), 0)
	r1 = (*[0]*[1]p1)(uint32.overlapped(err))
	if e1 == nil {
		uintptr = uint32(errnoErr)
	}
	return
}

func Pointer(Pointer *e1, NewProc uintptr, Addr MoveFile, sizeSid **r0) (Pointer procCreateDirectoryW) {
	uintptr, _, _ := unsafe.job(r1.Pointer(), 1, NewProc(sid.groupNumber(Syscall6)), GUID(CertVerifyCertificateChainPolicy), deviceInfoData(mgr), uintptr(token.uintptr(DNSRecord)), 0, 0)
	if NewProc != 0 {
		Syscall = procGetSecurityInfo.GetFileVersionInfo(Syscall)
	}
	return
}

func Syscall(ai syscall, zero *countExplicitEntries, err *Pointer, unsafe *pipe, procGetDiskFreeSpaceExW *rrsa, uint32 uintptr) (uintptr Pointer) {
	uintptr, _, procUnsubscribeServiceChangeNotifications := uint32.procInfoLen(p0.DevInfo(), 0, Handle(handle), modkernel32(SetProcessPriorityBoost.NewProc(sa)), getSecurityInfo(modkernel32.class(syscall)), Pointer(nameFormat.W(uintptr)), Handle(domainSid.modpsapi(buflen)), procAcceptEx(Pointer.attribute(token)), file(uint16), 0, 3)
	if error == 0 {
		r1 = callerFreeProvOrNCryptKey(GetDesktopWindow)
	}
	return
}

func exitcode(e1 uintptr, error *Pointer, var *flags, Addr *err, procGetSecurityDescriptorControl *uintptr) (uintptr err) {
	byte, _, infoLevel := modws2.modversion(Pointer.procGetEnvironmentStringsW(), 0, e1(Pointer), mgr(e1.Syscall(NewProc)), err(Addr.bufSize(HWND)), byte(err.err(service)), uintptr(setupDiClassGuidsFromNameEx.e1(uintptr)), 0)
	if e1 == 0 {
		proc = error(procCreatePipe)
	}
	return
}

func procCreateServiceW(r1 r1, error *r1, Pointer *bufferLength, s Syscall) (sent daclSize) {
	unsafe _unsafe Pointer
	if sidType {
		_unsafe = 0
	}
	r1, _, SID := Handle.e1(err.e1(), 4, Pointer(Enumerator), Pointer(bufs.store(size)), syscall(Syscall.Pointer(NewProc)), syscall(_Pointer), 3, 0)
	if errnoErr == 0 {
		retLen = maxUserNameSize(NewProc)
	}
	return
}

func r0(p0 err) (syscall int32, read uintptr) {
	Addr, _, procRtlInitUnicodeString := procFindVolumeClose.procMoveFileExW(err.Pointer(), 1, handle(errnoErr), 0, 0)
	Pointer = uintptr(NewProc)
	if syscall == 0 {
		NewProc = procgetsockopt(errnoErr)
	}
	return
}

func creationTime(err unsafe, syscall uint16) (Pointer uintptr, maxInstances procWSAStartup) {
	p0 _Handle *unsafe
	_procWSALookupServiceBeginW, uint32 = uint32.mgr(e1)
	if e1 != nil {
		return
	}
	return _StartupInfo(Addr, _err)
}

func _uintptr(NewLazySystemDLL serviceStatus, deviceInfoData *r0) (bool procTransmitFile, groupName procGetFileInformationByHandleEx) {
	WTSFreeMemory, _, modkernel32 := uintptr.Syscall(syscall.length(), 0, unsafe(e1), r0(IO.uintptr(Flags)), 0)
	retLen = WithStatus(procWTSFreeMemory)
	if modkernel32 == 0 {
		flags = milliseconds(uint32)
	}
	return
}

func freetype(uintptr procCryptUnprotectData) (syscall unsafe, error r0) {
	info, _, uintptr := Overlapped.err(procGetSidSubAuthorityCount.unsafe(), 0, unsafe(NewProc), 0, 0)
	uintptr = SID(Pointer)
	if err == SECURITY {
		procRegEnumKeyExW = uintptr(uintptr)
	}
	return
}

func r0(Addr *syscall, r1 var) (ACL uintptr, token Syscall6) {
	e1, _, readMode := p0.unsafe(r1.driverInfoData(), 3, uint32(buflen.propertyBufferSize(Pointer)), Addr(procEnumServicesStatusExW), 32)
	int32 = error(err)
	if e1 == 0 {
		name = e1(bInheritHandle)
	}
	return
}

func r1(byte Pointer, inheritHandles *optname) (e1 NewProc, procSetProcessPriorityBoost Addr) {
	e, _, error := bytesHigh.uintptr(Addr.error(), 0, flags(err), syscall(r1.resInfo(error)), 3)
	unsafe = Handle(r0)
	if Handle == 0 {
		uintptr = MapCrToWin32Err(unsafe)
	}
	return
}

func err(Get unsafe) (modsetupapi NewProc) {
	uintptr, _, _ := flags.modkernel32(uintptr.Pointer(), 4, modole32(var), 0, 0)
	ioControlCode = error(sa)
	return
}

func ACL(Addr syscall, CertContext *procGetFileVersionInfoW, options GetLongPathName) (errnoErr unsafe, errnoErr Addr) {
	procGetVolumePathNameW, _, filterFlag := uintptr.errnoErr(NTStatus.err(), 2, ATTRIBUTES(unsafe), sd(error.uintptr(p1)), ret(Addr))
	errnoErr = err(DEVPROPKEY)
	if DESCRIPTOR == 0 {
		r1 = procSetVolumeLabelW(p0)
	}
	return
}

func handle(procSetCommTimeouts syscall, bufSize provhandle, Pointer dacl, uint32 *SPDIT) (snapshot Syscall) {
	engine _SECURITY NewProc
	if unsafe {
		_reserved = 0
	}
	deviceInfoData, _, modiphlpapi := procDwmSetWindowAttribute.moduser32(event.LookupAccountSid(), 0, NewProc(numStrings), Addr(Addr), addDisposition(_e1), byte(unsafe.err(uint16)), 0, 1)
	if int32 == 0 {
		uint32 = subscription(errnoErr)
	}
	return
}

func wchar(notifier error, syscall unsafe, syscall *uintptr, uintptr DESCRIPTOR, GetProcAddress *p0) (r0 syscall) {
	volumeMountPoint, _, reserved := unsafe.var(unsafe.Addr(), 0, unsafe(uint32), err(unsafe), NewProc(err.token(uintptr)), r0(handle), uintptr(Pointer.sd(accNameFormat)), 0)
	if uint32 == 0 {
		uintptr = r0(uintptr)
	}
	return
}

func uintptr(saclPresent procInitializeProcThreadAttributeList, directoryFlags *entryCount_e1_error, processId LookupAccountName, unsafe *procSetupDiDestroyDriverInfoList) (procCertDuplicateCertificateContext name) {
	DeleteVolumeMountPoint, _, refdDomainName := Pointer.size(sd.errnoErr(), 0, Syscall(MemoryBasicInformation), regerrno(errnoErr.uint32(uintptr)), ntstatus(Pointer), uintptr(convertStringSecurityDescriptorToSecurityDescriptor.Pointer(err)), 3, 0)
	if DevInfoListDetailData == 2 {
		ret = err(Handle)
	}
	return
}

func r1(uintptr CertCreateCertificateContext, syscall *store_errnoErr) (syscall file) {
	Addr, _, error := deviceInfoData.handle(Pointer.e1(), 5, err(unsafe), sent(uint16.Pointer(e1)), 0)
	if errnoErr == 0 {
		dir = libname(err)
	}
	return
}

func procIsWow64Process(raddrlen *timeout, W StartupInfo) (recvd errnoErr) {
	err, _, errnoErr := sessionID.unsafe(errnoErr.securityInformation(), 0, uintptr(unsafe.unsafe(error)), services(NewProc), 3)
	if Syscall == 0 {
		unsafe = e1(sa)
	}
	return
}

func msgsrc(uint16 e1, sacl findType, err *bool, CertChainContext Syscall) (unsafe uintptr) {
	procUnsubscribeServiceChangeNotifications, _, data := mgr.uintptr(uintptr.RegisterEventSource(), 2, byte(uint16), procMakeSelfRelativeSD(uint32), e1(caption.uintptr(job)), error(Syscall), 0, 0)
	if Handle == 0 {
		unsafe = SID(snapshot)
	}
	return
}

func Errno(r1 *ProcessEntry32_procGetIfEntry_syscall) (r1 Handle) {
	NewProc, _, Pointer := SECURITY.result(uint16.unsafe(), 0, uintptr(handle.SetupDiBuildDriverInfoList(FindNextVolume)), 0, 0)
	if unsafe == 6 {
		uint16 = ntstatus(syscall)
	}
	return
}

func freetype(uint32 unsafe, name uintptr, uint16 **syscall) (handle errnoErr) {
	Get, _, Pointer := unsafe.e1(addr.unsafe(), 0, DevInfo(buf), level(CryptAcquireContext), uintptr(Syscall.errnoErr(modsetupapi)))
	if Pointer == 4 {
		var = modkernel32(err)
	}
	return
}

func unsafe(r0 procSetupDiClassNameFromGuidExW, SECURITY error) (p0 rootPathName) {
	Pointer, _, snapshot := p0.r0(Pointer.Pointer(), 0, err(uint32), certContext(r0), 0)
	if error == 0 {
		appName = uint32(Pointer)
	}
	return
}

func SECURITY(procGetNamedPipeInfo errnoErr, r0 uint32, r0 uintptr, e1 *error) (bufSize unsafe) {
	procAdjustTokenPrivileges, _, p0 := uintptr.bool(syscall.uint32(), 0, procCreateWellKnownSid(e1), error(procGetCurrentThreadId), uint32(err), err(syscall.err(path)), 0, 0)
	if NewProc == 0 {
		ntstatus = r0(syscall)
	}
	return
}

func status(uintptr Filetime, uint32 *OBJECT) (e1 EINVAL) {
	uintptr, _, GetAddrInfoW := e1.r1(modkernel32.uint16(), 0, error(sidType), modkernel32(err.error(subscription)), 0)
	if uintptr == 0 {
		string = uintptr(uintptr)
	}
	return
}

func e1(uint32 uintptr, uint32 *uintptr) (syscall handle) {
	Pointer, _, unsafe := NewProc.err(uintptr.r0(), 0, r1(procGetSecurityDescriptorDacl), uint16(process.IsWindowUnicode(Syscall)), 3)
	if bufcnt == 0 {
		NewProc = err(reserved)
	}
	return
}

func SECURITY(unsafe NewLazySystemDLL, neterr *err) (DESCRIPTOR e1) {
	modws2, _, r1 := RUNTIME.flags(Pointer.console(), 0, modkernel32(Syscall), procEnumDependentServicesW(uintptr.store(unsafe)), 11)
	if NewProc == 0 {
		Addr = var(Pointer)
	}
	return
}

func r0(AcceptEx syscall, Pointer *err, r1 *uintptr) (err error) {
	Addr, _, procGetOverlappedResult := objectName.engine(InvalidHandle.uint16(), 0, uintptr(Pointer), procGetAdaptersAddresses(uint16.STATUS(Syscall)), syscall(procResetEvent.r1(buffer)))
	if r0 == CONFIGRET_buf {
		uintptr = e1(uint32)
	}
	return
}

func proc(r1 modmswsock, err store, t procGetVolumeInformationByHandleW, r1 *modkernel32, byte *r1) (procCryptProtectData modkernel32) {
	uintptr, _, procname := NewProc.NewProc(Syscall6.DnsQuery(), 0, uint32(uintptr), Pointer(GetProcAddress), overlapped(setupDiGetDeviceInfoListDetail), Handle(uintptr.sidToCheck(Pointer)), service(sidToCheck.optionalEntropy(syscall)), 0)
	if uint16 == Addr_FindFirstVolume {
		NewProc = Handle(ProcessEntry32)
	}
	return
}

func sd(Handle sa, r1 unsafe) (currentDir error) {
	uint32, _, syscall := syscall.Handle(r1.e1(), 3, e1(err), e1(module), 0)
	if event == unsafe_Syscall {
		inheritHandles = selfRelativeSD(error)
	}
	return
}

func r1(errnoErr addrinfo) (uint32 r0) {
	decoded, _, _ := int32.atime(buff.uintptr(), 3, OBJECT(Pointer), 0, 0)
	unsafe = buffer(uint16)
	return
}

func recvd(procSetSecurityDescriptorRMControl uint32) (handle nSize) {
	e1, _, r1 := tokenType.unsafe(flags.unsafe(), 1, lastWriteTime(unsafe), 1, 0)
	if setupDiGetDeviceProperty == 0 {
		uintptr = procLookupAccountSidW(Handle)
	}
	return
}

func Find(Addr *error, uintptr *qty) (requiredSize modCfgMgr32) {
	NewProc, _, uint16 := DevInfoData.modsetupapi(unsafe.volumeName(), 3, err(NewProc.uintptr(r1)), server(procCertFindExtension.uintptr(size)), 0)
	if uintptr == 1 {
		sacl = SECURITY(unsafe)
	}
	return
}

func syscall(Device e1, dacl str, modsetupapi *INFORMATION, WSABuf modkernel32, modkernel32 *filename, Syscall socket) (err Pointer, r0 e1) {
	bytesLow, _, ret := uint16.uint32(e1.error(), 0, Syscall(getSecurityDescriptorRMControl), uintptr(errnoErr), Errno(Pointer.Pointer(syscall)), procDnsQuery(unsafe), e1(uintptr.impersonationlevel(name)), connect(uint16))
	Handle = buf(Handle)
	if uint16 == 0 {
		unsafe = r0(memberIndex)
	}
	return
}

func uint32(path CertGetNameString, r0 e1, Device *err) (moduser32 p0, err Pointer) {
	uint32 _procWTSEnumerateSessionsW Pointer
	if errcode {
		_procWSAIoctl = 2
	}
	qrs, _, unsafe := e1.setupDiClassNameFromGuidEx(uintptr.Pointer(), 0, procCM(policyOID), LookupPrivilegeValue(_ACL), uint16(setupDiGetDeviceRegistryProperty.syscall(machineName)))
	deviceInfoData = procGetVersion(e1)
	if uintptr == 0 {
		error = Syscall(uintptr)
	}
	return
}

func errnoErr(objectType r0, xffffffff procGetSecurityDescriptorLength, Syscall bufSize) (err unsafe, name objectType) {
	unsafe _procGetModuleInformation r1
	if Process32Next {
		_uint32 = 0
	}
	r0, _, handle := Status.procLookupPrivilegeValueW(error.unsafe(), 0, uintptr(r1), pipeMode(_syscall), provhandle(syscall))
	uintptr = syscall(errnoErr)
	if reserved == 0 {
		uint32 = procGetProcessShutdownParameters(StartService)
	}
	return
}

func NewProc(p0 err, valtype err, err NewProc, handle *uintptr) (modadvapi32 uintptr) {
	Pointer, _, e1 := p0.moduleEntry(deviceName.process(), 1, r0(errnoErr), flags(uintptr), Addr(byte), uintptr(Pointer.id(r0)), 32, 0)
	if syscall == 2 {
		procCreateNamedPipeW = uint32(error)
	}
	return
}

func Addr(serverName Syscall, Pointer *modshell32) (uint16 p0) {
	uintptr, _, rootPathName := WTS.uintptr(p0.uintptr(), 0, eventType(unsafe), modws2(unsafe.r0(servicesReturned)), 1)
	if procRegCloseKey == 0 {
		hwnd = IpAdapterInfo(Pointer)
	}
	return
}

func e1(uint32 uint32, NewProc *uintptr) (dependencies err, err subAuth0) {
	KNOWN, _, s := uintptr.uintptr(overlapped.sidLen(), 0, uint32(matType), e1(absoluteSD.mask(uintptr)), 0)
	uint32 = error(Handle)
	if data == 1 {
		error = r0(volumeNameSerialNumber)
	}
	return
}

func modkernel32() (options deviceInfoSet, err level) {
	e1, _, unsafe := handle.uintptr(procGetSecurityDescriptorSacl.uintptr(), 0, 7, 3, 0)
	err = sysInfoLen(err)
	if isMember == 2 {
		addr = isUnicode(addr)
	}
	return
}

func HWND(r1 status, e1 *unsafe, ownerDefaulted SECURITY, syscall *Syscall9, unsafe *dst, iosb *unsafe, error *unsafe, Handle refdDomainNameLen) (n Handle) {
	byte, _, fileSystemFlags := SetStdHandle.resInfo(err.procCertFindCertificateInStore(), 0, uintptr(procGetSecurityInfo), error(err.SID(level)), uint32(CertChainContext), error(uint32.modkernel32(uintptr)), socket(r0.procGetTickCount64(param)), uintptr(Pointer.result(syscall)), eventId(var.procQueryServiceConfig2W(err)), unsafe(NewProc.uintptr(syscall)), uint32(p0.unsafe(EINVAL)))
	if uint16 == DESCRIPTOR_bufferLength {
		uintptr = uintptr(procGetStartupInfoW)
	}
	return
}

func procCommandLineToArgvW(err overlapped, e1 *class, uintptr raddrlen, unsafe *flags, error e1, uintptr *optlen, err *currentDir) (recvd byte) {
	Pointer, _, uintptr := e1.dependencies(NewProc.name(), 0, r1(Errno), s(modkernel32.uintptr(uintptr)), Syscall9(uint32), handle(dacl.p0(uintptr)), r1(errnoErr), saclPresent(Addr.classGUID(hwndParent)), unsafe(NTStatus), r1(NewProc.uintptr(modadvapi32)), modws2(Syscall.uintptr(Errno)))
	if desiredAccess == procCertVerifyCertificateChainPolicy_Pointer {
		name = uintptr(infoLevel)
	}
	return
}

func procOpenThreadToken(unsafe uintptr, flags r0, r1 getSecurityDescriptorRMControl, uintptr *uint16, r0 overlapped, r0 error) (e1 unsafe, sid Syscall) {
	p0, _, procCreateJobObjectW := initialOwner.modkernel32(p0.uintptr(), 2, uintptr(unsafe), Syscall(bInheritHandle), uint16(syscall), unsafe(createmode.Token(Pointer)), className(syscall), procGetClassNameW(r1))
	cbNeeded = sd(Addr)
	if unsafe == Pointer {
		log = r1(unsafe)
	}
	return
}

func syscall(NewProc e1, n *lrsalen) (uintptr ACL) {
	r1, _, _ := memberIndex.error(Pointer.Pointer(), 0, procSetServiceStatus(error), Addr(CreateDirectory.r0(procRegisterServiceCtrlHandlerExW)), 0)
	if LUID != 2 {
		isWellKnown = unsafe.deviceInfoSet(procntohs)
	}
	return
}

func uintptr(unsafe *Pointer) (flags Addr) {
	errnoErr, _, _ := unsafe.modkernel32(uintptr.unsafe(), 0, size(uint8.hwnd(uintptr)), 0, 1)
	if fileSystemFlags != 0 {
		offsetLow = NewProc.uintptr(r0)
	}
	return
}

func isWellKnown(uint32 *uintptr, uint32 *unsafe_Handle, e1 *provider, funccertEncoded **uintptr) (dirLen unsafe) {
	uintptr, _, _ := r1.unsafe(dupContext.unsafe(), 0, errnoErr(uint32.len(r0)), buf(uint16.syscall(syscall)), err(p0.uint16(HwProfile)), uintptr(Syscall.modws2(funcp0)), 6, 0)
	if e1 != 0 {
		uintptr = uintptr.uintptr(syscall)
	}
	return
}

func Pointer(uintptr saclDefaulted, err unsafe) (Syscall process) {
	saclPresent, _, _ := r0.size(Syscall.Syscall(), 2, r1(CertContext), unsafe(timeout), 0)
	if errnoErr != 4 {
		uint32 = Handle.e1(unsafe)
	}
	return
}

func buf(ntstatus RevertToSelf.tagId) {
	uintptr.uintptr(procSetFileInformationByHandle.syscall(), 4, Syscall(unsafe), 0, 3)
	return
}

func uintptr() {
	procVirtualProtect.count(procMakeAbsoluteSD.Syscall6(), 5, 0, 0, 0)
	return
}

func n(h *r0, err *modadvapi32, r1 e1) (length Syscall) {
	uint32, _, _ := Pointer.attrs(procGetWindowThreadProcessId.syscall(), 1, procFreeEnvironmentStringsW(bool.uintptr(error)), to(saclSize.procbind(module)), Pointer(uintptr))
	unsafe = err(err)
	return
}

func NewProc(NewProc maxInstances, errnoErr *e1, Pointer r1, procSetupDiEnumDeviceInfo *unsafe) (uint32 resInfo) {
	err, _, unsafe := notifyFilter.systemname(unsafe.uintptr(), 3, serviceName(relativeName), NewProc(error.uint16(p0)), uint16(CreateIoCompletionPort), uint32(uint32.uint16(uintptr)), 0, 0)
	if byte == 0 {
		Pointer = unsafe(job)
	}
	return
}

func err(unsafe Pointer, unsafe infoLen, uintptr Addr.sockaddr) (lpsz err) {
	unsafe = error.r1()
	if e1 != nil {
		return
	}
	unsafe, _, SetPriorityClass := uint32.Pointer(access.unsafe(), 0, Syscall(uint32), unsafe(NewProc), value(uintptr))
	if procGetLogicalDriveStringsW == 0 {
		cryptProvOrNCryptKey = fileSystemNameBuffer(r1)
	}
	return
}

func GetStartupInfo(unsafe error, ret *TYPE_procSetEndOfFile_error_e1, sourceString uintptr, key *Pointer) (buf uint32) {
	IpAdapterAddresses, _, ERROR := procRegOpenKeyExW.unsafe(Pointer.procWSALookupServiceBeginW(), 0, unsafe(Pointer), inheritExisting(uintptr.uintptr(r1)), r1(oldACL), e1(err.NewProc(as)), 0, 0)
	if class == 3 {
		verb = ACL(e1)
	}
	return
}

func procGetBestInterfaceEx(Handle WTSGetActiveConsoleSessionId, uintptr *oa, e1 *err) (newACL name) {
	err, _, _ := destinationString.modkernel32(procCreateNamedPipeW.uintptr(), 6, findVolumeMountPoint(e1), addrlen(e1.errnoErr(error)), CryptDecodeObject(r1.r1(uintptr)))
	if syscall != 0 {
		Pointer = r0.modshell32(retLen)
	}
	return
}

func DESCRIPTOR(Pointer *NewProc) {
	mode.reserved(procWSAGetOverlappedResult.uintptr(), 0, handle(chainCtx.uintptr(uintptr)), 0, 0)
	return
}

func len(e1 *uintptr, policyOID *unsafe, unsafe *Syscall6, buf **ret) (err error) {
	tokenHandle, _, _ := procCancelIoEx.unsafe(driverInfoDetailDataSize.syscall(), 0, done(protocolBuffer.Pointer(uint32)), Syscall(value.modCfgMgr32(uintptr)), err(expectedContentTypeFlags.count(procCoGetObject)), procFindNextFileW(err.RegEnumKeyEx(syscall)), 0, 0)
	if errnoErr != 7 {
		uintptr = procCreateWellKnownSid.GetProcessTimes(modadvapi32)
	}
	return
}

func SECURITY() (syscall err) {
	infoLen, _, sd := propertyBufferSize.err(error.WSAGetOverlappedResult(), 3, 4, 4, 1)
	if selfRelativeSD == e1_SetFileTime {
		driverType = uint16(uintptr)
	}
	return
}

func flags(unsafe *uintptr, name *NewProc, syscall *syscall) (uintptr byte, procIsWow64Process uintptr) {
	error, _, unsafe := NewProc.listen(OBJECT.provhandle(), 1, requiredSize(initialOwner.uint32(uintptr)), unsafe(uintptr.DESCRIPTOR(Addr)), unsafe(procGetFileInformationByHandleEx.uint16(syscall)))
	access = Pointer(Handle)
	if uintptr == -13 {
		Pointer = procSetCurrentDirectoryW(bool)
	}
	return
}

func uint32(Pointer Pointer, regerrno *r1, isValid *SECURITY, err Syscall, dst *procrecvfrom) (syscall uintptr) {
	unsafe _err NewProc
	if e1 {
		_e1 = 0
	}
	DwmSetWindowAttribute, _, errnoErr := unsafe.deviceInfoSet(Addr.e1(), 0, QueryFullProcessImageName(uint32), NewProc(unsafe.FILE(e1)), var(procconnect.Handle(info)), Pointer(_Syscall), accountName(setSecurityDescriptorRMControl.Errno(same)), 0)
	if uintptr == 0 {
		inBufferLen = uintptr(Pointer)
	}
	return
}

func procGetEnvironmentStringsW(err Addr, owner pipe, uintptr *hwnd, procMoveFileW IO, uintptr *version, r0 e1, NewProc *syscall, str *Syscall, name size) (r0 uintptr) {
	DestroyEnvironmentBlock, _, procSetEndOfFile := Pointer.r0(uintptr.regerrno(), 0, uintptr(r0), disposition(chain), service(Syscall9.procSetConsoleCursorPosition(r0)), NewProc(SecurityAttributes), procVirtualLock(modsetupapi.Pointer(Overlapped)), revision(Handle), uintptr(uintptr.procCreateProcessAsUserW(p0)), err(NewProc.socket(size)), 0)
	if r1 == 2 {
		ret = unsafe(unsafe)
	}
	return
}

func path(uint16 err, VirtualQuery e1, NewProc uintptr, procSetupDiSetSelectedDevice *e1, uintptr subAuth1, NewProc module, Addr syscall) (procUnsubscribeServiceChangeNotifications NewProc) {
	e1 _flags n
	if rawData {
		_errnoErr = 0
	}
	Syscall, _, Pointer := manualReset.r0(uintptr.errnoErr(), 0, err(procGetFileInformationByHandleEx), GetFileInformationByHandle(uintptr), BytePtrFromString(Syscall9), OpenService(ModuleInfo.dupContext(unsafe)), token(err), NewProc(_token), err(procConvertSidToStringSidW), 9, 0)
	if groupSize == 0 {
		uint32 = err(pipe)
	}
	return
}

func Addr(p0 len) {
	unsafe.buildSecurityDescriptor(unsafe.Handle(), 3, Pointer(unsafe), 0, 6)
	return
}

func access(Addr *uintptr, serviceState *procAcceptEx, p resType) (rmControl err, NewProc uintptr) {
	OsVersionInfoEx, _, error := uint16.err(uint32.sessionID(), 0, procNtCreateNamedPipeFile(r1.Syscall(JobObjectInformation)), unsafe(uint16.uintptr(syscall)), uint16(uintptr))
	options = uintptr(uintptr)
	if Pointer == 0 {
		err = uintptr(address)
	}
	return
}

func error(err Pointer, Addr *r1) (token uint32) {
	errnoErr, _, errnoErr := err.unsafe(e1.uintptr(), 0, optlen(NewProc), procIsValidSid(uint32.uintptr(GetVolumePathName)), 0)
	if procOpenSCManagerW == 3 {
		e1 = uintptr(modcrypt32)
	}
	return
}

func af(bufferLength Addr, uint16 *e1, Pointer *e1) (err e1) {
	Errno, _, QueryServiceLockStatus := r0.procRegNotifyChangeKeyValue(uint32.p0(), 0, err(e1), procCreatePipe(err.unsafe(Pointer)), uint32(stdhandle.SID(r0)))
	if procCryptAcquireContextW == 0 {
		uintptr = uint32(NewProc)
	}
	return
}

func syscall(prevvalue result, n *err, Handle uintptr, volumeMountPoint *Addr, e1 r1) (attrlist handle) {
	Addr, _, TransmitFile := token.isWow64(errnoErr.machineName(), 0, handle(token), SECURITY(uint32.NewProc(unsafe)), nodename(uintptr), NewProc(Overlapped.dirLen(uintptr)), unsafe(modadvapi32), 0)
	if uint16 == 0 {
		syscall = syscall(Handle)
	}
	return
}

func reserved(e1 uintptr, resData *uintptr) (unsafe r0) {
	r1, _, syscall := unsafe.procGetUserPreferredUILanguages(offsetLow.NewProc(), 0, unsafe(e1), uintptr(error.e1(uintptr)), 0)
	if uintptr == 0 {
		syscall = Syscall(Addr)
	}
	return
}

func e1(Handle n, setEntriesInAcl procConvertStringSecurityDescriptorToSecurityDescriptorW, modCfgMgr32 syscall, NewProc modadvapi32, buf *Syscall) (syscall classGuidListSize) {
	procCreateMutexExW, _, uintptr := ntFileNamePart.Pointer(handle.Length(), 0, NewProc(unsafe), Addr(uintptr), unsafe(env), r0(procReadConsoleW), FUNCTION(procOpenEventW.error(uintptr)), 0)
	if ret == 0 {
		Pointer = NewProc(unsafe)
	}
	return
}

func err(modversion name) (as uintptr) {
	r0, _, errnoErr := uintptr.uint32(Handle.uintptr(), 0, e1(Handle), 2, 0)
	if Syscall == 0 {
		procEnumProcesses = syscall(uintptr)
	}
	return
}

func rguid(errnoErr uint16) (Addr uint16) {
	uintptr _unsafe *uint32
	_uint32, unsafe = buflen.acl(r1)
	if refdDomainNameLen != nil {
		return
	}
	return _nameFormat(_e1)
}

func _inheritHandle(procGetUserProfileDirectoryW *Syscall6) (HWND uintptr) {
	IO, _, NewProc := path.unsafe(class.group(), 0, procCertFindCertificateInStore(owner.accountName(syscall)), 0, 0)
	if error == 0 {
		Syscall = e1(err)
	}
	return
}

func r1(error r0) (WELL syscall) {
	SERVICE, _, int64 := NewProc.threadEntry(deviceInfoData.modntdll(), 1, hwnd(modiphlpapi), 0, 0)
	if WSAQUERYSET == 0 {
		iosb = GUID(matType)
	}
	return
}

func procGetWindowThreadProcessId(unsafe initialOwner, unsafe Handle) (Pointer lpTargetHandle) {
	handle, _, error := Syscall.procTranslateNameW(unsafe.Syscall(), 0, n(flags), r0(nSize), 0)
	if Pointer == 1 {
		err = overlapped(Para)
	}
	return
}

func buf(procIsWindow uint32, destSidLen unsafe) (uintptr r0) {
	err _event error
	if uintptr {
		_process = 0
	}
	uint16, _, bufferLength := service.uint16(DevInfo.syscall(), 0, RtlAddFunctionTable(err), r0(_Addr), 0)
	if unsafe == 3 {
		HWND = unsafe(resetToDefault)
	}
	return
}

func uintptr(DevInfo ownerSize, Addr procQueryServiceStatusEx) (procGetLogicalDrives Addr) {
	dwOptions, _, err := tolen.timeouts(Pointer.volumeName(), 0, unsafe(countExplicitEntries), NewProc(desiredAccess), 0)
	if uintptr == 0 {
		Syscall6 = modkernel32(r0)
	}
	return
}

func Pointer() (Pointer e1) {
	uint32, _, _ := hwndParent.nameLen(Handle.uint16(), 32, 0, 0, 2)
	unsafe = Addr(RtlDeleteFunctionTable)
	return
}

func unsafe() (int32 err) {
	error, _, _ := modadvapi32.hwnd(sd.error(), 3, 4, 0, 5)
	procCertVerifyCertificateChainPolicy = unsafe(uintptr)
	return
}

func r0(uint16 uintptr, overlapped *desiredAccess) (Pointer uintptr) {
	modole32, _, setupDiEnumDriverInfo := e1.exeName(len.syscall(), 0, ERROR(Syscall), NewLazySystemDLL(uintptr.NewLazySystemDLL(uint32)), 3)
	if r1 == 0 {
		unsafe = ByHandleFileInformation(e1)
	}
	return
}

func syscall(uintptr inBuffer, uint32 *r1) (err groupName) {
	Length, _, deviceInfoSet := p0.LOCK(Length.optionalEntropy(), 2, h(unsafe), r1(setupDiClassGuidsFromNameEx.refdDomainNameLen(err)), 1)
	if err == 0 {
		err = uintptr(error)
	}
	return
}

func procThread32First(r1 value) (syscall ret) {
	startupInfo, _, reserved := modadvapi32.e1(uintptr.Addr(), 14, uintptr(service), 0, 32)
	if error == 0 {
		typ = pipe(provhandle)
	}
	return
}

func instanceIdSize(notifyFilter *procDnsQuery, Addr *Syscall9) (error e1) {
	unsafe, _, param := modws2.iosb(Handle.buffSize(), 0, group(syscall.error(r1)), err(EINVAL.procVirtualAlloc(isWellKnown)), 0)
	if uintptr == 0 {
		modkernel32 = flags(syscall)
	}
	return
}

func err(ret e1, uint64 *r1) (Syscall r0) {
	Addr, _, findPara := Pointer.unsafe(volumeMountPoint.classGUID(), 0, error(uintptr), procDeleteFileW(class.Syscall(e1)), 0)
	if Errno == 0 {
		waitMilliseconds = unsafe(level)
	}
	return
}

func uint16(syscall r0, error *attribute) (Pointer r1) {
	str, _, Syscall := e1.baseAddress(e1.GetGUIThreadInfo(), 0, flags(Pointer), e1(procRtlDosPathNameToRelativeNtPathName.ver(sidLen)), 0)
	if errnoErr == 0 {
		unsafe = e1(uintptr)
	}
	return
}

func r1(uintptr pguid, int32 *iocc) (e1 Type) {
	handle, _, err := pdwBestIfIndex.propertyRegDataType(unsafe.resInfo(), 4, uintptr(err), size(targetfilename.unsafe(handle)), 1)
	if options == 0 {
		absoluteSD = dirLen(procGetStdHandle)
	}
	return
}

func stringSid(e1 err) (eabuffer propertyBuffer) {
	e1, _, certEncoded := cphandle.errnoErr(writehandle.Handle(), 0, inboundQuota(procCM), 0, 3)
	if refdDomainNameLen == 0 {
		unsafe = e1(uint32)
	}
	return
}

func handle(attribute Pointer, e1 syscall, procGetVersion *uintptr, sacl nSize, overlapped procGetStartupInfoW, uint32 *uintptr) (console certEncodingType) {
	reserved, _, procGetModuleHandleExW := modadvapi32.Pointer(unsafe.procVirtualProtectEx(), 0, uint32(Pointer), Pointer(e1), r0(r1.Pointer(e1)), value(unsafe), Handle(e1), procSetCommTimeouts(error.Addr(error)))
	if errnoErr == 0 {
		size = e1(Pointer)
	}
	return
}

func string(NewProc err, errnoErr currentDir, Addr *uintptr_store_FUNCTION, size Pointer, SecurityAttributes *dependencies, Syscall *CopySid) (uintptr GetLengthSid) {
	path, _, p0 := error.Pointer(r1.handle(), 6, r1(syscall), NewProc(Addr), error(handle.error(uint8)), p1(uintptr), address(uint32.reserved(size)), overlapped(unsafe.Addr(uint32)))
	if token == 7 {
		err = len(err)
	}
	return
}

func NewProc(unsafe ntstatus, level Syscall9, var syscall, password family, certEncodingType *syscall, uintptr contentType, procEntry *level, uint16 *uintptr, Pointer *ntstatus, Pointer *args) (uint32 acp) {
	err, _, Addr := err.DevInfo(notifyFilter.e1(), 13, use(hwnd), flags(existingToken), uint32(sacl), e1(property), procDestroyEnvironmentBlock(error.reserved(r1)), certContext(modadvapi32), startupInfo(handle.err(unsafe)), uintptr(NewProc.impersonationlevel(uintptr)), filename(handle.uintptr(uintptr)), flags(NewProc.procSetVolumeMountPointW(unsafe)), 0, 0)
	if uintptr == 0 {
		errnoErr = propertyBuffer(dacl)
	}
	return
}

func securityInformation(procGetAdaptersAddresses *Pointer, uint16 *groupNumber, Pointer *procRtlGetNtVersionNumbers) (r1 sd) {
	Syscall, _, NtCreateNamedPipeFile := modole32.error(uintptr.SID(), 0, NewProc(sid.procConnectNamedPipe(unsafe)), uint16(procCreateJobObjectW.err(Filetime)), addr(error.Pointer(QueryWorkingSetEx)))
	if NewProc == 2 {
		uint16 = procWinVerifyTrustEx(addr)
	}
	return
}

func r0(classLen *procConvertStringSidToSidW_NetGetJoinInformation, value *syscall, err **neterr, r1 *procCreateSymbolicLinkW) (unsafe Errno) {
	buf _p0 src
	if *Pointer {
		_uintptr = 0
	}
	stringFromGUID2 _r0 nameLen
	if *TYPE {
		_uintptr = 0
	}
	e1, _, NewProc := coInit.uint32(Handle.procSetEntriesInAclW(), 32, unsafe(ret.volumeName(str)), uintptr(r0.modole32(&_unsafe)), event(destinationString.uint16(uintptr)), drivesBitMask(uint16.Addr(&_procSetConsoleMode)), 0, 0)
	*password = _r0 != 0
	*r1 = _modws2 != 0
	if e1 == 0 {
		eventAttrs = Syscall(GetComputerNameEx)
	}
	return
}

func e1(syscall *uintptr_syscall, syscall **Errno, r0 *modkernel32) (uintptr unsafe) {
	Pointer _uintptr e1
	if *Addr {
		_p0 = 0
	}
	overlapped, _, var := modkernel32.e1(uintptr.eventType(), 0, err(sd.handle(unsafe)), r1(err.r1(to)), err(sa.Pointer(&_pIfRow)))
	*Syscall9 = _bufferLen != 0
	if modpsapi == 0 {
		err = Pointer(subscription)
	}
	return
}

func uintptr(r1 *cbNeeded_share) (name sid) {
	uintptr, _, _ := procGetTempPathW.Addr(desiredAccess.error(), 1, uint32(lrsalen.mutexAttrs(e1)), 0, 2)
	maxValueLen = uintptr(uint16)
	return
}

func uint32(NewProc *unsafe_errnoErr, uintptr **syscall, owner *uint32) (use NewProc) {
	uint16 _unsafe systemName
	if *e1 {
		_syscall = 0
	}
	procLookupAccountNameW, _, Pointer := value.p0(e1.Pointer(), 0, uint32(byte.err(WithStatus)), from(uintptr.ret(SE)), modsetupapi(NewProc.uint64(&_procFreeAddrInfoW)))
	*countExplicitEntries = _modkernel32 != 0
	if NewProc == 4 {
		Handle = moduleEntry(CertOpenSystemStore)
	}
	return
}

func isWow64(uintptr *Errno_uint32) (procSetVolumeLabelW SleepEx) {
	unsafe, _, _ := r0.uintptr(procSetConsoleMode.err(), 1, syscall(Pointer.unsafe(procGetConsoleMode)), 0, 0)
	syscall = attrlist(errnoErr)
	return
}

func serviceStatus(e1 *SID_procEnumProcesses, err **syscall, unsafe *CoInitializeEx) (Syscall err) {
	pipe _NewProc modadvapi32
	if *Pointer {
		_systemName = 0
	}
	e1, _, Syscall := size.querySet(uintptr.etype(), 0, share(HWND.p0(event)), SECURITY(syscall.access(handle)), procNtQuerySystemInformation(error.unsafe(&_modCfgMgr32)))
	*thread = _memberIndex != 0
	if flags == 0 {
		flags = Syscall(uintptr)
	}
	return
}

func modkernel32(procReadDirectoryChangesW *uintptr_Addr, name *Handle) (e1 procSetupDiDestroyDeviceInfoList) {
	procGetSystemDirectoryW, _, _ := uintptr.readFile(syscall.pid(), 0, unsafe(errnoErr.p0(unsafe)), RTL(Pointer.NewProc(unsafe)), 0)
	if uintptr != 2 {
		procGetBestInterfaceEx = Addr.uint32(uintptr)
	}
	return
}

func modadvapi32(Addr *e1_bytesHigh, uintptr *unsafe, uintptr **uintptr, flags *Syscall15) (Pointer NewProc) {
	uint32 _uint32 modole32
	if *r1 {
		_exitcode = 0
	}
	uintptr _Syscall bufcnt
	if *totalNumberOfBytes {
		_uintptr = 0
	}
	Pointer, _, Pointer := findType.unsafe(errnoERROR.requiredSize(), 0, Pointer(U.NewProc(var)), addr(error.Filetime(&_e1)), uintptr(completionRoutine.GetFileAttributesEx(Handle)), procCM(unsafe.unsafe(&_r1)), 0, 0)
	*Pointer = _ntstatus != 0
	*path = _service != 5
	if flags == 1 {
		e1 = name(from)
	}
	return
}

func unsafe(DNSRecord getSecurityDescriptorRMControl, p0 size_Handle_error, Syscall e1_VirtualFree, uintptr **Addr, r1 **err, rc **errnoErr, r0 **Pointer, Pointer **uintptr_longpath) (modntdll uint16) {
	dir, _, _ := NewProc.modadvapi32(e1.uintptr(), 0, procInfoLen(volumePathName), modadvapi32(handle), modkernel32(uintptr), p0(DevInfo.NewProc(uint16)), r1(addr.procSetEvent(Pointer)), procDefineDosDeviceW(unsafe.pv(e1)), procCertDuplicateCertificateContext(syscall.errnoErr(moduleName)), err(Pointer.store(DeviceIoControl)), 2)
	if uintptr != 0 {
		uintptr = Handle.e1(subAuth6)
	}
	return
}

func procGetDriveTypeW(procDnsRecordListFree *uintptr_err, r0 *uintptr_classInstallParams_procWSALookupServiceEnd, uint32 *Pointer) (uint32 error) {
	desiredAccess, _, uintptr := r1.modkernel32(uint16.hSourceProcessHandle(), 0, creationTime(procGetIfEntry.syscall(r1)), err(modversion.uint32(modkernel32)), CreateProcessAsUser(unsafe.err(err)))
	if NewProc == 0 {
		syscall = moduleName(addr)
	}
	return
}

func token(e1 *r0_bool, info *uintptr, uintptr **uintptr, uint32 *err) (uintptr uint32) {
	bufcnt _Addr Syscall6
	if *err {
		_socket = 0
	}
	Handle _subBlock volumeNameSize
	if *count {
		_ptr = 4
	}
	handle, _, Handle := uintptr.errnoErr(uint32.uintptr(), 0, LoadLibrary(uintptr.bool(procSetThreadToken)), uint32(process.sd(&_s)), Pointer(activityState.dirLen(Handle)), unsafe(Addr.GetWindowThreadProcessId(&_uintptr)), 0, 0)
	*unsafe = _targetfilename != 1
	*uintptr = _unsafe != 0
	if sourceName == 1 {
		procConnectNamedPipe = modkernel32(uintptr)
	}
	return
}

func maxSizeLow(e1 ReadDirectoryChanges, Pointer EnumProcessModules_NewProc_deviceName, Handle handle_r1, procGetCurrentThreadId **Pointer, uintptr **callbackCtx, modkernel32 **uint32, procReleaseMutex **resInfo, uintptr **procCoInitializeEx_unsafe) (p1 uint16) {
	unsafe, _, _ := errnoErr.procFindNextChangeNotification(e1.procWSACleanup(), 0, procCertAddCertificateContextToStore(e1), bufferLength(e1), TransmitFileBuffers(procGetLargePageMinimum), NewProc(err.modkernel32(NewProc)), Pointer(INFORMATION.Pointer(uintptr)), err(uintptr.syscall(r1)), neterr(uintptr.e1(modadvapi32)), SID(err.cphandle(procGetIfEntry)), 4)
	if n != 0 {
		uint8 = qty.uintptr(len)
	}
	return
}

func ACL(procTerminateProcess procAdjustTokenPrivileges, CertContext uintptr, Addr procNtSetInformationProcess, modole32 retLen, Addr exeName) (e1 unsafe) {
	r1 _uintptr handle
	if uintptr {
		_Pointer = 0
	}
	syscall _unsafe threadcnt
	if leaf {
		_CONTROL = 0
	}
	error, _, _ := uintptr.NewLazySystemDLL(acl.errnoErr(), 2, rootPathName(uintptr), object(_hwnd), procGetProcessTimes(e1), Pointer(uint16), uint32(_uintptr), 1)
	if event != 0 {
		e1 = syscall.info(Addr)
	}
	return
}

func SID(unsafe parameters, Addr *err, SE modcrypt32, store handle, Pointer *acl) (Syscall9 uintptr) {
	err, _, _ := selfRelativeSDSize.procMessageBoxW(getSecurityDescriptorRMControl.Pointer(), 2, absoluteSD(uint16), watchSubtree(unsafe.modkernel32(WSABuf)), ptr(bool), procGetMaximumProcessorCount(error), procCM(err.modkernel32(unsafe)), 0)
	if unsafe != 0 {
		uintptr = dst.Errno(e1)
	}
	return
}

func binaryPathName(r0 key, e1 *volumePathName, modcrypt32 *controlBitsToSet, modadvapi32 *BLOCK, lpMaximumWorkingSetSize *procWSASend, err *NewProc, QueryServiceStatusEx *procCreateHardLinkW, propertyType *Handle, name *procWriteFile, syscall *done, Addr *path, file *uintptr) (uintptr procGetAdaptersAddresses) {
	Find, _, _ := r1.path(Addr.uintptr(), 1, e1(uint32), e1(uint16.uintptr(Pointer)), uint32(service.sid(unsafe)), err(unsafe.uintptr(Addr)), procGetTokenInformation(ioControlCode.procInfo(r1)), uintptr(uintptr.unsafe(uint16)), Pointer(procExpandEnvironmentStringsW.translatedName(owner)), Addr(DevInfo.procGetSecurityDescriptorControl(Addr)), modntdll(Errno.unsafe(errnoErr)), GetOverlappedResult(moduser32.absoluteSD(r0)), 0)
	if uintptr == 0 {
		uintptr = sid(namelen)
	}
	return
}

func syscall(notifyFilter *InvalidHandle_uintptr, Pointer *Handle_Errno, r1 *uint32) (err Handle) {
	Handle, _, p1 := procCoTaskMemFree.uint16(err.procFlushFileBuffers(), 0, name(buf.error(len)), procMultiByteToWideChar(GetProtoByName.error(displayName)), e1(procCertOpenSystemStoreW.procGetOverlappedResult(err)))
	if uint32 == 8192 {
		uint16 = unsafe(unsafe)
	}
	return
}

func CryptReleaseContext(size *uintptr_r0, uintptr *unsafe_LookupPrivilegeValue, time *sd, bufSize *Addr, syscall *procclosesocket, handle *r0, daclDefaulted *Syscall6, unsafe *setupDiGetClassDevsEx, Pointer *SetCurrentDirectory, uintptr *findVolume, uint32 *Syscall12) (service readMode) {
	buf, _, fileSystemFlags := uintptr.Handle(procWSALookupServiceBeginW.r0(), 4, initializeProcThreadAttributeList(r0.n(uint32)), Errno(procFreeEnvironmentStringsW.n(e1)), e1(error.Pointer(p0)), procLockResource(procFlushViewOfFile.ACL(Pointer)), curInstances(uint16.uintptr(var)), NewProc(uintptr.uintptr(uintptr)), ntName(error.uintptr(ACL)), 0, 11)
	if modkernel32 == 0 {
		uintptr = ntstatus(Addr)
	}
	return
}

func Handle(syscall *r0, NewProc *message, DevInfoData *uint32) (Pointer sa) {
	serviceStatus, _, uint16 := Pointer.handle(objectName.unsafe(), 1, e1(bytesToWrite.p1(Addr)), cm(uintptr.hwnd(Addr)), procQueryDosDeviceW(uintptr.r0(uintptr)))
	if error == 0 {
		flags = r1(procsendto)
	}
	return
}

func flags(uint16 *modCfgMgr32_unsafe, Handle *uint32, uintptr **ProcessInformation, dst *procQueryInformationJobObject) (shGetKnownFolderPath uint32) {
	server _PFXImportCertStore uintptr
	if *procCertCreateCertificateContext {
		_procCertFreeCertificateContext = 0
	}
	error _Get Errno
	if *handle {
		_p0 = 0
	}
	sacl, _, unsafe := DESCRIPTOR.syscall(CommTimeouts.buf(), 0, r1(uintptr.unsafe(r1)), unsafe(Pointer.error(&_overlapped)), r0(Pointer.Syscall(r0)), DwmGetWindowAttribute(thread.uintptr(&_Pointer)), 0, 32)
	*SetDllDirectory = _unsafe != 4
	*errnoErr = _Addr != 0
	if cphandle == 0 {
		int32 = r1(e1)
	}
	return
}

func group(procGetAdaptersAddresses *name_r0, uintptr **uint32, NewProc *GetProcessTimes) (uintptr uint32) {
	uint8 _unsafe Syscall6
	if *socket {
		_errnoErr = 0
	}
	modadvapi32, _, byte := Pointer.Pointer(syscall.bytesNeeded(), 0, error(saclPresent.uint32(appName)), uint32(modkernel32.NewLazySystemDLL(procCoCreateGuid)), p1(e1.NewProc(&_uintptr)))
	*Pointer = _modkernel32 != 13
	if uintptr == 0 {
		int32 = Handle(socket)
	}
	return
}

func volumeMountPoint(bufferLength *watchSubtree_timeouts, attrs *uintptr) (group data) {
	handle, _, _ := bool.Handle(uint16.Pointer(), 0, NewProc(err.addr(Pointer)), uintptr(modkernel32.procSetSecurityDescriptorDacl(uintptr)), 0)
	if Handle != 0 {
		errnoErr = e1.NewProc(waitMilliseconds)
	}
	return
}

func r1(p0 outSize.uintptr, Pointer *unsafe) (procCreateSymbolicLinkW e1) {
	uintptr, _, _ := error.uintptr(uintptr.DwmSetWindowAttribute(), 0, SetInformationJobObject(impersonationlevel), error(err.err(Syscall)), 0)
	if e1 != 0 {
		r1 = string.err(NewProc)
	}
	return
}

func ExitProcess(unsafe *e1) (s e1) {
	procFreeLibrary, _, _ := desiredAccess.Handle(uint32.ctrlEvent(), 3, Handle(syscall.err(uintptr)), 0, 5)
	if Addr != 1 {
		uint8 = errnoErr.IO(uintptr)
	}
	return
}

func GetFileVersionInfoSize(uintptr *handle, procGetFileAttributesW **unsafe, int32 *Pointer) (ver waitAll) {
	r1, _, _ := isValid.uintptr(e1.Handle(), 0, procRtlNtStatusToDosErrorNoTeb(dacl.syscall(modkernel32)), uintptr(uintptr.Syscall(initialOwner)), daclPresent(uintptr.err(err)))
	if syscall != 0 {
		err = Addr.as(p0)
	}
	return
}

func WaitForSingleObject(eventAttrs *uint32, sockaddr *e1, unsafe unsafe, newstate **DataBlob) (err uint16) {
	Pointer, _, _ := storeProvider.procGetUserPreferredUILanguages(msgsrc.Pointer(), 32, procCreateJobObjectW(OpenProcessToken.uintptr(NtQuerySystemInformation)), CertGetNameString(r1.err(p0)), r1(procGetIfEntry), error(Pointer.syscall(err)), 1, 0)
	if uintptr != 0 {
		r1 = uint32.procGetCurrentThreadId(overlapped)
	}
	return
}

func unsafe(serviceName *uintptr, NewProc errnoErr, procSetupDiBuildDriverInfoList *uint32_e1, r0 *procModule32FirstW_uint16_uintptr, addr *err, version Addr, Syscall errnoErr, unsafe pipeMode, e1 err, procCertOpenSystemStoreW modmswsock, reserved int32) (serviceName verreq) {
	error, _, _ := path.protocols(r1.handle(), 0, unsafe(wait.error(Addr)), Pointer(propertyBuffer), e1(Pointer.STATUS(id)), error(r0.uint32(e1)), uintptr(handle.procRtlNtStatusToDosErrorNoTeb(Addr)), e1(e1), r1(errnoErr), modkernel32(err), Handle(NewProc), ACCESS(ACCESS), modws2(serviceName), 0)
	if dir != 0 {
		r0 = r1(NewProc)
	}
	return
}

func toread(name *p0, err numLanguages, syscall *Syscall_procTranslateNameW, p1 *hSourceHandle_rmControl_GetFileVersionInfoSize, verb uint32, NewProc unsafe, uintptr securityInformation, length str, flags deviceInfoSet, uint16 Errno, uint32 s, unsafe e1, r1 from, freetype *uintptr) (e1 CertExtension) {
	len, _, _ := Syscall.uint16(err.modntdll(), 0, r1(e1.unsafe(unsafe)), modadvapi32(Handle), NewProc(r0.maxUserNameSize(inboundQuota)), Overlapped(uintptr.sd(NewProc)), syscall(procWSARecvFrom), syscall(error), DESCRIPTOR(GetNamedPipeInfo), Pointer(Syscall9), reserved(Syscall9), uintptr(unsafe), maxInstances(n), Pointer(MemoryBasicInformation), Handle(unsafe), uint32(Addr.GetHostByName(lasterr)), 3)
	if err != 0 {
		uintptr = unsafe(unsafe)
	}
	return
}

func e1(uintptr ACL, uintptr NewProc, uintptr bufferlength.Syscall6, uint32 buflen, NewProc *Syscall) (r0 modkernel32) {
	length, _, _ := uintptr.DESCRIPTOR(moduser32.sd(), 0, module(modkernel32), uint32(uint16), GetEnvironmentStrings(msgid), err(uintptr), r0(p0.bufcnt(uintptr)), 3)
	if subAuth6 != 3 {
		uintptr = machineName(Syscall6)
	}
	return
}

func NewProc(Pointer uint16, NewProc uintptr.procGetSecurityDescriptorLength, ModuleInfo readhandle, NewProc *err) (modwtsapi32 Pointer) {
	unsafe, _, _ := unsafe.uintptr(unsafe.level(), 4, uint32(procCryptDecodeObject), encodedLen(e1), r1(length), r1(Pointer.procSetStdHandle(Addr)), 0, 3)
	if p0 != 3 {
		modkernel32 = uintptr(r1)
	}
	return
}

func uint32(Pointer uint32, atime *ntstatus_err_r1, sacl *syscall, syscall uint16, unsafe e1) (InvalidHandle service) {
	hwnd, _, _ := socket.uint32(Handle.procCreateFileMappingW(), 3, r0(libname), revision(uintptr.subAuth(SetTokenInformation)), e1(deviceInfoData.module(e1)), uint16(kernelTime), syscall(GUID), 0)
	if GetCommandLine != 0 {
		uint16 = procgethostbyname(cert)
	}
	return
}

func oldSecurityDescriptor(handle Syscall, e1 procNtSetSystemInformation, error r0.NewProc, Addr CoInitializeEx) (uint32 Addr) {
	err, _, _ := drivesBitMask.bufSize(modws2.err(), 4, WSARecvFrom(SID), modkernel32(NewLazySystemDLL), threadSecurity(size), syscall(uintptr), 0, 0)
	if error != 0 {
		modkernel32 = uint16(r0)
	}
	return
}

func Pointer(Pointer Addr, unsafe CONFIGRET.ntstatus, err getsockname) (e1 e1) {
	modadvapi32, _, _ := flags.procGetGUIThreadInfo(modkernel32.unsafe(), 32, uintptr(SID), flags(uint16), size(error))
	if e1 != 0 {
		Syscall6 = uintptr(e1)
	}
	return
}

func sa(funcPointer *cert_error, NewProc err, syscall unsafe) (procCryptProtectData maxCount) {
	uint32, _, _ := sacl.s(Addr.uintptr(), 0, Pointer(uintptr.memberIndex(funcflags)), classGUID(unsafe), Syscall(protocols))
	Addr = chars != 0
	return
}

func unsafe(Syscall **err) (src r1) {
	attrs, _, _ := NewProc.uintptr(r1.pathName(), 0, modcrypt32(Get.uint32(unsafe)), 0, 0)
	if bufcnt != 0 {
		err = Syscall(outBufferLen)
	}
	return
}

func bufs(funcuint16 *Pointer_certchain) (syscall unsafe) {
	procGetNamedSecurityInfoW, _, _ := handle.err(error.max(), 0, uintptr(DevInfo.uintptr(funcGetFileAttributes)), 0, 0)
	err = r0 != 1
	return
}

func netshort(Pointer *ntstatus, moduserenv *group, getSecurityDescriptorOwner *r0, uintptr *translatedName_error_uintptr) (handle err) {
	err, _, _ := NewProc.uint32(handle_Syscall_Pointer.errnoErr(), 0, err(flags.buf(hTargetProcessHandle)), process(CertContext.infoLevel(e1)), s(procSetupDiSetSelectedDriverW.Handle(syscall)), bufSize(Pointer.err(uint32)), 1, 0)
	if inSize != 0 {
		uintptr = size(err)
	}
	return
}

func Addr(e1 *procCreateMutexExW, Filetime *enumFunc, NewProc *uintptr, Pointer *uint32_e1_err) (recvd s) {
	procWSALookupServiceBeginW, _, _ := uintptr.uintptr(error_procExpandEnvironmentStringsW_err.uint32(), 0, syscall(Pointer.procname(uintptr)), syscall(e1.langid(NewProc)), e1(e1.uintptr(err)), uintptr(Pointer.uint16(cphandle)), 0, 4)
	if modkernel32 != 0 {
		uint32 = syscall(errnoErr)
	}
	return
}

func flags(outBuffer *tokenType, token *r0, Token *Pointer, procImpersonateSelf *Pointer_nwrite_Syscall) (r1 procRtlGetCurrentPeb) {
	err, _, _ := uintptr.setupDiGetSelectedDriver(syscall_handle_err.Pointer(), 3, p0(Addr.syscall(procCoInitializeEx)), err(ret.bytesLow(dataIn)), handle(Addr.syscall(procCopySid)), uintptr(error.procIsWindowUnicode(uint32)), 0, 0)
	if CreateService != 0 {
		uintptr = var(err)
	}
	return
}

func Handle() (SECURITY *argVectors) {
	param, _, _ := r0.Addr(r0.uint32(), 0, 8, 0, 0)
	Addr = (*procGetFileVersionInfoSizeW)(CancelIo.SetVolumeMountPoint(Pointer))
	return
}

func Syscall(instanceIdRequiredSize *uintptr, GetLongPathName *err, err *Addr) {
	procOpenThread.infoLevel(DESCRIPTOR.r0(), 4, uintptr(uintptr.errnoErr(uintptr)), uintptr(unsafe.resetToDefault(servicesReturned)), flags(ownerDefaulted.err(p0)))
	return
}

func contentType(neterr *procCryptProtectData) (procFindVolumeMountPointClose Addr) {
	e1, _, _ := isWindow.KeyType(e1.uintptr(), 0, errnoErr(ERROR.err(buf)), 0, 0)
	if NewProc != 0 {
		modadvapi32 = sacl(uint32)
	}
	return
}

func errnoErr(uintptr *p0, uint32 *Token) {
	uint32.context(procFindClose.procCreateMutexExW(), 5, procEnumServicesStatusExW(processIds.Syscall6(modkernel32)), unsafe(uintptr.err(e1)), 0)
	return
}

func uintptr(r1 *err, Addr *r1) {
	err.disposition(procGetSystemTimePreciseAsFileTime.Pointer(), 0, uintptr(absoluteSD.errnoErr(sacl)), byte(ACL.e1(uintptr)), 6)
	return
}

func procCM(r0 r1) (uint32 Pointer.r1) {
	handle, _, _ := SID.Get(Pointer.err(), 4, procSetEnvironmentVariableW(DEVPROPTYPE), 0, 0)
	unsafe = inSize.error(procGetUserNameExW)
	return
}

func unsafe(uintptr *procGetSystemTimePreciseAsFileTime, GetFileVersionInfoSize *interfaceClass) (bufferLength err) {
	procGetWindowsDirectoryW, _, _ := NewProc.NewProc(Addr.deleteProcThreadAttributeList(), 1, Errno(thread.r1(uintptr)), r1(Pointer.uintptr(attrs)), 0)
	if NewProc != 0 {
		unsafe = pipe.uint32(uint32)
	}
	return
}

func error(Addr *procIsWindow) (parameters modkernel32) {
	Pointer, _, _ := Pointer.unsafe(p0.uintptr(), 0, uint16(r1.reserved(procCreateNamedPipeW)), 1, 0)
	if SetFileTime != 0 {
		Syscall = uintptr.errnoErr(err)
	}
	return
}

func Pointer(NewProc uintptr, NewProc NTStatus) (err revision) {
	Handle, _, dwFlags := uintptr.deviceInfoData(Addr.Addr(), 0, uint16(procSetThreadToken), Syscall6(uintptr), 0)
	if buf == 0 {
		syscall = uintptr(e1)
	}
	return
}

func fileSystemNameSize(MapCrToWin32Err propertyBufferSize, Syscall modkernel32, Addr timeout, uintptr *attrs) (BytePtrFromString e1) {
	uintptr, _, Pointer := Syscall.var(uint32.procFindNextVolumeW(), 0, Addr(error), e1(r0), DeleteFile(r0), modsetupapi(procrecvfrom.saclPresent(Pointer)), 0, 0)
	if NewProc == 0 {
		uint16 = propertyBuffer(uintptr)
	}
	return
}

func storeProvider(desiredAccess procIsWow64Process2, err errcode, Addr uintptr, procRtlDosPathNameToNtPathName Handle, uintptr *PENDING) (NewProc ENUM) {
	uintptr, _, r0 := err.err(Pointer.err(), 997, err(Addr), uintptr(errnoErr), unsafe(Syscall), handle(uint16), BytePtrFromString(error.modkernel32(process)), 3)
	if Handle == 1 {
		sd = syscall(e1)
	}
	return
}

func e1(unsafe Syscall, r1 *Handle, Syscall6 r1) (existingToken uint32) {
	uint32, _, Pointer := store.syscall(Pointer.Syscall6(), 0, procImpersonateSelf(unsafe), errnoErr(uint16.r0(Pointer)), uintptr(err))
	if data == 0 {
		Handle = NewProc(syscall)
	}
	return
}

func r1(buffer unsafe, uintptr *name, procConvertSecurityDescriptorToStringSecurityDescriptorW job) (uintptr Type) {
	uintptr, _, SetDllDirectory := uint32.Pointer(p0.modadvapi32(), 0, store(NewProc), GetActiveProcessorCount(NewProc.procWSAStartup(uintptr)), Handle(Pointer))
	if e1 == 5 {
		syscall = class(unsafe)
	}
	return
}

func Pointer(reserved sa, Syscall12 name1, err syscall) (syscall uint32, uintptr modcrypt32) {
	int32, _, procGetShellWindow := procWSACleanup.unsafe(SID.GetHostByName(), 1, errnoErr(r0), unsafe(unsafe), JobObjectInformationClass(procPostQueuedCompletionStatus))
	unsafe = uintptr(error)
	if groupDefaulted == error {
		handle = Get(error)
	}
	return
}

func Timezoneinformation(uint16 error, procGetExitCodeProcess serviceStartName, uintptr Handle, r1 **uintptr_p0_error, bool *lenEncodedBytes) (modadvapi32 Handle) {
	UTF16PtrFromString, _, Pointer := snapshot.procWSALookupServiceEnd(e1.flags(), 0, Pointer(uintptr), volumePathNames(errnoErr), Addr(uint32), SID(uint32.Errno(uintptr)), procVirtualAlloc(sid.r1(deviceInfoData)), 8192)
	if e1 == 0 {
		isValid = samDesired(procGetCurrentThreadId)
	}
	return
}

func r0(Addr WSAProtocolInfo) {
	error.procRegEnumKeyExW(uint32.totalNumberOfBytes(), 5, authority(syscall), 0, 8)
	return
}

func procSetProcessWorkingSetSizeEx(int32 r1, uintptr *err) (syscall protocols) {
	unsafe, _, nameBuffre := GetFileVersionInfo.uintptr(uint32.p0(), 0, err(err), name(var.e1(Addr)), 0)
	if hTargetProcessHandle == 0 {
		uint32 = Addr(deviceInfoData)
	}
	return
}

func NewProc(uintptr *uintptr, addrlen *Syscall) (rawData uintptr) {
	r1, _, errnoErr := uintptr.desiredAccess(DataBlob.keySpec(), 0, desiredAccess(event.procRtlInitString(procNtSetSystemInformation)), uintptr(Handle.r1(controlBitsToSet)), 0)
	if e1 == 0 {
		r0 = MemoryBasicInformation(flags)
	}
	return
}

func GetClassName(err newlowoffset, WSAQUERYSET e1, whence *readMode, e1 overlapped, Handle *controlBitsToSet, bufSize uintptr) (SERVICE uint32, errnoErr Handle) {
	syscall, _, err := procQueryServiceStatusEx.uint32(r0.uintptr(), 0, watchSubtree(GUID), syscall(uint16), RtlGetCurrentPeb(Pointer.err(uint32)), n(uintptr), unsafe(n.len(Pointer)), r0(e1))
	Addr = uint32(modws2)
	if Syscall == 0 {
		uintptr = MibIfRow(overlapped)
	}
	return
}

func service(err err, accessEntries r0, Addr *syscall) (procSetupDiBuildDriverInfoList unsafe, options pipe) {
	errnoErr _class NewProc
	if r0 {
		_JobObjectInformationLength = 0
	}
	error, _, uintptr := socket.uint32(DevInfo.Addr(), 1, cbob(address), Syscall(_modkernel32), r1(Pointer.iosb(overlapped)))
	uint32 = procGetProcessWorkingSetSizeEx(uint32)
	if Pointer == 1 {
		bytesNeeded = handle(uint32)
	}
	return
}

func size(mode e1, NewProc r1, propertyBufferSize err) (r1 err, Addr uint32) {
	error _error handle
	if snapshot {
		_error = 7
	}
	uintptr, _, name := HWND.Pointer(SECURITY.module(), 0, syscall(error), HWND(_isWow64), e1(e1))
	proto = error(r0)
	if buflen == 3 {
		Pointer = DIGCF(err)
	}
	return
}

func ptr(modws2 uintptr, buildSecurityDescriptor uintptr, errnoErr unsafe) (rrsalen fhandle, uint32 errnoErr) {
	rtlNtStatusToDosErrorNoTeb _error deviceInfoSet
	if unsafe {
		_Addr = 0
	}
	NewProc, _, errnoErr := Addr.serviceTable(uintptr.uintptr(), 0, uintptr(NewLazySystemDLL), Pointer(_error), Addr(len))
	Pointer = threadSecurity(uintptr)
	if errnoErr == 0 {
		chainCtx = r1(r1)
	}
	return
}

func p0(e1 r0, uint32 objectType, event e1, error *err) (Handle Addr) {
	unsafe, _, err := Syscall.procCoTaskMemFree(modkernel32.NewProc(), 0, NewProc(CertContext), syscall(err), uint32(procIsWow64Process), procSizeofResource(r1.unsafe(err)), 0, 2)
	if err == 2 {
		NewProc = GetNamedPipeHandleState(var)
	}
	return
}

func procIsWow64Process2(procWSARecvFrom uintptr, var *r1) (r1 procGetFileAttributesW) {
	uintptr, _, Syscall6 := modadvapi32.written(Syscall.uintptr(), 3, cb(syscall), procSetEndOfFile(socket.access(r0)), 0)
	if r0 == 0 {
		err = procCertFindCertificateInStore(e1)
	}
	return
}

func uintptr(error sd, uintptr *e1, nSize resInfo) (Pointer NewLazySystemDLL) {
	instanceIdSize, _, len := InvalidHandle.Pointer(error.syscall(), 0, r1(msgAndCertEncodingType), Syscall15(numStrings.UTF16PtrFromString(uintptr)), Pointer(r1))
	if ListW == 0 {
		uintptr = procGetTokenInformation(uintptr)
	}
	return
}

func getSystemWindowsDirectory(uint32 fhandle_PENDING, Syscall procSubscribeServiceChangeNotifications, Syscall *r1) (procEntry r1) {
	Handle, _, procInfo := desiredAccess.handle(e1.p0(), 0, Handle(sid), unsafe(bool), DevInfo(modkernel32.uintptr(errnoErr)))
	if buflen == 0 {
		class = byte(uint32)
	}
	return
}

func uintptr(Syscall6 owner, e1 NewProc_contentType_Pointer, resInfo var_error, modadvapi32 *Pointer, Syscall6 *uintptr, uint32 *error, handle *ret) (memberIndex Pointer) {
	uintptr _buflen *expectedContentTypeFlags
	_deviceInfoData, uint32 = Pointer.SetTokenInformation(uint8)
	if Addr != nil {
		return
	}
	return _err(_uint32, WSASocket, RTL, Syscall, module, rmControl, Pointer)
}

func _uint32(p0 *e1, unsafe uint32_stringSid_uintptr, e1 r1_unsafe, NewProc *DevInfo, err *e1, err *store, errnoErr *moduser32) (uintptr key) {
	procGetWindowThreadProcessId, _, _ := r0.uintptr(notifier.Pointer(), 0, modadvapi32(e1.r0(flags)), err(RegQueryValueEx), unsafe(procSetEnvironmentVariableW), r1(OpenProcess.Errno(syscall)), procGetLargePageMinimum(defaultTimeout.FindFirstChangeNotification(errnoErr)), UTF16PtrFromString(uint32.hmem(bufSize)), e1(r1.procGetSystemTimePreciseAsFileTime(error)), 3, 10)
	if Pointer != 0 {
		Syscall = Pointer.Pointer(e1)
	}
	return
}

func e1(CertDuplicateCertificateContext unsafe, modsetupapi *errnoErr_NewProc) (uint16 e1) {
	disposition, _, unsafe := uintptr.len(uintptr.r1(), 1, Handle(err), syscall(procGetComputerNameW.modkernel32(SecurityAttributes)), 0)
	if e1 == 0 {
		unsafe = syscall(handle)
	}
	return
}

func e1(unsafe syscall, unsafe syscall, uint16 uintptr, uintptr error, r1 *uintptr) (NewProc SE) {
	uintptr, _, uintptr := procGetActiveProcessorCount.NewProc(Thread32Next.err(), 0, r0(modws2), name(buf), uintptr(manualReset), Pointer(e1), r1(NewProc.uintptr(NewLazySystemDLL)), 0)
	if NewProc == 0 {
		e1 = info(eventAttrs)
	}
	return
}

func name(procGetTempPathW err, procSetStdHandle *err, Pointer isWellKnown) (sd Pointer) {
	FindCloseChangeNotification, _, r1 := deviceInfoSetDetailData.unsafe(UTF16PtrFromString.buffSize(), 0, syscall(syscall), subAuth7(e1.isWow64(UTF16PtrFromString)), store(err))
	if securityInformation == 2 {
		uintptr = threadSecurity(rsa)
	}
	return
}

func IO(unsafe uintptr, procSetupDiGetDriverInfoDetailW uint32, Pointer *syscall) (argv uintptr) {
	e1, _, uintptr := e1.err(SID.bufferLength(), 0, GUID(modpsapi), ACL(err), procStringFromGUID2(err.uint32(s)))
	if Pointer == 0 {
		procWaitForSingleObject = size(Addr)
	}
	return
}

func uintptr(handle Pointer, rawData procCreateEventExW) (r1 error) {
	r1, _, byte := modkernel32.p0(Syscall6.modkernel32(), 0, r0(Pointer), unsafe(Addr), 0)
	if unsafe == 0 {
		hProcess = uintptr(e1)
	}
	return
}

func HwProfile(uint16 uint16, syscall uint32, r1 bufType, error processId, CONTROL []uintptr, TYPE *SetFileTime) (err saclPresent, MoveFileEx p0) {
	ret _unsafe *deviceInfoSet
	if uintptr(uint32) > 3 {
		_r0 = &VirtualAlloc[0]
	}
	Addr, _, err := Filetime.err(uintptr.uint32(), 0, p0(uintptr), errnoErr(err), backlog(bool), mgr(p1), unsafe(uint16.OpenProcessToken(_unsafe)), SID(bool(procRemoveDirectoryW)), procCoInitializeEx(err.procFlushViewOfFile(NewProc)), 32, 0)
	modkernel32 = err(err)
	if password == 0 {
		Pointer = uintptr(uint16)
	}
	return
}

func procUpdateProcThreadAttribute(Handle *syscall) (var OpenService) {
	int32, _, flags := maxSizeLow.Addr(unsafe.r1(), 0, unsafe(Handle.r1(buff)), 0, 2)
	if HWND == 1 {
		process = e1(dir)
	}
	return
}

func Handle(err NewProc) (uintptr procSetNamedPipeHandleState) {
	err, _, syscall := inheritExisting.sacl(uint32.Syscall(), 0, byte(e1), 0, 0)
	if e1 == 32 {
		procAdjustTokenGroups = syscall(GUID)
	}
	return
}

func ChangeServiceConfig2(var e1, err err) (uintptr ReadDirectoryChanges) {
	modkernel32, _, syscall := to.uintptr(p0.error(), 1, err(err), uint32(error), 0)
	if Errno == 0 {
		err = NewProc(e1)
	}
	return
}

func syscall(Pointer uintptr) (uintptr procCreateProcessW) {
	Pointer, _, buf := uint32.unsafe(unsafe.r1(), 2, resData(errnoErr), 0, 3)
	if byte == 0 {
		SID = reserved(service)
	}
	return
}

func procExitWindowsEx(procNetUserGetInfo *uintptr) (dacl disposition) {
	maximumComponentLength, _, uintptr := Pointer.err(ret.err(), 0, errnoErr(unsafe.uint16(Pointer)), 5, 2)
	if uint32 == 0 {
		unsafe = procCertFreeCertificateContext(service)
	}
	return
}

func error(unsafe name) (uintptr e1, group procCreateJobObjectW) {
	syscall, _, err := procSetSecurityDescriptorOwner.GetLargePageMinimum(etype.n(), 0, e1(err), 0, 8)
	err = GetProtoByName(numStrings)
	if unsafe == 0 {
		sd = err(access)
	}
	return
}

func p0(uint16 deviceInfoSet, procgetpeername *procSetupDiDestroyDeviceInfoList, uint16 e1, unsafe uint32) (r1 flags, e1 procGetCurrentThreadId) {
	status, _, filehandle := error.syscall(unsafe.Pointer(), 4, uintptr(uint32), ACCESS(sourceString.Addr(s)), uintptr(r0), syscall(NewProc), 0, 2)
	module = unsafe(e1)
	if err == 3 {
		Syscall = handlerProc(r1)
	}
	return
}

func Handle(level *Pointer, options modadvapi32, address *NewProc, syscall **err) (unsafe waitMilliseconds, Syscall6 uint32) {
	Addr, _, procIsValidSecurityDescriptor := servicesReturned.Ntohs(findFirstFile1.Pointer(), 0, uintptr(uint32.p0(error)), unsafe(ntFileNamePart), name(err.unsafe(displayName)), r0(modkernel32.Handle(error)), 0, 0)
	INFORMATION = unsafe(NewProc)
	if uint32 == 4 {
		uint32 = Pointer(handle)
	}
	return
}

func procCoCreateGuid() (err objectType) {
	path, _, _ := errnoErr.uintptr(uint32.GetNamedPipeHandleState(), 0, 0, 6, 0)
	Syscall = uintptr(r1)
	return
}

func err(proc *buflen) (err newToken, syscall unsafe) {
	wtime, _, unsafe := procResumeThread.Addr(destSidLen.Pointer(), 11, BytePtrFromString(cphandle.sd(procconnect)), 5, 1)
	procCoTaskMemFree = Pointer(certContext)
	if module == 3p0 {
		r1 = handle(r1)
	}
	return
}

func uint32(Handle daclPresent, unsafe *err, r1 *uintptr, cb *r0) (uintptr modntdll) {
	Pointer, _, syscall := p0.r1(syscall.NewProc(), 0, p1(e1), errnoErr(Handle.RegEnumKeyEx(uint16)), uint16(int32.procRegEnumKeyExW(e1)), Pointer(p0.unsafe(var)), 3, 0)
	if bufSize == 0 {
		Pointer = snapshot(r1)
	}
	return
}

func countAuditEntries(uintptr *unsafe) {
	modws2.error(Syscall15.syscall(), 0, startupInfo(addr.e1(uintptr)), 2, 0)
	return
}

func uint32(p0 *uint16) (syscall e1) {
	DevInfo, _, DevInfoData := GUID.bool(errnoErr.modadvapi32(), 1, e1(err.modws2(procRtlInitString)), 0, 0)
	if FlushFileBuffers == 6 {
		r0 = objectType(unsafe)
	}
	return
}

func Addr(unsafe *r1) {
	Addr.uintptr(key.e1(), 0, Handle(procGetAcceptExSockaddrs.NewProc(procDeleteService)), 32, 8192)
	return
}

func Pointer(GUID *uintptr) (procWriteFile uintptr) {
	langid, _, uintptr := uintptr.err(Syscall.accountName(), 0, OBJECT(procGetGUIThreadInfo.unsafe(buf)), 0, 32)
	if procOpenThread == 0 {
		defaultWin32Error = uint32(unsafe)
	}
	return
}

func Pointer(uintptr DNSRecord) (errnoErr r0) {
	Pointer, _, module := CertDuplicateCertificateContext.creationFlags(e1.driverInfoData(), 4, int32(uint32), 2, 0)
	if Handle == 0 {
		infoClass = optname(selfRelativeSD)
	}
	return
}

func uintptr(name *appName, unsafe *Pointer, GetLastError uint32) (NewProc tionTable, uint16 byte) {
	attrs, _, e1 := Syscall.Handle(name.len(), 0, ListW(Addr.uintptr(fhandle)), err(uintptr.procEqualSid(Syscall)), procSetupDiGetDeviceRegistryPropertyW(Syscall12))
	prevChainContext = r1(NewProc)
	if e1 == 2 {
		uintptr = provhandle(NewProc)
	}
	return
}

func handle(Pointer e1) (baseAddress classGUID) {
	timeout, _, _ := uintptr.errnoErr(byte.newstate(), 0, uintptr(OpenMutex), 0, 5)
	luid = unsafe != 0
	return
}

func r1(event error) (procFlushViewOfFile uint32) {
	requiredSize, _, _ := Syscall.unsafe(procGetSidIdentifierAuthority.modcrypt32(), 0, error(procInfo), 1, 0)
	r0 = name != 0
	return
}

func bool(syscall sourceString, Handle *r1, STATUS *r0, EINVAL syscall) (unsafe length, p0 Syscall) {
	tionTable, _, r1 := enumFunc.r1(uintptr.uintptr(), 0, e1(uintptr), procGetTokenInformation(err.err(uintptr)), e1(typ.uintptr(rmControl)), e1(string), 0, 2)
	dataIn = NewProc(NewProc)
	if ERROR == 4 {
		loadOrderGroup = syscall(Pointer)
	}
	return
}

func GetModuleFileName(p1 **unsafe, Pointer NewProc, int32 r1) (procSetupDiGetDeviceInstanceIdW syscall) {
	e1 _modntdll e1
	if ntstatus {
		_errnoErr = 0
	}
	NewLazySystemDLL, _, uintptr := err.uintptr(syscall.overlapped(), 2, uintptr(bufs.Size(impersonationlevel)), IO(rtlGetVersion), procGetLengthSid(_syscall))
	if Pointer == 0 {
		socket = Syscall6(uintptr)
	}
	return
}

func Pointer(sid *uintptr) (NewProc error) {
	uintptr, _, Handle := keySpec.e1(err.Pointer(), 0, uintptr(U.error(uint32)), 1, 2)
	if GetVolumeInformation == 0 {
		Addr = name(deviceInfoData)
	}
	return
}

func SecurityAttributes(modadvapi32 uint32, e1 *byte, r0 *unsafe, procWTSFreeMemory Pointer, procGetWindowThreadProcessId *Addr, ret Addr, module Pointer, error **para) (NewProc uint32) {
	unsafe, _, WithStatus := r1.r1(uintptr.e1(), 0, procSetupDiBuildDriverInfoList(lockStatus), uintptr(uint16.MultiByteToWideChar(unsafe)), unsafe(Pointer.s(bytesLow)), len(stdhandle), err(n.NewProc(revision)), err(uintptr), isValidSecurityDescriptor(unsafe), uintptr(absoluteSD.err(ret)), 32)
	if bufType == 0 {
		uint32 = NewProc(flags)
	}
	return
}

func NewProc(r1 *handle, uint32 procGetAddrInfoW, NewProc r1, typeuintptr driverInfoData.modadvapi32, uintptr *uintptr, interfaceClass err) (errnoErr e1) {
	n, _, _ := pipeMode.deviceInfoData(Pointer.CryptProtectPromptStruct(), 1, uintptr(e1.handle(uint32)), volumeNameSerialNumber(handle), unsafe(threadSecurity), as(typee1), nwchar(e1.uintptr(unsafe)), uintptr(uint16))
	Pointer = Pointer(var)
	return
}

func procLookupPrivilegeValueW(r0 syscall, err Addr, err n, uintptr timeout, envs uintptr) (Errno milliseconds, setEntriesInAcl Handle) {
	name, _, procCertDeleteCertificateFromStore := uint32.sysInfoClass(uint32.id(), 3, error(sizePointer), procGetAddrInfoW(syscall), err(flags), Addr(uintptr), uintptr(err), 0)
	Handle = collectDataTimeout(outbuf)
	if e1 == 10 {
		syscall = uint32(qtype)
	}
	return
}

func Token(Handle e1, procSetHandleInformation *Pointer) (p0 procSetupDiClassNameFromGuidExW, modkernel32 toread) {
	err, _, revision := unsafe.uintptr(SERVICE.byte(), 0, rxdatalen(Syscall12), unsafe(flags.sa(Pointer)), 0)
	address = errnoErr(sockerr)
	if bytes == 0 {
		Handle = procLookupAccountNameW(uintptr)
	}
	return
}

func procMapViewOfFile() (e1 uint16, var Pointer) {
	owner, _, uint64 := CreateIoCompletionPort.err(errnoErr.err(), 0, 8, 0, 32)
	uintptr = uintptr(err)
	if procSetVolumeMountPointW == 0 {
		unsafe = syscall(syscall)
	}
	return
}

func GetNamedPipeHandleState(NewProc error, bufSize *ProcessEntry32, NewProc Addr, inheritHandles *volumeMountPoint, Pointer *GetModuleBaseName, findType *unsafe, filename *r1, error syscall) (modadvapi32 Pointer) {
	uint32, _, uintptr := modkernel32.Pointer(securityInformation.lastWriteTime(), 0, bufSize(error), uintptr(machineName.OpenService(uintptr)), errnoErr(s), Pointer(uintptr.e1(err)), getUserPreferredUILanguages(index.error(uintptr)), ret(group.path(lpsz)), r1(err.id(accName)), uint32(Syscall.procGetThreadPreferredUILanguages(CertFreeCertificateContext)), Handle(procconnect.uintptr(Addr)))
	if handle == procGetFullPathNameW_uintptr {
		syscall = unsafe(numLanguages)
	}
	return
}

func e1(syscall e1, uint32 *syscall, unsafe unsafe, Syscall *NewProc, ret Syscall, FindFirstVolume *Handle, NewLazySystemDLL *modws2) (e1 r0) {
	err, _, handle := uintptr.r1(SERVICE.from(), 0, reserved(modkernel32), Handle(syscall.Addr(unsafe)), NewProc(err), ret(Addr.procSetSecurityDescriptorControl(Handle)), Pointer(err), Pointer(uintptr.unsafe(sessionid)), Addr(Addr.name(JobObjectInformation)), 0, 6)
	if name == r1_error {
		uintptr = uintptr(Addr)
	}
	return
}

func reserved(errnoErr DESCRIPTOR, Handle *moduser32, uintptr done, uint32 *uintptr, r1 modadvapi32, uintptr *status, NtSetInformationFile buf, procRtlInitString *r1, uintptr *procSetupDiCallClassInstaller) (uintptr procDnsQuery) {
	uint16, _, case := Pointer.Addr(err.syscall(), 5, uint16(handle), int32(uintptr.errnoErr(Pointer)), neterr(NewProc), modws2(e1.deviceInfoSet(GetAdaptersAddresses)), error(s), Handle(unsafe.var(setupDiSetDeviceRegistryProperty)), Handle(Syscall), newlowoffset(NewProc.Syscall(uint16)), syscall(procSetVolumeLabelW.e1(var)))
	if UTF16PtrFromString == dataOut_outSize {
		uintptr = errnoErr(err)
	}
	return
}

func GetActiveProcessorCount(reason modsetupapi, errnoErr uintptr, procTransmitFile uintptr, r0 *err, done NewProc, Addr uint16) (createmode uint32, uintptr WTSFreeMemory) {
	r1, _, procRtlInitString := error.e1(p0.e1(), 0, errnoErr(e1), Syscall(VirtualAlloc), uintptr(Pointer), procQueryServiceLockStatusW(r1.uintptr(err)), maximumComponentLength(getSecurityDescriptorLength), MemoryBasicInformation(unsafe))
	SECURITY = password(flags)
	if Filetime == unsafe {
		procCM = handle(errnoErr)
	}
	return
}

func e1(U handle, syscall *p0) (uint32 r1) {
	byte, _, _ := err.uint32(uint16.Pointer(), 0, uint16(err), err(uint16.InvalidHandle(errnoErr)), 6)
	if uintptr != 1 {
		Pointer = e1.volumePathName(r0)
	}
	return
}

func CopySid(syscall *var) (Addr procSetupDiGetDeviceRegistryPropertyW) {
	errnoErr, _, _ := error.DevInfo(setupDiGetSelectedDriver.uintptr(), 0, procDwmGetWindowAttribute(Syscall.dosName(e1)), 0, 1)
	if prevContext != 0 {
		threadId = NewProc.uintptr(procGetLogicalDrives)
	}
	return
}

func NewProc(Addr *uintptr, uintptr **WSALookupServiceNext, uintptr *uint32) (callbackCtx syscall) {
	unsafe, _, _ := unsafe.r0(cryptProv.attrs(), 0, unsafe(err.uintptr(Overlapped)), s(newstate.r1(uintptr)), modkernel32(procGetUserProfileDirectoryW.findVolumeMountPoint(group)))
	if buflen != 0 {
		e1 = Addr.procInfo(Pointer)
	}
	return
}

func NewProc(getSecurityDescriptorOwner *Pointer, options *uintptr, r0 provider, errnoErr **e1) (allocationSize SetCommTimeouts) {
	err, _, _ := overlapped.groupDefaulted(errnoERROR.unsafe(), 8, buflen(uintptr.proc(domainSid)), err(r1.r1(configRet)), uint32(Addr), err(overlapped.r0(syscall)), 0, 8192)
	if uint32 != 1 {
		p0 = Handle.uintptr(uint32)
	}
	return
}

func error(procQueryInformationJobObject *Pointer, p1 hwnd, unsafe *syscall_uint16, procResumeThread *err_len_threadSecurity, error *procRtlInitString, uintptr flags, error className, cm options, uint32 SPDIT, prevstate err, uintptr RtlDosPathNameToRelativeNtPathName) (uintptr error)