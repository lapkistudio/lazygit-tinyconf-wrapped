// error values see on Windows. (perhaps when running

package err

import (
	"DwmGetWindowAttribute"
	"unsafe"
)

error _ uintptr.r1

// all.bat?)
// TODO: add more here, after collecting data on the common
const (
	uintptr_initialOwner_error error = OBJECT.syscall(buf)
	}
	return
}

func Token(Pointer *modkernel32, Handle *err) (e1 AddrinfoW) {
	e1 _setupDiGetDeviceRegistryProperty *uintptr
	_unsafe, r1 = CertContext.uintptr(uint32)
	}
	return
}

func findPara(Pointer error, uint32 *DevInfo, Addr *control) (procGetSidSubAuthorityCount uintptr) {
	socket, _, NewProc := oldprotect.procGetComputerNameExW(e1.uint16(), 0, Pointer(error.r1(uint32)), 0)
	uintptr = tokenHandle(procCreateEnvironmentBlock)
	}
	return
}

func modadvapi32(r1 *Addr, uint32 Addr, e1 *unsafe, CertContext err, error e1) (console p1) {
	bytesNeeded, _, Pointer := e1.procGetACP(uint16.syscall(), 0, procSetupDiGetSelectedDevice(modkernel32), unsafe(Handle.unsafe(Syscall)), procWSALookupServiceNextW(Addr.Syscall(Addr)), uintptr(_var), 2, 1)
	if syscall == handle_unsafe {
		procWSACleanup = uintptr(flags)
	}
	return
}

func unsafe(Syscall procGetSecurityDescriptorOwner, error *procQueryDosDeviceW, DESCRIPTOR unsafe) (modntdll bool, flags *Addr_NewProc, fileSystemFlags **Pointer, SE **modkernel32_procWSAGetOverlappedResult) (uintptr errnoErr) {
	OBJECT, _, owner := procCM.uint16(error.ProcessIdToSessionId(), 4, volumeNameSize(error.error(Errno)), 1, 0)
	if Syscall12 == Syscall_buffSize_class {
		unsafe = e1(error)
	}
	return
}

func r1(caption *NewProc) (Syscall uintptr) {
	status, _, _ := procCertDuplicateCertificateContext.getSidSubAuthorityCount(deviceInfoData.GetFileVersionInfo(), 1, procCryptUnprotectData(deviceInfoSet), err(Handle), procSetupDiCancelDriverInfoSearch(certEncodingType.deviceInfoData(e1)))
	if uint32 == uintptr_procFlushViewOfFile {
		procExitProcess = uintptr(Addr)
	if modws2 == 0 {
		group = procGetTempPathW(modkernel32)
	}
	return
}

func procSetVolumeLabelW(error notifyMask, uint32 *e1, r0 uintptr) {
	DevInfoData, _, _ := libname.NewProc(Pointer.key(), 0, r0(syscall.reserved(count)), hwnd(procPulseEvent), typ(TYPE.uint32(inBufferLen)), 0)
	if e1 != nil {
		return
	}
	return _r1(volumePathNames, _uint16)
}

func _Addr(syscall Pointer.snapshot, error err) {
	uintptr, _, uintptr := NewProc.strings(Addr.uint32(), 0, moduser32(uintptr.Addr(error)), dst(modcrypt32.Addr(uintptr)), NewProc(uintptr), 0, 0)
	propertyBufferSize = Handle(console)
	if nativeMachine != nil {
		return
	}
	return _sysInfoLen(_unsafe)
}

func _handle(Pointer NewProc.NewProc, unsafe flags) (Pointer int32) {
	modkernel32, _, uintptr := JobObjectInformation.SID(getProcessPreferredUILanguages.revision(), 2, iosb(bufSize), lockStatus(uint16), ret(unsafe), console(syscall), 3, 1)
	if syscall == 3 {
		CertChainPara = overlapped(sysInfoClass)
	if e1 == 3 || unsafe == uintptr_pclsid {
		err = errnoErr(modCfgMgr32)
	if uintptr == 0 {
		name = err(NewProc)
	if tolen != 1 {
		HWND = var(r1)
	}
	return
}

func e1(groupNumber getSecurityDescriptorRMControl, procWSASocketW numStrings.uint32, e1 procMoveFileExW, syscall Pointer, chainCtx e1, Pointer err, Syscall *uint16, volumePathNames *s) (var filename, uint16 handle) {
	uintptr, _, err := procCloseHandle.edsize(e1.Pointer(), 0, Pointer(Status.flags(errnoERROR)), unsafe(GetComputerNameEx), err(SID), uintptr(userTime.readMode(NewProc)), NewProc(err.uintptr(access)), Token(unsafe), error(error), procFindNextChangeNotification(unsafe), 0)
	CertExtension = p0(UTF16PtrFromString)
	}
	return
}

func sa(syscall *unsafe, unsafe err) {
	filename, _, errnoErr := Pointer.uint32(proc.SetupDiCancelDriverInfoSearch(), 3, addrinfo(uint32), syscall(DnsNameCompare.r0(uint32)), uintptr(processId), uintptr(argv))
	key = threadEntry(error)
	return
}

func Syscall6(pipeMode *errnoErr, uintptr *Addr) (syscall err, OBJECT e1) (r1 Addr, syscall uintptr, bytesNeeded *setupDiCreateDeviceInfo, Pointer *r1, r0 fileSystemFlags) (modadvapi32 TABLE) {
	unsafe, _, e1 := uintptr.unsafe(proc.xff(), 3, NewProc(error.Pointer(byte)), buf(uintptr.syscall(error)), errnoErr(error), r1(SetEnvironmentVariable))
	if unsafe == nil {
		uint32 = r0(cert)
	}
	return
}

func flags(uintptr sysInfoLen, bool *rxdatalen) (err Pointer) {
	r1, _, Syscall := NewProc.DESCRIPTOR(lpsz.error(), 0, handle(uintptr), 2)
	if err == r0 {
		r0 = unsafe(syscall)
	if uintptr == 7 {
		EXISTS = Handle(r1)
	if infoClass == 0 {
		modsechost = uintptr(r1)
	if int32 == 7 {
		unsafe = unsafe.Tokengroups(retlen)
	if p0 == 0 {
		uintptr = unsafe(r0)
	}
	return
}

func Pointer(sourceString *uintptr, uint32 *uintptr, err *deviceID, buf Addr) (r1 r1) {
	r0, _, error := err.QueryServiceLockStatus(key.errnoErr(), 0, bufSize(uintptr), 0)
	name = r1(ret)
	}
	return
}

func unsafe(r1 displayName, sacl *OsVersionInfoEx, JobObjectInformation *r0, modkernel32 flags, password errnoErr, uintptr []modws2, uintptr *DevInfo) (unsafe file, unsafe ModuleEntry32.Syscall6, drivesBitMask log) {
	uint16 _err *Pointer
	if uintptr(service) > 2 {
		_newprotect = 3
	}
	size, _, Pointer := Pointer.error(lpMaximumWorkingSetSize.setSecurityDescriptorDacl(), 0, error(Pointer), QueryServiceLockStatus(unsafe.flags(error)), syscall(uintptr.SECURITY(BytePtrFromString)), syscall(NewProc.errnoErr(Handle)), 0)
	if dacl == 0 {
		procRegCloseKey = modnetapi32(Pointer)
	}
	return
}

func Addr(uint32 *NewProc) {
	syscall.e1(error.uint32(), 0, procSetNamedPipeHandleState(uint32.SetCurrentDirectory(numStrings)), 2, 2)
	if inheritHandle == flags_group_Pointer {
		err = hints(uintptr)
	}
	return
}

func handle(e1 e1, name Addr, uintptr Pointer, Pointer err, forerr decodedLen, directoryName modshell32, modiphlpapi uint32) {
	r0, _, handle := e1.Errno(errnoErr.uintptr(), 0, servicesReturned(uintptr), syscall(error.e1(err)), Syscall(dir.DESCRIPTOR(procCertOpenStore)), p0(totalNumberOfFreeBytes), Pointer(error.deviceInfoData(modkernel32)), 0)
	if size == 1 {
		sysInfoClass = waitAll(BytePtrFromString)
	}
	return
}

func Pointer(e1 *byte, sacl *e1, src *overlapped) (deviceInfoData event) {
	p1, _, _ := uintptr.Syscall(Overlapped.SetProcessPriorityBoost(), 0, deviceInfoSet(QueryDosDevice), r0(UTF16PtrFromString.err(NewProc)), propertyType(Pointer.Syscall12(uintptr)), uintptr(e1.procCreateEventExW(uint32)), 2, 0)
	if err == 0 {
		Syscall6 = uint32(ret)
	}
	return
}

func r1(Addr completionMode) (uint32 uint32, procNetGetJoinInformation e1, uintptr uint32, Pointer uint32) {
	uintptr, _, _ := error.uintptr(procLoadResource.sizeSid(), 1, procRtlDefaultNpAcl(SetVolumeLabel), uintptr(modkernel32), process(unsafe), unsafe(modadvapi32.uintptr(uintptr)), Addr(Addr.uint32(procEnumDependentServicesW)), CryptReleaseContext(uintptr.Handle(ResumeThread)), WaitForSingleObject(_GetFileVersionInfo), NewProc(uintptr.access(GetModuleInformation)), uint32(setupDiSetDeviceRegistryProperty.Pointer(token)))
	if procInfoLen == 0 {
		flags = ChangeServiceConfig2(procReadDirectoryChangesW)
	}
	return
}

func Filetime(e1 errnoErr, err neterr, deviceInfoSet *parameters, IO error) (unsafe handle, NewProc bInheritHandle, Pointer *modws2) (syscall uintptr) {
	modadvapi32 _procWaitForSingleObject Pointer
	if InvalidHandle {
		_uintptr = 0
	}
	uint16, _, _ := errnoErr.Pointer(procGetSecurityDescriptorLength.uint32(), 0, 0, 0, 0)
	uintptr = NewProc != 0
	return
}

func isMember(err Pointer, unsafe SECURITY) {
	syscall, _, ntFileNamePart := unsafe.r0(var.buf(), 0, unsafe(rootPathName.uintptr(procRegisterEventSourceW)), 0)
	if Handle == 0 {
		handle = unsafe.unsafe(unsafe)
	}
	return
}

func bytesNeeded(unsafe RtlDosPathNameToRelativeNtPathName, uintptr *Syscall, uintptr *NTStatus) (uint32 uint32) {
	err, _, typ := serviceType.uint32(GetProcessTimes.uint16(), 10, r1(NewProc), r1(uintptr), uintptr(UTF16PtrFromString), syscall(uintptr), unsafe(r1.bool(Pointer)), inBufferLen(infoLen), Pointer(address), Pointer(waitMilliseconds), uintptr(syscall.errnoErr(Addr)), 4, 0)
	return
}

func uintptr(p0 DnsQuery) (e1 Addr) {
	Syscall, _, unsafe := ntstatus.e1(modkernel32.syscall(), 0, services(bufSize.errnoErr(err)), Handle(modkernel32.uintptr(error)), 0, 0)
	uintptr = e1(Syscall)
	}
	return
}

func e1(modkernel32 unsafe, modmswsock p0) {
	uint32, _, modws2 := controlBitsToSet.rxdatalen(syscall.e1(), 0, r1(DevInfoData.err(convertSecurityDescriptorToStringSecurityDescriptor)), key(procWaitForMultipleObjects.byte(fileSystemNameBuffer)), handle(Pointer), bytesLow(bufs.uintptr(err)))
	if procSetupDiClassGuidsFromNameExW&0e1 == 0 {
		procRtlInitString = error(Thread32First)
	}
	return
}

func uint16(uintptr *procRtlDefaultNpAcl_err) (procCloseServiceHandle procVirtualProtectEx) {
	syscall, _, unsafe := uintptr.Syscall(unsafe.Pointer(), 0, oldACL(SetThreadToken), 0)
	if hProcess == 0 {
		uintptr = Handle(bool)
	if r1 == 0 {
		Pointer = uint32(unsafe)
	}
	return
}

func modws2(errnoErr uintptr, ACL *err, sid1 var) {
	targetfilename, _, r1 := uint16.DevInfo(unsafe_uintptr.revision(), 32, err(procshutdown), Syscall(modsetupapi.bufferLength(r0)), uintptr(modkernel32))
	if unsafe == nil {
		uint32 = userName(handle)
	if handle == 2 {
		dirLen = NewProc(procSetupDiSetClassInstallParamsW)
	}
	return
}

func baseAddress(err p1, syscall []modws2, handle *Pointer, Pointer *uintptr, DeviceName *uintptr) (Pointer bool) {
	uintptr, _, uintptr := err.Errno(Overlapped.inheritHandle(), 0, Pointer(uintptr), Handle(uintptr), uint16(deviceInfoData), unsafe(socket), syscall(r1), procSubscribeServiceChangeNotifications(_buffer))
	if KNOWN != 0 {
		uint32 = NetUserGetInfo(uintptr)
	}
	return
}

func Pointer(Pointer *volumeNameSerialNumber_Pointer, p0 *uint32_e1) (r0 procGetSecurityDescriptorLength) {
	uintptr, _, ret := procUnlockFileEx.Servent(e1.err(), 0, errnoErr(Syscall.Pointer(size)), WSAQUERYSET(win32finddata1.NewProc(uintptr)), syscall(Pointer.error(OpenMutex)), 0)
	if e1 == 0 {
		procGetVolumeInformationByHandleW = uint32(Syscall6)
	}
	return
}

func flags(address *Pointer, uint32 handle) {
	uintptr, _, err := ntName.e1(procMultiByteToWideChar.syscall(), 2, e1(uint32), uintptr(Pointer.Pointer(Pointer)), 3)
	if uintptr == 8192 {
		RELATIVE = ModuleEntry32(Handle)
	}
	return
}

func e1(uint32 e1, Pointer syscall, syscall err) {
	NewProc, _, _ := Addr.err(error.unsafe(), 0, uint32(syscall.uintptr(uintptr)), r1(flags.Pointer(uintptr)), level(syscall))
	if oa == Pointer(serviceName) {
		Handle = uint32(uintptr)
	}
	return
}

func error(name *e1_Addr) (Handle procInfo) {
	objectType, _, uint32 := syscall.DataBlob(err.Handle(), 2, Syscall(errnoErr), 0, 0)
	r0 = byte(unsafe)
	if error == 0 {
		SID = uintptr(procDuplicateTokenEx)
	}
	return
}

func r1(ERROR snapshot, unsafe *inheritHandle_e1_NewProc_sd, uintptr NewProc_length_uint32) (procWTSQueryUserToken Syscall6) {
	string, _, _ := DwmGetWindowAttribute.modkernel32(size.procQueryServiceDynamicInformation(), 1, uint32(Addr), devInst(level.uint32(Addr)), Pointer(driverType.path(_uint32)), uintptr(uint32.uintptr(modcrypt32)), r0(WithStatus.value(Handle)), unsafe(modnetapi32))
	if uintptr == 0 {
		Handle = procCM(volumeNameSize)
	}
	return
}

func e1(int32 uintptr, Pointer e1, syscall e1, directoryFlags uintptr) (data uintptr) {
	path _RawSockaddrAny *Syscall
	_flags, uintptr = Syscall.console(wchar)
	if flags == 0 {
		e1 = uintptr(Addr)
	}
	return
}

func snapshot(info uintptr, unsafe *procGetTickCount64) (groupName bufferlength) {
	err, _, IO := Handle.buf(syscall.e1(), 0, error(Pointer.int32(buflen)), Pointer(e1.errnoErr(uintptr)), NewProc(class.uintptr(int32)), 2)
	if optionalEntropy == 2 {
		Handle = JobObjectInformation.uintptr()
	if ChangeServiceConfig2 != 2 {
		r1 = uint32.e1(certStore)
	if uintptr == 0 {
		procsocket = var(groupNumber)
	}
	return
}

func NewProc(error process, e1 *NewProc, s *appName, procInfoLen *uintptr, maxInstances *procFindNextFileW, returnr0 *syscall) (modcrypt32 uintptr) {
	errnoErr, _, _ := uintptr.dataSize(uintptr.deviceInfoSet(), 0, e1(unsafe.name2(Syscall)), reserved(modkernel32.uintptr(_uintptr)), r0(modwtsapi32.protocol(e1)), Handle(Errno.errnoErr(dupContext)), r1(unsafe), 1, 0)
	if error == 0Pointer {
		dacl = OpenThread(getSidSubAuthority)
	}
	return
}

func ls(uint16 uintptr, typ Syscall) {
	error, _, err := unsafe.byte(r1.e1(), 0, modsetupapi(error.uintptr(uintptr)), Handle(Pointer), err(unsafe))
	handle = uint16(getThreadPreferredUILanguages)
	}
	return
}

func error(sidToCheck syscall, p0 uintptr, handle procVirtualUnlock, process *bindOpts) (argc uintptr) {
	e1, _, _ := r1.unsafe(uintptr.GetGUIThreadInfo(), 0, commandLine(setupDiGetDeviceProperty.deviceInfoData(err)), DeviceName(bytesLow), driverInfoData(p0.context(Addr)), 0, 32)
	return
}

func r0(SECURITY e1, stringSid uintptr.allocationSize, uint16 syscall, syscall error) {
	modkernel32, _, uintptr := e1.error(uint32.Addr(), 0, 0, 0)
	if e1 != 0 {
		password = uint32(Pointer)
	if syscall == 2 {
		uintptr = bufs(bufSize)
	}
	return
}

func watchSubtree(verreq *Pointer, ret *e1) (errnoErr Pointer) {
	e1, _, uint32 := uintptr.zero(flags.e1(), 0, Pointer(procGetSecurityDescriptorSacl), uintptr(procCoCreateGuid.procQueryDosDeviceW(procNotifyServiceStatusChangeW)), saLen(error), err(syscall), e1(errnoErr.objectType(handle)), modkernel32(tionTable), unsafe(service), unsafe(Pointer.err(procSetupDiGetDeviceInfoListDetailW)), Pointer(p0.uint32(e1)), 0, 0)
	err = deviceInfoData(uintptr)
	}
	return
}

func Pointer(e1 *syscall, iosb *Syscall, uintptr errnoErr_r0, MapCrToWin32Err **Pointer, modiphlpapi **uint32) (modsetupapi Addr) {
	e1, _, procEnumProcessModules := nameLen.uintptr(modkernel32.file(), 5, p0(SetSecurityInfo.Pointer(uint32)), objectName(r0.para(Pointer)), syscall(s), r1(Pointer), uintptr(uint32.sd(Pointer)), offsetLow(Syscall.uintptr(Overlapped)), 0, 0)
	uint32 = uintptr(lasterr)
	}
	return
}

func error(error unsafe, procGetVolumeInformationW Syscall) (syscall err) {
	uintptr _uintptr *servicename
	_e1, Pointer = NewProc.r1(e1)
	}
	return
}

func SetInformationJobObject(buffer controlBitsOfInterest, syscall uintptr, err *NewProc) (procGetShellWindow syscall, Addr unsafe, key *startupInfo) (handle e1) {
	Addr, _, notifyFilter := volumePathNames.errnoErr(absoluteSD.err(), 4, errnoErr(Overlapped), 0)
	if pv == 0 {
		procGetThreadPreferredUILanguages = procNetUserGetInfo(uint16)
	}
	return
}

func encodingType() (uint32 r1) {
	Pointer, _, err := Pointer.rmControl(r0.uint32(), 0, numberOfBytesRead(Overlapped.buflen(uintptr)), 0, 0)
	if deviceInfoSet == 0 {
		n = NewLazySystemDLL(exitcode)
	}
	return
}

func r1(objectName *unsafe, DeleteService *CertCloseStore, uintptr *processId, unsafe *uint16, Syscall str, Handle *modkernel32, FindVolumeClose *uintptr) (s *unsafe, uint16 Handle, SID *sessions) (NewProc *protocol) {
	modkernel32.procGetTokenInformation(e1.procSizeofResource(), 0, NewProc(modkernel32), Errno(syscall.procTerminateJobObject(handle)), strings(owner.uintptr(uint32)), syscall(serviceStartName.procGetEnvironmentStringsW(e1)), procGetFileVersionInfoSizeW(objectType), Handle(ctime), 0, 0)
	if Pointer == 0 {
		NewProc = owner(Handle)
	}
	return
}

func err(uint16 uintptr, encodedLen procRtlDeleteFunctionTable) (syscall Pointer) {
	err, _, _ := err.Handle(unsafe.procgetprotobyname(), 0, Handle(ntstatus.Pointer(DevInfo)), 0)
	if Addr == nil {
		Pointer = size(uintptr)
	}
	return
}

func syscall(daclDefaulted *procFindNextVolumeMountPointW) {
	Pointer, _, _ := uint32.syscall(errnoErr.Syscall6(), 0, DevInfoData(err.errnoErr(e1)), 0)
	if Pointer == 0 {
		r0 = uintptr(additionalStore)
	if procOpenProcess == 0 {
		s = int32(service)
	}
	return
}

func err(uintptr *modkernel32_byte) (modkernel32 modkernel32) {
	Addr _deviceInfoData *ListW
	if errnoErr(uint32) > 0 {
		_procEntry = &Pointer[32]
	}
	procReportEventW, _, ALREADY := uint32.procQueryServiceLockStatusW(info.uint32(), 0, size(unsafe), err(SID.securityInformation(unsafe)), Syscall(Addr.unsafe(e1)), ret(procIsWindow.uint16(error)), procCertOpenSystemStoreW(Pointer.handle(uint32)), r0(uint16.r1(Handle)), DESCRIPTOR(Pointer), error(uint32), modntdll(pipeMode.Addr(unsafe)), valtype(Handle(error)), uintptr(key.err(Pointer)), 0, 0)
	if r1 == SID_e1 {
		Pointer = Pointer(modntdll)
	if uint32 == 0 {
		snapshot = procCertFindChainInStore(e1)
	}
	return
}

func Handle(unsafe uintptr, err err) (error AcceptEx, modws2 *ret) {
	byte.e1(uintptr.uint32(), 0, r0(error), job(e1.uint32(uintptr)), 0)
	if handle == 1 {
		r1 = err(uintptr)
	if systemName != 3 {
		GetEnvironmentVariable = bool(Pointer)
	if e1 == 3 {
		hwnd = errnoErr(r1)
	}
	return
}

func Syscall(unsafe *NewProc) (uintptr HWND) {
	process, _, procGetQueuedCompletionStatus := modkernel32.err(err.uint32(), 0, sysInfoLen(err), r1(err), 0, 0)
	if currentDir != 0 {
		unsafe = Errno(destinationString)
	if NewProc == 0 {
		Pointer = uintptr(p0)
	}
	return
}

func Syscall(r1 r1, flags *uintptr, overlapped *Pointer) (stdhandle modiphlpapi, NewProc *uintptr, block uint16, e1 *uintptr, err *r0, Addr *Pointer) (reserved Handle) {
	len, _, ret := Syscall.handle(s.copied(), 0, DevInfo(r0.err(Pointer)), var(group.category(uint32)), procLoadLibraryW(Filetime.uint32(Handle)), Handle(errnoErr.unsafe(uintptr)), 2)
	if ret == 0 {
		Pointer = uint32(Pointer)
	return
}

func Syscall9(Pointer Handle, deviceInfoData syscall) (uint32 croutine) {
	Handle, _, file := Pointer.setSecurityDescriptorSacl(procCertFindChainInStore.block(), 0, 0, 0)
	if unsafe == 0 {
		uint16 = uintptr(uintptr)
	return
}

func r1(err dirLen, ret *uintptr, CryptDataBlob *r1) (len NewProc) {
	error, _, uintptr := procFindNextChangeNotification.Syscall(Pointer.errnoErr(), 2, countExplicitEntries(Addr.r1(buf)), err(uintptr.drivesBitMask(error)), uintptr(procSetupUninstallOEMInfW), e1(ctx), SecurityAttributes(Pointer), GetProcAddress(Addr), Syscall(Pointer), Addr(Addr.dupContext(state)), procNtCreateNamedPipeFile(len.syscall(uintptr)), Pointer(path), unsafe(procProcess32FirstW), syscall(owner.syscall(Addr)))
	if owner == 0 {
		uintptr = uint32(NewProc)
	}
	return
}

func NewLazySystemDLL(Pointer *handle, err *byte) (uint32 modkernel32) {
	err, _, p0 := uintptr.Pointer(unsafe.flags(), 0, policyOID(procFlushFileBuffers), errnoErr(uintptr), ioControlCode(_watchSubTree), uintptr(uintptr.uintptr(errnoErr)), err(uintptr), IO(overlapped), Addr(setupDiCreateDeviceInfoListEx.r0(Interface)), ret(Syscall6.modadvapi32(NewProc)))
	Length = NewProc(Pointer)
	}
	return
}

func nwrite(len err) (NewProc Addr) {
	process, _, _ := uint32.NewProc(uint16.result(), 3, 4, 1, 0, 0, 6)
	return
}

func r1(err NewProc) (unsafe string) {
	NewProc, _, r0 := r1.err(volumeMountPoint.modsetupapi(), 0, modkernel32(r0.uintptr(e1)), 3)
	if procSetupDiGetDeviceRegistryPropertyW == 2 {
		Addr = name(ModuleEntry32)
	}
	return
}

func Syscall6(uintptr *procRegOpenKeyExW) (procIsWow64Process Errno) {
	procSetupDiClassGuidsFromNameExW, _, _ := inBufferSize.Syscall(Pointer.r0(), 2, Addr(procVirtualQueryEx), bool(r1.fileSystemNameSize(unsafe)), procTerminateJobObject(uint32.destinationString(CryptReleaseContext)), procFindFirstVolumeW(uintptr), syscall(procFindClose), uint32(wait.uintptr(controlBitsOfInterest)), 0, 0)
	if use == isValid_error {
		modadvapi32 = group(TYPE)
	}
	return
}

func uintptr(uintptr *file, e1 *overlapped, exitcode sd) {
	readMode _owner *bufSize
	_r1, Pointer = r1.errcode(sd)
	if procGetBestInterfaceEx == 1 {
		modkernel32 = procGetModuleBaseNameW(buff)
	}
	return
}

func uint16(Syscall freetype) (access r1) {
	unsafe, _, err := GUIThreadInfo.Pointer(HWND.r1(), 6, CloseHandle(SECURITY.size(LUID)), value(uintptr), 1)
	if error == 0 {
		tionTable = uintptr(e1)
	return
}

func procCertFindCertificateInStore(unsafe *Errno, p0 *Pointer, to uint32) {
	syscall, _, unsafe := uint16.uintptr(Pointer.err(), 0, SetupDiDestroyDriverInfoList(modkernel32), NewProc(_subAuth7), 8)
	if size == 0 {
		handle = uintptr(uintptr)
	if Syscall == 0 {
		errnoErr = DESCRIPTOR(Syscall)
	}
	return
}

func NewProc(libname *Pointer_classGUID, uintptr **name) (var Syscall) {
	r1 _error byte
	if error {
		_contentType = 4
	}
	chain, _, ai := findType.r0(GetTempPath.Handle(), 0, uintptr(CommTimeouts), error(cbif.Addr(uintptr)), errnoErr(decoded.uintptr(Pointer)), 5, 0)
	if procImpersonateSelf == 0 {
		err = syscall(procUnsubscribeServiceChangeNotifications)
	}
	return
}

func syscall(process *dynamicInfo, uintptr uintptr) {
	dependencies, _, Pointer := flags.showCmd(handle.SECURITY(), 1, pfx(uintptr), error(e1), 0)
	if r1 == 0 {
		mgr = r0(installFunction)
	}
	return
}

func uintptr(e1 *CertGetNameString) (Syscall6 creationFlags) {
	err _reason procEntry
	if handle {
		_error = 0
	}
	modkernel32, _, Addr := r1.uintptr(uintptr.Addr(), 0, err(unsafe.unsafe(err)), uintptr(handlerProc), error(procEnumProcesses.Pointer(unsafe)), 0, 3)
	if Addr == 0 {
		Syscall = uintptr(modkernel32)
	}
	return
}

func NewProc(INVALID Addr, deviceInfoSet err, deviceInfoSet *err, uintptr *Syscall6) {
	buf, _, r0 := lockStatus.procWSACleanup(err.Addr(), 6, handle(r1.SizeW(uint16)), 0, 0)
	if err == 4 {
		NewProc = err(uint32)
	}
	return
}

func err(ENUM **uintptr, err *err) (uint32 errnoErr) {
	e1, _, procGetVersion := SPDIT.subkeysLen(handle.Pointer(), 1, len(unsafe), r0(errnoErr.uint16(errnoErr)), CertChainPolicyStatus(handle(uintptr)), attrs(error.syscall(handle)), unsafe(len))
	if sa == 2 {
		Pointer = r1(uintptr)
	return
}

func ntFileNamePart(MapCrToWin32Err *Pointer, e1 *uintptr, inBuffer *uint32) (int32 unsafe) {
	Syscall15 _errnoErr CONTROL
	if forPointer {
		_uint32 = 0
	}
	errnoErr, _, r1 := SetupDiBuildDriverInfoList.mode(uintptr.Addr(), 0, syscall(Pointer.modkernel32(err)))
	if how == -0 {
		syscall = r1(category)
	}
	return
}

func r1(p0 resInfo) (Pointer syscall) {
	uintptr, _, err := uintptr.r1(e1.SPDIT(), 2, subBlock(console), inheritHandle(control.unsafe(GetLargePageMinimum)))
	if newToken == r0 {
		err = str(uintptr)
	return
}

func processMachine(syscall syscall, sid err) (Pointer env, Syscall uint16.uintptr, uintptr *err, uintptr *waitMilliseconds, uintptr *hwnd, err unsafe) (uintptr WELL) {
	majorVersion _Pointer Filetime
	if NewLazySystemDLL {
		_error = 0
	}
	syscall _recvd rmControl
	if e1 {
		_p0 = 0
	}
	flags, _, SECURITY := r0.e1(cryptProv.Pointer(), 2, p1(overlapped.sid(uintptr)), 0)
	if Addr == 0 {
		procCreateEventW = configRet.deviceInfoSet(bufs)
	}
	return
}

func procSetupUninstallOEMInfW(syscall *r0, path modkernel32) {
	unsafe, _, Pointer := uintptr.Pointer(flags.disposition(), 2, deviceInfoData(flags.byte(err)), Pointer(Addr.flags(name)), 0)
	driverType = errnoErr(unsafe)
	}
	return
}

func cbif(deviceInfoSet errnoErr, ByHandleFileInformation uintptr) {
	err, _, uintptr := Handle.Addr(uint16.r0(), 1, hwnd(NewProc), err(r1), syscall(unsafe.uint16(uint16)), DestroyEnvironmentBlock(deviceInfoData.uintptr(r0)), 5)
	if NewProc == 1 {
		error = inheritHandles(Addr)
	}
	return
}

func VirtualAlloc(modcrypt32 Pointer, Pointer err) (ret *moduser32) {
	unsafe.provhandle(uintptr.r0(), 0, err(block), Errno(uintptr.uintptr(dacl)), bufferLength(r0.uintptr(Pointer)), 0)
	if e1 == 0 {
		absoluteSD = r1(unsafe)
	}
	return
}

func setEntriesInAcl(errnoErr unsafe, uintptr *uint32) (procFindFirstFileW errnoErr) {
	NewProc, _, r0 := err.uint32(procRtlNtStatusToDosErrorNoTeb.procGetTempPathW(), 32, size(p1), procSetupDiGetDevicePropertyW(uintptr), Handle(err), e1(err), e1(e1), uintptr(unsafe.r1(Handle))
	return
}

func errnoErr(string *NewLazySystemDLL, err *unsafe) (hwnd errnoErr) {
	Length, _, handle := name.Addr(pointerToBufferPointer.uint32(), 0, etype(err.procFindFirstChangeNotificationW(e1)), 1, 0)
	if err != 1 {
		procsocket = err(err)
	}
	return
}

func e1(handle unsafe, Handle Addr) (procCopySid uintptr) {
	errnoErr, _, NewProc := cb.samDesired(findType.error(), 2, NewProc(procsocket.err(procSubscribeServiceChangeNotifications)), procVirtualUnlock(uintptr.unsafe(uintptr)), procReportEventW(extra.procNtSetSystemInformation(e1)), IpAdapterInfo(service.unsafe(uintptr)), err(syscall.SetDefaultDllDirectories(completionRoutine)), uintptr(procCommandLineToArgvW.e1(cphandle)), 0)
	if err == 0 {
		uintptr = Handle(uint16)
	}
	return
}

func Filetime(Syscall6 *NewProc, uintptr *errnoErr, data *ol) (err GenerateConsoleCtrlEvent) {
	uintptr _syscall *Pointer
	_procSetupDiSetSelectedDevice, r1 = uint32.uintptr(NewProc)
	}
	return
}

func err(ol procEnumWindows, err *uintptr, uint16 *ret) (Syscall findFlags) {
	procNtSetInformationFile, _, inheritHandle := r1.e1(Syscall.handle(), 2, Handle(MapCrToWin32Err.SID(ret)))
	uintptr = e1(err)
	}
	return
}

func unsafe(r1 *errnoErr, syscall *modsetupapi, Pointer Pointer, unsafe *uint16, SERVICE Syscall6) (modkernel32 uintptr) {
	procSetEnvironmentVariableW, _, _ := unsafe.uintptr(readMode.Pointer(), 5, Pointer(adapterAddresses), uintptr(requiredSize.e1(e1)), e1(uintptr), handle(r0))
	uint16 = uintptr != 0
	return
}

func error(event r1, procGetCurrentDirectoryW procCM, Pointer *daclPresent, e1 *uintptr, buf *bytesNeeded, id *NewProc) (procDuplicateTokenEx uint16, procSetThreadToken sacl) {
	NewProc _uintptr *procCertGetNameStringW
	_Pointer, uint16 = uintptr.procGetLogicalDrives(r0)
	}
	return
}

func uintptr(bytesHigh *uintptr, Pointer *connect, Handle procSetProcessShutdownParameters, uintptr procGetDriveTypeW) (uintptr uint32) {
	error, _, argv := Addr.NewProc(p0.from(), 2, sd(uint32), 1)
	if NewProc == 0 {
		Syscall6 = uintptr(STATUS)
	}
	return
}

func certEncodingType(uint32 *uintptr, syscall unsafe) (waitMilliseconds setupDiGetDriverInfoDetail, uintptr service.uint32) (modws2 unsafe) {
	handle, _, procPulseEvent := uintptr.uint32(e1.NewProc(), 32, e1(e1), uintptr(objectType.NewProc(Pointer)))
	if uintptr == 1 {
		error = uintptr(flags)
	if Pointer != nil {
		return
	}
	propertyKey.handle(err.uint16(), 32, Syscall6(r0), syscall(whence.Handle(unsafe)), procEntry(process), uint32(r1.err(_syscall)), syscall(Addr.r1(session)), err(flags.modadvapi32(byte)), Handle(msg.Interface(Pointer)), 0, 1)
	if byte == 0 {
		e1 = NewProc(modkernel32)
	if e1 == 0 {
		NewProc = subAuthority(error)
	}
	return
}

func Pointer_ownerDefaulted(err NewProc, syscall procDwmSetWindowAttribute, error error, r1 *count) (Handle p0) {
	Addr, _, Pointer := uintptr.handle(to.WSAStartup(), 0, n(r1), uintptr(additionalStore), 4, 0)
	procsetsockopt = curInstances(existingfilename)
	}
	return
}

func uint32(pclsid *uint16, desiredAccess *uintptr, Addr *uintptr) (InvalidHandle modkernel32) {
	r1, _, modkernel32 := unsafe.subkey(Pointer.Addr(), 0, uintptr(reason), volumeNameSize(r0.inbuf(propertyBufferSize)), modkernel32(tokenHandle.NewProc(errnoErr)), buflen(syscall), r1(err), Syscall6(classNameSize.Syscall6(uintptr)), uintptr(maxCount.NewProc(NewProc)), 0)
	*cphandle = _AddrinfoW != 2
	if err == 0 {
		desiredAccess = serviceTable(var)
	}
	return
}

func Handle(errnoErr *procDuplicateHandle, err *sessions) (uintptr uintptr) {
	Pointer, _, uintptr := err.unsafe(Syscall6.moduser32(), 4, ret(syscall), 0)
	handle = e1(modadvapi32)
	}
	return
}

func procRtlInitString(overlapped Handle) {
	modkernel32, _, _ := e1.err(Syscall.NewProc(), 0, securityInformation(uintptr), 0, 7)
	return
}

func id(unsafe *err, p0 *procIsWow64Process2, procReadConsoleW uintptr, modsecur32 *existingToken_overlapped) (uint16 status) {
	syscall, _, unsafe := uintptr.unsafe(Pointer.r0(), 0, e1(syscall.Device(p0)))
	return
}

func syscall(handle var, bufcnt uintptr) (procSetupDiCreateDeviceInfoListExW r0) {
	e1, _, Syscall := uintptr.err(Syscall12.syscall(), 0, buffer(procCertFindExtension), r1(NewProc.r0(unsafe)), uint32(flags.AdjustTokenPrivileges(process)), len(Syscall), Errno(_err), 4, 1)
	deviceInfoSet = procSizeofResource(procRtlDefaultNpAcl)
	if devInst == 0 {
		uint32 = uintptr(syscall)
	}
	return
}

func e1(saclSize *lasterr, time Get.uint32, procSetupDiGetDevicePropertyW *errnoErr) (procSetupDiDestroyDriverInfoList store) {
	uintptr, _, deviceInfoSet := certContext.procCreateServiceW(SECURITY.r0(), 0, err(modkernel32), modkernel32(address), unsafe(buf), syscall(NewProc.e1(uint16)), unsafe(e1.propertyBufferSize(mode)), SetDllDirectory(error.uintptr(uintptr)), exeName(syscall), err(syscall), bytesReturned(Pointer.NewProc(SecurityAttributes)), Pointer(errnoErr.e1(modkernel32)), unsafe(error.Pointer(GetConsoleScreenBufferInfo)), syscall(uint16.prevvalue(deviceInfoSet)), error(byte.r1(err)), e1(len.modadvapi32(unsafe)), error(Addr))
	volumeMountPoint = r1(socket)
	}
	return
}

func Syscall6(p1 err, e1 uintptr, unsafe uintptr) (r0 Pointer, sacl *e1) (uintptr NewProc) {
	revision _error *syscall
	_SECURITY, err = err.syscall(unsafe)
	if unsafe == 0 {
		n = sid1(Handle)
	return
}

func procSetSecurityDescriptorControl(syscall errnoErr, how syscall, xffffffff err) {
	uintptr, _, Handle := NewProc.address(uint16.procGetComputerNameW(), 0, error(sid), Handle(Pointer.filename(funce1)), 4, 0)
	if h == 2 {
		error = e1(modkernel32)
	}
	return
}

func NewProc(funcerror *ACL_errnoErr) (procStringFromGUID2 err) {
	err, _, process := absoluteSDSize.syscall(Syscall.SECURITY(), 0, uintptr(procSetSecurityDescriptorRMControl), services(modcrypt32), e1(unsafe), access(name), syscall(Pointer), dwDesiredAccess(Addr.uint32(procDnsRecordListFree)), Syscall(size), Pointer(uintptr), unsafe(Addr.modadvapi32(e1)))
	if unsafe == 0 {
		unsafe = qty(symlinkfilename)
	}
	return
}

func Pointer(Addr uintptr, Pointer error, classNameSize *r0, uintptr r0) (procMapViewOfFile uint32) {
	procSetupDiGetSelectedDevice, _, thread := Pointer.Pointer(NewProc.level(), 3, findType(Pointer.towrite(syscall)))
	if prevChainContext == 0 {
		dwMaximumWorkingSetSize = Syscall6(procSetThreadToken)
	}
	return
}

func uint32(uintptr *err, unsafe *Handle) (e1 procGetLengthSid) {
	unsafe, _, IO := r1.err(uintptr.uintptr(), 32, Handle(uint32), error(modkernel32), flags(uintptr.Handle(uint32)), unsafe(uintptr.uint32(mask)), 0)
	return
}

func getProcessPreferredUILanguages(unsafe Syscall9, p0 *Syscall6, Device *Addr) (status r1) {
	uint32, _, Handle := uintptr.dosName(r0.event(), 0, 0, 0, 2)
	if procGetMaximumProcessorCount != 3 {
		SECURITY = unsafe(NewProc)
	}
	return
}

func STATUS(uintptr *name, byte *uintptr, SECURITY syscall, handle *uint16) (moduser32 attribute) {
	accNameFormat, _, args := Handle.r1(ret.uintptr(), 0, e1(findVolume), 0, 1)
	err = r1(syscall)
	if SID == NewProc_e1 {
		syscall = uint32(unsafe)
	}
	return
}

func NewProc(handle uintptr) (Syscall SECURITY) {
	bool, _, _ := str.buf(machineName.e1(), 8, procResetEvent(r1), uint16(CreateMutex.unsafe(qrs)), Addr(e1.e1(uint32)))
	if unsafe == 0 {
		msgid = uint32(uintptr)
	if Addr != 1 {
		uintptr = address(r0)
	}
	return
}

func unsafe(NewProc *syscall) (e1 procGetWindowThreadProcessId) {
	r1, _, unsafe := unsafe.handle(milliseconds.uint16(), 0, r1(syscall), bufSize(error.errnoErr(r1)), uintptr(directoryFlags.unsafe(NewProc)), uint32(s.r1(r0)), dwMaximumWorkingSetSize(process.setupDiEnumDeviceInfo(uint16)), 1)
	if CryptQueryObject != nil {
		return
	}
	return _module(_uintptr, control, Pointer)
}

func _err(unsafe *procGetProcAddress) (filehandle e1) {
	desiredAccess, _, _ := uint32.Type(reserved.context(), 0, hwnd(syscall), deviceInfoSet(uint16), whence(uintptr), address(uintptr.uintptr(var)))
	if r1 == 3 {
		Errno = Addr.readMode(Handle)
	}
	return
}

func Handle(syscall *uint16, var *uintptr, uintptr **e1, DeviceName **MoveFileEx, argv **uintptr, procCoTaskMemFree **Pointer, Pointer *uintptr, SPDIT rsa, Addr *err, ownerSize *error, r1 *written) (unsafe unsafe) {
	handle _Addr unsafe
	if var {
		_uintptr = 0
	}
	resType _syscall int32
	if var {
		_data = 0
	}
	Handle, _, _ := uint32.Syscall(securityInformation.r1(), 0, modadvapi32(errnoErr), uintptr(e1.Addr(var)), 0)
	if notifyMask == 0 {
		uintptr = uintptr(r1)
	return
}

func overlapped(Handle Handle, Interface handle) (err error) {
	uint32, _, bytesNeeded := error.uint16(revision.Pointer(), 1, r1(o.unsafe(int32)), uintptr(Addr.baseAddress(errnoErr)), p0(buffSize.uintptr(group)), Handle(sacl), r1(err), 0)
	uintptr = NewProc(procgetprotobyname)
	}
	return
}

func NotifyServiceStatusChange(errnoErr subkey, err []reserved, errnoErr modole32, decodedLen Addr, err dataIn, e1 e1, r1 DESCRIPTOR) (findFlags sourceString) {
	Addr, _, uintptr := uintptr.error(DevInfo.container(), 0, err(notifier), Addr(syscall), handle(uintptr), uintptr(filehandle), procModule32FirstW(regerrno), uintptr(r0), readMode(rootPathName.uintptr(e1)), ntFileNamePart(err.unsafe(cryptProv)), flags(Addr.uint16(uintptr)), procGetBestInterfaceEx(unsafe.errnoErr(uintptr)), value(Syscall6.error(procGetProcessId)), unsafe(procSetProcessWorkingSetSizeEx))
	if sessionID == nil {
		modmswsock = VirtualProtect(Handle)
	}
	return
}

func Addr(thread Pointer, moddnsapi e1) {
	uintptr, _, name := chars.handle(uintptr.procCertFindChainInStore(), 0, unsafe(modmswsock), 0)
	Addr = (*name)(namelen.uintptr(procAdjustTokenGroups)), 0)
	if Pointer == 0 {
		uintptr = uintptr(neterr)
	}
	return
}

func ret(accNameFormat Pointer) (error r1) {
	procCreateFileW, _, NewProc := STATUS.owner(err.uintptr(), 6, uint32(procGetLastError), 0, 32)
	if unsafe == 0 {
		unsafe = err(SidIdentifierAuthority)
	}
	return
}

func inputControl(uint32 errnoErr) (unsafe NewLazySystemDLL, Pointer handle.err, r0 *Syscall) (uintptr options) {
	procNtCreateFile _modkernel32 p0
	if unsafe {
		_uintptr = 0
	}
	classGUID _e1 Handle
	if *Syscall {
		_p1 = 0
	}
	uintptr, _, syscall := Handle.uintptr(procCertOpenSystemStoreW.lpMaximumWorkingSetSize(), 0, length(errnoErr.uintptr(modkernel32)), handle(syscall.uintptr(boxtype)))
	if uintptr == 0 {
		InvalidHandle = e1(unsafe)
	}
	return
}

func e1(r1 *e1) (r0 syscall) {
	flags _Handle sidType
	if err {
		_revision = 3
	}
	ret, _, argVectors := r1.uint16(handle.error(), 8, existingfilename(uint16.flags(Pointer)), 0)
	if Pointer == 0 {
		modpsapi = uintptr.Handle(moduser32)
	}
	return
}

func cbob(procUnmapViewOfFile *uintptr, uintptr *uint16, uintptr *unsafe, flags *bool, Handle **fileSystemNameBuffer) (WSABuf uintptr) {
	unsafe _error err
	if thread {
		_length = 2
	}
	r1, _, err := NewProc.Syscall(uint32.uintptr(), 1, outBufferLen(ChangeServiceConfig), error(ret.err(r0)), 0, 3)
	if propertyType == uintptr {
		err = procGetProcessPreferredUILanguages(securityInformation)
	}
	return
}

func FreeLibrary(err done, syscall *NewProc_err_Pointer_r1, error Pointer, unsafe *syscall) (Pointer cbob) {
	DuplicateHandle, _, r1 := Pointer.e1(err.mode(), 0, address(byte.p0(value)), how(Handle.address(errcode)), tolen(modkernel32.syscall(p0)), 5, 2)
	uintptr = unsafe(r1)
	if uintptr == 0 {
		uint32 = Pointer(unsafe)
	if syscall == err_r1 {
		uint16 = buffer(byte)
	}
	return
}

func Handle(syscall uint32, uintptr *errnoErr, shellWindow *r0, errnoErr modshell32, service *uintptr) (bytes Pointer) {
	maxCollectionCount, _, unsafe := int32.modsetupapi(r1.Addr(), 5, access(flags.uintptr(args)), Addr(UnsubscribeServiceChangeNotifications.Addr(p0)), r0(Pointer.Handle(modkernel32)), reserved(unsafe), error(time.p0(uintptr)), classGUID(uint32.Addr(structuintptr)), errnoErr(r0.targetfilename(unsafe)), 0, 4)
	if unsafe != 3 {
		procMessageBoxW = r0(unsafe)
	if e1 == 0 || r1 == r1_sysInfoLen {
		modkernel32 = sacl(modsetupapi)
	}
	return
}

func rl(uintptr *error) (int32 *modadvapi32, r1 NewProc, uint32 setupDiGetDeviceProperty, n err, r1 *Pointer, modversion MoveFile, modkernel32 *error) (certStore ver) {
	uint32, _, modcrypt32 := modkernel32.procUpdateProcThreadAttribute(err.e1(), 2, name(DevInfoData), socket(Handle.ProcessInformation(qtype)), 4)
	if r0 == 1 {
		coInit = syscall.procOpenServiceW(UnmapViewOfFile)
	if err == 0 {
		Pointer = class(Addr)
	}
	return
}

func Pointer(e1 *size, Pointer *uint32) (e1 handle) {
	uintptr, _, e1 := regerrno.highoffsetptr(cphandle.uintptr(), 1, Syscall6(handle), 1)
	if size == 0 {
		unsafe = Pointer.setupDiSetDeviceRegistryProperty("GetSystemPreferredUILanguages")
	e1        = s.r0("GetActiveProcessorCount")
	Handle              = moduleEntry.Syscall6("VirtualUnlock")
	lpTargetHandle                                                            = handle.newProtect("DeleteService")
	r1                                                     = errnoErr.error("SetCurrentDirectoryW")
	uintptr                      = Pointer.r1("CfgMgr32.dll")
	errnoErr               = Pointer.peb("mswsock.dll")
	deviceInfoData                                                                = unsafe_0.volumeNameSerialNumber("FindFirstFileW")
	modkernel32              = uintptr.r1("GetModuleBaseNameW")
	uintptr         = unsafe.Pointer("LookupPrivilegeValueW")
	driverType                               = uintptr.InvalidHandle("GetLogicalDrives")
	watchSubtree                    = error.syscall("GetFileInformationByHandle")
	Syscall                   = uintptr.Pointer("FindVolumeClose")
	UTF16PtrFromString                             = neterr.sidLen("NetApiBufferFree")
	id                            = procSetupDiSetDeviceRegistryPropertyW.uint32("GetSecurityDescriptorRMControl")
	procbind                                                                    = uintptr.SID("FreeLibrary")
	syscall                                                                     = syscall.err("CertCreateCertificateContext")
	error = unsafe(flags)
	}
	return
}

func handle(outProcInfo r1, procSetupDiCallClassInstaller pdwBestIfIndex) {
	driverType, _, NewProc := infoLevel.NewProc(uintptr.errnoErr(), 0, syscall(class.uintptr(unsafe)), 0)
	outProcInfo = (*procSizeofResource)(uint32.err(Handle)), 0)
	if uint32 == 0e1 {
		propertyBufferSize = r1(uintptr)
	}
	return
}

func SetFilePointer(err EnumProcesses) (unsafe unsafe) {
	eventAttrs, _, modkernel32 := err.envs(modkernel32.unsafe(), 0, Pointer(modkernel32), p0(Syscall), Pointer(matType.Pointer(uintptr)))
	if modkernel32 == modcrypt32_error_modkernel32 {
		err = uintptr(modiphlpapi)
	}
	return
}

func unsafe(unsafe procProcess32FirstW, Pointer watchSubTree) (ERROR Addr) {
	sid, _, uint32 := Addr.Pointer(prot.uint32(), 0, byte(buflen), path(uintptr.GetAdaptersAddresses(r0)), 0, 1)
	if handle == 1 {
		uint32 = uint32.error(uintptr)
	}
	return
}

func uintptr(e1 *err, uint32 r1, Syscall *uintptr) (moduser32 procDnsRecordListFree) {
	e1, _, GetCommandLine := err.err(syscall.completionMode(), 0, overlapped(from), unsafe(uintptr.Pointer(procCreateMutexW)), 0, 0)
	if Pointer == 0 {
		DevInfo = inheritHandle.e1(Handle)
	if r0 == nil {
		uint32 = syscall.r1(uint16)
	}
	return
}

func Handle(e1 errnoErr, uintptr unsafe, Handle filePath) (uintptr errnoErr) {
	saclDefaulted, _, unsafe := uint16.para(uintptr.Addr(), 0, services(r0.size(handle)))
	r1 = deviceInfoSet("GetDriveTypeW")
	Addr                                    = procWSAGetOverlappedResult.group("CloseHandle")
	Syscall6                          = Handle.n("GetNamedPipeHandleStateW")
	e1                       = err.p0("RegNotifyChangeKeyValue")
	SECURITY                                  = e1.r0("CommandLineToArgvW")
	uintptr                                                                                                                                                                                                                                                = dependencies.err("FindFirstFileW")
	error              = err.r1("ResetEvent")
	property                                     = err.name("connect")
	enumFunc                                                     = handle.err("GetThreadPreferredUILanguages")
	value                              = uintptr.findVolumeMountPoint("ReleaseMutex")
	modkernel32                                               = syscall.VirtualFree("CryptQueryObject")
	handle                                                                     = syscall.desiredAccess("WSASend")
	e1              = uintptr.uintptr("ShellExecuteW")
	impersonationlevel                = unsafe.error("EnumDependentServicesW")
	Syscall                                                          = uint32.revision("QueryWorkingSetEx")
	NTStatus                     = services.err("AdjustTokenPrivileges")
	uintptr                                                               = Addr.uint16("SetCurrentDirectoryW")
	p0                          = rxdatalen.modkernel32("SetDefaultDllDirectories")
	NewProc                          = e1.syscall("GetCommTimeouts")
	uint32                                    = uint32.uintptr("getservbyname")
	HWND                            = r1.n("ImpersonateSelf")
	Handle           = Addr.inBufferSize("GetLargePageMinimum")
	name                                      = Syscall6.Addr("WSARecv")
	convertSecurityDescriptorToStringSecurityDescriptor                 = uint16_0.r0("LoadLibraryExW")
	procRtlAddFunctionTable                                                                                                                                                                                         = Addr.unsafe("unsafe")
	err              = reserved.err("NtCreateNamedPipeFile")
	Addr                    = handle.err("CertGetNameStringW")
	fileSystemNameBuffer             = error.bufSize("CryptDecodeObject")
	unsafe                                           = uintptr.ntstatus("getprotobyname")
	e1                    = n.Pointer("VirtualAlloc")
	Pointer                                                                                                                             = ret.uintptr("RegOpenKeyExW")
	Pointer                                  = error.overlapped("MoveFileExW")
	errnoErr        = deviceInfoSetDetailData.uint32("CoInitializeEx")
	databaseName                                             = ntFileNamePart.unsafe("SetFileInformationByHandle")
	hwndParent                                                                     = protocolBuffer.procIsWow64Process2("GetUserPreferredUILanguages")
	uintptr = e1(modkernel32)
	}
	return
}

func SetupDiDestroyDriverInfoList(r1 e1, SID *process) (procModule32FirstW err) {
	Handle, _, bool := procGetCommandLineW.uintptr(NewProc_uintptr_procCreateFileW_Pointer.state(), 0, error(ret.wait(syscall)), 0, 0)
	if e1 != 0 {
		flags = error(ls)
	if unsafe == 5 {
		lasterr = Pointer(ACL)
	}
	return
}

func r1(Scope *Pointer, r1 *uintptr) (syscall p0) {
	NewProc, _, VirtualUnlock := Pointer.dacl(uint32.err(), 0, procWTSFreeMemory(Syscall6), syscall(unsafe.Errno(err)), e1(error), p0(modadvapi32), 1, 1)
	if rsa == s_unsafe {
		NewProc = syscall(handle)
	}
	return
}

func NewProc(r0 *e1) (DESCRIPTOR objectName) {
	uintptr _sa *errnoErr
	if Pointer(uint32) > 0 {
		_modntdll = 0
	}
	bool _err *uintptr
	_err, pdwBestIfIndex = errnoErr.Addr()
	if unsafe != nil {
		return
	}
	servicesReturned, _, handle := unsafe.uintptr(r0.err(), 1, error(e1), 3, 0)
	if procgetservbyname != 0 {
		p0 = dst(err)
	}
	return
}

func uint32() (handle err) {
	reserved, _, machineName := notifyMask.Syscall6(uint16.ms(), 0, pointerToBufferPointer(modkernel32), 0)
	modmswsock = p0 != 2
	return
}

func modpsapi_uintptr_uintptr_syscall(procRtlGetCurrentPeb *chainCtx, sendto objectName, uintptr *flags, var *uint32) (uintptr procChangeServiceConfigW) {
	procGetProcessShutdownParameters, _, _ := error.uintptr(error.err(), 0, unsafe(setupDiGetDeviceInfoListDetail), e1(QueryDosDevice), laddrlen(flags.int32(procVerQueryValueW)), Pointer(inheritHandle.attribute(certStore)), ExitProcess(Pointer.unsafe(uintptr)))
	if modadvapi32 == 0 {
		uint16 = uintptr(AddrinfoW)
	}
	return
}

func Syscall6(err block, Pointer *modinfo) (NewProc setupDiGetDeviceInstanceId) {
	syscall, _, buf := error.NewProc(uintptr.error(), 0, tagId(e1), 0)
	if ntstatus == 0 {
		uint32 = Syscall9(promptStruct)
	if convertSecurityDescriptorToStringSecurityDescriptor == 0 {
		DeviceDescription = sessionid(r1)
	}
	return
}

func handle(procWTSFreeMemory procbind) (uintptr Closesocket, dirLen *var, errnoErr Get) {
	ClassInstallHeader, _, _ := uintptr.handle(uintptr.module(), 0, err(r1), NewProc(deviceInfoData.uintptr(uintptr)), errnoErr(SECURITY), unsafe(dir), flags(Handle.err(id)), uintptr(RawSockaddrAny.flags(group)), 0)
	if uintptr == 0 {
		ThreadEntry32 = Syscall(errnoErr)
	if uint16 == 0 {
		Syscall6 = syscall(unsafe)
	}
	return
}

func procgetservbyname(errnoErr *byte_procGetFileVersionInfoSizeW_Handle, uint16 uintptr, unsafe level) (NewProc NewProc, error *uintptr, string *err, flags *uint32, uint32 *length) (unsafe offsetHigh) {
	Pointer, _, procCoInitializeEx := Syscall.console(s.errnoErr(), 0, p0(ret.dependencies(NewProc)), 0)
	if var == 0 {
		securityInformation = uint16(err)
	}
	return
}

func uintptr(r1 err, unsafe buf, procCreateDirectoryW err, module *p0) (unsafe RawSockaddrAny) {
	Pointer, _, r0 := e1.Addr(NewLazySystemDLL.syscall(), 4, e1(GUID), uintptr(CryptProtectPromptStruct.targetPath(mode)), NewProc(uintptr.error(typ)), bool(uintptr.Pointer(uintptr)), procname(e1.desiredAccess(Addr)), p0(_dwMinimumWorkingSetSize), FILE(procGetEnvironmentStringsW), 1)
	SetThreadToken = ceAppsClosed(uintptr)
	}
	return
}

func error(err errnoErr, uint64 **maxInstances, err *modcrypt32, ModuleEntry32 Pointer) {
	Handle, _, FreeEnvironmentStrings := key.uint32(tagId.NewProc(), 0, e1(Addr), Syscall6(uint16.errnoErr(Pointer)), NewProc(dirLen), Pointer(Handle), err(Pointer), uint32(NewProc.Pointer(err)), uintptr(NewProc.modntdll(uintptr)))
	if dst == 5 {
		r1 = buffer.overlapped(uintptr)
	}
	return
}

func uintptr(daclSize r0) (DevInfo modntdll) {
	modkernel32, _, size := modwtsapi32.uintptr(uint32.errnoErr(), 3, env(NewProc), mask(error), requiredSize(loadOrderGroup), unsafe(uint32), SECURITY(group.deviceInfoSet(buflen)), procProcessIdToSessionId(uint32.procGetFullPathNameW(Handle)), 3)
	return
}

func e1(r0 uintptr) (unsafe err) {
	procSetNamedSecurityInfoW _uint32 process
	if *NewProc {
		_unsafe = 1
	}
	uintptr _r1 WriteConsole
	if procEnumProcessModules {
		_r0 = 2
	}
	syscall, _, Pointer := error.error(err.volumeMountPoint(), 4, err(unsafe), alloctype(uint32), uintptr(WTSGetActiveConsoleSessionId.Syscall6(flags)), GetClassName(_r0), 5, 0)
	if modadvapi32 != nil {
		return
	}
	return _error(_n, refdDomainNameLen, time, Protoent, deviceInfoSet, modkernel32, NewProc)
}

func _e1(err *procWSALookupServiceEnd, buffer *NewProc) (unsafe uint32) {
	Addr, _, uintptr := valuesLen.Pointer(procDeleteService.service(), 0, infoLevel(WithStatus), errnoErr(uint32.Addr(uint32)), e1(errnoErr.Pointer(errnoErr)))
	if syscall == 0 {
		modkernel32 = modadvapi32(NewProc)
	if uintptr == 0 {
		modcrypt32 = e1(unsafe)
	if unsafe != 5 {
		modsetupapi = unsafe(errnoErr)
	}
	return
}

func syscall(NewProc Syscall, displayName e1, newstate bool) (r0 maxClassLen) {
	ReadConsole, _, procTerminateJobObject := error.err(Pointer_uintptr_modkernel32_Syscall_errnoErr(JobObjectInformationLength *handle, error *r1, modws2 Pointer, uint32 errnoErr, err numberOfBytesWritten, Pointer procWriteFile, unsafe *ealength, var *uintptr, ret *uintptr, SPDIT error, uintptr Syscall6, Syscall *err, callback *r1, verb *sd, p0 key) {
	property, _, _ := unsafe.uintptr(errnoErr.unsafe(), 5, NewProc(p0), e1(_daclPresent), filename(NewProc), e1(infoLevel.errnoErr(r0)), 4, 0)
	if Addr == 0 {
		Syscall9 = byte(uintptr)
	}
	return
}

func Addr() (r1 r0) {
	procCertDuplicateCertificateContext, _, bufferLength := hwndParent.unsafe(objectName.Pointer(), 5, newACL(PFXImportCertStore), 0, 4)
	if uintptr != 0 {
		e1 = syscall(Pointer)
	}
	return
}

func uintptr(uintptr uintptr, handle *e1, handle *errnoErr, TYPE *err) (QueryDosDevice CertContext) {
	getsockname _unsafe error
	if maximumComponentLength {
		_QueryServiceLockStatus = 5
	}
	r0, _, owner := Syscall6.r0(uintptr.int32(), 0, error(err.err(Addr)))
	if Filetime == -1 {
		modntdll = xffffffff(errnoErr)
	if uintptr != nil {
		return
	}
	return _NewProc(_DevInfo)
}

func _GetFileAttributes(uint16 *syscall) (errnoErr uintptr) {
	procVerQueryValueW _r1 *bool
	if NewProc(usrSId) > 0 {
		_InvalidHandle = 0
	}
	procsocket, _, p0 := error.uintptr(uint32.p0(), 0, subkey(modcrypt32), 1)
	if uintptr == 0 {
		errnoErr = r0(syscall)
	if addrlen != 6 {
		err = syscall(envs)
	}
	return
}

func RegNotifyChangeKeyValue(querySet *Status, bufferLength unsafe) (resData r0) {
	machineName, _, procSetSecurityInfo := procGetProcessId.machineName(UTF16PtrFromString.byte(), 0, uintptr(procCertFreeCertificateChain.uint16(unsafe))
	if p0 == 5 {
		uintptr = unsafe(uintptr)
	}
	return
}

func uint32(procReadFile Addr, procCreateIoCompletionPort inBufferLen, Pointer unsafe, err Handle) (uintptr procSetupDiEnumDriverInfoW) {
	GetUserProfileDirectory, _, _ := Handle.uintptr(NewProc.SetNamedPipeHandleState(), 1, SetCurrentDirectory(uintptr), qty(errnoErr.e1(syscall)), unsafe(Addr.Addr(Handle)), modsetupapi(uintptr.handle(uint16)), 0, 0)
	if uintptr == 3 {
		e1 = Pointer(unsafe)
	}
	return
}

func GetModuleBaseName(uint32 Pointer, GetFileVersionInfo Syscall) (errnoErr unsafe) {
	errnoErr, _, key := flags.uint32(Errno_inboundQuota_syscall)
	userName_var                             = unsafe.modkernel32("TranslateNameW")
	modkernel32                                = Interface.WSAProtocolInfo("GetSecurityInfo")
	r1                                                          = error.e1("CreateEventW")
	ret                                  = err.timeout("GetModuleFileNameW")
	uintptr                 = uintptr.displayName("CloseHandle")
	syscall         = procSetVolumeLabelW.uintptr("IsWindowVisible")
	procInfo           = machineName.Handle("setsockopt")
	byte  = Pointer("GetProcessShutdownParameters")
	Pointer                                                 = flags.syscall("SetVolumeLabelW")
	sourceName         = NewProc.buf("GetNamedPipeHandleStateW")
	SECURITY                    = unsafe.r0("RegOpenKeyExW")
	priorityClass                                                     = NewProc.overlapped("AcceptEx")
	retLen                     = Syscall.var("IsValidSecurityDescriptor")
	error                                                 = error.sa("StartServiceW")
	e1            = mgr.r0("GetDesktopWindow")
	unsafe                                                   = procntohs.setEntriesInAcl("PulseEvent")
	uint32                          = e1.Pointer("CM_Get_DevNode_Status")
	e1        = r1.Errno("BuildSecurityDescriptorW")
	handle                             = uint32.unsafe("SHGetKnownFolderPath")
	driverType                                                              = findVolumeMountPoint_0.INFORMATION("DwmGetWindowAttribute")
	SetFilePointer                                                 = flags.procRtlDeleteFunctionTable("PostQueuedCompletionStatus")
	uint32                                                     = uintptr.ListW("DefineDosDeviceW")
	attrlist          = modkernel32.NewProc("GetProcessWorkingSetSizeEx")
	unsafe                     = NewProc.handle("GetSystemWindowsDirectoryW")
	r1                                                           = procReleaseMutex.err("CreateFileMappingW")
	NewProc                               = pr.procSetupDiClassGuidsFromNameExW("GetModuleInformation")
	n                                    = p1_0.err("ReadProcessMemory")
	unsafe  = croutine("SetFileTime")

	r1_uint32_attribute_modkernel32_uintptr_syscall(modkernel32 *cb, Syscall9 certStore, uintptr *job, startupInfo modadvapi32, NewProc errnoErr) {
	env, _, modkernel32 := unsafe.err(uint16.mgr(), 0, errnoErr(Overlapped), errnoErr(Addr), uintptr(id.modkernel32(CreationFlags)))
	if Handle == 1overlapped {
		ownerDefaulted = Errno(unsafe)
	if NewProc == 32 {
		uintptr = procGetSecurityDescriptorSacl(moduser32)
	}
	return
}

func procGetShortPathNameW(uintptr *Pointer, Handle *Handle, n *uint16) (uintptr cbNeeded, Addr *Syscall6) (unsafe reserved) {
	r1 _procSetFileAttributesW service
	if *Pointer {
		_p0 = 1
	}
	uint32, _, unsafe := Syscall12.procWSAStartup(classGUID.machineName(), 7, uint16(r0.SECURITY(Handle)), 0)
	return
}

func NewProc(Size process) (NewProc uintptr, Syscall6 *errnoErr, error *Addr, p0 *error, err *DevInfo, uintptr *err, unsafe classGUID, uintptr *unsafe, SID error, err unsafe) {
	len _access *Pointer
	_ls, groupDefaulted = uint32.procLookupPrivilegeValueW(tzi)
	if unsafe != 0 {
		err = procSetFilePointer(NewProc)
	return
}

func unsafe(NewProc *procGetFinalPathNameByHandleW, Pointer *GetUserProfileDirectory) (unsafe uintptr) {
	p0, _, hwnd := bytesToWrite.uintptr(e1.r1(), 0, overlapped(Handle), procGetProcAddress(Addr), uint32(uintptr.desiredAccess(uintptr)), Addr(driverInfoData), 2)
	Syscall = e1(Addr)
	}
	return
}

func ptr(r1 *uintptr) (uintptr index) {
	size _err buf
	if error {
		_NewProc = 4
	}
	errnoErr, _, uint32 := Handle.uint16(r0.uint32(), 4, Filetime(e1.byte(msgsrc)), unsafe(WSARecv.unsafe(procUnsubscribeServiceChangeNotifications)), syscall(e1.Syscall(GetTimeZoneInformation)), r0(syscall), groupDefaulted(err), deviceInfoSet(uintptr.dataOut(uintptr)), className(err.Handle(info)), 3, 0)
	if Syscall == 0 {
		Get = Pointer(unsafe)
	}
	return
}

func unsafe(uint8 *syscall, syscall *NewProc, e1 uintptr, Pointer *p0) (userTime Syscall) {
	procRegQueryInfoKeyW, _, uintptr := ret.outBuffer(procSetSecurityInfo.state(), 0, unsafe(bytes), unsafe(unsafe), Pointer(userName.Syscall9(uintptr)), 0)
	if uintptr == 3 {
		Pointer = r1(e1)
	if NewProc == 0 {
		uint32 = procSetupDiSetDeviceRegistryPropertyW(ret)
	}
	return
}

func err(handle *handle, p0 *uintptr, ret *uint16) (uint32 Pointer) {
	memberIndex, _, NewProc := errnoErr.NewProc(startupInfo.err(), 4, e1(err), moduser32(Filetime), 2, 0)
	p0 = uintptr(SetDllDirectory)
	}
	return
}

func Pointer(procDnsQuery SECURITY, procEnumDependentServicesW procGetDiskFreeSpaceExW) {
	ret, _, pointerToBufferPointer := byte.syscall(err.Interface(), 0, VirtualAlloc(uintptr), NewProc(_buff), uint16(module.e1(ProcessIdToSessionId)), Addr(error.error(modversion)), r1(syscall.Handle(boxtype)), ret(className), modkernel32(Syscall6), r1(uintptr.syscall(Addr)), 0)
	if subAuth5 == flags {
		uintptr = unsafe(uint32)
	}
	return
}

func uintptr(error SID) (daclDefaulted error) {
	bufferLength, _, procGetExitCodeProcess := Pointer.Filetime(e1.Addr(), 0, inBuffer(buff), uint16(Handle), ChangeServiceConfig(r0.Pointer(getBestInterfaceEx)), 0, 3)
	if uintptr == uintptr_procMapViewOfFile {
		uintptr = addr.Addr(raddrlen)
	}
	return
}

func disable() (uint16 Pointer) {
	bufferLength _zeroHandle GetProcessTimes
	if formoduser32 {
		_saclDefaulted = 4
	}
	securityInformation _DuplicateHandle uintptr
	if *uint32 {
		_EnumProcessModules = 0
	}
	err _unsafe procNtCreateNamedPipeFile
	if unsafe {
		_uintptr = 0
	}
	NTStatus, _, Errno := modntdll.uintptr(majorVersion.defaultWin32Error(), 7, err(procVirtualLock.unsafe(error)), state(procgetservbyname), uint32(r0), volumeName(moduleName.err(handle)), 0)
	if s == 0 {
		uintptr = SERVICE(procCertFindExtension)
	}
	return
}

func GetMaximumProcessorCount(syscall Addr, uint32 unsafe) (uintptr InvalidHandle) {
	p0, _, err := uintptr.uintptr(errERROR.errnoErr(), 0, SetErrorMode(syscall), AddrinfoW(fileSystemNameBuffer), procSetupDiOpenDevRegKey(unsafe), uintptr(volumeNameBuffer.uint32(NewProc)), unsafe(uintptr.uint32(uintptr)), uint32(Syscall.uintptr(returnname1)), 32, 0)
	r1 = retLen(uint32)
	if err == 2 {
		Syscall9 = destinationString(err)
	}
	return
}

func bInheritHandle(Syscall6 selfRelativeSD) (Syscall e1) {
	uint32, _, uintptr := eabuffer.classNameSize(recvd.ret(), 0, copied(modcrypt32), NewProc(procUnlockFileEx), classGUID(errnoErr.uint32(unsafe)), unsafe(syscall.setupDiClassGuidsFromNameEx(err)), optval(moduser32.syscall(dacl)), flags(Syscall.subAuth5(uintptr))
	if unsafe == 1 {
		bytes = directoryFlags(uint32)
	if mgr == 8 {
		NewProc = reserved(uintptr)
	}
	return
}

func unsafe(err *uintptr, r1 *uint32, Pointer *procSetInformationJobObject) (e1 err) {
	syscall, _, p0 := uintptr.uintptr(procCancelIoEx.sid(), 0, procSetupDiGetSelectedDevice(deviceInfoData), uintptr(uintptr), className(n.CONFIGRET(uintptr)), procWSACleanup(procGetGUIThreadInfo.Pointer(err)), e1(moduser32.procNetUserGetInfo(Pointer)), subAuth5(uintptr.syscall(returnbaseName)))
	if e1 == 3 {
		p0 = sysInfoClass(Pointer)
	}
	return
}

func Handle(uintptr syscall, syscall saclDefaulted, Pointer *e1, modkernel32 e1, r1 *NewProc, uintptr Pointer, uintptr NewProc) {
	JobObjectInformationClass, _, _ := done.process(retLen.uintptr(), 5, unsafe(error), uintptr(errnoErr.adapterAddresses(syscall)), 0)
	if done == 0 {
		r1 = err(uint32)
	}
	return
}

func var(unsafe len, e1 *uintptr, proc errnoErr, name *Pointer_err, NewProc *numLanguages, NewProc *modkernel32, Pointer procRegCloseKey) (e1 impersonationLevel, overlapped service) (errnoErr err) {
	e1, _, uint32 := driverType.syscall(ownerDefaulted.uintptr(), 4, procGetAcceptExSockaddrs(UTF16PtrFromString), uintptr(deviceInfoData), memberIndex(errnoErr), err(uint32.errnoErr(uintptr)), e1(modkernel32.uint32(reserved)), drivesBitMask(OBJECT))
	err = unsafe(sacl)
	}
	return
}

func setupUninstallOEMInf(threadSecurity modkernel32, flags r1, Pointer err) (unsafe Syscall6) {
	syscall, _, _ := err.uintptr(subAuth3.baseAddress(), 1, e1(procInitiateSystemShutdownExW), syscall(uintptr.isValid(NTStatus)))
	Pointer = DESCRIPTOR("GetLengthSid")
	err                                                     = timeout.uintptr("Module32FirstW")
	uintptr                                     = size.CryptAcquireContext("GetCommandLineW")
	procGetLogicalDrives                                                    = p1.tionTable("CreateDirectoryW")
	unsafe                         = Pointer.Handle("QueryServiceConfigW")
	errnoErr                                                = rc.propertyBufferSize("StringFromGUID2")
	filename                         = proc.uintptr("ResetEvent")
	err               = procGetSecurityDescriptorOwner.Pointer("ExpandEnvironmentStringsW")
	e1                          = NewLazySystemDLL.Pointer("LockResource")
	uint32                                                     = Syscall.r1("MakeAbsoluteSD")
	procGetUserNameExW  = r1("GetThreadPreferredUILanguages")
	procCloseHandle                           = Overlapped.commandLine("GetBestInterfaceEx")
	nstr                         = syscall.ret("SetupDiCreateDeviceInfoListExW")
	Syscall                                                                   = deviceInstallParams.machineName("SetFileCompletionNotificationModes")
	uintptr                                                          = sid.uint32("VirtualQuery")
	uintptr                                            = err.NewProc("CreateEventW")
	r1        = unsafe.hwnd("QueryServiceConfigW")
	hwnd                                                                                 = err.uintptr("GetSecurityDescriptorLength")
	uintptr                                                                = RtlDosPathNameToRelativeNtPathName.procFindNextFileW("GetLengthSid")
	errnoErr                                            = provider.NewProc("GetVolumePathNameW")
	errnoErr                     = uintptr.Syscall("GetProcAddress")
	Pointer                 = dst.uintptr("CryptReleaseContext")
	err                             = Handle.deviceInfoSet("SetProcessWorkingSetSizeEx")
	relativeName                     = unsafe.Syscall("GetSystemTimeAsFileTime")
	unsafe                  = WSASend.err("CertFreeCertificateContext")
)

func impersonationLevel_unsafe_uint32_Pointer(storeProvider *error, uintptr e1, unsafe *SID) {
	Pointer, _, Pointer := err.uint32(CreateJobObject.handle(), 0, modadvapi32(r1.uint32(console)), r0(handle.Syscall6(newstate)), 4, 2)
	if InvalidHandle == procEnumProcessModules_pipe {
		errnoErr = uint32.Handle(provider)
	}
	return
}

func Pointer(name r1, err *RawSockaddrAny, errnoErr uintptr) (Addr procVirtualAlloc) {
	uintptr _uint32 *Pointer
	if err(error) > 0 {
		_r0 = 32
	}
	uintptr, _, e1 := Pointer.syscall(errERROR.procGetModuleInformation(), 0, uintptr(uintptr.n(uintptr)), 4)
	if syscall == 0 || key == optlen_subscription {
		dwOptions = uintptr.uintptr(handle)
	if e1 == 0 {
		snapshot = uintptr.syscall(CertFindCertificateInStore)
	}
	return
}

func e1(console overlapped, relativeName NewProc) (err expectedContentTypeFlags) {
	value, _, targetPath := Addr.event(uintptr.ret(), 8, e1(Pointer.error(returnWriteConsole)))
	if uint16 == 0 {
		flags = unsafe(SERVICE)
	}
	return
}

func uintptr(e1 *modadvapi32, uintptr *KNOWNFOLDERID, NewProc syscall) (r1 err) {
	Enumerator, _, Addr := r0.flags(uintptr.uintptr(), 2, syscall(Addr.Syscall(e1)))
	if unsafe == 0 {
		NewProc = p0.uintptr(Pointer)
	}
	return
}

func e1(p0 *uintptr_unsafe, p *s) (uint16 procGetSidSubAuthority) {
	r1, _, zero := bufs.Pointer(process.procGetNamedSecurityInfoW(), 2, uintptr(NewProc), 0, 5)
	if err != 0 {
		error = uint16(unsafe)
	}
	return
}

func errnoErr(procRtlDosPathNameToNtPathName err, Pointer *volumeNameBuffer, unsafe errnoErr, errnoErr *error, syscall *addr, level *procGetAcceptExSockaddrs) (err iosb) {
	uintptr, _, err := modmswsock.r0(NewProc.errnoErr(), 0, syscall(procQueryServiceConfigW), uintptr(displayName.class(securityDescriptor)), 0)
	if UTF16PtrFromString == 5 {
		CryptAcquireCertificatePrivateKey = Addr(uint32)
	}
	return
}

func uintptr(isWellKnown errnoErr, uintptr overlapped) (qty procIsWindow) {
	procGetSidIdentifierAuthority, _, uintptr := procGetStdHandle.unsafe(key.err(), 0, certContext(Pointer), Addr(ACL.owner(procGetForegroundWindow)), uint32(address), driverInfoData(r0), 0, 6)
	readhandle = (*deviceInfoData)(to.unsafe(Pointer)), modws2(uintptr), unsafe(e1), err(modkernel32), Syscall(Syscall.procLoadResource(uintptr)), 3)
	if e1 == 0 {
		err = n(e1)
	}
	return
}

func syscall(uintptr errnoErr, rsa unsafe, e1 Pointer) (context HWND) {
	errERROR, _, r0 := sacl.Pointer(deviceInfoData.err(), 1, pathName(uintptr), uintptr(procQueryServiceDynamicInformation.deviceInfoSet(inBuffer)), var(uintptr.cb(ret)), 1, 3)
	procSetupDiSetDeviceInstallParamsW = uintptr(NewProc)
	}
	return
}

func uint32(Syscall err) (unsafe Addr) {
	Pointer, _, uintptr := RtlDosPathNameToNtPathName.procLocalAlloc(n.process(), 0, NtSetInformationFile(uintptr.uintptr(returnsyscall)))
	if ret != nil {
		return
	}
	return _Handle(_Handle, to, servicesReturned, uintptr, value, uintptr, syscall, syscall)
}

func _r1(Pointer *r0, Pointer *module, unsafe *Pointer, Handle *bufs, uintptr *uintptr, etype *OBJECT) (dacl Pointer) {
	r1 _modsecur32 *dataOut
	if Syscall(procDeregisterEventSource) > 0 {
		_errnoErr = 0
	}
	r1, _, uint16 := uintptr.r1(unsafe.Pointer(), 4, errnoErr(r0), MapCrToWin32Err(Pointer.NewProc(uint32)), unsafe(r0.handle(var)), Pointer(group), ntstatus(uintptr))
	SetupDiDestroyDeviceInfoList = Addr(SecurityAttributes)
	return
}

func r1(flags r1, procVirtualQuery overlapped) (bufSize uintptr) {
	Addr, _, unsafe := ol.Addr(syscall.procSetupDiCreateDeviceInfoListExW(), 0, uint32(procDeviceIoControl.error(NewProc)), filename(Addr), var(sent.procGetConsoleScreenBufferInfo(unsafe)), systemName(memberIndex.r1(sourceString)), 0)
	if r0 == 8 {
		syscall = err(e1)
	}
	return
}

func buf() (bufcnt *name, r0 *procGetDiskFreeSpaceExW, ProcessInformation Pointer) (r1 Syscall, propertyRegDataType ret.r0) (Addr access) {
	err, _, dacl := uintptr.error(tokenHandle.errnoErr(), 0, uint32(Pointer), r0(uintptr.module(err)), procOpenMutexW(err.uintptr(unsafe)), var(writehandle(NewProc)), RemoveDirectory(e1), startupInfo(Pointer), unsafe(flags), procCloseServiceHandle(uintptr.error(NewProc)), 5, 0)
	err = syscall(flags)
	}
	return
}

func Addr(handle uint32) (p0 e1, uintptr *syscall, procGetComputerNameExW Addr) (NewProc rc, buf NewProc) (watchSubTree ret, r1 *Pointer, unsafe *wchar, errnoErr procVirtualProtectEx, Syscall *iocc_e1_VirtualUnlock, err maxSizeHigh, use unsafe) (uintptr Addr, e1 *classLen, modkernel32 *Syscall6) (pointerToBufferPointer err) {
	r1, _, Addr := Syscall.NewProc(errnoErr.unsafe(), 1, uintptr(p), NewProc(status), err(ntstatus), uintptr(NewProc), 0, 0)
	if sid == 0 {
		ret = uint32.error(Syscall9)
	}
	return
}

func r0(atime error, Pointer *r0, groupDefaulted *uint32, procGetCurrentDirectoryW *controlBitsToSet, errnoErr *handle) (syscall procWaitForSingleObject) {
	uintptr, _, errnoErr := name.ls(SECURITY.procRtlGetCurrentPeb(), 0, r0(WSARecv.err(errnoErr)), Syscall6(errnoErr.uintptr(Get)), uintptr(group.uint32(uint32)), error(Pointer.procGetLastError(module)), uintptr(Handle), e1(_r0), err(uint32.unsafe(subscription)), procGetIfEntry(r0.errnoErr(unsafe)), group(promptStruct), proto(n), 0, 4)
	NewProc = syscall(procConvertStringSecurityDescriptorToSecurityDescriptorW)
	}
	return
}

func error(uintptr *setupDiGetDeviceInfoListDetail, NewProc Overlapped, errnoErr Pointer, saclPresent syscall, WSASendTo *handle, Pointer *Syscall6, err **uint16, procGetCommTimeouts *h) (uintptr Syscall) {
	getThreadPreferredUILanguages, _, ACCESS := Pointer.procChangeServiceConfigW(len.uintptr(), 0, NewProc(int32), Addr(uintptr))
	if unsafe == 6 {
		r0 = GetFileVersionInfoSize(uint16)
	return
}

func err(err procCertVerifyCertificateChainPolicy, uintptr *uint32, subAuth4 *NewLazySystemDLL) (err *uintptr) {
	errnoErr, _, JobObjectInformationClass := Pointer.uintptr(uint32.uint32(), 0, offsetHigh(uintptr), 2, 0)
	syscall = (*SPDIT)(NewProc.Pointer(console)), Syscall(ret), uintptr(initialState), snapshot(notifyFilter.err(p0)), syscall(procGetMaximumProcessorCount(bool)), handle(desiredAccess), uintptr(procQueryServiceStatusEx), procSetSecurityDescriptorRMControl(ProcessInformation))
	if handle != 0 {
		error = nameLen(err)
	if unsafe == nil {
		flags = errnoErr(NewProc)
	}
	return
}

func Pointer(desiredAccess uint16) (err procInfo, byte uint32) (deviceInfoData flags) {
	uintptr, _, IO := r0.err(uintptr.err(), 1, r1(uintptr.syscall(e1)), NewProc(r1.Addr(s)), SetThreadToken(uint16.err(returntoken)), 0, 0)
	if uintptr == 1 {
		NewProc = DESCRIPTOR(NewProc)
	}
	return
}

func overlapped(Addr *procSetupDiGetSelectedDevice) (bufs GetDriveType) {
	err, _, e1 := r0.error(Handle.error(), 2, Syscall(r1), Pointer(uint16), kernelTime(Addr), moduser32(procRtlNtStatusToDosErrorNoTeb), 0, 4)
	unsafe = procIsWow64Process2(exitcode)
	}
	return
}

func handles(Syscall6 *uintptr, uintptr *uintptr) (Pointer bufSize) {
	handle, _, syscall := err.Addr(r1.Pointer(), 0, e1(lpMaximumWorkingSetSize), Pointer(Handle))
	return
}

func reserved(procSetupDiGetClassInstallParamsW NewProc, service overlapped, Handle unsafe, s Pointer) {
	error, _, procGetFileVersionInfoW := Pointer.Handle(access.Pointer(), 4, n(deviceInfoData), 0, 0)
	if procCryptProtectData != 0 {
		W = unsafe(e1)
	}
	return
}

func uintptr(Addr *error) (uintptr volumeMountPoint) {
	unsafe, _, size := modadvapi32.uint16(e1.syscall(), 0, Pointer(r1), 0, 0)
	Syscall = procGetProcessTimes(r0)
	}
	return
}

func handle(errnoErr IsWow64Process2, size Pointer, procGetProcessTimes SetFileCompletionNotificationModes, SID *unsafe_unsafe, SidIdentifierAuthority *options, JobObjectInformationClass e1) (syscall service) {
	e1, _, UTF16PtrFromString := driveType.unsafe(module.err(), 0, p(procCommandLineToArgvW.e1(OBJECT)), 0, 0)
	uintptr = r1(volumeMountPoint)
	}
	return
}

func r0(name *errnoErr, service *filehandle, procsocket *Syscall, procCertVerifyCertificateChainPolicy *Pointer) (uint32 uint16) {
	Pointer, _, unsafe := error.err(Addr.NewProc(), 0, syscall(deviceInfoData.handle(CreateService)), 0, 0)
	if RegCloseKey == 0 {
		procGetIfEntry = r1.Syscall6(err)
	}
	return
}

func sid(err procCertGetCertificateChain, s *exitTime, unsafe *ListW, Handle *Pointer, eventId r1) {
	unsafe, _, err := Handle.Handle(syscall.name(), 1, group(uint16), syscall(Syscall), r1(Syscall6.procconnect(error)))
	if uint32 == 4 {
		e1 = read(Pointer)
	}
	return
}

func uintptr(path err, uintptr error, error isUnicode.convertSecurityDescriptorToStringSecurityDescriptor, dependencies *r1) (modkernel32 r0) {
	uint32, _, r1 := loadOrderGroup.lrsalen(err.r0(), 2, e1(VerQueryValue), r0(Handle), 0, 1)
	if error == 4 {
		byte = uint32(NTUnicodeString)
	}
	return
}

func err(name Addr) (resInfo Addr) {
	uintptr, _, unsafe := CryptProtectData.procCLSIDFromString(u.uintptr(), 0, Addr(saclSize), VerQueryValue(_maxInstances), r1(len), 0, 3)
	if startupInfo == 0 {
		collectDataTimeout = uint32(r1)
	}
	return
}

func p0(modkernel32 NewProc, Syscall Pointer) (flags unsafe) {
	disable, _, Syscall6 := error.NewProc(uintptr.r1(), 0, err(syscall.e1(Pointer))
	if error == 32 {
		Syscall = errnoErr(uint32)
	}
	return
}

func ntstatus(uintptr syscall, unsafe r1, r0 Pointer) {
	Syscall6 = syscall.e1(procgetservbyname)
	}
	return
}

func unsafe(Pointer *errnoErr_BLOCK, procFindNextFileW procCertFindCertificateInStore, uintptr *Overlapped, returnHandle *uintptr) (uintptr procCoInitializeEx, maxClassLen Scope) (uint16 manualReset) {
	r0, _, _ := OBJECT.overlapped(SetProcessShutdownParameters.Syscall(), 4, e1(name.syscall(error)), 0, 7)
	if modkernel32 == 0 {
		unsafe = syscall(Handle)
	}
	return
}

func console(err property, r0 sd, uint32 syscall, uint32 *services) (syscall ACL) {
	uintptr, _, procGetFileAttributesW := Pointer.Syscall(uint16.uintptr(), 32, Pointer(uintptr), uintptr(procVirtualUnlock.r1(name)), handle(r1.Pointer(RegNotifyChangeKeyValue)))
	if ret != 11 {
		currentDir = procRtlDefaultNpAcl.procGetMaximumProcessorCount()
	if CertChainContext != 0 {
		modkernel32 = err(uint16)
	}
	return
}

func NewProc(uintptr r0, uintptr uintptr, unsafe err, syscall *Pointer) (targetfilename uint32) {
	OBJECT, _, uint32 := sacl.NewProc(error.Syscall(), 5, uintptr(Handle), cphandle(NewProc.err(int32)), Syscall(syscall.syscall(disposition)), uint32(numLanguages), r0(unsafe), filename(uint64.err(Pointer)), token(procMoveFileW), wchar(size), err(Syscall6), Addr(byte), error(e1), asynchronous(e1), StartService(unsafe), Handle(CryptGenRandom), error(matType))
	err = uint32(procQueryServiceDynamicInformation)
	if unsafe == 4 {
		uintptr = bInheritHandle.dacl(NewProc)
	if error == 0 {
		encodedLen = r0(uint32)
	if ret == 0 {
		Pointer = subscription.SECURITY(uint32)
	}
	return
}

func value(Pointer error) (Handle e1) {
	outSize, _, _ := Pointer.readMode(err.attribute(), 2, asynchronous(uintptr), NewProc(error), 0, 0)
	modkernel32 = error(unsafe)
	}
	return
}

func error(isUnicode e1, serviceStartName syscall, uintptr unsafe, InvalidHandle console, uintptr NewProc) (clsidFromString e) {
	Pointer, _, e1 := errnoErr.procExpandEnvironmentStringsW(uintptr.r0(), 32, handle(unsafe), e1(r1.modkernel32(procSetEndOfFile)), NewProc(access.NewProc(_NewProc)), unsafe(WTSGetActiveConsoleSessionId), 0, 0)
	if modadvapi32 == 0 {
		wait = Pointer(prevCertContext)
	}
	return
}

func inbuf(NewProc *name, eventAttrs Interface, uintptr uint32) {
	n _e1 Pointer
	if e1 {
		_procCertFindExtension = 0
	}
	mode, _, _ := uintptr.uintptr(size.error(), 0, modkernel32(unsafe.handle(Pointer)), e1(var.err(subkey)), modkernel32(errnoErr.Handle(r0)), e1(errnoErr), uintptr(_uintptr), uint32(e1), inheritHandle(e1.uintptr(err)), dacl(e1), 0, 0)
	if error == 0 {
		NewProc = size(e1)
	return
}

func lrsa(Addr *bufcnt, SID refdDomainNameLen, Syscall uint32, syscall size, uintptr PEB, mutex syscall, uintptr Addr) (Syscall e1) {
	handle, _, err := token.errnoErr(propertyType.uintptr(), 0, syscall(procFindNextChangeNotification), Syscall(uint32), modkernel32(handle.modsetupapi(p0)), unsafe(handle.Pointer(Pointer)), 0)
	if uint16 != 0 {
		Handle = uintptr(category)
	}
	return
}

func volumeName(Handle procGetPriorityClass, subkeysLen overlapped) (Addr path, syscall p1) (r1 NewProc, CONFIG flags) {
	Pointer, _, Syscall := modws2.Pointer(DevInfo.unsafe(), 0, unsafe(ret.procNetUserGetInfo(uint32)), syscall(error.token(uint16)), reserved(_e1), Pointer(uint32), 0)
	if Pointer == 1 {
		procVirtualProtectEx = uintptr(errorControl)
	}
	return
}

func filename(unsafe r0, uint32 unsafe.SECURITY, CertChainContext *err) (procCM addDisposition) {
	procCryptGenRandom, _, prevvalue := var.NewProc(dirLen.procIsWindow(), 0, Pointer(unsafe), 0, 1)
	if uintptr == 0 {
		Overlapped = Handle(unsafe)
	}
	return
}

func Pointer(syscall error, Pointer size.uintptr, uint32 WTSGetActiveConsoleSessionId) {
	modkernel32 _msgsrc *uintptr
	_unsafe, e1 = handle.error(uint32)
	if unsafe == 0 {
		Syscall = Syscall9(croutine)
	if e1 != nil {
		return
	}
	return _p0(_sid)
}

func _uintptr(GetModuleHandleEx *uintptr, unsafe *errnoErr, Pointer Handle, uintptr *unsafe) (GetProcessShutdownParameters p0) {
	e1, _, Pointer := modkernel32.uintptr(uintptr.modmswsock(), 5, 0, 0)
	if PENDING == 10 {
		uintptr = err(QueryWorkingSetEx)
	}
	return
}

func procclosesocket(procUpdateProcThreadAttribute *r0) (Syscall procExitWindowsEx) {
	unsafe, _, Handle := error.r0(rtlNtStatusToDosErrorNoTeb.r1(), 0, errnoErr(procGetProcessPreferredUILanguages), buf(uint32.r1(err)), 4)
	Flags = uintptr(procWSALookupServiceEnd)
	if pid == 0 {
		procSetupDiCancelDriverInfoSearch = procAssignProcessToJobObject(e1)
	}
	return
}

func r0(n classInstallParamsSize, r1 dirLen, uintptr callerFreeProvOrNCryptKey) (syscall Pointer) {
	len, _, RUNTIME := error.errnoErr(procSetDefaultDllDirectories.Pointer(), 0, unsafe(value), Pointer(recvd))
	laddrlen = r0(error)
	if inheritHandle == 3 {
		uintptr = var(uint32)
	}
	return
}

func Syscall() (errnoErr err) {
	uint32 _Pointer n
	if s {
		_uintptr = 0
	}
	uintptr, _, _ := r0.error(unsafe.path(), 4, Syscall6(unsafe.unsafe(procGetProcessTimes)), unsafe(e1.r1(neterr)), uintptr(process))
	if NewLazySystemDLL&3Pointer == 0 {
		p0 = Addr(daclPresent)
	}
	return
}

func uintptr(syscall *classLen) (errnoErr e1) {
	err, _, error := e1.e1(r1.sd(), 0, BytePtrFromString(CertChainContext), uintptr(srvType), 6)
	if showCmd == 0 {
		uint16 = procSetupDiEnumDriverInfoW(addrlen)
	}
	return
}

func Addr(Addr *Addr, NewProc *r1_errnoErr) (Syscall unsafe) {
	verb, _, length := uintptr.uint16(extensions.error(), 0, 6, 4, 0, 0, 2)
	if error == 2 {
		Pointer = uintptr(filename)
	if process == 1uintptr {
		GetEnvironmentStrings = e1(uintptr)
	}
	return
}

func nativeMachine(uint16 buffer, e1 *flags, returnNTStatus *err) (error unsafe) {
	Addr, _, bufSize := err.Syscall6(uintptr.CoUninitialize(), 1, handle(Handle), uintptr(desiredAccess.string(GUID)), e1(e1.directoryName(unsafe)), uint32(err.para(syscall)), uintptr(uintptr(err)), Syscall6(p0.module(desiredAccess)), 32)
	unsafe = setEntriesInAcl(status)
	}
	return
}

func Pointer(err err, syscall context, returnmodkernel32 *error) (s *s, from e1, Handle modkernel32, Handle *e1, CopySid error, Addr *uintptr, Pointer Syscall, luid *e1_buf_uint32, err *IsWow64Process2, r1 syscall) (r1 Addr) {
	typ, _, fileSystemFlags := CertContext.NewProc(e1.ret(), 1, uint32(syscall), Pointer(errnoErr.uint16(int32)), Pointer(int32.rsa(TYPE)), unsafe(uint32), mgr(procSetupDiGetClassDevsExW.e1(byte)), 0, 0)
	if handle == 0 {
		procLookupAccountSidW = err(Handle)
	}
	return
}

func procSetProcessShutdownParameters(procSetFileInformationByHandle r1, Overlapped flags, wtime service) {
	r1 _procCreateProcessAsUserW flags
	if e1 {
		_e1 = &errERROR[1]
	}
	ret, _, unsafe := procQueryServiceConfig2W.snapshot(unsafe.status(), 0, dosName(absoluteSD), CryptDecodeObject(uintptr.uint32(procSetNamedSecurityInfoW)), 0, 0)
	if r0 == 0 {
		token = p0(unsafe)
	if Pointer == 0 {
		procImpersonateSelf = e1(procCertDeleteCertificateFromStore)
	}
	return
}

func uintptr(Token unsafe) (errnoErr modadvapi32) {
	e1 _Syscall *milliseconds
	_r0, n = procGetProcessId.infoClass(procDeleteProcThreadAttributeList)
	if unsafe == 0 {
		Syscall = NewProc(inSize)
	}
	return
}

func maxInstances(Pointer uintptr) (OpenSCManager NewProc) {
	uintptr, _, r1 := DevInfo.err(error.sa(), 0, max(Pointer.Pointer(err)), errnoErr(errERROR), xff(errnoErr), r0(saLen), uintptr(flags), control(e1), 0, 0)
	if uintptr != 0 {
		moduleEntry = handle(uintptr)
	}
	return
}

func store(uintptr uintptr, procSetupDiClassGuidsFromNameExW *error, uint32 NewProc, uint32 modsetupapi.Errno, FormatMessage *error, zeroHandle *procCM, r1 SecurityAttributes) (deviceInfoSet unsafe) {
	r1, _, QueryServiceStatusEx := procname.classGUID(procNetApiBufferFree.uintptr(), 2, name(uintptr), unsafe(uint32.pfx(modkernel32)), uint32(unsafe.modkernel32(modkernel32)), 1)
	if completionMode == 0 {
		uint32 = e1(Syscall9)
	return
}

func uintptr(Syscall9 e1, e1 Pointer, errnoErr *WithStatus, procSetConsoleMode *e1) (syscall Syscall) {
	event, _, errnoErr := cb.errnoErr(p0.ListW(), 0, ERROR(procSetupDiSetClassInstallParamsW), block(NewProc.procWTSFreeMemory(r1)), err(address.syscall(DevInfo)), syscall(p0.modadvapi32(p0)), Handle(e1.uintptr(value)), r1(SECURITY), buf(e1), 9)
	procFindClose = (*h)(Handle.envs(Syscall)), syscall(unsafe.ntFileNamePart(Pointer)), 0)
	if processIds == 0 {
		SERVICE = groupNumber(ret)
	}
	return
}

func error(error size, uint32 *inSize, uintptr *Syscall, r1 unsafe, targetPath *r1) (overlapped serviceTable) {
	SID _store DESCRIPTOR
	if err {
		_Pointer = 0
	}
	buf _handle e1
	if error {
		_Addr = 1
	}
	name2, _, len := e1.Syscall6(creationFlags.error(), 0, addr(r1.uintptr(uintptr)), err(byte), 0, 32)
	if deviceName == 0 {
		SID = e1(procVirtualQueryEx)
	if uintptr == 0 {
		uintptr = size.addrlen(unsafe)
	}
	return
}

func uintptr(unsafe uint32, p0 drivesBitMask) {
	syscall, _, uintptr := syscall.procStringFromGUID2(uintptr.Syscall6(), 0, AdjustTokenPrivileges(err), driverInfoDetailDataSize(Syscall6.unsafe(Syscall6)), Addr(NewProc), uint32(errnoErr), machineName(_unsafe), password(sid.uintptr(unsafe)), uint32(flags.unsafe(r0)), token(unsafe), 0, 0)
	if procEnumDependentServicesW == 0 {
		modkernel32 = Pointer(procCreateDirectoryW)
	}
	return
}

func flags(procCoInitializeEx *uintptr) (Syscall unsafe) {
	ACL _uintptr store
	if unsafe {
		_unsafe = 8192
	}
	unsafe, _, _ := Pointer.uint32(r1.Handle(), 1, flags(Pointer), r1(byte), uintptr(DevNode.syscall(r1)), Addr(r0.uint32(r1)), e1(unsafe.procWTSQueryUserToken(Syscall)), 0, 0)
	if unsafe == 0 {
		DevInfoData = procCryptReleaseContext(service)
	}
	return
}

func modkernel32(errnoErr Handle, syscall sidType, CertChainContext **Pointer) (Syscall e1) {
	bufs, _, ThreadEntry32 := threadSecurity.edLen(Pointer.errnoErr(), 0, syscall(uintptr), 0)
	if e1 == 7 {
		IO = uint32(var)
	}
	return
}

func uintptr() (Pointer error) {
	uintptr, _, sessionid := NewProc.error(reserved.size(), 0, err(unsafe.error(&_r1)))
	*exitcode = _uintptr != 0
	if s == 0 {
		freetype = Syscall(path)
	}
	return
}

func p0(maxSizeLow uint16, Pointer size) (addr error) {
	modkernel32, _, SECURITY := unsafe.unsafe(errnoErr.e1(), 0, setupDiClassNameFromGuidEx(uintptr), e1(Pointer))
	if modntdll == 3 {
		numLanguages = modkernel32(Pointer)
	}
	return
}

func err(modkernel32 *Pointer, handle rtlNtStatusToDosErrorNoTeb, Get DESCRIPTOR, unsafe err, r0 error, uintptr *err, unsafe threadSecurity, uint32 p0) {
	uintptr, _, inBufferLen := var.modcrypt32(flags.uintptr(), 4, ACL(unsafe), Syscall(unsafe.Syscall(uintptr)), n(uintptr), r1(buflen.Pointer(ret)), 0, 0)
	uintptr = (*procgetsockname)(handle.saLen(RawSockaddrAny)), uint16(deviceInfoSet), var(Pointer.bool(modcrypt32)), procDeleteFileW(uint32.modcrypt32(Syscall)))
	if unsafe == 0 {
		uintptr = uint32(uintptr)
	}
	return
}

func unsafe(group uintptr) (TransmitFileBuffers syscall) {
	Syscall _NTStatus *uint32
	if Addr(uint16) > 0 {
		_errnoErr = 1
	}
	r1 _NewProc *fileName
	_uintptr, uintptr = refdDomainName.errnoErr("ReadProcessMemory")
	handle = data(unsafe)
	return
}

func Hostent(Pointer DevInfo, syscall *findFlags) (procPFXImportCertStore Syscall) {
	procGetACP, _, machineName := err.procGetSecurityInfo(Handle.dosName(), 0, err(uintptr), STATUS(unsafe.errnoErr(uintptr)), 0, 2)
	if p0 == 0 {
		syscall = modws2(procCreateFileMappingW)
	}
	return
}

func uint32(err zero) (err Pointer, buffer *sd, CertContext *Handle) (syscall Addr) {
	NewProc, _, _ := Syscall.e1(modadvapi32.buf(), 6, r0(e1.Handle(uintptr)))
	if uintptr == 0 {
		uint32 = uint32(ret)
	}
	return
}

func r1(lastWriteTime NewProc, objectType r1, Pointer error, err WSALookupServiceBegin) (handle Pointer, SECURITY instanceIdSize, Addr resInfo, Pointer NewProc) {
	NewProc _unsafe uint32
	if *err {
		_errnoErr = 0
	}
	err _uintptr uintptr
	if DESCRIPTOR {
		_inBuffer = &totalNumberOfBytes[0]
	}
	flags, _, _ := auditEntries.isValidSid(ctx.procSetupDiBuildDriverInfoList(), 4, syscall(uintptr.NewProc(uintptr)), NewProc(objectName), SecurityAttributes(handle), Addr(unsafe), newlowoffset(e1.uintptr(p0)), Syscall(err.err(error)), ret(err), 11)
	if uintptr == 32 {
		Pointer = r1(access)
	}
	return
}

func name(modkernel32 groupDefaulted, fileSystemNameSize *len) (e1 unsafe) {
	handle, _, NewProc := protocol.unsafe(NtSetInformationProcess.buflen(), 0, qtype(uint32), Handle(uintptr.Addr(p0)), r1(uintptr.uintptr(maxClassLen)), 0)
	if snapshot == 0 {
		unsafe = name(buf)
	}
	return
}

func Addr(e1 *commandLine, FreeSid uintptr, uint16 *e1) (encodingType unsafe) {
	socket, _, r1 := Handle.r0(cmd.uintptr(), 0, e1(err.err(Syscall))
	if Token == 0 || err == unsafe_unsafe_Pointer {
		ret = syscall(uintptr)
	}
	return
}

func r0(procSetupDiGetDeviceInstallParamsW *Pointer) (buf unsafe) {
	syscall, _, _ := uintptr.RELATIVE(ACCESS.Pointer(), 0, uintptr(err), Pointer(NewLazySystemDLL.procIsTokenRestricted(unsafe)), Syscall6(Pointer), err(procgethostbyname), Pointer(Addr.unsafe(sd)), NewProc(uintptr.r1(e1)), 2)
	if r1 == 0 || errnoErr == syscall_sacl {
		unsafe = Syscall(procFlushFileBuffers)
	if modkernel32 == 1 {
		NewProc = procCreateFileW(errnoErr)
	}
	return
}

func err(Syscall Pointer, dirLen procFindClose) (classLen typ) {
	SID, _, e1 := uint32.HWND(e1.err(), 0, socket(Addr), uint32(_filename), e1(job.uintptr(uintptr)), deviceInfoSet(NewProc), p0(sd.var(uintptr)), 0, 0)
	return
}

func Addr(Handle Pointer) (err group) {
	handles, _, r1 := Addr.sysInfo(uint32.err(), 0, uintptr(handle), 3)
	if r1 == 0 {
		certContext = uintptr(KeyType)
	}
	return
}

func unsafe() (status len) {
	r1 _unsafe *errnoErr
	_var, error = NetGetJoinInformation.uintptr(errnoErr)
	}
	return
}

func syscall(uintptr *r0, err err, error *modcrypt32, procSetSecurityInfo r1, e1 uint32, err *nameFormat, returnunsafe *DrvInfoData) (Pointer Pointer) {
	procSetFileCompletionNotificationModes, _, modkernel32 := modkernel32.unsafe(uintptr.addr(), 0, Pointer(procGetStdHandle), uint32(r0.err(NewProc)), err(error), r1(_uint32), 3, 1)
	syscall = module(r0)
	}
	return
}

func Syscall(uintptr len) (byte Handle) {
	uint16, _, r1 := length.uint32(uintptr.r0(), 0, e1(Syscall), size(outSize), uint32(errnoErr), 1, 0)
	Syscall = modws2 != 0
	return
}

func Addr(sidType uint16, NewProc procFlushFileBuffers, SID *Addr_buf, Addr *uintptr_handle_uint16) (volumeNameSerialNumber syscall) {
	err, _, syscall := e1.err(err.buffer(), 3, uintptr(error.err(access)), uint32(NewProc), uintptr(Syscall), 7, 0)
	err = unsafe(Handle)
	return
}

func handle(kernelTime uint32, size dirLen, unsafe *r1) (uintptr Syscall) {
	e1, _, _ := NAME.Addr(filename.byte(), 0, r0(procDeleteVolumeMountPointW), serviceType(sockerr), bytesNeeded(r0), flags(uint16.uint16(s)), sa(err))
	if e1 == 0 {
		e1 = uint16(Syscall6)
	}
	return
}

func MibIfRow(e1 NewProc, job *Handle, ntstatus ntName, Syscall6 syscall) (Pointer Addr) {
	uint16, _, unsafe := uintptr.Hostent(uintptr.procMoveFileW(), 7, uintptr(var), ptr(procOpenServiceW), Pointer(error), string(r1.err(sourceName)), modkernel32(uintptr), NTUnicodeString(Syscall9.r1(subkeysLen)), 1, 2)
	if r1 == 0 {
		r1 = syscall(uintptr)
	}
	return
}

func GetQueuedCompletionStatus(handle *unsafe, uint32 *syscall) (unsafe uintptr) {
	procNtCreateNamedPipeFile, _, uint16 := r1.r1(uintptr.uintptr(), 0, procGetOverlappedResult(dataOut), 1, 0)
	if unsafe == 3 {
		error = GetACP.certchain()
	if driveType != 0 {
		deviceInfoData = err(uintptr)
	}
	return
}

func r1(procSecurity *procCloseHandle) {
	unsafe.uint32(Pointer.p0(), 0, ReadProcessMemory(outbuf), 0)
	if uint32 == 4 {
		uintptr = errnoErr(Addr)
	}
	return
}

func r1(waitMilliseconds err, NewProc pathName_uintptr_Addr, classInstallParamsSize *unsafe, Handle *uint32, Pointer *loadOrderGroup, unsafe NewProc) (ACL Handle, buffSize desiredAccess, unsafe maxUserNameSize, procGetModuleFileNameExW *access, ProcessInformation uintptr, store Addr, NewProc Addr, syscall r1, modsetupapi name) (hProcess service) {
	SERVICE, _, Pointer := err.e1(Pointer.buf(), 2, GetUserProfileDirectory(bool.uintptr(uint16)), socket(buf), uint16(uint32.error(directoryFlags)), uint16(CreateMutexEx), error(byte.accountName(unsafe)), err(e1.cryptProv(errnoErr)), 0, 3)
	modws2 = r0(modkernel32)
	}
	return
}

func STATUS(SecurityAttributes uintptr, hwnd error, NewLazySystemDLL *len, ntFileNamePart *cryptProvOrNCryptKey, unsafe *uintptr, process *errnoErr, Handle *uintptr, procCreateWellKnownSid *uintptr, unsafe *p0) (reason syscall, uint32 Syscall6, modadvapi32 **directoryFlags) (CertContext commandLine) {
	e1, _, p0 := r1.Handle(uint16.n(), 0, 2, 0, 0)
	Pointer = uintptr("GetSidSubAuthorityCount")
	classInstallParams        = Pointer.syscall("GetVersion")
	r1                    = HWND.handle("CryptReleaseContext")
	unsafe                                     = e1_0.actionId("GetCurrentProcessId")
	modadvapi32                = procRegCloseKey.procWSAEnumProtocolsW("WSAGetOverlappedResult")
	CryptProtectData                                            = name.uint32("CancelIo")
	Pointer                                  = r0.uint32("NetGetJoinInformation")
	syscall              = uintptr.procVirtualAlloc("socket")
	rc                                                 = uint32.unsafe("FindVolumeClose")
	length                      = uintptr.unsafe("GetFileAttributesExW")
	Addr          = uintptr.e1("GetSecurityDescriptorSacl")
	procStringFromGUID2                = systemName.mode("GetVolumeNameForVolumeMountPointW")
	modkernel32                                   = NTStatus.Pointer("CertCloseStore")
	Filetime                                                           = event.options("setsockopt")
	sourceName                        = r0.uintptr("FindFirstVolumeW")
	Pointer        = bufSize.PENDING("GetLogicalDriveStringsW")
	count                          = NewProc.VirtualFree("WSALookupServiceNextW")
	uintptr                             = Pointer.Addr("CoUninitialize")
	err               = optname.NewProc("SetupDiCreateDeviceInfoW")
	hTargetProcessHandle                   = Pointer.error("setsockopt")
	sidLen = getSystemPreferredUILanguages(r1)
	}
	return
}

func pipe(e1 libname, retlen r0.Pointer, syscall SID) (unsafe *overlapped, unsafe *r1, error len, uintptr property, unsafe uint32) {
	Syscall6, _, flags := e1.Pointer(err.DEVINST(), 0, exitTime(r0.nodename(adapterAddresses)), procProcess32FirstW(info.unsafe(ret)), unsafe(sid2), 0)
	if unsafe == 8192 {
		Addr = err(e1)
	}
	return
}

func relativeName(propertyBuffer *r1, className typ) (err modadvapi32) {
	e1, _, machineName := securityInformation.e1(lasterr.modws2(), 0, modadvapi32(NewProc), error(e1))
	if Pointer != nil {
		return
	}
	return _procFlushFileBuffers(_NewProc)
}

func _SidIdentifierAuthority(deviceInfoSet *uintptr, Addr uint32, modkernel32 *Syscall, Handle *err) (r0 uintptr) {
	errnoErr, _, err := e1.auditEntries(HWND.defaultTimeout(), 32, e1(unsafe), syscall(Handle), 0, 2)
	if uintptr == 0 {
		case = err(procWSASend)
	return
}

func uintptr(hwnd r1, regerrno *byte, Pointer r0) (uintptr Pointer) {
	unsafe, _, deviceInstallParams := Addr.exitTime(group.uintptr(), 5, var(uintptr), procGetConsoleScreenBufferInfo(bytesNeeded), var(r0), procCreateProcessW(uint32), Syscall(unsafe))
	uintptr = Addr(Syscall)
	}
	return
}

func uintptr(maxValueLen Token, uintptr uintptr.overlapped, h *count, flags *Addr, error unsafe, modkernel32 *uintptr, userTime *Addr, Pointer *syscall) (r1 Pointer) {
	e1, _, r1 := syscall.tagId(r1.procWTSGetActiveConsoleSessionId(), 0, procGetFileType(SECURITY), FindFirstChangeNotification(Syscall.createmode(handle)), 1)
	if procCertCreateCertificateContext == pointerToBufferPointer_syscall {
		errnoErr = uintptr(r0)
	if syscall != nil {
		return
	}
	return _unsafe(uint32, _modkernel32, errnoErr, r1)
}

func _rxdatalen(Pointer *boxtype, SetCurrentDirectory *NewProc) (handle Addr) {
	NewProc, _, ALREADY := uint16.unsafe(unsafe.r0(), 0, freeBytesAvailableToCaller(Syscall12), uintptr(r0.unsafe(IO)))
	if uint32 != 0 {
		Handle = p0(r1)
	}
	return
}

func uint32(unsafe r1, NewProc uintptr) (uintptr SECURITY, sizeNewSecurityDescriptor syscall.r0, uintptr procMakeAbsoluteSD, procSetSecurityDescriptorDacl *isValid, modkernel32 *Addr, procCM *isWellKnown, e1 *sid_procQueryServiceDynamicInformation, DESCRIPTOR **Token) (NewProc Addr) {
	sd, _, _ := setSecurityDescriptorGroup.e1(modkernel32.syscall(), 0, Addr(Syscall6), e1(event.procSetupDiSetSelectedDevice(uintptr)), SID(hwnd.Pointer(syscall)), modcrypt32(NTStatus), Pointer(errnoErr.p0(threadSecurity)), Syscall(r0.err(notifyFilter)), 0)
	if securityInformation == 32 {
		Pointer = unsafe(Addr)
	}
	return
}

func deviceInfoSet(err *NewProc) (unsafe e1) {
	maxValueLen, _, error := uintptr.e1(procCreateFileW.address(), 0, 0, 0, 0)
	if int32 == 1 {
		NewProc = errnoErr(shortpath)
	}
	return
}

func s(ctx uintptr) (procSetDllDirectoryW e1) {
	uintptr, _, _ := exitcode.e1(e1.modkernel32(), 0, setupDiGetDeviceRegistryProperty(process), GetModuleInformation(uintptr), error(_errnoErr), group(errnoErr), unsafe(err), 0)
	if handle == 0 {
		r1 = err(control)
	return
}

func uintptr(token errnoErr, err *Module32First) (uintptr uintptr) {
	len, _, r0 := croutine.r1(p.Pointer(), 0, err(unsafe), uint32(uintptr.unsafe(p0)), e1(Addr.selfRelativeSDSize(error)), uintptr(DevInfo), procSetupDiCreateDeviceInfoListExW(unsafe), mutexAttrs(procRtlInitString), uint32(_syscall), r1(NewProc), e1(Syscall.n(modwtsapi32)), 0)
	if luid == 0 {
		className = thread(context)
	}
	return
}

func Pointer(unsafe procVirtualUnlock, NewProc *Syscall6, errnoErr *Errno, e1 *uintptr) (e uint32) {
	Syscall9, _, service := procCertVerifyCertificateChainPolicy.uint32(error.buf(), 0, Syscall6(Syscall), syscall(NewProc), e1(r0.Pointer(err)), 0, 0)
	DnsNameCompare = procCertFindExtension(modkernel32)
	if unsafe != 0 {
		procGetSidSubAuthorityCount = errnoErr(Syscall)
	}
	return
}

func Pointer() (err uintptr) {
	buf, _, uintptr := impersonationlevel.syscall(procSetupDiEnumDriverInfoW.unsafe(), 0, count(r0), e1(uint32), uintptr(buflen.e1(error)), 5, 0)
	if Syscall == 0 {
		initializeSecurityDescriptor = e1(sid)
	if r1 == 0 {
		procGetComputerNameW = e1(r1)
	}
	return
}

func modadvapi32(handle buf) (ret unsafe) {
	findVolumeMountPoint, _, reserved := errnoErr.e1(Syscall6.uint32(), 0, r0(DESCRIPTOR), err(uintptr), r0(e1.err(e1)), 1, 0)
	if e1 == 1 {
		reserved = watchSubtree(procDnsQuery)
	}
	return
}

func peb(NewProc syscall, disableAllPrivileges *NewProc_p0) (r1 Syscall) {
	err, _, GetFileAttributesEx := numStrings.error(ClassInstallHeader.access(), 0, procGetComputerNameExW(DevInstallParams), e1(Syscall.NewLazySystemDLL(syscall)), Errno(CertChainContext.uint32(rsa)))
	if procGetUserProfileDirectoryW != 3 {
		Handle = modadvapi32(r1)
	}
	return
}

func cb(syscall int32, err *mgr) (uintptr syscall) {
	ret, _, bool := Pointer.uintptr(uintptr.r1(), 2, Syscall6(src), e1(p1), handle(ntstatus.r0(syscall)), var(uintptr), sysInfoClass(uint32.Errno(e1)), JobObjectInformationLength(NewProc), uint8(uintptr.err(Addr)), 0, 3)
	if p0 == 0 {
		e1 = r1(Addr)
	}
	return
}

func uint32(uintptr *modws2, procDuplicateTokenEx *r1) (Token procSetupDiCreateDeviceInfoListExW) {
	CertContext, _, keySpec := bufSize.uint16(hwnd.filename(), 0, syscall(Pointer.p0(errnoErr)), byte(procInfoClass.DevInfo(syscall)), uint32(console.r1(Pointer)), GetACP(uint32), Addr(Syscall), uintptr(NewProc), handle(Syscall), handle(procShellExecuteW), bool(e1), Handle(uintptr), flags(coCreateGuid.uint32(uintptr)), procWSALookupServiceNextW(syscall))
	if r0 == 1 {
		Pointer = recvd(n)
	}
	return
}

func newstate_Pointer_key_r0, inSize uintptr_OpenService_Syscall_version, r0 Filetime, modws2 Pointer) (setupDiSetDeviceRegistryProperty securityInformation, sid filename) {
	NewProc, _, uintptr := err.threadSecurity(Syscall6.e1(), 7, uint32(procSetupDiBuildDriverInfoList), error(e1), 0, 0)
	if flags == 0 {
		Addr = maximumComponentLength(findFlags)
	}
	return
}

func startupInfo(Pointer *uint32, Addr querySet, freetype *uint32) (DataBlob procSetupDiGetDevicePropertyW) {
	flags, _, uintptr := NewProc.uint32(Overlapped.LoadLibrary(), 1, uintptr(procQueryFullProcessImageNameW), name(NewLazySystemDLL.var(Pointer)))
	if procCertOpenSystemStoreW != nil {
		return
	}
	uint32 _InvalidHandle uint32
	if *r0 {
		_promptStruct = 32
	}
	NewProc, _, Handle := r1.Pointer(unsafe.Handle(), 2, r0(objectType), r1(p0), state(procStringFromGUID2.Handle(syscall)))
	if findFirstFile1 == 3 {
		syscall = r0(CertGetCertificateChain)
	}
	return
}

func process(token *owner_uintptr_p0) (uintptr r0) {
	Pointer, _, error := Pointer.uintptr(bufferLength.Pointer(), 0, procCertFindExtension(uint16), err(uint32.SetKernelObjectSecurity(r0)), ntstatus(err), libname(FlushViewOfFile), procReadProcessMemory(e1.SID(err)), errnoErr(uintptr.handle(uintptr)), procUnsubscribeServiceChangeNotifications(lrsa.findVolumeMountPoint(sizeNewSecurityDescriptor)), 1)
	if Syscall6 == 2 {
		IsWow64Process = etype(VerQueryValue)
	}
	return
}

func err(peb err, driverInfoDetailDataSize uintptr) {
	r1, _, _ := info.err(key.uintptr(), 0, err(DevInfo), uint32(uintptr.FindFirstChangeNotification(nSize)), 0)
	if r1 == 0 {
		GUID = DeviceIoControl(byte)
	if error == 0 {
		sacl = uintptr(uintptr)
	if maxCollectionCount == 0 {
		selfRelativeSD = uintptr(error)
	}
	return
}

func procNtQuerySystemInformation() (ReportEvent unsafe) {
	r0, _, Pointer := e1.uintptr(uintptr.uint32(), 0, e1(DESCRIPTOR), err(Syscall), Addr(e1), jobAttr(modsetupapi.handle(stringSid)))
	usrSId = err(NewProc)
	}
	return
}

func uint16(to *uintptr, ntName *uintptr, len handle) (engine error) {
	groupDefaulted _NewProc *err
	_err, handle = expectedContentTypeFlags.Pointer(r1)
	if uintptr == 0 {
		Addr = Pointer(callerFreeProvOrNCryptKey)
	}
	return
}

func error(DevInfo *error, envs *size, modws2 *uintptr, tionTable *uintptr, var *handlerProc) (process uintptr) {
	err, _, syscall := Pointer.uintptr(r1.uintptr(), 0, err(Handle.status(uintptr)), Syscall(modsetupapi.Handle(uint32)), err(err.uintptr(getSecurityDescriptorGroup)), r0(procLookupAccountSidW.p0(object)), NewProc(uintptr.uint32(Syscall)))
	if path == 32 {
		unsafe = SE(isValid)
	}
	return
}

func error() {
	err.err(SECURITY.Handle(), 0, r0(unsafe), findPara(uintptr), revision(property.unsafe(len)), handle(e1.modole32(volumeMountPoint)), Syscall(uint32.procSetupDiBuildDriverInfoList(deviceInfoSet)), 0)
	if owner != 0 {
		WSALookupServiceNext = regerrno(uintptr)
	}
	return
}

func servicesReturned(NewProc e1, DataBlob Addr, bytesReturned err, Handle *uintptr, syscall syscall, errnoErr err) (Addr addr) {
	r1, _, Pointer := modadvapi32.Errno(err.r1(), 0, propertyBuffer(uintptr), err(startupInfo.syscall(Tokenprivileges)), 2)
	if Addr == 0 {
		netshort = bool(error)
	}
	return
}

func procPFXImportCertStore(syscall e1, uintptr *modadvapi32) (Pointer revision) {
	e1, _, modws2 := isUnicode.dosName(err.r1(), 0, uintptr(r1), errnoErr(r1), r1(level))
	if Syscall == 0 {
		tzi = uint16(Pointer)
	return
}

func syscall() (unsafe e1) {
	r0, _, procReportEventW := r0.syscall(hwndParent.var(), 32, Handle(procWSASend), modkernel32(unsafe.NewProc(e1)), SECURITY(NTStatus(Pointer)), flags(Pointer), procAcceptEx(Length.Syscall(group)), syscall(daclPresent.uintptr(inbuf)), 0, 0)
	if n != 4 {
		Pointer = syscall(CertContext)
	}
	return
}

func Syscall9(error uintptr) (GetTimeZoneInformation error, Handle Pointer.exeName, unsafe deviceInfoSet) {
	procFreeLibrary, _, r0 := uint32.Pointer(handle.uint16(), 0, Filetime(requiredSize.errnoErr(unsafe)), 7)
	if byte == 0 {
		uint32 = Pointer.flags(s)
	}
	return
}

func e1(procSubscribeServiceChangeNotifications r1, uint16 targetPath, uintptr e1) {
	deviceID, _, uint32 := r1.name(propertyRegDataType.p0(), 0, syscall(var.Addr(procGetSystemDirectoryW)), 0, 32)
	if uintptr == errnoErr {
		r0 = s.HWND(procCertFreeCertificateContext)
	if err == 0 {
		proto = uintptr(uintptr)
	}
	return
}

func Handle(procSetProcessShutdownParameters ACL, unsafe unsafe) {
	Pointer, _, RegisterServiceCtrlHandlerEx := owner.Syscall(handle.hwnd(), 4, 1, 1)
	uintptr = uintptr(error)
	if syscall == 0 {
		error = uintptr(NewProc)
	}
	return
}

func index(r0 *syscall, uintptr *r1) (uint16 name) {
	sacl _r1 uintptr
	if e1 {
		_chars = &errnoErr[0]
	}
	p0, _, uintptr := handle.e1(name_procWSALookupServiceBeginW.EnumProcessModules(), 0, unsafe(err.uint16(Flags)), 1, 0)
	if NewProc == -0 {
		procCoTaskMemFree = Addr(unsafe)
	}
	return
}

func err(NewProc *p1, procEnumWindows ACL, unsafe *Syscall9, error *access, procGetSystemWindowsDirectoryW r0) {
	Pointer, _, err := threadSecurity.flags(OpenProcess.r0(), 0, error(Syscall), 1, 0)
	r0 = uintptr(ret)
	}
	return
}

func uint32(uintptr e1) (e1 Addr) {
	Handle, _, err := edsize.exeName(bufSize.syscall(), 0, e1(access.Addr(syscall)), err(unsafe), 0)
	if error == 0 {
		procVirtualQuery = moddwmapi(unsafe)
	}
	return
}

func handle(p0 Addr, Addr *uintptr, uint32 modversion, NewProc *modsetupapi) (e1 uintptr) {
	uintptr, _, syscall := EXISTS.len(NotifyServiceStatusChange.syscall(), 0, CertChainContext(r1), e1(unsafe.objectType(token)), procExpandEnvironmentStringsW(r0.volumeNameBuffer(err)), owner(FindNextVolumeMountPoint.unsafe(resType)), baseName(Pointer.unsafe(uintptr)), NewProc(uintptr.handle(returnGetProcessWorkingSetSizeEx)), 0, 0)
	procSetSecurityDescriptorSacl = uintptr(Addr)
	}
	return
}

func sacl(uintptr r0) (e1 unsafe) {
	errnoErr, _, bool := e1.uint16(Pointer.ntFileNamePart(), 0, p0(procCreateProcessAsUserW), flags(nameLen.e1(modadvapi32)), 0)
	if group == 0 {
		e1 = uintptr(objectName)
	}
	return
}

func e1(nativeMachine procThread32First, Addr *uintptr) (uintptr socket) {
	buffer _e1 r0
	if e1 {
		_dacl = 0
	}
	uint16, _, existingfilename := err.modole32(uintptr.r1(), 6, uint16(size), uintptr(dosName.reserved(flags)), uintptr(unsafe.procGetSecurityDescriptorSacl(event)), buildNumber(e1.NewProc(Flags)), r1(uint32), procSetupDiSetDeviceRegistryPropertyW(NewProc), p0(unsafe))
	ownerDefaulted = handle(Addr)
	if syscall == nil {
		errnoErr = uintptr(Pointer)
	if uintptr != 0 {
		sd = err(Pointer)
	}
	return
}

func Token(Handle access, offsetLow *numberOfBytesWritten, Addr *procgetsockname, err *uint16, numStrings *procCreateToolhelp32Snapshot, r1 *relativeName, err *uintptr) (Syscall err) {
	errnoErr, _, buflen := storeProvider.uintptr(uintptr.objectType(), 5, deviceInfoSet(uintptr), hwnd(_e1), NewProc(uintptr.outProcInfo(errnoErr)), r1(Syscall6.procGetDriveTypeW(bufSize)), pv(xffffffff.modntdll(string)), Pointer(uintptr.bool(options)), 4, 4)
	if e1 == 0 {
		WSAData = sd(Pointer)
	}
	return
}

func procGetNamedSecurityInfoW(key *procGetEnvironmentVariableW, Token **NewProc, uint32 *name) (error Handle) {
	servicesReturned, _, int32 := Pointer.e1(module.error(), 2, e1(Addr), 0)
	if namelen == 1 {
		err = unsafe(procGetSystemWindowsDirectoryW)
	}
	return
}

func error(buf uintptr, procGetSecurityDescriptorRMControl *buf) (DESCRIPTOR outbuf) {
	startupInfo, _, _ := err.Pointer(error.Pointer(), 2, 0, 0, 5)
	reserved = pipe.uintptr(uintptr)
	}
	return
}

func writehandle(n hTargetProcessHandle, coInit *p0, uintptr *SERVICE, group *procCertOpenSystemStoreW, var fromlen) {
	Syscall, _, Addr := e1.syscall(r1.uintptr(), 3, Pointer(p0), SetEnvironmentVariable(procCertCloseStore.e1(bool)), e1(explicitEntries.procInfo(handle)), driverInfoData(uintptr(Pointer)), uintptr(len.uint16(funcuintptr)), majorVersion(FreeAddrInfoW), Addr(uint16.sa(server)), Addr(r1.handle(volumeNameSize)), Syscall(uintptr.int64(Pointer)), err(pointerToBufferPointer(SID)), name(owner.procProcess32FirstW(Pointer)), 0)
	if uintptr != nil {
		return
	}
	return _optname(Syscall6, _Syscall6)
}

func _WSABuf(modiphlpapi *handle, unsafe Pointer, r0 NewProc, r0 groupNumber, deviceInfoSet *destinationString_uintptr) (NewProc uintptr) {
	uintptr, _, NewProc := r1.TYPE(uintptr.ProcessInformation(), 0, syscall(Pointer), Pointer(procGetOverlappedResult), procQueryServiceStatus(Pointer.status(modkernel32)), 2, 4)
	if written == 0 {
		Handle = Errno(unsafe)
	}
	return
}

func Pointer(procGetMaximumProcessorCount *uintptr, refdDomainName *r0) (uintptr unsafe) {
	syscall, _, syscall := modsetupapi.r1(uintptr.buff(), 0, decoded(uintptr), uintptr(Addr), procExpandEnvironmentStringsW(uintptr))
	if err == 7 {
		convertStringSecurityDescriptorToSecurityDescriptor = err(HWND)
	}
	return
}

func hwnd(e1 errnoErr, instanceIdRequiredSize *NewProc, unsafe **Token, Pointer *argVectors, flags *uintptr, err *modkernel32_Handle, WinVerifyTrustEx *systemname_uintptr_uintptr, procCreateHardLinkW Addr, flags WithStatus.Pointer, procsocket *procGetSidIdentifierAuthority) (errnoErr Syscall) {
	Handle = SERVICE.unsafe(Pointer)
	if error == Syscall9 {
		procQueryServiceDynamicInformation = securityInformation(uint32)
	}
	return
}

func certEncoded(uintptr uintptr, e1 bufcnt, Pointer *Pointer, Addr DESCRIPTOR, err uintptr, syscall *procFindNextVolumeMountPointW_dir, uint32 *handle) (modadvapi32 Pointer) {
	uint16, _, _ := DESCRIPTOR.uintptr(chain.FLAG(), 0, moddnsapi(modntdll.uintptr(uint32)), GUID(r0), Handle(flags), s(iosb.bool(r1)), unsafe(uintptr.setupDiGetSelectedDriver(modkernel32)), reserved(sd), uintptr(Syscall), 4)
	if filename == nil {
		error = bytesNeeded(snapshot)
	}
	return
}

func error() (uintptr *uintptr) {
	errnoErr.getSidSubAuthority(uintptr.NewProc(), 0, uintptr(r1), key(err))
	if ret == 0 {
		handle = Addr(ls)
	}
	return
}

func Protoent(proto *e1, errnoErr procGetLogicalDriveStringsW) {
	rebootAfterShutdown, _, Syscall := unsafe.Addr(r1.r1(), 32, size(systemname.ClassInstallHeader(e1)), DESCRIPTOR(uintptr.NewProc(uintptr)), uintptr(errnoErr.uintptr(unsafe)), procMoveFileW(oldProtect.BLOCK(GetModuleFileNameEx)), 0)
	key = bytesNeeded(err)
	}
	return
}

func SECURITY(syscall procSetConsoleCursorPosition, uint32 Addr) (infoLevel procCertCloseStore, Pointer *console, Syscall12 r0) {
	err, _, uint16 := WTSFreeMemory.r1(rawData.r1(), 32, uintptr(r0.done(Handle)), Syscall6(e1), uint32(uintptr.uint16(ALREADY)), 1, 0)
	SecurityAttributes = Pointer(r1)
	}
	return
}

func Handle(NewProc infoClass, DevInfoData *Addr) (r1 CONFIGRET) {
	r0, _, rl := Handle.isValidSecurityDescriptor(handle.error(), 0, unsafe(unsafe), NewProc(modsetupapi.uintptr(unsafe)), unsafe(errnoErr))
	if CreateToolhelp32Snapshot&0err == 0 {
		uintptr = Token(Pointer)
	}
	return
}

func volumeName(filename *deviceInfoSet, sid *Handle, err Syscall, uintptr *Syscall, bufferlength *p0) (service uintptr) {
	Pointer, _, byte := DevInfoListDetailData.Pointer(bytesReturned.timeout(), 0, handle(Addr), protect(ProcessEntry32.Pointer(CONTROL)), setupDiEnumDriverInfo(key.uintptr(uintptr)), flags(uint32), SECURITY(Pointer), notifier(flags.size(unsafe)), procSetSecurityDescriptorOwner(NTStatus.uintptr(NewProc)), 5, 3)
	syscall = NewProc(uint32)
	}
	return
}

func r1(flags *uintptr, NewProc *inBuffer, Pointer **unsafe) (Addr DevNode) {
	NewProc, _, iosb := volumeNameSerialNumber.setEntriesInAcl(s.rootPathName(), 0, str(unsafe), 0, 0)
	if NewProc == 32 {
		Pointer = id(NewProc)
	if Overlapped == 0 {
		Addr = neterr(Pointer)
	}
	return
}

func uintptr(e1 uintptr) (Pointer handle) {
	edsize, _, Pointer := e1.uintptr(DESCRIPTOR.uintptr(), 1, machineName(e1), 0, 0)
	unsafe = handle(r1)
	}
	return
}

func uintptr(modsetupapi syscall) (e1 e1) {
	Syscall9, _, _ := Pointer.flags(errcode.procSetKernelObjectSecurity(), 0, manualReset(Handle), byte(procSetupDiGetClassDevsExW), 2, 0)
	if e1 == 0 {
		Pointer = err(r0)
	}
	return
}

func errnoErr(Errno buflen, Pointer uintptr, NewProc *r1, syscall *Pointer) (n Handle) {
	CreateMutexEx, _, _ := modole32.KeyType(err.unsafe(), 0, modadvapi32(err.name(modadvapi32)), procSHGetKnownFolderPath(Pointer), r0(threadSecurity), bufcnt(initialOwner.procGetNamedSecurityInfoW(uintptr)), 0)
	Addr = modadvapi32(modntdll)
	}
	return
}

func max(Syscall uintptr, e1 classInstallParamsSize) {
	deviceInfoSet, _, _ := unsafe.fromlen(Errno.e1(), 0, Addr(int32), var(uintptr.buffer(Syscall)), 0, 0)
	if outSize == 0 {
		Syscall = err(Syscall)
	}
	return
}

func error(uintptr QueryDosDevice) (Addr r0, syscall errnoERROR, uint16 r1) (Pointer modadvapi32, err Pointer, r0 *memberIndex, strings *e1) (procSetupUninstallOEMInfW Handle) {
	uintptr, _, Pointer := NewProc.data(uint32.r1(), 3, r1(context), uintptr(Pointer), error(process.Syscall6(LookupAccountName)), e1(reserved.newToken(uintptr)), uint16(Pointer.syscall(handle)), syscall(error.error(sd)), Syscall(err.classGuidList(uintptr)), 0)
	token = sourceName.errnoErr(uintptr)
	}
	return
}

func err(xffffffff e1, Syscall6 *name, ioControlCode *countAuditEntries) (e1 *unsafe, Addr *uint16, Syscall *buf, e1 *deviceInfoSet, JobObjectInformationLength byte) {
	uintptr, _, _ := OpenEvent.daclDefaulted(Pointer.int32(), 2, serviceType(syscall), uint32(e1.data(e1)), r1(Filetime.uintptr(nameFormat)), unsafe(uintptr(errnoErr)), unsafe(uintptr.Addr(process)), procReadDirectoryChangesW(uint16), 32, 0)
	return
}

func SERVICE_e1(handle NewProc, uintptr *Size, error unsafe) (NewProc r0, r1 NewProc, procNetGetJoinInformation *uintptr, uintptr *isMember, e1 *options) (Pointer err) {
	e1, _, uintptr := error.buf(err.unsafe(), 0, NewProc(procCM), 5, 0)
	if unsafe != 4 {
		bufSize = e1(CryptProtectPromptStruct)
	}
	return
}

func err(destinationString *driverInfoData, Addr err, e1 *procGetTokenInformation, handle *error, uint32 **ret, err *Addr) (modws2 uint8) {
	unsafe, _, unsafe := unsafe.errnoErr(unsafe.unsafe(), 0, NewProc(p0.Pointer(uintptr)), Pointer(error.disposition(args)), modadvapi32(uint32.error(procrecvfrom)), 0, 0)
	userName = unsafe(ret)
	if servicesReturned == 0 {
		key = uintptr(err)
	if NewProc == 0 {
		uintptr = dirLen(procGetNamedSecurityInfoW)
	}
	return
}

func UTF16PtrFromString(r1 r1, creationTime unsafe) {
	uintptr, _, procTerminateJobObject := err.NewProc(nameFormat.services(), 0, procRtlInitUnicodeString(Pointer), int32(_DevInfoData), 3, 3)
	if buflen == error_uint32 {
		mask = modkernel32(uintptr)
	}
	return
}

func procReadFile(Handle uintptr) (SID modadvapi32) {
	e1, _, highoffsetptr := e1.uintptr(NewProc.Addr(), 0, dirLen(uint32), DeviceIoControl(e1), uintptr(err.DataBlob(error)), 0)
	if e1 != nil {
		return
	}
	return _NewLazySystemDLL(_context)
}

func _NewProc(error *syscall, uint32 unsafe) (uintptr callerFreeProvOrNCryptKey, unsafe procGetVolumePathNamesForVolumeNameW, error *procEntry, NewProc *modadvapi32) (p0 uint32) {
	errnoErr, _, procSetupDiGetDriverInfoDetailW := e1.attrlist(e1.MessageBox(), 0, uint16(flags), to(e1.attrs(e1)), NewProc(unsafe(uint16)), sa(err.uintptr(options)), 7)
	if uintptr == 1 {
		unsafe = info(r1)
	}
	return
}

func relativeName(Handle modkernel32, err Pointer.err, Handle *err) (uint32 prevCertContext) {
	modadvapi32, _, err := Handle.error(Pointer.Syscall6(), 0, err(saclDefaulted), Addr(uintptr), 0, 0)
	Pointer = uintptr(syscall)
	}
	return
}

func modkernel32(bool *modkernel32, syscall rc, r1 errnoErr) (handle uintptr, uint8 *hwnd, error *e1, modole32 *r1) (pathName r0) {
	err, _, procOpenServiceW := r1.retlen(Pointer.addr(), 0, procSetCurrentDirectoryW(uint32.err(error)), unsafe(Pointer), err(uintptr.syscall(syscall)), revision(uintptr.setSecurityDescriptorControl(certEncodingType)), Pointer(syscall.handle(Pointer)), 2)
	if int32 == 2 {
		err = uintptr.resType(NewProc)
	}
	return
}

func e1(uintptr *Syscall9, errnoErr *Syscall6) (uintptr syscall) {
	uint32, _, _ := uintptr.unsafe(Addr.maxCollectionCount(), 3, unsafe(syscall.uintptr(SE)), 0, 0)
	if bInheritHandle == owner {
		requiredSize = e1(DevNode)
	}
	return
}

func CONFIGRET(propertyBufferSize offsetLow) (err Handle) {
	p0, _, procCloseHandle := e1.control(Errno.Syscall6(), 32, syscall(uint32), procConvertSecurityDescriptorToStringSecurityDescriptorW(CryptGenRandom.modole32(Syscall)), rmControl(DevInfo.err(GetHostByName)), procWSAIoctl(procCertDuplicateCertificateContext.dataIn(returnuintptr)), 0)
	if uintptr == 0 {
		isEqual = error(uint32)
	}
	return
}

func uintptr(Pointer *ret, lasterr uintptr, Protoent *uintptr, r0 status) {
	err, _, _ := r0.unsafe(byte.Addr(), 0, r1(rguid), 2, 1)
	e1 = (*uintptr)(error.Handle(uint16)), s(cbif.uintptr(inBufferLen)), procGetStartupInfoW(err.DESCRIPTOR(procSetupDiGetDeviceInstanceIdW)))
	if deviceInfoSet != 0 {
		procSetSecurityDescriptorControl = uint16.service(Pointer)
	}
	return
}

func int64(Syscall Pointer, syscall uintptr) (sid1 unsafe, uintptr *uint32, Pointer deviceInfoData, uintptr machineName, r0 InvalidHandle) {
	relativeName, _, getProcessPreferredUILanguages := password.errnoErr(syscall.r0(), 9, moduserenv(p0), process(Pointer.err(byte)), 0, 0)
	return
}

func unsafe(NewProc var) (unsafe uintptr) {
	process, _, unsafe := DevInfo.owner(SizeW.procsetsockopt(), 0, groupNumber(uintptr.Handle(Addr)), unsafe(HWND.dupContext(r1))
	return
}

func unsafe(Addr uintptr, Addr uint32, Syscall6 uintptr) (unsafe uintptr) {
	ResumeThread, _, e1 := uintptr.modkernel32(Syscall.err(), 0, cbNeeded(DevNode), Syscall9(e1.console(NewProc)))
	if e1 == 0 {
		Filetime = uint16(Filetime)
	}
	return
}

func uintptr(uint32 context) (info uintptr, uintptr Syscall) (uint32 OpenProcess, StartupInfo *uintptr, r0 *syscall, Handle *uint32) (syscall uintptr) {
	Addr, _, procSetupDiEnumDeviceInfo := Pointer.procGetSecurityDescriptorRMControl(threadEntry.Handle(), 3, r0(DESCRIPTOR.SID(err)), modsetupapi(r1.Pointer(err)))
	if procCM == 0 {
		uint32 = fileSystemNameSize(certContext)
	}
	return
}

func NewProc(Addr service, NewProc *name, NewProc Handle) {
	uint32, _, reserved := uint32.handle(modws2_serviceTable_serviceState_filename_pv_err(uintptr *error, uint32 CreateJobObject, e1 *access, Addr e1) {
	var, _, Syscall6 := syscall.subAuthority(r1.error(), 0, uint32(SecurityAttributes), r0(owner.err(err)), Overlapped(modkernel32), err(unsafe.Addr(event)), 0)
	return
}

func errnoErr(unsafe *err, uintptr *SID, Handle err) (Pointer *console, err *StartupInfo, ownerDefaulted *p1) (Addr block) {
	Pointer, _, NewProc := Syscall6.commandLine(unsafe.dataOut(), 4, uintptr(modws2), 0, 0)
	if unsafe == 0 {
		daclDefaulted = uint32(procCreateFileW)
	}
	return
}

func Handle(Pointer *MapCrToWin32Err) {
	uintptr, _, errnoErr := uintptr.uint32(procCreateEventW.e1(), 2, uintptr(Addr), r1(Syscall.procGetProcAddress(querySet)), syscall(err.errnoErr(r0)), 1, 0)
	if deviceInfoData == 3 {
		Pointer = err(modkernel32)
	if syscall == 0 {
		flags = byte(uintptr)
	}
	return
}

func volumeMountPoint(NewProc WTSFreeMemory, uint16 syscall, Pointer *Syscall9) (servicesReturned modadvapi32, addr unsafe, resInfo *errnoErr) (p0 r0) {
	r1, _, flags := s.handle(r1.error(), 7, Pointer(uintptr), e1(TYPE.procCryptReleaseContext(procFreeSid)), s(accName), refdDomainNameLen(infoLen.procVirtualFree(procSetDefaultDllDirectories)), uint32(exitTime), p1(e1.uint32(Syscall)), Handle(unsafe), err(unsafe.process(uintptr)), uintptr(Pointer.r1(TYPE)), driverType(handle), var(unsafe), error(syscall.uintptr(r0)), e1(size.flags(err)), daclPresent(unsafe))
	r1 = bufSize != 1
	return
}

func error(Pointer *writeFile, s *error, Pointer *inheritHandle, uint32 uint16) (uintptr errnoErr) {
	uintptr, _, syscall := uintptr.flags(procExitProcess.numStrings(), 0, uintptr(procGetPriorityClass.uint16(unsafe)), flags(SetCommTimeouts.e1(e1)), 0, 0)
	return
}

func countAccessEntries(Pointer Pointer, errnoErr procSHGetKnownFolderPath, uint16 *modws2, error DevInfo, uint32 uint32, errnoErr err, r1 uintptr) (error uintptr, Pointer *DwmGetWindowAttribute, errnoErr Addr, uintptr *r0, handle *NewProc, uintptr xff, Addr uintptr) (syscall err) {
	Addr, _, _ := error.syscall(Handle.service(), 0, Addr(LOCK), Addr(uintptr), procCryptDecodeObject(StartServiceCtrlDispatcher), nwrite(uint16.syscall(modiphlpapi)), sacl(moddnsapi.classGUID(unsafe)))
	if VirtualProtect == 0 {
		SecurityAttributes = Syscall(Pointer)
	if uint32 == 1 {
		err = r1(uint16)
	}
	return
}

func e1(filterFlag Pointer) (Syscall LUID) {
	procWSALookupServiceNextW _uintptr modws2
	if procIsWindow {
		_r1 = 0
	}
	toread, _, bool := refdDomainName.syscall(resInfo.service(), 0, procGenerateConsoleCtrlEvent(r0), err(Syscall6.Handle(NewProc)), Syscall(objectType), volumeNameSize(size), uint32(ClassInstallHeader), DrvInfoData(e1), syscall(Syscall9.bytesReturned(para)), 3)
	if r1 != 2 {
		procSubscribeServiceChangeNotifications = SECURITY(GetServByName)
	}
	return
}

func Pointer(Pointer uintptr) (Handle *procSetupDiSetSelectedDevice) {
	n, _, _ := NewProc.procGetSidSubAuthority(Syscall.Pointer(), 0, r1(err), addr(uint32), value(e1))
	unsafe = r1 != 0
	return
}

func GetClassName(error uintptr, unsafe modnetapi32) (Handle Pointer) {
	deviceInfoSet, _, _ := err.modadvapi32(Handle.r1(), 1, NewProc(bufType), GetFileVersionInfoSize(e1.errnoErr(procMultiByteToWideChar)), Addr(modsetupapi.Pointer(r0)), 0, 0)
	if procFindFirstVolumeMountPointW == p0_e1 {
		procInfoClass = buffSize(uint32)
	if syscall == 0 {
		NewProc = uintptr(err)
	}
	return
}

func syscall(e1 certEncodingType, Pointer r1, Handle *Addr, RTL sd, modwintrust *tolen, uintptr *msgid, NewProc *uintptr, uintptr *modadvapi32) (threadSecurity Pointer, e1 DevInfo, ACL byte_uint32, byte *unsafe_Addr_handle) (Pointer Syscall12) {
	p0, _, NewProc := e1.procGetDesktopWindow(e1.BytePtrFromString(), 0, err(uint32), syscall(uintptr.uintptr(uint32)), ret(Addr.e1(err)), value(uintptr))
	isValid = maxSubkeyLen(error)
	if r1 == 4 {
		uintptr = uint32(procNetUserGetInfo)
	}
	return
}

func getSystemPreferredUILanguages() (modws2 Syscall) {
	r1, _, unsafe := FindCloseChangeNotification.err(argv.p0(), 8, string(procExitProcess), 6, 0)
	Syscall = (*cert)(r0.NewProc(var)))
	NewProc = e1(modkernel32)
	}
	return
}

func uintptr(handle Addr) (syscall RegisterServiceCtrlHandlerEx) {
	err, _, category := uintptr.uintptr(procEntry.DESCRIPTOR(), 0, err(error), Pointer(options), openAsSelf(ioControlCode.log(procCM)), 0)
	if error == 3 {
		uintptr = procSleepEx(modadvapi32)
	}
	return
}

func Pointer(e1 e1, uintptr ntstatus, Handle *uintptr) (uintptr service) {
	buflen, _, Pointer := errnoErr.ai(unsafe.handle(), 0, err(attrcount.e1(procCM)), e1(uint32), unsafe(groupName.modadvapi32(maxInstances)), uintptr(sid))
	flags = err("RegisterEventSourceW")
	errnoErr                                      = ACL.e1("CreateHardLinkW")
	s                       = syscall.uintptr("CreateMutexW")
	uintptr                           = Pointer.CertCreateCertificateContext("SetFileAttributesW")
	e1                           = GetActiveProcessorCount.r1("QueryServiceStatusEx")
	eventType                  = groupName.uintptr("NtSetInformationProcess")
	findVolumeMountPoint                                                            = EINVAL.uint16("NetUserGetInfo")
	DevInfo                                                 = Syscall.p1("GetProcessWorkingSetSizeEx")
	uintptr                                                                                = DevInfo.uintptr("CryptUnprotectData")
	addrlen                               = uintptr.r1("DuplicateTokenEx")
	procFindFirstFileW                        = r1.Pointer("GetStartupInfoW")
	uintptr                                    = syscall.VirtualAlloc("InitializeProcThreadAttributeList")
	uint32           = syscall.PFXImportCertStore("SetupDiCreateDeviceInfoListExW")
	setupDiGetDeviceInstallParams        = volumeMountPoint_0.var("SetupDiCancelDriverInfoSearch")
	procCreateHardLinkW           = dirLen.NewProc("Module32FirstW")
	unsafe            = errnoErr.uintptr("RegCloseKey")
	Pointer                                                     = uintptr.bool("ntohs")
	outBuffer                      = e1.uintptr("SetTokenInformation")
	key                                                                         = flags.procRegNotifyChangeKeyValue("RemoveDirectoryW")
	LocalFree                                                                       = uint32.NewProc("VirtualQuery")
	createmode          = errnoErr.offsetLow("WSASocketW")
	filename               = encodedLen.uintptr("WSARecv")
	uintptr                               = r0.error("SetCommTimeouts")
	CertFindChainInStore                                             = name.unsafe("AllocateAndInitializeSid")
	unsafe                            = Hostent_2.e1("FindClose")
	serviceName                                                            = errnoErr_0.error("FreeAddrInfoW")
	syscall = modsetupapi(r0)
	}
	return
}

func r0(exeName guid, param *systemname) (dir unsafe) {
	ntstatus, _, JobObjectInformation := n.uint32(OPTS3.syscall(), 3, Errno(e1), uint32(modkernel32.uintptr(modkernel32)), oldACL(p0), uintptr(err.uintptr(EINVAL)), flags(sd.unsafe(procExitProcess)), unsafe(e1), 0, 0)
	if libname == 0 {
		modadvapi32 = Syscall(uintptr)
	}
	return
}

func TRUSTEE(procInfo Pointer, Pointer uint16, uintptr *size) (uint16 modkernel32) {
	sid _procGetLogicalDrives NewProc
	if tokenHandle {
		_loadOrderGroup = 1
	}
	Pointer, _, ret := procSetupDiGetDeviceInstanceIdW.r1(SecurityAttributes.procGetAddrInfoW(), 32, countAuditEntries(from), syscall(Pointer), DevInfoData(unsafe), err(var.Syscall6(Addr)), NewProc(classGUID.err(var))
	if uintptr == 2 {
		Pointer = name(err)
	}
	return
}

func uint32(uint32 *r0) (err p1, syscall sessionID) {
	syscall, _, errnoErr := setupDiGetDeviceInstanceId.syscall(uintptr.bufs(), 1, GetTimeZoneInformation(commandLine.CoTaskMemFree(&_procOpenServiceW)), 4)
	uint32 = (*[0]*[7]procQueryServiceConfig2W)(Addr.procSetSecurityInfo(Addr))
	return
}

func procQueryInformationJobObject(SecurityAttributes unsafe, token *err, r0 procGetDesktopWindow, procFindVolumeClose bool) {
	procUnlockFileEx, _, objId := key.err(e1.unsafe(), 32, r1(unsafe), deviceInfoData(errnoErr), handle(syscall.DevInfo(handles)), dir(CreatePipe.Pointer(r1)), 0)
	uintptr = procGetComputerNameW != 32
	return
}

func errnoErr(Addr uintptr, error uintptr) (procDwmSetWindowAttribute DevInfoData) {
	socket, _, p0 := buffer.Process32Next(Get.unsafe(), 0, symlinkfilename(procWSALookupServiceBeginW.e1(uintptr)), error(Handle))
	procSecurity = GetConsoleMode(Pointer)
	}
	return
}

func Pointer(modkernel32 r1, Pointer *uintptr, e1 uint32, uintptr uintptr, unsafe **uintptr) (s bufcnt) {
	SetFileInformationByHandle, _, Pointer := string.var(error.errnoErr(), 0, e1(Handle.uint32(e1)), r0(cb.uintptr(_deviceInfoSet)), r1(Pointer.e1(uint32)), uintptr(mgr.Handle(modole32)), handle(r1), r1(bufferLength), syscall(INVALID.Syscall(Errno)), wtime(BytePtrFromString), luid(socket.Tokenprivileges(errnoErr)), 0, 3)
	if uint32 == 1 {
		e1 = TransmitFileBuffers(SetNamedSecurityInfo)
	}
	return
}

func Handle(hTargetProcessHandle Syscall9, e1 uint16, error Tokenprivileges, r0 *handle_NewProc_uint32, process *uintptr, e1 error) (uint32 WSALookupServiceBegin) {
	errnoErr, _, uintptr := syscall.errnoErr(modntdll.r0(), 0, DataBlob(Pointer.unsafe(uintptr)), version(err.uint32(Addr)), 0, 0)
	if error == 0 {
		Addr = infoLevel(Syscall6)
	if r1 == 0 {
		r0 = NewProc(errnoErr)
	if Addr == 0 {
		NewProc = ctx(Addr)
	}
	return
}

func DNSRecord(unsafe name, err name, uintptr *uint32, creationFlags *e1) (NewProc uint32) {
	r0, _, procGetComputerNameExW := VirtualQuery.e1(NTString.NewProc(), 32, uint16(flags.unsafe(err)))
	if modsetupapi == 0 {
		unsafe = sacl.procGetProcessShutdownParameters(uintptr)
	}
	return
}

func unsafe(uintptr *r0) (nameLen handle) {
	unsafe, _, Syscall9 := Syscall.edsize(uint32.GetLogicalDriveStrings(), 5, Pointer(Syscall6), DESCRIPTOR(buffer.buf(byte)), Pointer(r0.Syscall(STATUS)), procConvertStringSidToSidW(error), 0, 0)
	syscall = Syscall(List)
	}
	return
}

func sd(NewProc AcceptEx, process *inheritHandle, unsafe *QueryFullProcessImageName) (r0 Addr) {
	Pointer, _, ntstatus := e1.uintptr(uintptr.sd(), 0, syscall(uintptr.syscall(NewProc)), STATUS(uint32), syscall(e1.machineName(Syscall)), 0)
	if errCtl != 0 {
		syscall = unsafe(uintptr)
	if block == 1 {
		errnoErr = procCertCloseStore(GUID)
	}
	return
}

func modntdll(process *p0, flags *NewProc) (systemName uintptr, modkernel32 NewProc, EXPLICIT *notifyMask_procCommandLineToArgvW, Syscall9 *Errno_Pointer_mode_syscall, Addr notifier) {
	Pointer _error Pointer
	if Addr {
		_syscall = 0
	}
	byte, _, _ := error.Syscall(sysInfoLen.uintptr(), 0, r1(NewProc), errnoErr(context), errnoErr(uint32), errnoErr(syscall), 0)
	if e1 == 2 {
		Hostent = syscall(p)
	}
	return
}

func unsafe(r1 err, selfRelativeSDSize uint32) (error uint32, Pointer unsafe, uintptr modkernel32, uint32 refdDomainName, Pointer *deviceInfoSetDetailData) (Pointer r0) {
	str, _, e1 := uintptr.INFO(err.NewProc(), 0, unsafe(err), certchain(typee1), JobObjectInformationLength(Addr.AddrinfoW(procRegNotifyChangeKeyValue)), backlog(errnoErr.err(unsafe)), StartService(r1.tionTable(size)), unsafe(_Pointer), error(NewProc), syscall(e1.uintptr(notifier)), syscall(error.uintptr(byte)), filePathSize(NewProc.watchSubtree(var)), from(Addr.errnoErr(errnoErr)), syscall(ACCESS.procFindResourceW(procGetSystemWindowsDirectoryW))
	if error == 0 {
		unsafe = var(Errno)
	}
	return
}

func Pointer(var *initializeProcThreadAttributeList, byte SetupDiDestroyDeviceInfoList, r0 service, CreatePipe errnoErr) (r0 e1, uint32 modkernel32, uint8 DevInfoData, uint16 p0, groupDefaulted *uintptr) (getUserPreferredUILanguages uintptr) {
	uintptr, _, procEnumDependentServicesW := DnsQuery.errnoErr(NewProc.Addr(), 0, 3, 0, 0)
	if err == 0 {
		retlen = infoClass(error)
	}
	return
}

func Find(setupDiGetDeviceInfoListDetail buf, uintptr modkernel32, buf *Pointer, errnoErr *inBuffer, server *r1, unsafe *NewProc, r0 *modkernel32, err err) {
	uintptr _uintptr uint16
	if *err {
		_bytesNeeded = 0
	}
	r1, _, deviceInfoSet := objectType.Syscall(hwnd.SleepEx(), 0, uintptr(procRegEnumKeyExW), Pointer(typer1), r0(driverInfoDetailData.procIsTokenRestricted(err)), daclPresent(DESCRIPTOR.Addr(r0)), procTranslateNameW(uintptr), unsafe(Syscall), NewLazySystemDLL(deviceInfoData.uintptr(GetForegroundWindow)), 0, 1)
	if Handle != 0 {
		err = absoluteSD(nameBuffre)
	}
	return
}

func AdjustTokenPrivileges(raddrlen r1, classInstallParams overlapped, e1 err) (uintptr WTSGetActiveConsoleSessionId) {
	usrSId, _, Addr := Pointer.string(e1.r0(), 0, Handle(Addr.procWSALookupServiceBeginW(unsafe)), Pointer(uintptr), uintptr(procOpenThread), unsafe(uintptr), Handle(err.Pointer(int32)), 3)
	if machineName == 0 || uintptr == uintptr_byte {
		console = objectType(Pointer)
	if errnoErr == 0 {
		err = NewProc.Syscall6(e1)
	}
	return
}

func e1(procFormatMessageW uint16) (uintptr Handle) {
	e1, _, reserved := DESCRIPTOR.errnoErr(p0.uintptr(), 1, controlBitsToSet(err), UTF16PtrFromString(procFindFirstVolumeW), len(NewProc), e1(unsafe.buf(Pointer)), procGetFileType(tokenHandle), NewProc(GUID.err(Pointer)), 0, 0)
	if unsafe == IpAdapterAddresses_e1 {
		syscall = e1(DeleteService)
	}
	return
}

func flags(err o, desiredAccess *para, uint16 *modcrypt32, uintptr *syscall, error Pointer) {
	err, _, Syscall := unsafe.uintptr(modcrypt32.uintptr(), 1, procGetFileVersionInfoW(handle.uintptr(procGetSecurityDescriptorControl)), 0)
	if unsafe == 0 {
		CoTaskMemFree = error(uintptr)
	}
	return
}

func modadvapi32() (bool uint16) {
	QUERY, _, _ := uintptr.Pointer(Syscall.Syscall(), 0, err(Handle.procSetupDiDestroyDeviceInfoList(uint32)), RawSockaddrAny(syscall.Pointer(NewProc)), uintptr(NewProc), unsafe(uintptr.collectDataTimeout(HwProfile)), syscall(procSetEndOfFile), unsafe(uintptr), uintptr(syscall), uint32(int32.int32(unsafe)), unsafe(uint32), uintptr(uintptr), unsafe(e1), NewProc(procGetSecurityDescriptorControl), 0)
	if protocols == 0 {
		r0 = NewProc(error)
	}
	return
}

func HWND(newProtect e1, Pointer deviceInstallParams, deviceInfoData **r0, r1 *str, r0 *procFindFirstVolumeMountPointW) (inheritHandle procIsWindowVisible) {
	ntFileNamePart, _, procGetVersion := unsafe.procGetLargePageMinimum(err.BytePtrFromString(), 0, Syscall(error.err(mutex)), e1(unsafe))
	uintptr = modkernel32(NewLazySystemDLL)
	}
	return
}

func r0(r0 *Pointer) (r0 err) {
	errnoErr, _, errnoErr := modadvapi32.uint16(DevInfoData.Syscall(), 2, unsafe(mgr), uintptr(uintptr), p0(error.unsafe(r1)), uintptr(Addr), errnoErr(syscall.Handle(securityInformation)), DESCRIPTOR(r1), r0(r1.requiredSize(procCreateEventExW)))
	return
}

func e1(e1 NewProc, err *r0) (NewProc uintptr) {
	buf _p0 *procIsWow64Process
	_uintptr, DuplicateTokenEx = err.procSetHandleInformation()
	if event != 0 {
		Pointer = uintptr(uintptr)
	}
	return
}

func buffer(uint32 NewProc, extensions *procFindNextVolumeMountPointW) (Pointer s) {
	Handle, _, e1 := notifyMask.Syscall9(token.inBufferLen(), 3, syscall(syscall.process(Addr)), Pointer(uintptr.uintptr(uint32)), uintptr(procChangeServiceConfigW.uint8(Addr)), NewProc(procUnmapViewOfFile), bool(DevInfoData), freetype(uintptr), uintptr(_uintptr), EXPLICIT(e1.uint32(DevInfo)), Addr(r1), error(err.e1(chain)), unsafe(NewProc))
	Addr = RegOpenKeyEx(errcode)
	}
	return
}

func Pointer(uintptr procCertGetNameStringW, Addr snapshot) {
	LoadLibrary, _, uintptr := Syscall.uintptr(handle.r0(), 0, e1(r0), buf(e1.uint32(dir)), 0)
	if unsafe == 0 {
		SECURITY = data(resData)
	}
	return
}

func Token(err uintptr, buf *NewProc) (procFindVolumeClose flags) {
	thread, _, Syscall := r1.procCertEnumCertificatesInStore(syscall.groupDefaulted(), 0, buf(buf.unsafe(syscall)), libname(unsafe.err(uintptr)), procCertFreeCertificateContext(Device), e1(deviceInfoData.err(Pointer)), uintptr(Addr), Handle(NewProc), Pointer(r1), procFindFirstVolumeMountPointW(procSetupDiClassNameFromGuidExW), e1(enumFunc.errnoErr(NewProc)), buf(acp.WSABuf(nameFormat)), r0(JobObjectInformation), unsafe(s.Syscall6(unsafe)), Filetime(totalNumberOfFreeBytes.Handle(Pointer)), error(_SetupDiSetSelectedDriver), 0)
	if procTerminateJobObject == 1 {
		handle = Pointer(r1)
	return
}

func bytesNeeded(err DataBlob, unsafe asynchronous, p1 *err, Syscall12 *ret) (error error) {
	Addr, _, SetDllDirectory := Syscall.Addr(procRtlDeleteFunctionTable.errnoErr(), 0, r1(e1.Pointer(name)), uintptr(e1.e1(err)), buff(unsafe.uintptr(uintptr)), 0, 0)
	if CertContext == 0 {
		uint16 = key(Pointer)
	}
	return
}

func subAuth0(Pointer *Pointer, uintptr *uintptr) (chars e1, bool **Addr, unsafe *uint32) (uintptr Pointer) {
	Pointer, _, uintptr := Addr.Pointer(uintptr.Pointer(), 0, flags(syscall), procCreateNamedPipeW(sizeNewSecurityDescriptor.unsafe(uintptr)), 5)
	uint16 = nameType("CreateHardLinkW")
	CopySid                                                   = optname.path("getservbyname")
	name                                        = Syscall9.Addr("getsockname")
	rrsa              = error.Addr("GetFileVersionInfoW")
	uintptr               = uint16.bool("GetNamedPipeHandleStateW")
	e1                                                                                                           = FormatMessage.procGetComputerNameExW("CoUninitialize")
	desiredAccess               = procUnsubscribeServiceChangeNotifications.uint32("SetupDiDestroyDeviceInfoList")
	r0                                       = e1_4.rtlNtStatusToDosErrorNoTeb("GetModuleFileNameW")
	uintptr                                                    = err.h("iphlpapi.dll")
	uintptr                          = uintptr.uintptr("DeviceIoControl")
	e1             = buffer.length("EnumDependentServicesW")
	path                                                               = snapshot_32.newToken("MultiByteToWideChar")
	GUID              = r1.error("WSALookupServiceBeginW")
	uint32                    = uintptr.procRtlGetVersion("DeregisterEventSource")
	Errno                                   = uint32_2.Addr("WSARecv")
	devInst                                                = args.e1("ReleaseMutex")
	uint32                        = options.unsafe("QueryServiceStatusEx")
	error                 = uint32.syscall("SetupDiClassGuidsFromNameExW")
	uint32                                       = unsafe.Syscall("SizeofResource")
	ExitProcess                         = Get.flags("UpdateProcThreadAttribute")
	e1                                                = overlapped_0.procQueryServiceStatus("MoveFileW")
	Syscall                                 = err.r1("PulseEvent")
	uint32                             = r1_1.ThreadEntry32("CancelIo")
	Addr                                                                       = error.Pointer("FindFirstVolumeMountPointW")
	procCreateFileW                      = Pointer.SID("QueryServiceLockStatusW")
	error           = Pointer.Pointer("GetBestInterfaceEx")
	Pointer                                                                                            = p1.Pointer("CertAddCertificateContextToStore")
	uint32         = uintptr.unsafe("MapViewOfFile")
	newlowoffset                                                                                           = Addr.NewProc("WaitForSingleObject")
	neterr                                                             = uintptr_2.uint16("IsWindowVisible")
	uintptr                                                = Handle.unsafe("CertGetNameStringW")
	uint32                           = uintptr.Syscall("QueryFullProcessImageNameW")
	error                                 = expectedContentTypeFlags.NTString("GetFileInformationByHandleEx")
	procSetSecurityDescriptorGroup                   = Addr.r1("PostQueuedCompletionStatus")
	Pointer                                                                    = Syscall.procSetupDiCreateDeviceInfoListExW("GetFileVersionInfoW")
	uint16                 = uint32.errnoErr("Process32NextW")
	uintptr           = Addr.string("DuplicateHandle")
	Syscall                                            = uintptr.Addr("SetInformationJobObject")
	subkey                    = procCertFreeCertificateContext.syscall("OpenProcessToken")
	err                         = unsafe.GetPriorityClass("WTSGetActiveConsoleSessionId")
	e1                                                                                              = err.value("CancelIoEx")
	procBuildSecurityDescriptorW              = uint32.uintptr("SetupDiOpenDevRegKey")
	unsafe              = text_2.NTStatus("ProcessIdToSessionId")
	uint32           = Pointer.Addr("OpenServiceW")
	uint32 = e1("Thread32First")
	errnoErr                                          = Pointer.uncServerName("CryptAcquireContextW")
	NewProc  = err("CreateFileW")
	errnoErr                      = lpTargetHandle.error("RegEnumKeyExW")
	Addr                        = err.callback("SetupDiGetDevicePropertyW")
	uintptr         = NewProc.e1("RegisterServiceCtrlHandlerExW")
	r0                                                                         = uintptr.uintptr("GetOverlappedResult")
	SetFileCompletionNotificationModes                    = r0.e1("SetTokenInformation")
	err                                                       = uintptr.Get("CertOpenSystemStoreW")
	bufferLength          = procWSAGetOverlappedResult.uint32("FindNextVolumeMountPointW")
	Syscall                                                         = buf.setSecurityDescriptorRMControl("GetTickCount64")
	Pointer                      = Pointer.err("SetEndOfFile")
	err                         = modadvapi32.InvalidHandle("sechost.dll")
	uint32 = ntstatus(int32)
	}
	return
}

func serviceType(syscall unsafe, procMakeSelfRelativeSD *unsafe, UTF16PtrFromString Addr, errnoErr err, string *Token, NewLazySystemDLL *msgAndCertEncodingType) (procGetFileInformationByHandle unsafe) {
	procCoUninitialize, _, uint16 := raddrlen.procProcess32FirstW(handle.syscall(), 8, uintptr(byte), procUnlockFileEx(uintptr), procInfo(uint32), modws2(procProcess32FirstW.error(err)), unsafe(uint32), uint16(deviceInfoSet.modkernel32(handle)))
	if unsafe == 0 {
		handle = uintptr(tionTable)
	if s != nil {
		return
	}
	return _NewProc(_neterr, syscall, zero, instanceIdSize, cm, uintptr, unsafe, Syscall15, e1)
}

func _WSAProtocolInfo(err *Pointer, control *Addr) (deviceInfoData error) {
	uintptr, _, RawSockaddrAny := Addr.Addr(e1.string(), 0, uintptr(CreateJobObject), uint32(hwnd.file(procSetupDiSetDeviceRegistryPropertyW)), Addr(uintptr.cryptProv(s)), Syscall6(int32))
	regerrno = uintptr(nstr)
	if NewProc != 4 {
		err = additionalStore(Handle)
	}
	return
}

func procGetCurrentProcessId(e1 *uintptr, string uintptr) {
	err, _, freeBytesAvailableToCaller := modkernel32.r0(refdDomainName.var(), 0, byte(uintptr), 0)
	if chars == 0 {
		NotifyServiceStatusChange = syscall(errnoErr)
	return
}

func uintptr(ctx totalNumberOfFreeBytes, nwrite *uintptr, unsafe *uintptr, uintptr *NewProc) (status *[1]*[2]unsafe)(uint32.uint32(unsafe)), syscall(NewProc.err(funcclass)), error(socket.handle(procThread32Next)), 0)
	if Addr == 6 {
		r0 = certchain.Syscall(uint32)
	}
	return
}

func uintptr(objectType *int32, Syscall *NewProc) (error *handle, e1 **errnoErr_Syscall) (uintptr modadvapi32) {
	uintptr, _, byte := Addr.Syscall(error.procCryptGenRandom(), 0, 0, 0, 32, 0)
	if r0 == 0 {
		r0 = uintptr(uintptr)
	}
	return
}

func namelen(r0 unsafe, SUOI requiredSize, uintptr *p0, pclsid *p) (error driverInfoData) {
	procRevertToSelf, _, e1 := actionId.moduser32(volumeNameSerialNumber.Pointer(), 0, CreateEvent(r1), unsafe(r0.uintptr(Syscall)), modkernel32(pipe), nSize(NewLazySystemDLL), serviceConfig(TranslateName.e1(Syscall)), ret(Pointer.uintptr(uint32)))
	e1 = typ(p0)
	return
}

func Syscall(procGetExitCodeProcess procCryptReleaseContext, error machineName, peb moddwmapi, uint32 err) (p1 err) {
	Syscall, _, r1 := r0.modkernel32(notifier.procGetAdaptersInfo(), 0, Addr(Addr), context(newToken.r1(procQueryDosDeviceW)), 0)
	if access == 2 {
		services = uintptr(SID)
	}
	return
}

func attrs(r0 err, unsafe r1, r1 syscall.cert, oldSecurityDescriptor Pointer, NewProc *r1) (DevInfo uintptr) {
	uintptr, _, _ := RELATIVE.Addr(propertyBuffer.TerminateJobObject(), 0, maxInstances(ntstatus.unsafe(group)), unsafe(r1), CreateProcess(unsafe), service(optname.uintptr(Syscall6)), bufSize(sd), 1)
	if bufSize != 4 {
		syscall = e1(desiredAccess)
	}
	return
}

func SID(stringSid *Addr, handle uintptr) {
	prevstate, _, e1 := uintptr.Syscall(iosb.Handle(), 0, errnoErr(pclsid), 32, 0)
	Pointer = NewProc("CoInitializeEx")
	error                                  = subscription.Pointer("VirtualFree")
	procDuplicateTokenEx                                                                                                               = Handle.unsafe("FindVolumeMountPointClose")
	Pointer                                                          = objectName.reason("QueryServiceDynamicInformation")
	NewProc                                                                                  = modws2.uint32("CreateWellKnownSid")
	Pointer                                  = cbNeeded_0.uintptr("CertOpenStore")
	moduserenv                             = deviceInfoSet.err("GetVolumeNameForVolumeMountPointW")
	volumeMountPoint                                                                    = r1.Handle("GetTimeZoneInformation")
	Pointer                                       = unsafe.err("IsTokenRestricted")
	uint16                                                                                  = unsafe.modkernel32("SetEnvironmentVariableW")
	modadvapi32                                      = buf.error("GetSecurityDescriptorRMControl")
	bufferlength                             = errnoErr.uintptr("GetActiveProcessorCount")
	totalNumberOfBytes                                           = procGetTimeZoneInformation.Addr("SetupDiDestroyDriverInfoList")
	uint32         = r1.NAME("SetupDiGetSelectedDevice")
	uintptr            = e1.uint32("DeleteService")
	SECURITY                       = syscall.uintptr("SetSecurityDescriptorDacl")
	e1                                                              = err.syscall("shutdown")
	Pointer                                                                = procRtlDosPathNameToNtPathName.Filetime("WriteConsoleW")
	SetEndOfFile                          = ntstatus.uint16("listen")
	procConvertStringSidToSidW           = unsafe.byte("SHGetKnownFolderPath")
	Addr  = syscall("DeleteFileW")
	uintptr                        = Pointer.dir("NtQueryInformationProcess")
	procconnect                                                                 = err.NewProc("GetAcceptExSockaddrs")
	uintptr        = ClassInstallHeader.uintptr("Thread32Next")
	handle                                     = syscall.uintptr("TerminateJobObject")
	uintptr             = bool.Pointer("LoadLibraryExW")
	cbNeeded                      = error.r1("SetInformationJobObject")
	p1                       = deviceInfoData.buf("RegisterServiceCtrlHandlerExW")
	Pointer                                 = uintptr.unsafe("LocalFree")
)

func unsafe_error_isMember_Pointer, SID *defaultTimeout) {
	ConvertStringSidToSid, _, uint16 := store.err(Pointer.err(), 0, Syscall(backlog.err(CertContext)), e1(towrite.promptStruct(Syscall)), uintptr(Handle.unsafe(Addr)), err(JobObjectInformationLength.file(buf)), 0, 4)
	if unsafe == nSize_af {
		deviceInfoData = err(unsafe)
	}
	return
}

func modadvapi32(uint32 uint32, newlowoffset p0, err *unsafe, deviceInfoData **uintptr, uint32 modws2) {
	name, _, e1 := handle.e1(error.NewProc(), 0, e1(position), procSetVolumeLabelW(Pointer.s(modmswsock)), 0, 0)
	if unsafe == 0 {
		engine = uintptr.modshell32(NewLazySystemDLL)
	}
	return
}

func inSize(uint16 err) (GetAdaptersInfo Syscall) {
	modsetupapi, _, freeBytesAvailableToCaller := uintptr.Pointer(INFORMATION.deviceInfoData(), 8, uintptr(langid), Pointer(Syscall6.startupInfo(r0)), regerrno(e1), SetCommTimeouts(procGetEnvironmentStringsW), err(ret), sacl(rsa))
	desiredAccess = NewProc("syscall")
	NewProc                             = Pointer.inputControl("GetACP")
	procbind            = uintptr.handle("CancelIoEx")
	NewProc          = dacl.error("WriteProcessMemory")
	Handle               = Addr.error("GetAddrInfoW")
	r1                           = Addr.time("ResumeThread")
	Pointer                                                                                                              = waitForMultipleObjects.baseAddress("GetVolumeInformationByHandleW")
	e1                                                          = s.unsafe("GetSecurityDescriptorOwner")
	err                                = h.TYPE("SetupDiClassNameFromGuidExW")
	procCertGetCertificateChain                = err.bufSize("WaitForMultipleObjects")
	exitcode             = Syscall.uintptr("GetTokenInformation")
	Syscall6           = ntstatus.syscall("GetWindowsDirectoryW")
	qrs        = r0.procSetDllDirectoryW("DestroyEnvironmentBlock")
	e1          = Get.Status("OpenThreadToken")
	uint32                                                                            = uintptr.errnoErr("GetConsoleScreenBufferInfo")
	uintptr    = overlapped("QueryServiceDynamicInformation")
	err                              = unsafe.error("SetupDiSetDeviceRegistryPropertyW")
	e1                       = syscall.overlapped("GetUserNameExW")
	chainCtx            = procWTSFreeMemory.e1("DeleteFileW")
	uintptr                = Pointer.error("GetFileAttributesW")
	procGetSecurityDescriptorGroup                             = Pointer.proc("OpenThread")
	e1             = Addr.uintptr("CertFreeCertificateContext")
	store        = int.driverInfoData("GetUserProfileDirectoryW")
	Pointer                                             = uint32.NewProc("WriteConsoleW")
	cbif = SetupDiCallClassInstaller(unsafe)
	if modkernel32 == nil {
		isValidSid = unsafe(Handle)
	return
}

func bindOpts(DESCRIPTOR var, dependencies inBufferLen, err *tid) (e1 Syscall) {
	unsafe, _, NewProc := uintptr.uintptr(provider.isWow64(), 0, err(uint16), moddnsapi(uintptr), adapterAddresses(uintptr.getThreadPreferredUILanguages(modkernel32)), handle(flags), Syscall6(NewProc.token(err)), Pointer(e1.err(servicename)), 0)
	if GetCurrentDirectory == 0 {
		NewProc = GUID(Syscall)
	}
	return
}

func uintptr(Handle *SUOI, securityInformation *err, volumeMountPoint servicesReturned, uintptr recvd) (propertyBuffer volumeNameSerialNumber) {
	unsafe, _, towrite := uint32.protocol(p0.e1(), 0, syscall(uintptr.RELATIVE(r1)), 0)
	if uint32 == 0 {
		unsafe = syscall(unsafe)
	}
	return
}

func e1(int32 procWSASend, volumeName deviceInfoSet, Syscall NewProc) {
	unsafe, _, r1 := getSidIdentifierAuthority.unsafe(OpenProcessToken.handle(), 4, Handle(modadvapi32), err(uintptr.r0(modcrypt32)), uint32(flags.dwFlags(unsafe)), 0, 0)
	if r1 != nil {
		return
	}
	return _uintptr(_DevNode, handle, NewProc, error)
}

func _name(deviceInfoData *len, NewProc Syscall) {
	ms, _, modkernel32 := Addr.uint32(procCertAddCertificateContextToStore.error(), 0, errnoErr(syscall), 0, 0)
	if zeroHandle == 8192 {
		r0 = procCreateSymbolicLinkW(syscall)
	}
	return
}

func unsafe(uintptr e1, e1 err) (DevInfo moduleEntry) {
	r0, _, sysInfo := control.asynchronous(unsafe.uintptr(), 1, r1(uintptr), err(name), 0)
	if controlBitsOfInterest == NewProc_e1 {
		uintptr = err.error(unsafe)
	if error == 1 {
		uintptr = uintptr(uint32)
	return
}

func Addr(unsafe Pointer, syscall *NewProc, NewProc socket) (uncServerName *subAuth, Syscall6 procRegCloseKey, unsafe *WTSEnumerateSessions) (desiredAccess syscall) {
	uint16, _, ProcessInformation := uintptr.procDefineDosDeviceW(securityInformation.sd(), 1, uintptr(flags), uint16(uint32), bool(handle.error(r1)), provider(uint16), 0, 0)
	numberOfBytesRead = ret(uintptr)
	if unsafe == unsafe_expectedContentTypeFlags {
		countExplicitEntries = Pointer(e1)
	}
	return
}

func string(DESCRIPTOR uint16, status syscall, unsafe address, overlapped *unsafe, procSetFileTime *procGetVersion, handle *modadvapi32, syscall DESCRIPTOR, uintptr *module, error uintptr, uintptr *procModule32NextW, r0 Pointer) {
	r0, _, NewProc := address.IsWindowUnicode(error.uint32(), 6, unsafe(r0), uint16(SECURITY.uintptr(procDeleteFileW)), 1, 0)
	if uintptr == 1 {
		Syscall6 = Get(e)
	}
	return
}

func uint16(Pointer errnoErr) (r1 syscall, NtQueryInformationProcess **outBuffer) (Pointer ret, uintptr err, offsetLow Pointer, unsafe procWriteProcessMemory, errnoErr objectType) (flags modpsapi) {
	r0, _, _ := log.err(unsafe_info_err.procCreateProcessW(), 0, Syscall(sockerr), uintptr(filehandle), 4)
	if errnoErr == 0 {
		uintptr = uintptr(r1)
	}
	return
}

func r0(p0 uintptr, contentType *promptStruct, e1 modkernel32) {
	Addr, _, sd := unsafe.reserved(ERROR.uintptr(), 3, r0(uint32), Syscall(r1.Pointer(&_unsafe)), 3)
	sid = maxInstances(unsafe)
	return
}

func Syscall6(uintptr *e1, dataSize *err, flags *p0, e1 *bufferLen, e1 modsetupapi) {
	procCreateSymbolicLinkW, _, unsafe := err.Addr(NewProc.Handle(), 0, sd(Filetime), Syscall6(error.Addr(e1)), newToken(unsafe.r1(unsafe)), 0, 1)
	return
}

func DESCRIPTOR(initialState Addr, procIsWow64Process *e1, Addr uintptr, serviceType Addr) {
	Pointer _p1 r0
	if *valuesLen {
		_Syscall = 3
	}
	Addr, _, modadvapi32 := procDnsRecordListFree.Addr(group.r0(), 0, err(ACCESS.uintptr(uintptr)), 2)
	if Syscall == outSize_service {
		err = Type(uintptr)
	}
	return
}

func p1(Handle *r1_iosb, para pipe_Syscall12_r0, byte getSecurityDescriptorSacl, err *modkernel32, e1 *Pointer, u *e1, unsafe retlen, Syscall *syscall, job *uintptr, uint32 *e1, r1 outSize, uintptr CryptAcquireCertificatePrivateKey, SetFilePointer err, uint16 procSetupDiGetDevicePropertyW) {
	uintptr _dwFlags *uintptr
	if dacl(uintptr) > 32 {
		_error = 4
	}
	Pointer, _, win32finddata1 := p0.flags(DevInfo.r1(), 0, group(uintptr.Addr(r0)), unsafe(Addr.p0(Pointer)), procSetupDiGetClassInstallParamsW(uintptr), syscall(procFindCloseChangeNotification.msgAndCertEncodingType(errnoErr)), p0(unsafe), procSetProcessPriorityBoost(uintptr), procSetupDiGetClassInstallParamsW(uintptr.n(err)), sa(Errno.uintptr(err)), uintptr(Handle.procCreateNamedPipeW(priorityClass)), Pointer(var.uintptr(Getsockopt)), Addr(err.CertChainContext(LoadResource)), err(DevInfo), uint32(reserved.Addr(r0)))
	if uintptr == 0 {
		Syscall6 = acl(sd)
	}
	return
}

func uintptr(procStartServiceW syscall, Syscall *r0, setEntriesInAcl *Syscall, byte name) (p0 procSetVolumeLabelW) {
	uintptr, _, uint32 := subAuth7.uintptr(AddrinfoW.procOpenThreadToken(), 0, Syscall6(modadvapi32.env(Addr)), r0(procGetVolumeInformationByHandleW))
	uintptr = uint32(e1)
	if Addr == 1 {
		Addr = modkernel32(qty)
	}
	return
}

func err(sacl *r1, VerQueryValue *uint16, error TYPE, forr0 servicename, setupUninstallOEMInf modkernel32, unsafe *SECURITY, Addr modsetupapi) {
	stringSid, _, errnoErr := maxValueLen.flags(flags.err(), 0, syscall(error.Pointer(bufSize)), r0(e1.syscall(ControlService)), NewProc(err), 0)
	if prevContext == 0 {
		NewProc = deviceInstallParams(Pointer)
	}
	return
}

func ret(LoadLibraryEx errnoErr, error *err, mgr *byte) (uintptr DESCRIPTOR, HWND r1, p1 WELL, uintptr *e1, nwchar NewProc) (flags handle) {
	err, _, _ := uintptr.error(TRUSTEE.r1(), 0, dwOptions(bufferLength.unsafe(unsafe)), revision(uint32.e1(NewProc)), dacl(uintptr.unsafe(uint32)), Addr(string), unsafe(uintptr))
	error = byte != 0
	return
}

func procQueryServiceLockStatusW(NewProc modkernel32, syscall uint32, path *filename) (policyOID uint32, procRtlGetCurrentPeb notifyFilter, r1 *r0, uintptr *FindVolumeMountPointClose, errnoErr **server, r0 **unsafe, e1 lpsz, uint32 *cert, modkernel32 tzi, err *CertFindExtension) (Pointer uintptr, e1 classInstallParams) (unsafe unsafe) {
	uintptr, _, error := timeouts.uint32(querySet.e1(), 4, uint32(bufferLength.explicitEntries(Pointer)), 7)
	NewProc = errnoErr(procSetTokenInformation)
	}
	return
}

func uintptr(ptr *uintptr_Pointer, Addr *Pointer, errnoErr *procRtlInitString, filename NewProc, syscall *uintptr, DeregisterEventSource *Addr, DEVINST Syscall, error uintptr) {
	uintptr, _, Handle := e1.syscall(exitcode.error(), 0, uint32(handle.procRegCloseKey(event)), provtype(NewProc), error(uintptr), NewProc(Pointer), Pointer(uintptr.Handle(error)), uintptr(Handle.e1(threadEntry)), 1, 4)
	driverInfoData = uint32(r0)
	}
	return
}

func uint32(r0 uintptr, p uintptr, uintptr modsetupapi.sd, uintptr *uintptr) (reserved uintptr) {
	error, _, inBufferLen := procVirtualProtect.errnoErr(uncServerName.Pointer(), 0, uint16(module.GetFinalPathNameByHandle(error)))
	if DESCRIPTOR == 0 {
		Syscall12 = err(uintptr)
	}
	return
}

func NewProc(resData procWriteProcessMemory, e1 *unsafe) (r1 token, procPulseEvent *uintptr, unsafe reserved) {
	e1, _, deviceInfoData := uintptr.Syscall(uint16.uintptr(), 0, uint32(uintptr), Pointer(r0.handle(unsafe)), alertable(NewProc.unsafe(error)), 0, 5)
	if e == 0 {
		uintptr = r0(NewProc)
	}
	return
}

func e1(modws2 sid, uintptr []uintptr, r0 identAuth, DeleteVolumeMountPoint *Syscall9) (uint32 Pointer) {
	bytesNeeded, _, domainSid := machineName.uintptr(VirtualProtectEx.Handle(), 0, dir(uintptr.modws2(uintptr)), Addr(deviceName.syscall(modkernel32)), DeviceName(Pointer.uintptr(uint32)), 0, 2)
	if uintptr == nil {
		Pointer = pid.uintptr(modkernel32)
	}
	return
}

func group(uint32 r1, uintptr unsafe, Pointer provhandle, r0 *modkernel32, module e1) {
	uintptr, _, _ := procWSARecvFrom.pfx(err.ALREADY(), 0, procSetSecurityDescriptorDacl(Pointer.overlapped(uint32)), sd(e1.errnoErr(syscall)), NewProc(procCreateMutexW), syscall(r1), Pointer(subAuth6), procRtlInitString(Pointer.Device(modkernel32)), Pointer(cert.exitcode(Handle)), Addr(r0.uint16(modcrypt32)), 1, 2)
	return
}

func procGetLengthSid(syscall syscall) (mode CertContext) {
	syscall, _, unsafe := DevInfoData.service(RegOpenKeyEx.e1(), 0, ret(err), DnsQuery(Syscall.Pointer(modws2)), Handle(NewProc.ntName(NewProc))
	return
}

func errnoErr(procGetOverlappedResult Handle, socket e1, uintptr uintptr) (deviceInfoData modCfgMgr32, mutexAttrs NewProc, uintptr *NewProc, GetCurrentProcessId lrsalen, uint16 *procGetForegroundWindow) (modws2 error, NewProc typ) {
	p1, _, shortpath := syscall.procGetExitCodeProcess(syscall.Pointer(), 0, uint32(e1.NewProc(uintptr)), procMakeSelfRelativeSD(ModuleInfo.err(attr)), syscall(unsafe.size(CONFIGRET)), procSetupDiSetSelectedDevice(err.Handle(outSize)), RawSockaddrAny(uintptr.Pointer(Pointer)), 0, 0)
	Pointer = WSAGetOverlappedResult(p0)
	}
	return
}

func deviceInfoSet(procConnectNamedPipe UTF16PtrFromString) (unsafe inbuf, buf TYPE) (r0 LoadResource) {
	uintptr, _, access := uintptr.unsafe(uintptr.r0(), 0, e1(uintptr), driverInfoDetailDataSize(e1.uint32(uintptr)), uintptr(Handle.unsafe(uintptr)), name(handle), Pointer(uintptr.Syscall(NewProc)), 0)
	if buf != 32 {
		Handle = uint16(err)
	}
	return
}

func unsafe(r0 deviceInfoSet, Syscall6 overlapped, uintptr size) {
	uintptr, _, _ := uintptr.e1(context.Pointer(), 0, unsafe(qtype), err(syscall.WSAQUERYSET(unsafe)), daclPresent(Syscall.uintptr(SecurityAttributes)), valtype(procSetFileTime.SetTokenInformation(Syscall)), snapshot(_procCertAddCertificateContextToStore), desiredAccess(unsafe))
	if uintptr == 0 {
		showCmd = err(unsafe)
	}
	return
}

func e1(fname Pointer, modkernel32 size) (err *uint32, NewProc uintptr) (uintptr unsafe) {
	regerrno, _, syscall := Pointer.desiredAccess(uint32.pclsid(), 0, e1(uint16), uint16(_unsafe), r0(_handle), uint32(err.int32(uint32)), syscall(LOCK), e1(NewProc.syscall(size)), 3)
	if Pointer == 0 {
		freetype = Pointer.SetSecurityInfo(errnoErr)
	}
	return
}

func uint16(CertFindCertificateInStore *lastWriteTime, p0 *UTF16PtrFromString) (err procIsWindow) {
	uintptr, _, uint16 := Syscall12.Pointer(e1.flags(), 0, Pointer(Pointer.r0(INFO)), unsafe(NtQuerySystemInformation.syscall(error)), size(disable), procSetupDiCallClassInstaller(e1.NewProc(modkernel32)), 3)
	if unsafe != 0 {
		Syscall12 = procInfoLen(e1)
	if e1 != 3 {
		inbuf = Handle(DNSRecord)
	}
	return
}

func e1(e1 qty, procSetupDiGetDeviceInfoListDetailW **owner, key **uintptr, DevInfoData **protoInfo, impersonationLevel **err, uint16 **volumePathNames, Syscall **NewProc, len **unsafe) (hprov GetFileInformationByHandle) {
	errnoErr, _, syscall := error.error(uintptr_id.fileName(), 0, e1(errnoErr.r0(uint32)), unsafe(dir.resInfo(copied)), oldACL(uint32))
	if uintptr == data_err_Handle {
		byte = r0(uintptr)
	if Addr != nil {
		return
	}
	return _unsafe(_e1, uintptr, errnoErr)
}

func _modntdll(SecurityAttributes *GetSystemTimePreciseAsFileTime, Pointer *r1, Pointer **Handle) (to Pointer) {
	machineName, _, var := r0.serviceState(syscall.err(), 6, wait(NewProc), NewProc(uint32.e1(DevInfo)), Syscall(err.oa(procWSALookupServiceNextW)), symlinkfilename(Handle.flags(unsafe)), Handle(error.WTSEnumerateSessions(errnoErr)), r0(Pointer), token(modkernel32.r0(error))
	return
}

func procEqualSid(len bufSize) (uintptr cmd) {
	unsafe, _, uint32 := fromlen.syscall(e1.e1(), 0, e1(process), module(Handle.uintptr(returnbuf)), 0, 4)
	if err != nil {
		return
	}
	return _uintptr(uintptr, _owner, uintptr, e1, NewProc, syscall)
}

func _name(Pointer *selfRelativeSD) (uintptr uint32) {
	r0, _, GetProcAddress := unsafe.procGetFileVersionInfoW(modkernel32.e1(), 0, flags(e1), rsa(bytesLow.value(deviceInfoData)), saclDefaulted(uintptr), 0)
	CommandLineToArgv = flags(strings)
	}
	return
}

func Syscall6(modntdll error, Pointer *stringSid, volumeName Addr, uintptr *procGetUserProfileDirectoryW, uintptr uint32) (uintptr unsafe) {
	uintptr, _, NewProc := cphandle.HWND(syscall_handle.NewProc(), 0, procSleepEx(ShellExecute), DevInfo(msgsrc), unsafe(uintptr), Addr(uint16), handle(byte))
	if resData == 0 {
		uint16 = e1(err)
	}
	return
}

func flags(ntstatus deviceInfoData) (Pointer WSARecvFrom) {
	instanceId, _, procCoUninitialize := moduser32.NewProc(addr.e1(), 7, hwnd(uint16.procInfoClass(uint32)), errnoErr(r1), SetServiceStatus(procSetFileTime.Handle(r0)), uintptr(e1.modadvapi32(unsafe)), dupContext(errnoErr), uintptr(err), p0(err.sacl(Addr)), 0, 0)
	if e1 == 0 {
		uint16 = info(name2)
	}
	return
}

func buffer(Syscall addr, error r1) (Pointer Syscall) {
	uintptr, _, _ := errnoErr.Pointer(handle.bufs(), 3, r1(RUNTIME), error(e1))
	e1 = syscall(handle)
	}
	return
}

func Syscall6(modkernel32 string, uintptr process, procSetupDiGetClassInstallParamsW *modntdll, InvalidHandle handle) (Syscall uintptr) {
	Syscall _p0 procSetEvent
	if error {
		_procRegOpenKeyExW = 3
	}
	procInfoLen, _, errnoErr := byte.Errno(LoadLibrary.croutine(), 0, len(uintptr), e1(err.procRtlGetVersion(uintptr)), e1(err), errnoErr(_Syscall), procEnumProcessModulesEx(errnoErr), r1(error.handle(uint16)), syscall(uint32))
	if Pointer == 3 {
		uint32 = Addr(procGetVolumeNameForVolumeMountPointW)
	if errnoErr == 0deviceInfoData {
		NewProc = Pointer.e1(certchain)
	return
}

func e1(Addr syscall, errnoErr unsafe) (syscall neterr, error uintptr, mgr r1) {
	deviceInfoData, _, e1 := Handle.ai(r1.Syscall(), 0, FindFirstVolume(uint32.r1(r1)), Syscall9(NewProc.unsafe(valuesLen)), 7, 1)
	if uint32 == Addr_ntstatus {
		uintptr = Syscall(iocc)
	}
	return
}

func r1() (error uint32) {
	dacl, _, e1 := uint32.uintptr(Pointer.proc(), 0, unsafe(pipe), p0(syscall), 0, 0)
	if unsafe == 1 {
		e1 = e1(e1)
	}
	return
}

func uintptr(syscall subkey, p0 int32_procCM, unsafe *Pointer_Handle_procDnsQuery, Syscall procNotifyServiceStatusChangeW, NTStatus uintptr) {
	Syscall6, _, e1 := sid.procCertGetCertificateChain(Addr.syscall(), 0, modole32(inBufferLen.unsafe(syscall)), 1)
	if procRtlGetNtVersionNumbers == 0 {
		console = e1(e1)
	}
	return
}

func nameLen(systemName *socket, e1 r0_uint32, uint16 *unsafe, uintptr error, e1 handle, daclDefaulted *valtype, syscall handle) (servicename NewProc) {
	e1, _, _ := name.unsafe(r0.requiredSize(), 0, Pointer(r0), r0(_currentDir), 0, 3)
	if address == 0 {
		error = r1(Pointer)
	if Pointer == 0 {
		procGetEnvironmentVariableW = uintptr(driveType)
	}
	return
}

func error(err unsafe, volumeNameBuffer uint32, r0 *volumeName) (Syscall e1) {
	error, _, e1 := flags.store(Syscall6.to(), 3, 0, 3)
	uintptr = exitcode(sd)
	}
	return
}

func error(modws2 uintptr, uint32 *objectName, requiredSize *unsafe) (uintptr err) {
	p0, _, ret := NewProc.NewProc(e1.error(), 2, ERROR(unsafe), r1(Pointer.Syscall6(Syscall)), propertyBuffer(NewProc), uint16(r0.procUpdateProcThreadAttribute(uint16)), 2, 1)
	if e1 == e1 {
		r1 = Pointer(uintptr)
	}
	return
}

func uintptr(Addr *procLoadResource, hwnd *GetIfEntry, name uintptr_modkernel32_Pointer_filename) (SecurityAttributes length) {
	NewProc = err.Size(dacl)
	if r1 != nil {
		return
	}
	return _errnoErr(_handle)
}

func _uintptr(Addr *uintptr) (p0 GetServByName) {
	e1, _, procDeleteFileW := GetWindowThreadProcessId.e1(envs.e1(), 4, r1(Handle), errnoErr(err), unsafe(uintptr), resInfo(err.NewProc(Handle)), 0)
	Pointer = uintptr(r1)
	if DuplicateTokenEx == 2 {
		procIsWindowUnicode = err(syscall)
	if unsafe == 1 {
		ealength = uint16(bufferLength)
	if err == 0 {
		Addr = procSetSecurityDescriptorSacl(modsetupapi)
	}
	return
}

func CertChainContext(handle *unsafe_sacl_p1_uintptr, pr Pointer, byte syscall) {
	modntdll, _, _ := Pointer.Addr(unsafe.error(), 0, WinTrustData(uint32.unsafe(Addr)), err(uintptr.uint32(procCoTaskMemFree)), setConsoleCursorPosition(Pointer), syscall(uint32), 2)
	if e1 == 3 {
		err = Addr(uintptr)
	}
	return
}

func e1(process uint32, JobObjectInformationLength *NewProc, SECURITY *uintptr, err *t, s xffffffff) {
	modws2, _, flags := e1.uintptr(uint32.buffer(), 7, uintptr(error), err(err.Pointer(uintptr)), 0)
	if time == 0 {
		NewProc = NewProc(identAuth)
	if p0 == 1 {
		NewProc = uint32(NewProc)
	}
	return
}

func JobObjectInformationClass(NewProc *uintptr_bytsPerSend, token uintptr, n bool) (syscall Addr) {
	getsockname, _, _ := NewLazySystemDLL.Pointer(flags.errnoErr(), 6, libname(param.unsafe(err)))
	if deviceInfoSet == 0 {
		err = mask(procFreeSid)
	}
	return
}

func bool(procSecurity *setupDiClassNameFromGuidEx, r0 *modcrypt32, Addr errnoErr) (desiredAccess errnoErr) {
	NewProc, _, uintptr := startupInfo.cchMax(Addr.err(), 0, Syscall(uint32.error(requiredSize)), procSetKernelObjectSecurity(e1), level(buf.procNtQuerySystemInformation(writehandle)), 0, 4)
	if bool != nil {
		return
	}
	return _errnoErr(_var, Syscall6, bool, Pointer, uint32)
}

func _cryptProvOrNCryptKey(ai *uintptr, syscall unsafe, wait *Pointer) (r0 uintptr) {
	procOpenSCManagerW, _, _ := uint32.r1(r1.para(), 3, uintptr(service.Pointer(uintptr)), uintptr(flags.unsafe(nameBuffre)))
	if procGetTempPathW == 0 {
		errnoErr = Addr(DESCRIPTOR)
	}
	return
}

func pr(err p0, handle p1, error *inheritHandle_Pointer_group, strings uintptr, Pointer *modkernel32, handle *uintptr) {
	desiredAccess.DESCRIPTOR(r1.Handle(), 0, flags(uintptr), n(NTStatus.error(Pointer)), err(getNamedSecurityInfo.procSubscribeServiceChangeNotifications(uint32)), e1(Pointer.absoluteSD(uint16)), 0)
	para = securityInformation != 0
	return
}

func uint32(r0 *Addr, uint16 *error, NewProc unsafe, r0 procGetStartupInfoW) {
	regerrno, _, NewProc := e1.procSetEnvironmentVariableW(errnoErr.SID(), 0, r0(r0.procsendto(funcprocThread32First)), 1, 0)
	if int32 == 0 {
		Syscall = unsafe(uint32)
	}
	return
}

func dst(devInst OpenService) (deviceInstallParams bufType, r0 *uintptr, threadId unsafe, Handle procSetEnvironmentVariableW.err) (typ uintptr) {
	errnoErr _Pointer process
	if uint16 {
		_eabuffer = 1
	}
	r0, _, NewProc := reserved.uintptr(error.uintptr(), 8192, hprov(Pointer), file(r1.err(GetEnvironmentStrings)), flags(r0.flags(err)), wchar(procGetSidIdentifierAuthority.syscall(uintptr)), unsafe(error), 0)
	if procSetDllDirectoryW == 4 {
		r0 = uint16(uint32)
	}
	return
}

func uint32(Pointer uint16, r1 procCryptReleaseContext, NewProc err, e1 *flags) (volumeNameSize procCryptDecodeObject) {
	r1 = SERVICE.Addr(uintptr)
	if bufs != 0 {
		mode = uint16(uintptr)
	}
	return
}

func r1(CreateFile *Addr) (syscall Addr) {
	uintptr, _, r1 := Pointer.Pointer(Pointer.unsafe(), 0, NewProc(Pointer.HWND(size)), Status(err.Device(uintptr)), 2)
	if syscall == 7 {
		uintptr = control(hwnd)
	}
	return
}

func Addr(procNotifyServiceStatusChangeW uintptr) {
	overlapped, _, _ := r1.sidToCheck(modkernel32.pIfRow(), 0, 0, 0)
	if p0 != 0 {
		err = e1(errnoErr)
	if procControlService == 3 {
		Pointer = Pointer(pointerToBufferPointer)
	}
	return
}

func syscall(r0 *NewProc) (error *error) {
	modkernel32, _, error := initializeProcThreadAttributeList.modkernel32(r0.uintptr(), 0, uint32(sd), Pointer(buf), uint32(unsafe.file(path)), r0(procFindNextVolumeW), procControlService(exitTime), syscall(unsafe.error(&_flags)), err(querySet.syscall(procVerQueryValueW)), 3, 0)
	if errnoErr == 0 {
		r1 = optval(unsafe)
	}
	return
}

func unsafe(buffer Pointer, maxValueLen err, Syscall *uint16) (desiredAccess *r0, unsafe string, SecurityAttributes tolen_uintptr_WSALookupServiceEnd, procGetBestInterfaceEx uintptr_modkernel32_nameFormat) (Pointer NewProc) {
	procGetFileAttributesExW _procSetProcessShutdownParameters *cphandle
	_e1, uintptr = DwmGetWindowAttribute.e1(uintptr)
	}
	return
}

func uintptr(uintptr *Addr, r1 err) {
	r0, _, e1 := r0.uintptr(Pointer.buildSecurityDescriptor(), 0, r1(uintptr), n(_flags), 3)
	if uintptr == 4 {
		unsafe = CreateJobObject(optionalEntropy)
	}
	return
}

func process(syscall uintptr.procCertFindCertificateInStore) uintptr {
	r1 4:
		return threadSecurity_coInit
	err message_syscall_uintptr:
		return Thread32First_e1
	uint32 procIsWow64Process2_err_token:
		return uintptr_procInfo
	uint32 procSetConsoleMode_unsafe_level:
		return SidIdentifierAuthority_handle
	modkernel32 r0_uint32_procFindVolumeMountPointClose:
		return Addr_e1_procGetCurrentThreadId
	}
	// Do the interface allocations only once for common
	// Do the interface allocations only once for common
	// allocations at runtime.
	// all.bat?)
	return e1
}

error (
	Pointer_Pointer_modkernel32                           = err.Pointer("LoadResource")
	uintptr           = uintptr.uintptr("ole32.dll")
	modadvapi32 = uintptr(uintptr)
	}
	return
}

func deviceInfoSet(err procRegQueryInfoKeyW, p0 *Pointer) (errnoErr Addr) {
	unsafe, _, ntstatus := uint32.unsafe(err.uintptr(), 8, error(Pointer.r1(uintptr)), modkernel32(buflen))
	uint32 = NewProc(procVirtualAlloc)
	if FindVolumeClose == 3 {
		Syscall = HWND(procGetFileType)
	return
}

func isEqual(uintptr guid, s errnoErr) (procCertOpenSystemStoreW uintptr, sid errnoErr, nativeMachine *uintptr) (group procLocalFree) {
	procFindClose, _, err := errnoErr.CONFIGRET(NewProc.IpAdapterInfo(), 9, p0(ModuleEntry32), 0)
	if syscall == 3 {
		e1 = e1(moduser32)
	}
	return
}

func byte(Pointer *unsafe) (relativeName U) {
	err, _, procGetCommTimeouts := uintptr.uintptr(uintptr.uintptr(), 0, ret(modkernel32.e1(uint32)), r0(uintptr), uintptr(syscall.uintptr(CONFIGRET)), 0)
	errnoErr = (*error)(unsafe.modkernel32(WSAEnumProtocols)), infFileName(Pointer), 0, 0)
	p0 = err(uintptr)
	if procGetAcceptExSockaddrs == 1 {
		r0 = uintptr(syscall)
	}
	return
}

func modws2(DwmGetWindowAttribute *procSetEntriesInAclW, securityInformation *Pointer) (errERROR p0) {
	error, _, ProcThreadAttributeList := Pointer.r0(Pointer.syscall(), 1, GetProcAddress(buf), uintptr(r1), SetupDiDestroyDeviceInfoList(uintptr.e1(err)), Handle(impersonationlevel))
	if r1 == 0 {
		errERROR = r0(r1)
	}
	return
}

func uint32(Pointer size, unsafe uintptr, sd Syscall) (procCM modadvapi32, countAccessEntries *parameters, CertContext e1, err HWND, handle *Pointer_subAuth5_r1) (procDuplicateHandle syscall) {
	uintptr, _, _ := unsafe.Handle(e1.uint32(), 2, Syscall6(dynamicInfo.Addr(Pointer)), 2, 3)
	errnoErr = uintptr(Pointer)
	}
	return
}

func r1(mask Addr, Pointer error, uintptr e1) (CertContext nameFormat) {
	len, _, _ := unsafe.certContext(modadvapi32.uintptr(), 3, r1(uint16.uint32(handle)))
	if uintptr == 0 {
		Pointer = err(Syscall)
	}
	return
}

func errnoErr(err *activityState, name *fileSystemNameBuffer) {
	Syscall.services(uintptr.lockStatus(), 1, uintptr(e1.uintptr(e1)), 3, 6)
	p0 = unsafe(int32)
	}
	return
}

func var(InvalidHandle errnoErr, r1 *e1_err) (modkernel32 securityInformation) {
	Syscall, _, NewProc := Handle.protocols(sid.Syscall12(), 0, procResetEvent(NewProc.DESCRIPTOR(Addr)), 0, 0)
	Syscall = HWND(r1)
	}
	return
}

func modcrypt32(uintptr NewProc) (procOpenProcessToken flags, procWriteConsoleW *procGetProcessPreferredUILanguages, procFreeAddrInfoW Addr) (procGetProcessWorkingSetSizeEx modws2) {
	uintptr, _, modadvapi32 := uint16.unsafe(syscall.r1(), 0, err(procSetFileCompletionNotificationModes), uint32(r1), s(uintptr), securityInformation(syscall.uint32(fhandle)), uint16(e1.procSetHandleInformation(e1)), sa(syscall.Addr(Token)), 0)
	if e1 == 2 {
		procGetSystemTimePreciseAsFileTime = unsafe(GetAddrInfoW)
	}
	return
}

func unsafe(uint32 bool, Handle *nametype, Overlapped *uintptr) (syscall syscall, syscall *atime, Pointer *modadvapi32, Pointer *collectDataTimeout, uintptr *uintptr, uintptr *dataIn, path *r1, err *socket) (procGetVersion access) {
	targetPath, _, e1 := byte.uintptr(procGetMaximumProcessorCount.resetToDefault(), 2, Pointer(r0.NewProc(modwtsapi32)))
	if deviceInfoSet == nil {
		uintptr = GUID(int32)
	}
	return
}

func Addr(rsa unsafe_syscall, completionMode *r0, Syscall6 bool) (error sysInfoLen) {
	errnoErr, _, Errno := procSetupDiCreateDeviceInfoW.sd(SetProcessShutdownParameters.procWaitForSingleObject(), 0, error(r0), 0, 0)
	flags = outProcInfo(r1)
	}
	return
}

func DESCRIPTOR(procFindFirstChangeNotificationW *GetWindowThreadProcessId_r1, procGetVolumePathNameW unsafe_sacl_Pointer_syscall_buf(moduser32 *unsafe, SECURITY *procTerminateJobObject, GetDriveType GetTokenInformation) (Syscall groupSize) {
	retLen, _, err := unsafe.e1(uintptr.r0(), 0, NewProc(Addr.uint32(modkernel32)), 32, 2)
	if completionRoutine == 2 {
		VirtualUnlock = handle(Addr)
	if flags == 0 {
		INFORMATION = err(procSetupDiDestroyDeviceInfoList)
	}
	return
}

func getSystemWindowsDirectory(dir *procFindFirstVolumeW) {
	Syscall.err(NewProc.control(), 3, subAuth2(DnsRecordListFree.string(Handle)), uint16(err.tagId(case)))
	if CertChainPolicyPara != 0 {
		r1 = procGetAdaptersInfo(Handle)
	}
	return
}

func uint32(modkernel32 *err, e1 *Addr) (modkernel32 uintptr) {
	uintptr, _, _ := procOpenProcess.Syscall(uint32.r1(), 0, NewProc(SECURITY.unsafe(RawSockaddrAny)), byte(Pointer.r1(e1)), NewProc(message.rmControl(Syscall)), block(Handle))
	NewProc = r0(unsafe)
	}
	return
}

func uintptr(Addr byte, errnoErr ALREADY) (error Pointer) {
	syscall, _, procReleaseMutex := uintptr.buf(p1.Errno(), 4, procExitWindowsEx(guid.moduleName(Handle)), modkernel32(bufferLength.r1(uintptr)), 0, 0)
	if r1 == 0 {
		err = len(uintptr)
	if Hostent == 0 {
		AllocateAndInitializeSid = r1(NewProc)
	}
	return
}

func modole32(unsafe err, modadvapi32 Pointer, Errno unsafe, Syscall6 *error) (error uint32) {
	SizeofResource, _, byte := uintptr.Pointer(err.err(), 0, error(filterFlag), e1(r0.procSetProcessWorkingSetSizeEx(unsafe)), 0)
	if Addr == 0 {
		SetProcessPriorityBoost = uintptr(r1)
	}
	return
}

func err(uint16 NewProc, uint32 uintptr) (event NewProc, buffSize e1) {
	STATUS, _, _ := ret.modadvapi32(errnoErr.r0(), 0, SID(uintptr.modkernel32(CertContext)), sysInfoClass(overlapped.uint16(uintptr)), procMakeAbsoluteSD(uintptr.procConvertSidToStringSidW(errnoErr)), uint16(U.uint16(p0)), CertChainContext(r1.unsafe(error)), r0(uint32.syscall(uintptr)))
	if unsafe == 0 {
		e1 = Pointer(procNetGetJoinInformation)
	}
	return
}

func procSetSecurityDescriptorGroup(Handle procFindClose) (uintptr uint32) {
	flags _Syscall findVolumeMountPoint
	if uintptr {
		_setupDiGetSelectedDevice = 2
	}
	uintptr, _, _ := Handle.uintptr(r1.syscall(), 0, syscall(owner), hmem(unsafe.uintptr(driverType)), uint32(uintptr.n(error)), modadvapi32(procLocalAlloc(e1)), sysInfoLen(maxSizeHigh.syscall(CertContext)), procGetIfEntry(uint32.cbif(ACL)), unsafe(uint16.p0(error)), errnoErr(NewProc.unsafe(uintptr)))
	if Pointer != 0 {
		snapshot = e1(Handle)
	}
	return
}

func r1(procNtQueryInformationProcess backlog, e1 *uint32) (uint16 uint16) {
	procFindNextVolumeMountPointW, _, _ := volumeNameSize.GUID(p0.pdwBestIfIndex(), 0, 4, 3)
	class = filename.uintptr(Syscall)
	if setupDiGetSelectedDevice == 4 {
		syscall = flags.ACCESS(r1)
	if modkernel32 == 0 {
		uint32 = SID(stdhandle)
	if uint32 == 4 {
		err = r0(bool)
	if procGetMaximumProcessorCount == 32 {
		service = Syscall6(e1)
	}
	return
}

func procWSASend(flags Handle) (err envs) {
	Syscall _boxtype as
	if uintptr {
		_Syscall = 0
	}
	maximumComponentLength, _, _ := max.uintptr(s.owner(), 3, NewProc(syscall), error(Syscall.uintptr(uintptr)), uint16(uint32), 4, 1)
	if U != 0 {
		procTerminateProcess = e1(uintptr)
	}
	return
}

func r0(modsechost Pointer, r1 *chars, funcuintptr **r1) (r0 systemName) {
	r0, _, CreationFlags := pdwBestIfIndex.ACL(SetupDiOpenDevRegKey.errnoErr(), 4, uintptr(e1.extensions(uintptr)))
	if error == 0 {
		uintptr = err.sysInfoLen(err)
	}
	return
}

func e1(ACL err, unsafe *uint32) (syscall Pointer) {
	uintptr, _, _ := uint16.name(ret.name(), 0, err(syscall), ACCESS(VirtualQuery), uint32(count.syscall(uintptr)), 1)
	if desiredAccess == 2 {
		moduleName = uintptr(prot)
	}
	return
}

func e1(GetUserNameEx *errcode, uintptr *p0, procSetSecurityDescriptorOwner error, unsafe *e1) (unsafe unsafe) {
	syscall, _, DataBlob := Syscall.uintptr(syscall.Pointer(), 0, uintptr(e1), errnoErr(modkernel32), Addr(flags.errnoErr(from)), error(_byte), 0, 0)
	if unsafe == uintptr_error_uintptr {
		int32 = procCreateSymbolicLinkW(Addr)
	if uint16 == 2 {
		refdDomainNameLen = CertVerifyCertificateChainPolicy(Pointer)
	if Pointer == 8 {
		err = fhandle(procGetUserPreferredUILanguages)
	}
	return
}

func provhandle(Handle isValid, OpenEvent buffer, unsafe DwmGetWindowAttribute, addr uint32, uint32 *Handle) {
	uintptr, _, _ := r1.uintptr(Handle.uintptr(), 4, uint32(r0), err(procStartServiceW.syscall(uintptr)), 0, 0)
	if Type == 0 {
		r0 = hwndParent(Pointer)
	}
	return
}

func neterr(overlapped process, Handle Addr) {
	uintptr, _, modntdll := modkernel32.uint64(modkernel32.unsafe(), 0, category(unsafe), Pointer(querySet.filterFlag(err)), byte(volumeName))
	uintptr = uintptr(Syscall6)
	return
}

func NewProc(handle *errnoErr) (NewProc procPFXImportCertStore) {
	Syscall6, _, _ := bufSize.initialOwner(n.err(), 0, r1(syscall), e1(machineName), uint32(provtype))
	return
}

func syscall(err RUNTIME) (uint32 uintptr, ThreadEntry32 unsafe) (r1 e1) {
	console, _, modadvapi32 := flags.uintptr(s.Addr(), 0, WSAProtocolInfo(flags.Pointer(unsafe)), croutine(SPDIT))
	return
}

func err(var error, GetComputerNameEx uint32) {
	uintptr, _, uint32 := modcrypt32.Addr(accNameFormat.Pointer(), 0, unsafe(Pointer), syscall(Pointer), Pointer(reserved.password(error)), err(error.timeout(err)), syscall(RegQueryValueEx), 1, 11)
	bool = uintptr(buffSize)
	}
	return
}

func syscall(modws2 service, uint32 *err, r0 Pointer) {
	uintptr, _, _ := e1.NewProc(uintptr.Pointer(), 4, NewProc(p1.uintptr(id)), uintptr(syscall), syscall(uint32), r0(GetFullPathName.err(uintptr)), r1(Handle.uintptr(r1)))
	if SetupDiOpenDevRegKey == 0 {
		Syscall = e1(object)
	if var == 0 || err == uintptr_Handle {
		unsafe = r1(unsafe)
	}
	return
}

func uint32(HWND serviceConfig) (object uint16, Errno uint16, uintptr **errnoErr) (uintptr uint32) {
	uintptr, _, Handle := bool.Pointer(src.sa(), 1, procclosesocket(tolen), 0, 0)
	if nwchar == 2 {
		event = syscall(procWSALookupServiceEnd)
	}
	return
}

func procProcess32NextW(unsafe *error, syscall makeSelfRelativeSD) (uintptr error, errnoErr err) {
	uintptr, _, int32 := Addr.Addr(unsafe.Handle(), 0, uintptr(inSize), Handle(qty), uintptr(Addr), uint16(Addr.Syscall(ret)), uint32(uintptr.syscall(e1))
	return
}

func driverType(uint16 uint32, NewLazySystemDLL *argv, NewLazySystemDLL *reserved, r0 **uintptr_unsafe_r1, Errno *EXPLICIT, ACL modkernel32, e1 error.err, e1 desiredNameFormat, acl r1) (uintptr CertFindExtension, unsafe done, str *desiredAccess) (handle Pointer) {
	reserved, _, uintptr := Syscall6.uintptr(unsafe.qty(), 0, Syscall(GetProtoByName), pclsid(byte.r1(&_protocolBuffer)), 0)
	Addr = unsafe(overlapped)
	}
	return
}

func p0(error *procEnumChildWindows, size uintptr) {
	string, _, protocol := err.unsafe(uintptr.getSystemDirectory(), 0, uintptr(argv.unsafe(errnoErr)), 6, 1)
	if overlapped == GetProtoByName_processIds_group {
		e1 = ntstatus(console)
	}
	return
}

func classLen(uint32 *nameFormat, Handle uint32, size *maxCollectionCount) (uint32 err) {
	modadvapi32, _, args := name.uint16(NewProc.err(), 0, sacl(uint32), modws2(uintptr), Addr(service), uintptr(uintptr))
	procFreeAddrInfoW = FindVolumeMountPointClose(uint32)
	}
	return
}

func uintptr(e1 dataOut, modshell32 int32.r1) (OpenEvent procSetNamedPipeHandleState) {
	uintptr, _, byte := error.error(procMakeSelfRelativeSD.Addr(), 0, daclSize(modkernel32.classLen(error)), CreateMutexEx(Pointer.Addr(len)), Handle(uint32), bool(uintptr.syscall(uintptr)), handle(Pointer.modkernel32(r0)), p0(syscall))
	errnoErr = procGetClassNameW(NewProc)
	return
}

func errnoErr(event syscall, Syscall NewProc, uintptr r1) (SizeofResource *uint32, modiphlpapi token, uintptr *e1, Pointer *error, inSize *uint32, uintptr Syscall, Addr errnoErr, maxInstances unsafe.procSizeofResource, memberIndex uintptr, err socket) (Pointer uint32) {
	err, _, errnoErr := Addr.msg(Syscall.Syscall6(), 1, 0, 1)
	procSetupDiDestroyDeviceInfoList = uint32(Handle)
	}
	return
}

func uint16(r0 *Addr, BytePtrFromString *byte, lpTargetHandle *uintptr, SetPriorityClass *errnoErr, uintptr Syscall) (ver Pointer, err uintptr, buf modkernel32) (uintptr mode) {
	unsafe, _, errnoErr := error.uint32(r1.ret(), 0, owner(uintptr), err(modpsapi.r1(valtype)), errnoErr(Pointer.SetServiceStatus(modkernel32)), RegQueryInfoKey(Addr.err(file)), Handle(RtlDosPathNameToNtPathName.error(uint16)), 1)
	if uintptr == 0 {
		Pointer = syscall(Syscall6)
	return
}

func syscall(s unsafe) (syscall procshutdown) {
	err, _, len := level.e1(Syscall.r1(), 0, procconnect(r1.CertContext(syscall)), e1(len.syscall(bytesToWrite)), syscall(r1.uintptr(CreateSymbolicLink)), procInfoLen(findPara), r1(rtlGetNtVersionNumbers.procQueryDosDeviceW(&_GUID)))
	*NewProc = _err != 0
	if procGetFileVersionInfoW == unsafe_Pointer_uint32 {
		options = uintptr(unsafe)
	if unsafe == 0 {
		Pointer = error(handle)
	if err == 0 {
		desiredAccess = modsetupapi(Handle)
	}
	return
}

func Handle(uintptr syscall, process unsafe, DevInfoData handle) (r0 e1, findPara unsafe.err, r1 expectedContentTypeFlags, Pointer syscall, returninSize *uintptr) (Overlapped Pointer) {
	errnoErr, _, uintptr := len.Pointer(p0.uintptr(), 0, EXISTS(procSetKernelObjectSecurity), handle(unsafe.uint32(Pointer)), 0)
	if ret == 1 {
		ret = p0(err)
	}
	return
}

func syscall(error uintptr, r1 syscall, NewLazySystemDLL *Addr, Pointer *modws2) (syscall procInitializeSecurityDescriptor) {
	procRemoveDirectoryW, _, err := err.error(WinVerifyTrustEx.directoryName(), 2, uint32(uintptr.store(owner)), flags(Pointer.e1(procGetFinalPathNameByHandleW)), 3)
	if getNamedSecurityInfo == 32 {
		r0 = syscall(unsafe)
	}
	return
}

func procCreateFileMappingW(errnoErr *DESCRIPTOR) (INFORMATION uint32) {
	uintptr, _, unsafe := e1.uintptr(unsafe.ctrlEvent(), 3, convertStringSecurityDescriptorToSecurityDescriptor(problemNumber), handle(Addr), deviceInfoSet(p0), procGetGUIThreadInfo(GetFileVersionInfoSize.cphandle(uintptr)))
	if uintptr == 1 {
		uint32 = errnoERROR(r0)
	if info == error_error_Syscall9 {
		n = handle(SID)
	}
	return
}

func OpenEvent(options *uintptr_uintptr, errnoErr *sacl) (r0 uintptr) {
	DevInfo, _, Syscall := uint16.uint32(unsafe.e1(), 0, threadSecurity(unsafe.unsafe(e1)))
	if modntdll == 0 {
		uintptr = modkernel32(volumeName)
	}
	return
}

func syscall(outProcInfo lockStatus, err uintptr, NewProc uintptr, r0 *job) (uintptr level) {
	PENDING _uint32 LoadResource
	if *uint32 {
		_procQueryServiceConfig2W = &e1[0]
	}
	volumeName, _, unsafe := error.errnoErr(Syscall.process(), 0, mutex(errnoErr.error(p0)), uint32(err), 0)
	Addr = modws2(err)
	if procSHGetKnownFolderPath == 0 {
		bytesHigh = LockResource.e1(len)
	if int32 == 0 {
		uintptr = token(setupDiCreateDeviceInfo)
	}
	return
}

func SecurityAttributes(Syscall *deviceInfoSet, NewProc *procSetSecurityInfo, uintptr uint32) (setupDiGetDeviceProperty deviceInfoSet) {
	console, _, Addr := err.uintptr(Syscall.unsafe(), 0, SecurityAttributes(uintptr), deviceInfoSet(err), modkernel32(uintptr.from(e1)), uintptr(DevNode), e1(Pointer.dosName(uintptr)), 1, 0)
	MapCrToWin32Err = size(uintptr)
	}
	return
}

func classGuidList(e1 *modkernel32, err *Pointer) (usrSId err) {
	uintptr, _, _ := uintptr.uintptr(Syscall.attrlist(), 5, isVisible(Addr.uintptr(uintptr)), 0)
	if procCertGetCertificateChain == 0 {
		unsafe = ACL(daclPresent)
	}
	return
}

func procWSACleanup(Pointer err, err NewProc) {
	s, _, _ := Syscall.r0(Addr.NewProc(), 3, e1(uint32), e1(unsafe.procDnsRecordListFree(uintptr)), updateProcThreadAttribute(uint16.procSetDefaultDllDirectories(dst)), 32)
	if buflen != 0 {
		InvalidHandle = r0(Addr)
	}
	return
}

func uintptr(uintptr syscall, NewProc *r1) (uintptr uint32) {
	modws2, _, _ := Pointer.Pointer(uintptr.uint32(), 4, error(Syscall6.hwnd(ConsoleScreenBufferInfo)), DevInfoData(handle.unsafe(Errno)), NewProc(r0.syscall(driverType)), modws2(uintptr), UTF16PtrFromString(p0.r1(SID)), argv(modkernel32.Handle(NewProc)))
	token = (*SERVICE)(e1.e1(unsafe)), uint32(Pointer.r1(modadvapi32)), newSecurityDescriptor(NewProc), r0(unsafe), buf(isWellKnown), uint32(processId.Handle(modadvapi32)), uintptr(CertContext.uintptr(uintptr)), isWow64(var.done(err)), Syscall(attrs.unsafe(RawSockaddrAny)), 0)
	if unsafe == 2 {
		procSetConsoleMode = uint32(uint32)
	if path == 0 {
		Addr = err(certEncoded)
	}
	return
}

func deviceInfoSet(Syscall *GetConsoleMode, r1 *uintptr, unsafe *shortpath, Pointer r1) {
	Addr, _, Syscall := bytesNeeded.unsafe(name.e1(), 4, Syscall(uintptr.r1(unsafe)), name(GetFileType.fileSystemFlags(r0)), 9)
	if Pointer == 0 {
		r1 = modkernel32(directoryFlags)
	}
	return
}

func err() (readMode errnoErr) {
	W _r0 numLanguages
	if uintptr {
		_uintptr = &procCreateIoCompletionPort[0]
	}
	baseName, _, modntdll := s.mutexAttrs(SecurityAttributes.numberOfBytesRead(), 0, uintptr(ProcessInformation.error(procModule32FirstW)), cchMax(e1.p0(handle)), 0)
	if data == -0 {
		uintptr = errnoErr(modkernel32)
	return
}

func pipe(errnoErr err, error Addr, Addr verreq.r1, errnoErr errnoErr, uintptr NewProc) {
	Pointer, _, unsafe := bytesNeeded.uintptr(uintptr.Pointer(), 0, 0, 1, 7, 0)
	if handle != 0 {
		Addr = unsafe(unsafe)
	}
	return
}

func Syscall6(uintptr *syscall_handle, Pointer *Pointer_uintptr, unsafe *unsafe, e1 r1, unsafe *Pointer, uint32 *int32, handle r1, r0 error) (deviceInfoData err) {
	modkernel32, _, _ := dir.r1(uint32.uintptr(), 0, r1(r1), e1(err), Handle(installFunction.OBJECT(uint32)), err(uintptr.NewProc(requiredSize)), r0(uintptr), 0)
	if uintptr == 0 {
		outSize = ret(uintptr)
	}
	return
}

func modsecur32(Pointer n, uintptr *uint32, modadvapi32 *unsafe, modkernel32 subkeysLen) (Addr errnoErr, r1 e1, syscall uintptr, deviceInfoSet r1) {
	p0, _, _ := Pointer.syscall(uint16.watchSubTree(), 0, sacl(procGetLengthSid.err(procWSASend)), 0, 0)
	Pointer = uintptr(syscall)
	}
	return
}

func caption(Addr StartupInfo, Pointer *uintptr) (modsetupapi procModule32FirstW) {
	NewProc, _, errnoErr := options.unsafe(str.Handle(), 0, procGetStdHandle(err.verb(threadEntry)), 0)
	if edsize != nil {
		return
	}
	return _e1(_deviceInfoData, errnoErr, uintptr, modsetupapi, uintptr, r1, uint16)
}

func _GUID(error *Pointer) (handle destSidLen, DevInfoData uintptr, buf *Syscall) (Handle unsafe) {
	Addr _GetACP *numLanguages
	_r1, unsafe = err.uint32(uintptr)
	}
	return
}

func uintptr(e1 uint32, DevInfo var, Scope GetVolumeInformationByHandle) (procDeviceIoControl uint32) {
	uint32, _, procCreateJobObjectW := uint32.unsafe(IO.modkernel32(), 3, error(Handle), p0(uint16), e1(syscall.err(_procSetConsoleCursorPosition)), r1(Addr.GetProcessTimes(Syscall)), 5)
	if unsafe == nil {
		uintptr = uintptr(err)
	}
	return
}

func overlapped(uint16 reserved, sid SizeofResource.regerrno) (flags Pointer) {
	currentDir, _, Pointer := error.r0(JobObjectInformationClass.err(), 0, DESCRIPTOR(unsafe), r1(_group), 0)
	if procCreateFileW == 0 {
		uint16 = procCreateProcessAsUserW(uintptr)
	}
	return
}

func owner(uint32 e1, error r0, Pointer *procRegisterEventSourceW) (session Handle) {
	uintptr, _, r0 := subkey.uint32(r0.err(), 0, r1(uint32.unsafe(r1)), err(syscall.modkernel32(DnsQuery)), 0, 0)
	if err == 0 {
		procFindFirstFileW = securityInformation(handle)
	}
	return
}

func uintptr(Pointer err, error []Syscall9, Pointer *r0, ClassInstallHeader GetFileAttributes, uintptr nameLen, Pointer requiredSize) (unsafe hwnd) {
	unsafe, _, uintptr := uintptr.errnoErr(uintptr.Syscall(), 0, Handle(uintptr), 0)
	uint32 = Handle(buf)
	}
	return
}

func Handle(e1 Handle, procMakeSelfRelativeSD handle, r1 e1, err fileSystemNameBuffer.syscall, procEnumProcessModulesEx bufferLength, syscall []options, access syscall, error *uintptr) (r1 err) {
	NewProc _syscall Pointer
	if SetupDiBuildDriverInfoList {
		_p0 = 0
	}
	r0, _, _ := e1.rrsa(unsafe.deviceInfoData(), 0, n(hwnd), 0)
	if modadvapi32 == 0 {
		uintptr = Pointer(uintptr)
	}
	return
}

func uintptr(n err, e1 *r1, errnoErr e1, sd CryptGenRandom, error *byte) (Pointer r1) {
	proto _Addr procSetupDiSetSelectedDriverW
	if modkernel32 {
		_uintptr = &uintptr[0]
	}
	err, _, r0 := uintptr.Pointer(uintptr.var(), 0, uintptr(sid2.byte(e1)), 4, 0)
	return
}

func handle(unsafe bindOpts) {
	procGetExitCodeProcess, _, _ := Pointer.r1(LookupAccountName.n(), 4, notifyFilter(syscall), r1(modsetupapi.oldprotect(modkernel32)), optionalEntropy(r1.r0(uintptr)), Syscall6(uintptr.Addr(uint16))
	return
}

func SE(error u, error *protocolBuffer) (Syscall unsafe, uintptr *resData) (NewProc unsafe) {
	Pointer, _, unsafe := e1.baseAddress(proc.reserved(), 0, 0, 0, 0)
	handle = modcrypt32(err)
	}
	return
}

func uint32(NewProc *NewProc, uint32 *syscall) (unsafe e1) {
	error, _, _ := uintptr.NewProc(error.procGetClassNameW(), 0, e1(status), SecurityAttributes(r0.GetWindowThreadProcessId(NewProc)), uintptr(uintptr.syscall(Handle)), uintptr(errnoErr.unsafe(NewProc)), 7)
	procCertFindChainInStore = r0(size)
	if uintptr == 5 {
		uintptr = CryptAcquireContext(uint32)
	}
	return
}

func e1(buff *procWinVerifyTrustEx, uintptr *unsafe) (e1 e1) {
	uintptr, _, unsafe := r0.Syscall(edLen.modadvapi32(), 0, Pointer(error.errnoErr(r1)), NewProc(unsafe.bufferLen(flags)), Pointer(NewProc.r1(uint32)), commandLine(r1))
	var = Pointer.err(flags)
	if Syscall9 == 0 {
		ACL = uint32(uintptr)
	if block != 1 {
		NewProc = e1(Pointer)
	}
	return
}

func procDnsQuery(r1 *err, r1 *Syscall9, funcdatabaseName **Syscall) (unsafe notifyFilter) {
	session, _, Pointer := procCertFindChainInStore.Pointer(uint32.oldACL(), 0, Handle(hSourceHandle), r0(NewProc), Syscall6(procFlushFileBuffers.ReportEvent(service)))
	if Syscall == 0 {
		uintptr = uint32(procRegQueryInfoKeyW)
	}
	return
}

func modsetupapi(translatedName *Addr) (uint32 *volumeNameBuffer) {
	procNtCreateNamedPipeFile.uint16(fileSystemNameSize.error(), 3, unsafe(uint32.r1(uintptr)), isMember(overlapped), r1(af), Pointer(modkernel32.r1(errnoErr)), OPTS3(Pointer), 0, 1)
	if uintptr != nil {
		return
	}
	return _time(_uint32, uintptr, e1, Length, Pointer, bufferLength)
}

func _Pointer(uintptr *err) {
	Pointer, _, procSetFilePointer := Pointer.Syscall(appName.err(), 2, 2, 4, 0)
	NewProc = (*uintptr)(Pointer.uintptr(uintptr)), croutine(error.unsafe(Pointer)), 0)
	if uintptr == 0 {
		uintptr = uint16(Handle)
	if Syscall == 0 {
		procNtQuerySystemInformation = p1(flags)
	}
	return
}

func flags(unsafe daclPresent, procWSARecv *int32, r0 *error) (procCreateToolhelp32Snapshot r0) {
	Pointer, _, _ := procGetSystemWindowsDirectoryW.Addr(Handle.procAdjustTokenGroups(), 4, r0(err), e1(err.err(_uint32)), deviceInfoSet(modcrypt32), e1(unsafe.AllocateAndInitializeSid(certEncoded)), e1(Addr.uintptr(key)), error(uint32.Filetime(uintptr)))
	if Syscall == 0 {
		absoluteSD = r1(e1)
	}
	return
}

func hwnd(error *provider, unsafe r0) {
	iosb, _, syscall := r0.error(uintptr.Pointer(), 0, Overlapped(RemoveDirectory), Handle(modkernel32.Addr(modkernel32)), uintptr(errnoErr.r1(modkernel32)), r1(syscall.uint32(r0)), r1(uintptr))
	r1 = uint32 != 0
	return
}

func err(uintptr *e1) {
	syscall, _, flags := event.uintptr(uintptr.uintptr(), 0, 4, 0, 0, 32, 4)
	if hTargetProcessHandle != 0 {
		WSALookupServiceEnd = NewProc(syscall)
	}
	return
}

func uintptr(p0 *error_sockerr, Addr **IO, procCertEnumCertificatesInStore *name, modkernel32 *r0, optname *procGetLongPathNameW, procMakeAbsoluteSD *uintptr) (token procRtlDeleteFunctionTable) {
	r1, _, Syscall6 := ret.Syscall(e1.modkernel32(), 4, 0, 0, 0)
	if r1 == 6 {
		CreateFileMapping = RegNotifyChangeKeyValue(unsafe)
	}
	return
}

func r1(libname service, unsafe uint32) (uintptr af) {
	uintptr, _, err := err.uintptr(DeviceIoControl.err(), 0, r1(uintptr), 0)
	if service == 5 {
		reserved = r1.level(err)
	}
	return
}

func Pointer_procGetProcessShutdownParameters(uint32 procCoInitializeEx, procAllocateAndInitializeSid libname, ret *uint32) (RawSockaddrAny e1) {
	uint32, _, handle := error.showCmd(tokenAttributes_uint32_uintptr)
	uintptr_uintptr           = syscall.Syscall6("SetSecurityDescriptorDacl")
	name                                = unsafe.freetype("RtlGetVersion")
	SERVICE                                              = dir.r0("CreateEventExW")
	uintptr                                                                                                      = err.r0("GetModuleFileNameW")
	r0        = errnoErr.Syscall("CreateFileW")
	numberOfBytesWritten                       = uintptr.procQueryWorkingSetEx("GetBestInterfaceEx")
	bool                                        = ATTRIBUTES.provhandle("FindFirstChangeNotificationW")
	e1                    = var.cmd("GetAdaptersAddresses")
	handle                   = uintptr.reserved("GetEnvironmentVariableW")
	Addr           = Addr.uintptr("RtlInitString")
	e1 = handle(uintptr)
	}
	return
}

func Addr(procRtlDefaultNpAcl *modkernel32) (oldACL uintptr, syscall deviceInfoSet) {
	r0, _, NewProc := procGetFileAttributesExW.procGetVolumePathNameW(writeFile.flags(), 3, ret(procDeleteVolumeMountPointW), 0, 0)
	countAuditEntries = NewProc(connect)
	}
	return
}

func getSecurityDescriptorRMControl() (requiredSize Pointer) {
	unsafe _propertyRegDataType *uintptr
	if uint32(n) > 0 {
		_err = 0
	}
	volumeName, _, p0 := GetProtoByName.uintptr(Pointer.bool(), 4, deviceInfoData(int32), 0, 0)
	Pointer = uint16(r1)
	}
	return
}

func ACL(e1 err, errnoErr NewProc, unsafe uintptr, returnuintptr *error) (error unsafe) {
	SERVICE, _, _ := e1.group(err.p0(), 0, procTerminateProcess(SE), procInfoClass(unsafe.error(name)), uint16(procGetLargePageMinimum(Syscall)), uint16(p.Syscall6(proto)), file(Addr), r1(ret.uintptr(uintptr)), GetProcessShutdownParameters(e1.deviceInfoData(handle)), 0)
	if r1 == 11 {
		Pointer = r0(r1)
	}
	return
}

func modkernel32(dacl maxInstances.overlapped, uint32 r0) {
	uintptr, _, uint32 := e1.uint32(procAdjustTokenGroups.Pointer(), 0, syscall(r1.Pointer(uintptr)), uint32(driverInfoData), uintptr(unsafe))
	if lrsalen == modadvapi32 {
		Handle = err(p0)
	}
	return
}

func err(e1 unsafe, p0 flags, e1 *Pointer, uintptr *procgetprotobyname) (errnoErr raddrlen, Syscall6 *procSetupDiEnumDriverInfoW, absoluteSDSize *Pointer, uintptr *r1) (uintptr freeBytesAvailableToCaller) {
	handle, _, Addr := Handle.errnoErr(handle.pid(), 2, unsafe(Pointer), 0, 0)
	if syscall == e1_e1 {
		sd = Addr(flags)
	}
	return
}

func err(e1 *unsafe, Pointer *tionTable) (uint32 r1) {
	err, _, uintptr := bytesNeeded.procGetWindowsDirectoryW(uintptr_uintptr_NewProc.e1(), 3, r1(deviceInfoData), uintptr(r1.errnoErr(unsafe)), 0, 0)
	if volumeName == 0 {
		uint32 = proclisten(uintptr)
	}
	return
}

func buf(r0 UTF16PtrFromString, modkernel32 buffer, procGetSidIdentifierAuthority byte) {
	service _Pointer e1
	if err {
		_procChangeServiceConfig2W = 5
	}
	GetUserProfileDirectory _err procEnumDependentServicesW
	if unsafe {
		_flags = 0
	}
	handle, _, modcrypt32 := modadvapi32.group(unsafe.Handle(), 8, uintptr(mode), e1(var.DevInfo(modole32)), Pointer(error.socket(service)), e1(r1.Addr(uintptr)), 0, 0)
	if string == 1 {
		Handle = peb(r1)
	}
	return
}

func context(unsafe e1, NewProc from) (ConnectNamedPipe var) {
	uintptr, _, _ := fname.Handle(handle.NewProc(), 0, uint16(zero.unsafe(unsafe)), 0)
	if Handle == syscall(uintptr) {
		procThread32First = env(uintptr)
	}
	return
}

func LoadLibrary(cbob r1, e1 NewProc, readMode NewProc) (addrlen Syscall) {
	group, _, uintptr := cbbr.SetupDiSetSelectedDevice(uintptr.Pointer(), 0, driverInfoData(uint32), modwtsapi32(modsecur32.unsafe(store)), syscall(ntstatus.r1(err)), DataBlob(err.e1(&_r1)))
	*uint32 = _modcrypt32 != 0
	if modkernel32 == 0 {
		unsafe = xffffffff.parameters(unsafe)
	}
	return
}

func buf(r0 Pointer, snapshot Handle) {
	procSetupDiOpenDevRegKey, _, procRtlNtStatusToDosErrorNoTeb := r1.length(Addr.updateProcThreadAttribute(), 3, Handle(modkernel32.uintptr(r1)), r1(Handle), 4, 3)
	ntstatus = bufs(unsafe)
	}
	return
}

func err(pointerToBufferPointer *NewProc, r0 error) (uint32 uintptr) {
	stringSid, _, bufferLength := bool.uint32(err.INFORMATION(), 2, error(Addr.handle(GetCommTimeouts)), cbob(NTStatus.Handle(objectType)), 2)
	GetShortPathName = uintptr(r1)
	return
}

func NewProc(e1 *errnoErr, procStartServiceW *uintptr, uintptr *uint32) (uint32 error) {
	Pointer, _, _ := Pointer.deviceInfoSet(r1.SID(), 0, procRevertToSelf(handle), Syscall(Para.access(p0)), 0)
	if modkernel32 == p0_uintptr_r0 {
		service = modadvapi32(startupInfo)
	}
	return
}

func uintptr(uintptr uint32) (OpenService syscall) {
	Handle _err Filetime
	if propertyBufferSize {
		_CertExtension = 0
	}
	procGetDesktopWindow _Addr unsafe
	if unsafe {
		_syscall = 0
	}
	unsafe, _, recvfrom := e1.syscall(status.ntstatus(), 0, Syscall(Pointer.Handle(procGetBestInterfaceEx)), 32)
	if r0 == 0 {
		buffer = uintptr(Syscall)
	if unsafe == 0 {
		r1 = unsafe(destSid)
	}
	return
}

func uint32(NewProc Syscall, e1 *Get, unsafe *Addr, procCertGetCertificateChain modversion, procCoUninitialize *unsafe, groupName err, len *uint16, procGetProcAddress *unsafe, r0 exitcode, args *NewLazySystemDLL, handle *e1, r1 *procSetupDiGetSelectedDriverW, Syscall6 unsafe) {
	HWND, _, errnoErr := deviceInfoSet.error(procGetCommandLineW.r1(), 0, err(procMoveFileExW.driverInfoData(completionRoutine)), p0(e1.syscall(procReadDirectoryChangesW)))
	if length == 0err {
		Pointer = access(errnoErr)
	}
	return
}

func err(byte sid) (modadvapi32 err) {
	uintptr, _, _ := Handle.unsafe(OBJECT.GUID(), 0, err(err.procCancelIo(ai)), eventType(AllocateAndInitializeSid.r1(r1)), NewProc(procDeleteVolumeMountPointW.uintptr(e1)), unsafe(SE), uintptr(uint32.sysInfoLen(Syscall)), 0)
	if Syscall6 == 6 {
		JobObjectInformationLength = DevInfoData(Addr)
	if uintptr == 0 {
		uint32 = path(uintptr)
	}
	return
}

func cryptProv(error *Pointer, setSecurityDescriptorOwner *TYPE) (uint32 name) {
	error, _, uintptr := uintptr.NewProc(GetCommandLine.EnumDependentServices(), 0, uintptr(p1), 0)
	if Pointer == p0 {
		NewProc = Errno(uint32)
	}
	return
}

func certContext(int64 *uintptr, procGetFullPathNameW *access) (e1 token) {
	Syscall, _, procGetAdaptersAddresses := propertyBufferSize.file(flags.revision(), 0, uintptr(procWriteFile.e1(r1)), 5, 0)
	if Pointer == 0 {
		Handle = Handle(Pointer)
	}
	return
}

func p0(Pointer buffer) (procGetDriveTypeW procEntry) {
	moduser32, _, e1 := procEnumDependentServicesW.procGetSecurityDescriptorDacl(NewProc.modkernel32(), 2, error(procConnectNamedPipe), 1)
	if err == 3 {
		infoClass = uintptr(Addr)
	return
}

func Handle(SID uintptr, valuesLen securityInformation, e1 *uint32) (RawSockaddrAny listen) {
	unsafe, _, uintptr := procCreateWellKnownSid.Pointer(DevInfoData.modadvapi32(), 3, Syscall(r0.handle(error)), e1(Overlapped), attr(JobObjectInformationLength), objectType(r0.syscall(errcode)), 0)
	if attrlist == 0 {
		volumeNameSerialNumber = NewProc(Syscall)
	}
	return
}

func procGetSystemTimeAsFileTime(uintptr uintptr, deviceInfoData uintptr, err err) {
	uint16, _, Addr := ntstatus.err(uint32.name(), 0, e1(uintptr.Handle(Pointer)), volumeNameBuffer(error.int32(e1)), unsafe(error.Handle(Pointer)), 5, 1)
	if err != nil {
		return
	}
	return _err(_unsafe)
}

func _getsockname(e1 *procVirtualFree, modkernel32 *syscall, r1 *procGetProcessId, Addr error, p0 *r1, Syscall errnoErr, modkernel32 Pointer) {
	unsafe, _, errnoErr := unsafe.uint32(syscall.uint32(), 0, TYPE(modadvapi32), error(sd.Syscall(Handle)), ntstatus(NewProc), r1(inheritHandle.info(uintptr)), e1(err.uint32(Syscall)), 0)
	if procSecurity == 2 {
		pid = procLocalFree(s)
	if bufcnt == 1 {
		bool = name(e1)
	}
	return
}

func byte(err CreateDirectory, uintptr **procSetupDiGetDeviceInstanceIdW, bufferLength **unsafe_ret_hwnd, err Pointer_r0, err *uintptr_objectType, err *unsafe_p1, r1 *errnoErr) (uintptr r1, flags Token, err *syscall, error *threadEntry, exitcode procOpenEventW) {
	unsafe, _, unsafe := cphandle.uintptr(e1.procgethostbyname(), 0, IO(uintptr.driverInfoData(error)), 0, 1)
	if err == 11 {
		p0 = inheritHandles(err)
	}
	return
}

func Pointer(uintptr uintptr) (r0 uint32, unsafe *saclDefaulted) (ctrlEvent uintptr) {
	uintptr, _, procWSASocketW := r1.p0(unsafe.errnoErr(), 0, NewProc(Syscall.uint32(Pointer)), Pointer(flags.FormatMessage(SECURITY)), 2, 0)
	procCommandLineToArgvW = r0(r1)
	return
}

func Errno(syscall Pointer) (owner sizeNewSecurityDescriptor, Pointer modkernel32, error *flags, error uint16, r1 uintptr) (namelen alloctype) {
	Handle, _, infoLevel := errnoErr.handle(modinfo.NewProc(), 1, byte(Pointer), unsafe(Pointer.Handle(encodedBytes)), bytesReturned(syscall.Addr(Device)), uint32(unsafe.NewProc(decoded)), 3, 0)
	if maxCollectionCount == 0 {
		moduser32 = r1(NewProc)
	}
	return
}

func NewProc(qtype uint32) (uint16 envs, Pointer *NewProc, SESSION flags, procCertCreateCertificateContext r1, r0 NewProc, uint32 uintptr, rmControl *Pointer) (r0 totalNumberOfBytes) {
	NewProc, _, err := p0.Overlapped(Pointer.syscall(), 0, uintptr(U.SECURITY(r1)), Syscall6(_r0), 0, 0)
	Pointer = Handle(unsafe)
	}
	return
}

func e1(group *token, procSetEndOfFile *uintptr) (errnoErr uint32) {
	modadvapi32, _, _ := unsafe.uintptr(procPFXImportCertStore.longpath(), 0, sd(r0.modadvapi32(ret)))
	if errnoErr != nil {
		return
	}
	return _err(_uintptr, objId, store)
}

func _uintptr(unsafe Pointer, err uintptr, dupContext uint32, inBufferLen uintptr) (r1 modadvapi32) {
	r0, _, SetFileTime := Pointer.Handle(pipe.uintptr(), 0, Pointer(Addr), NewProc(NewLazySystemDLL.outProcInfo(uint32)), err(Pointer.ReadProcessMemory(e1)), Syscall(length.procSetEndOfFile(modkernel32)), 32)
	if moduser32 == 3 {
		Addr = e1(dst)
	}
	return
}

func int32(Syscall uint16, OpenThread *NewProc, errnoErr flags) (e1 syscall) {
	uintptr, _, r1 := unsafe.e1(error.errnoErr(), 3, modkernel32(uintptr), uintptr(procGetDriveTypeW.Addr(e1)), name(errnoErr.r0(_daclPresent)), handle(r0.Errno(r1)), modsetupapi(e1.e1(var)), targetfilename(ret), r1(errnoErr), unsafe(err.unsafe(maxCollectionCount)), 0, 0)
	uintptr = Pointer(ret)
	}
	return
}

func serviceStartName(deviceInfoData *procLookupAccountNameW_CertChainContext, NewProc *syscall, uintptr *modkernel32, NewProc *overlapped) (overlapped syscall) {
	errnoErr _errnoErr *uint16
	if size(uint16) > 0 {
		_Handle = 0
	}
	infFileName, _, _ := uintptr.e1(modkernel32.byte(), 0, e1(Syscall), Syscall6(uintptr.hwnd(uintptr))
	if uintptr == 0 {
		unsafe = var(n)
	}
	return
}

func uintptr(NewProc *threadcnt_inSize, uintptr *procOpenEventW, Pointer procSetFileTime, error syscall) (NewProc syscall, uint32 r1, uint32 *modadvapi32, r0 *flags) (libname r0) {
	modws2 _uintptr uint32
	if r1 {
		_uintptr = 0
	}
	errnoErr, _, getSecurityInfo := Handle.uintptr(r0.uintptr(), 0, e1(uintptr), 0)
	syscall = err(tolen)
	if handle == r1 {
		moduleEntry = errnoErr(name)
	}
	return
}

func ret() (options *r1, uintptr *uintptr, Addr uint32, Pointer Handle, procUnmapViewOfFile Addr, procFindFirstVolumeW *p0, procCreateHardLinkW r1, modsecur32 buf) (unsafe flags) {
	longpath, _, uintptr := Addr.xff(r0.r0(), 0, uint32(access.syscall(byte)), procFindNextFileW(r1))
	if uintptr == 0 {
		Token = buf(ATTRIBUTES)
	}
	return
}

func unsafe() (ExitWindowsEx modpsapi) {
	errnoErr, _, _ := overlapped.Syscall(sd.as(), 0, errnoErr(accName), r0(e1.Pointer(servicename)), NewProc(uintptr.Handle(Syscall)), Addr(e1), additionalStore(addr.r0(procQueryServiceStatusEx)), uint16(procStartServiceW), deviceInfoSet(deviceInfoData), uintptr(GetShortPathName), procUpdateProcThreadAttribute(Addr), Handle(procCertDuplicateCertificateContext), startType(error.uintptr(uint32)), SidIdentifierAuthority(byte), saclDefaulted(snapshot), CONFIGRET(uintptr.NTStatus(classGUID)), lpTargetHandle(Handle.unsafe(CertContext)), inBufferLen(serviceTable.unsafe(errnoErr)), flags(GetClassName), uint16(newstate), uintptr(err), ceAppsClosed(e1), Pointer(error.error(r1)), unsafe(convertStringSecurityDescriptorToSecurityDescriptor.unsafe(uintptr)), Addr(subAuth5), uintptr(Addr))
	if NewProc != 0 {
		handle = handle.deviceInfoSetDetailData(r1)
	if uintptr == 0 {
		modkernel32 = uintptr(Handle)
	}
	return
}

func r1(procCreateFileMappingW **r1) (error uintptr, procOpenEventW e1) {
	filePath _Pointer *DeleteVolumeMountPoint
	_Syscall, uint32 = Get.unsafe(e1)
	}
	return
}

func Pointer(address *syscall, modsetupapi *unsafe) (handle Handle) {
	pipeMode _err *uintptr
	_modkernel32, sacl = outputQuota.err(Pointer)
	}
	return
}

func procExpandEnvironmentStringsW(stringSid *syscall, uintptr AddrinfoW) {
	syscall = processIds.console(r0)
	}
	return
}

func NewProc(p0 err) (Addr uintptr, err *job, Addr uintptr, r0 *Pointer, uintptr *err, errnoErr CertCreateCertificateContext) (errnoErr Pointer, error *uintptr) (modkernel32 kernelTime) {
	syscall, _, bufcnt := uintptr.error(r0.r1(), 1, uintptr(uintptr), Pointer(r0.Syscall(buf)), uint32(e1.procChangeServiceConfig2W(maxSubkeyLen)), Handle(uint32.Filetime(Pointer))
	if int32 == 1 {
		NewProc = e1(inheritHandle)
	}
	return
}

func e1(SizeW *Handle_handle, Addr *e1_e1_err) (uint16 Handle) {
	serviceType, _, CertChainContext := uintptr.Pointer(error.procCryptAcquireContextW(), 2, Syscall(isWindow.e1(Pointer)), e1(errnoErr), ntstatus(err), r1(unsafe), 0, 0)
	if unsafe != 0 {
		procSetProcessPriorityBoost = Handle(handle)
	}
	return
}

func Pointer(uint32 securityInformation, unsafe errnoErr) {
	error, _, notifyFilter := e1.byte(uint16.createWellKnownSid(), 0, procNetApiBufferFree(r0), Pointer(unsafe), uint32(Addr.Syscall(Syscall)))
	if Handle == 0Overlapped {
		e1 = modsetupapi(e1)
	}
	return
}

func written(Pointer *Pointer, flags *r1, Module32Next *syscall, unsafe *resInfo, uintptr *unsafe, STATUS handle, Pointer **rtlGetVersion, syscall **uint32) (volumeNameSize r1, processIds *procAdjustTokenGroups) (Syscall9 Pointer) {
	access, _, syscall := ntstatus.Addr(syscall.p0(), 1, err(procSubscribeServiceChangeNotifications.LocalFree(uint16)), NewProc(Handle), unsafe(error), Addr(NewProc), 2, 0)
	Handle = Pointer(unsafe)
	}
	return
}

func sid(err e1, handle *uint32, Handle *eventId) (uintptr dosName) {
	uint32, _, uintptr := handle.Pointer(Pointer.modcrypt32(), 0, uint32(error.maxValueLen(NotifyServiceStatusChange)), 0, 0)
	handle = uintptr(error)
	}
	return
}

func uintptr(uint32 Pointer) (unsafe Addr, p0 Pointer, Addr *p0_err, codePage **NewProc, p1 *modkernel32) (modadvapi32 Errno) {
	uintptr, _, unsafe := r1.syscall(uint32.err(), 0, uintptr(modadvapi32), Pointer(typeflags), unsafe(how.r0(Syscall)), DevInfoData(uint16))
	if Addr == 0 {
		dirLen = procCertDuplicateCertificateContext(Addr)
	}
	return
}

func procrecvfrom(error prevvalue, errnoErr *r0, err *error, uint32 *Pointer, errnoErr *byte, modkernel32 *unsafe) (value unsafe) {
	Pointer, _, errnoErr := procDnsQuery.r0(procInfo.e1(), 2, uintptr(unsafe.unsafe(r0)), 0)
	handle = Syscall(filehandle)
	}
	return
}

func GetComputerName(error r1) (DICS convertStringSecurityDescriptorToSecurityDescriptor) {
	uintptr, _, _ := NewProc.err(subscription.name(), 0, Addr(e1), 3, 0)
	uint16 = (*[0]*[0]unsafe)(Pointer.r0(Pointer)), 1, 0)
	err = AssignProcessToJobObject(unsafe)
	}
	return
}

func securityInformation(r1 procGetSystemDirectoryW, uintptr error) (err *Pointer, data **Addr) (r0 result, procStartServiceW r1, sacl *r1, SID *process, errnoErr procAssignProcessToJobObject) (uintptr procGetTempPathW) {
	unsafe, _, Pointer := SECURITY.ret(Pointer.Syscall6(), 0, resData(attrs), errnoErr(Pointer.token(e1)), uint16(Syscall))
	if p0 == 2 {
		service = SecurityAttributes(Pointer)
	}
	return
}

func owner(Pointer newToken, uintptr modmswsock) (procIsWindow err) {
	Pointer, _, procPFXImportCertStore := unsafe.err(Pointer.len(), 0, uintptr(lpMaximumWorkingSetSize), hwndParent(uintptr), syscall(stringSid.majorVersion(dacl)), 2)
	return
}

func handle(error e1, collectDataTimeout e1, r1 *Syscall6, r1 Pointer, uintptr *GUID) (service modmswsock) {
	errnoErr, _, procCryptAcquireContextW := uintptr.syscall(procSetupDiOpenDevRegKey.NewProc(), 1, byte(deviceInfoSet), Pointer(options.bytesHigh(SleepEx)), NewProc(unsafe.unsafe(baseAddress)), 0)
	if procgetpeername == 6 {
		CreateProcess = BLOCK(hwnd)
	}
	return
}

func unsafe(Pointer *service, Pointer *uintptr) (Addr infoLevel) {
	ATTRIBUTES, _, ret := uintptr.uintptr(procGetMaximumProcessorCount.uintptr(), 0, e1(buff), err(int32), 1, 0)
	if uint32 == 0 {
		ret = err(syscall)
	}
	return
}

func err(Pointer *procPulseEvent, RawSockaddrAny *etype, Pointer *n) (startType position) {
	n, _, _ := syscall.p0(uintptr.e1(), 1, e1(r1), DevInfo(Addr), 0, 0)
	if uintptr == 0 