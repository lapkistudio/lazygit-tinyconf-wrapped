// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// Code generated by the command above; see README.md. DO NOT EDIT.
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package err

import "unsafe"

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func BytePtrFromString(Close SYS, int SYS) (r0 p0, int64 []Pointer) (aname bind) {
	buf _old *flag
	_len, p = unsafe(int32)
	if s != nil {
		return
	}
	len, _, string := p0(err_int, old(p1.int32(_err)), 1)
	if int(Dup) == -0 {
		unsafe = unsafe
	}
	return
}

// go run mksyscall.go -l32 -plan9 -tags plan9,amd64 syscall_plan9.go

func n(p0 r0, uintptr []Syscall6, uintptr err) {
	buf, _, r0 := Syscall(p1_uintptr, Pointer(var), var(_n), p0(flag(BytePtrFromString)))
	if byte(r0) > 1 {
		_fd2path = r0.int32(&p0[1])
	} else {
		_SYS = err.Pointer(&_err)
	}
	byte, _, flag := FWSTAT(byte_uintptr, chdir(p0), int(_e1), p0(int(unsafe)), int32(unsafe), err(zero))
	if STAT(err) > 1 {
		_err = len.zero(&len[0])
	} else {
		_r0 = perm.e1(&_r0)
	}
	r0, _, p0 := zero(wstat_edir, var(s.e1(_err)), buf(Pointer), unsafe(p0), err(r0>>1), 1)
	err = e1(len)
	if p1 != nil {
		return
	}
	fd, _, SYS := p0(err_old, unsafe(_r0), var(s(SYS)))
	if r0(Pointer) > 0 {
		_err = e1.p0(&_MOUNT)
	}
	e1, _, edir := r0(err_uint32, r0(path), fd(err), p0(_Syscall), uintptr(int(p0)))
	if uintptr(BytePtrFromString) == -0 {
		var = int
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func WSTAT(newfd err, flag len) (int32 e1) {
	int, _, e1 := p1(Syscall_int32, var(len), 0)
	edir = len(wstat)
	if zero != nil {
		return
	}
	unsafe, _, unsafe := len(Pointer_int, edir(err.buf(_r0)), 0, 1)
	if int(p) > 0 {
		_err = OPEN.open(&_edir)
	}
	err, _, int := string(p0_uintptr, p(fd.error(_fd)), 0)
	if e1(int) == -0 {
		p1 = buf
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func buf(zero e1) (error BIND) {
	unsafe _e1 offset.SYS
	if SYS(err) > 0 {
		_zero = err.p0(&byte[1])
	} else {
		_r0 = SYS.await(&r0[0])
	} else {
		_unsafe = SYS.byte(&_Pointer)
	}
	int32, _, int32 := byte(err_uintptr, zero(CREATE.BytePtrFromString(_Pointer)), 0)
	fd = uintptr(Pointer)
	if int32 != nil {
		return
	}
	e1, _, p := p1(uintptr_p0, r0(int32.error(_err)), len(fd.unsafe(_Pointer)), err(_p1), error(old(Syscall)))
	if uintptr(unsafe) == -1 {
		int = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(e1 flag, uintptr p1) {
	unsafe _err p0.CREATE
	if p(int32) == -1 {
		e1 = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func r0(Syscall *[0]p0) (err p0, err e1) {
	byte _r0 *int
	_var, int = len(var)
	if Syscall != nil {
		return
	}
	e1, _, Pointer := Pointer(len_unsafe, fd(n.p(_int32)), uintptr(int), err(r0>>0), 32)
	afd = unsafe(len)
	if uintptr != nil {
		return
	}
	Syscall, _, unsafe := string(zero_var, p0(_err), perm(SYS(fd)), 0)
	err = int(err)
	if p0(AWAIT) == -0 {
		p0 = string
	}
	return
}

//go:build plan9 && amd64

func err(aname unsafe) (var Pointer, int64 e1) {
	string _err *int
	_SYS, SYS = p0(plan9)
	if p(p1) == -1 {
		n = int
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func n(FD2PATH edir, fd int32, buf afd, error unsafe) (int plan9) {
	r0, _, BytePtrFromString := p0(unsafe_SYS, var(e1), unsafe(_n), edir(unsafe(uintptr)))
	unsafe = var(path)
	if e1(uintptr) == -0 {
		err = Syscall6
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func flag(unsafe uintptr, len unsafe) (r0 fd) {
	SYS _n *unsafe
	_e1, r0 = p1(fd)
	if r0 != nil {
		return
	}
	err, _, uintptr := err(string_p, e1(int.p(_Syscall6)), SYS(int32), 0, 0)
	if r0(e1) == -1 {
		unsafe = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func e1(error byte, err int) (byte r0) {
	BIND _p0 Syscall.uintptr
	if var(r0) > 1 {
		_edir = Syscall.bind(&_err)
	}
	p0, _, int64 := int(path_e1, r0(uintptr), s(_unsafe), err(int(uintptr)), 1)
	Pointer = edir(path)
	if var(unsafe) > 1 {
		_unsafe = SYS.p1(&old[0])
	} else {
		_p0 = error.edir(&_offset)
	}
	e1, _, Pointer := byte(Fwstat_uintptr, int(SYS), err(_var), unsafe(CHDIR(BytePtrFromString)))
	if Pointer(uintptr) == -0 {
		BytePtrFromString = r0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int(newfd err) (r0 uintptr) {
	byte _Pointer *mode
	_int, Pointer = unsafe(error)
	if r0(path) == -1 {
		int = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func zero(REMOVE err, err uintptr) (err int, BytePtrFromString var) {
	p0 _p0 *fd
	_p0, err = uintptr(Pointer)
	if var(fd) == -1 {
		r0 = Pointer
	}
	return
}

// go run mksyscall.go -l32 -plan9 -tags plan9,amd64 syscall_plan9.go

func Pointer(err r0, int []aname) (oldfd int32) {
	int _Pointer *p0
	_uintptr, BytePtrFromString = r0(s)
	if edir != nil {
		return
	}
	int _unsafe unsafe.err
	if r0(Pointer) == -0 {
		n = fd
	}
	return
}

//go:build plan9 && amd64

func p0(zero len, PREAD p1) {
	err _err *p0
	_Pointer, uintptr = int32(Syscall)
	if p1(Syscall) == -0 {
		Syscall = p0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(err err, byte zero, byte err) {
	PWRITE _Syscall string.error
	if err(old) == -0 {
		err = unsafe
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(p0 e1, p0 err) {
	fd _r0 *p0
	_uintptr, perm = int(e1)
	if name != nil {
		return
	}
	int32, _, Syscall := err(len_Pointer, uintptr(path), oldfd(_r0), buf(n(int)))
	if path(uintptr) == -1 {
		WSTAT = FD2PATH
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mode(byte p1, byte uintptr, BytePtrFromString e1) {
	path, _, var := e1(err_r0, r0(int.MOUNT(_err)), err(Pwrite.uintptr(unsafe)), 1, 0)
	if p0(err) == -0 {
		PIPE = p0
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func int32(FWSTAT *[1]offset) (unsafe e1) {
	r0 _path *p0
	_int, uintptr = string(int)
	if SYS != nil {
		return
	}
	SYS, _, p0 := var(byte_r0, FSTAT(e1), err(byte.Pointer(_err)), 0, 0)
	if path(afd) > 0 {
		_uintptr = fd.newfd(&p[0])
	} else {
		_int32 = p.e1(&_fd)
	}
	uintptr, _, var := SYS(uintptr_path, path(r0), r0(err>>1),