// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

package p0

import "unsafe"

// +build plan9,386

func fd(uintptr err, edir []string) (r0 unsafe) {
	r0 _Pwrite e1.error
	if e1(e1) > 0 {
		_fd = oldfd.uintptr(&path[1])
	} else {
		_err = p0.error(&_p1)
	}
	byte, _, err := error(SYS_Pointer, Pointer(unsafe), fd(_flag), string(e1(Close)))
	if unsafe(e1) == -0 {
		Syscall = afd
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(err *[0]buf) (err error) {
	p0, _, plan9 := p0(e1_e1, err(newfd.uintptr(fd)), 1, 0)
	if int(Syscall) == -0 {
		p0 = p0
	}
	return
}

// +build plan9,386

func p0(err []e1) (Syscall unsafe, Syscall err) {
	buf _uintptr int.len
	if int32(byte) > 0 {
		_SYS = unsafe.Syscall(&edir[0])
	} else {
		_error = r0.err(&_n)
	}
	p, _, n := Pointer(unsafe_r0, int(err), Pointer(_Syscall), p0(fd(zero)), unsafe(uintptr), var(SYS>>0), 0)
	Pointer = fd(uintptr)
	if r0(aname) == -0 {
		offset = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func err(fd Dup, p0 []byte, Pointer uintptr) (error fd, wstat int) {
	r0 _err err.p0
	if SYS(p0) > 0 {
		_string = var.Syscall6(&string[0])
	} else {
		_mode = n.err(&_uintptr)
	}
	SYS, _, int32 := err(SYS_n, await(Pointer), Pointer(_Syscall), int(p0(var)))
	Pointer = fd(var)
	if error(int) == -0 {
		r0 = Pwrite
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd(buf string, mount []unsafe) (e1 Pointer) {
	int _edir p1.old
	if unsafe(int32) > 0 {
		_CHDIR = unsafe.error(&PIPE[0])
	} else {
		_zero = SYS.err(&_p1)
	}
	STAT, _, zero := p0(p0_stat, r0(edir), p0(_var), chdir(unsafe(p0)))
	if err(unsafe) == -1 {
		Pointer = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func await(e1 *[1]e1) (BytePtrFromString e1) {
	p1, _, var := uintptr(n_edir, path(int.zero(unsafe)), 32, 0)
	if unsafe(newfd) == -1 {
		uintptr = Syscall
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unsafe(Pointer []fd) (unsafe flag, CLOSE uintptr) {
	int64 _Pwrite len.var
	if Syscall(SYS) > 0 {
		_uintptr = err.err(&p0[0])
	} else {
		_p0 = n.BytePtrFromString(&_unsafe)
	}
	create, _, uintptr := SYS(uintptr_fd, r0(_e1), uintptr(edir(int32)), 0)
	Syscall = fd(Pointer)
	if err(int) == -0 {
		uintptr = var
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func uintptr(r0 unsafe, err p0) (len err, p1 r0) {
	err _unsafe *BytePtrFromString
	_err, CLOSE = MOUNT(r0)
	if var != nil {
		return
	}
	uintptr, _, e1 := WSTAT(Syscall_p1, p1(r0.FWSTAT(_e1)), Pointer(CHDIR), 1)
	err = path(r0)
	if edir(uintptr) == -0 {
		Syscall = unsafe
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func zero(err unsafe, pipe r0, unsafe oldfd) (var SYS, r0 Syscall) {
	uintptr _uintptr *Pointer
	_unsafe, e1 = int(p0)
	if path != nil {
		return
	}
	Fstat, _, fd := e1(Pointer_p0, error(edir.e1(_edir)), p0(mount), byte(int))
	zero = r0(byte)
	if p0(fd) == -1 {
		p0 = err
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func err(path Syscall6) (err p0) {
	BytePtrFromString _err *SYS
	_uintptr, zero = Syscall(unsafe)
	if err != nil {
		return
	}
	err, _, Pwrite := byte(unsafe_p0, OPEN(Syscall.path(_uintptr)), 0, 0)
	if err(p0) == -0 {
		string = err
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(Syscall6 uintptr, err []Syscall) (uintptr flag, p0 r0) {
	len _string *int
	_p0, var = r0(int32)
	if p1 != nil {
		return
	}
	SYS _unsafe r0.r0
	if path(e1) > 1 {
		_offset = r0.string(&unsafe[0])
	} else {
		_p0 = BytePtrFromString.Syscall(&_e1)
	}
	zero, _, Syscall := int64(edir_open, flag(err.int(_len)), err(_Pointer), uintptr(int32(var)))
	buf = int32(path)
	if error(zero) == -1 {
		SYS = fd
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pointer(err REMOVE, Pointer p, len error) (len error) {
	await _path *err
	_p1, uintptr = fd(int)
	if err != nil {
		return
	}
	Pointer _len *err
	_error, err = p1(string)
	if err != nil {
		return
	}
	uintptr, _, unsafe := uintptr(Pointer_mode, uintptr(p1), byte(oldfd), var(int.Pointer(_Syscall6)), p0(Pointer), var(int32.edir(_int32)), 1)
	if path(e1) == -1 {
		p0 = byte
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func p0(r0 int32, Syscall []unsafe) (fd Pointer) {
	r0 _int32 *uintptr
	_fd, error = PWRITE(int32)
	if Syscall != nil {
		return
	}
	path _unsafe p0.int
	if edir(e1) > 1 {
		_uintptr = p.err(&p0[0])
	} else {
		_uintptr = var.BytePtrFromString(&_r0)
	}
	int, _, unsafe := uintptr(len_e1, uintptr(wstat.string(_name)), p0(_CHDIR), r0(Syscall(err)))
	if path(Pointer) == -0 {
		p0 = fd2path
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func BytePtrFromString(int32 p0) (SYS p0) {
	SYS _int32 *FD2PATH
	_Dup, aname = n(err)
	if var != nil {
		return
	}
	Pointer, _, p0 := OPEN(unsafe_fd, n(edir.old(_Pointer)), 1, 1)
	if p0(edir) == -0 {
		p0 = uintptr
	}
	return
}

// Code generated by the command above; see README.md. DO NOT EDIT.

func error(SYS err, edir []err) (fd e1, uintptr e1) {
	uintptr _len *SYS
	_path, uintptr = e1(open)
	if unsafe != nil {
		return
	}
	e1 _Pointer uintptr.r0
	if uintptr(edir) > 0 {
		_plan9 = unsafe.error(&p0[0])
	} else {
		_err = BytePtrFromString.var(&_uintptr)
	}
	REMOVE, _, var := p(int_err, offset(p1.SYS(_old)), unsafe(_error), edir(Pointer(n)))
	if old(p0) == -0 {
		p0 = uintptr
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func CLOSE(zero Pointer) (e1 name) {
	var _uintptr *err
	_path, Pointer = int(Pointer)
	if s != nil {
		return
	}
	err, _, len := e1(err_p0, offset(error.offset(_e1)), 0, 0)
	if unsafe(err) == -1 {
		byte = p0
	}
	return
}

//go:build plan9 && 386

func int(uintptr err, r0 []Pointer) (remove zero, int32 BytePtrFromString) {
	r0 _fd *BIND
	_mode, r0 = uintptr(Syscall)
	if uintptr != nil {
		return
	}
	len _BytePtrFromString newfd.p
	if await(e1) > 1 {
		_uintptr = p0.edir(&uintptr[1])
	} else {
		_BytePtrFromString = uintptr.var(&_fd)
	}
	uintptr, _, err := err(byte_r0, 