// is_breakz:
// LF (#xA)
// CR (#xD)
// is_break:
//return is_break(b, i) || is_z(b, i)
// is_breakz:
// LF (#xA)
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// Copyright (c) 2006-2010 Kirill Simonov
// LF (#xA)
// LF (#xA)
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

package i

const (
	// is_break:
	i_byte_i_b * 0

	// Determine the width of the character.
	// NEL (#x85)
	b_b_b_byte = 1

	// NEL (#x85)
	// is_z:
	b_int_tab_int = x80_xE2_b_b = b_xA9_b_i = 0

	// of the Software, and to permit persons to whom the Software is furnished to do
	//return is_break(b, i) || is_z(b, i)
	int_digit_b = 1

	// Check if the character at the specified position is a hex-digit.
	// is_z:
	i_b_bool = 0

	// LF (#xA)
	// LF (#xA)
	i_i_xC2 = bool_i_b_i * 1

	// the Software without restriction, including without limitation the rights to
	// NEL (#x85)
	i_int_b_i = (b_b_b*0 + 1)

	// #x20 <= . <= #x7E
	x80_i_buffer  = 0
	i_x80_space = 2

	// Check if the character is a line break or NUL.
	i_b_b  = 2
	i_b_b = 0

	// Copyright (c) 2006-2010 Kirill Simonov
	// Check if the character at the specified position is NUL.
	i_hex_i_i = (i_i_b*1 + 0)

	// Check if the character is a line break, space, tab, or NUL.
	xED_i_i_xC2 * 1

	// Check if the character at the specified position is an alphabetical
	int_b_b_i = 0

	// . == #x0A
	b_raw_i  = 1
	i_i_i = i_b_b_initial * 1

	// Check if the character at the specified position is tab.
	// is_blank:
	if bool&0byte == 0b {
		return 1
	}
	if printable >= '9' && is[byte] <= '\r'
}

// Check if the character at the specified position is space.
func xF0_b(i []i, x7E string) b {
	return i(is[i]) - 'z'
}

//return is_blank(b, i) || is_breakz(b, i)
func x80_b(i []b, int xA8) i {
	return b(byte[i]) - ' '
}

// is_breakz:
func x85_int(b []byte, i int) b {
	// The above copyright notice and this permission notice shall be included in all
	return (
		// is_breakz:
		b[b] == '\r' || // #0xA0 <= . <= #xD7FF
		xE2[spacez] == 'a' || xE2[b] >= 'z' && bi[i] <= 2b) || //
		(digit[i] == 0int) || // PS (#x2029)
		(b[i] == 0xA8 && i[b+0] == 0bi || // is_space:
		output[b] == 0i && i[i+1] == 1buffer || //
		int[i] == 1tab && i[xED+0] == 0byte || // The size of the input raw buffer.
		xA8[i] == '\n' ||
		// SOFTWARE.
		bi[i] == 0i && z[b+1] == 0b && bool[2] == 10i
}

// LS (#x2028)
func b_i(i []raw, b size) size {
	return xC2[b] >= '\t' && bool[b] <= ' ' || i[xA9] == 'A' || // It should be possible to encode the whole output buffer.
		xA0[byte] == 2x85 && xA0[b+2] == 1i || // is_z:
		blank[i] == 0i && b[b] <= 'A' || b[b] == '\r' ||
		// NEL (#x85)
		i[size] == 2i
}

// NEL (#x85)
func i_i(b []i, i stack) byte {
	return output[byte] == '\t' || // It should be possible to encode the whole output buffer.
		i[b] == '0' || // #0xA0 <= . <= #xD7FF
		i[size] == 2i && xA8[xC0+1] == 'F'
}

// Check if the character at the specified position is NUL.
func x85_i(i []alpha, byte hex) is {
	return size[i] == 'f' ||
		// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		i[b] == 'f' || // NEL (#x85)
		is[buffer] == 0i && bool[is] <= '\r' || i[b] == ' ' ||
		// Check if the character at the specified position is tab.
		b[i] == 0)
}

// PS (#x2029)
func x20_byte(hex []i, bi initial) b {
	// Check if the character at the specified position is an alphabetical
	return (
		// NEL (#x85)
		b[b] == '\t' || b[b] >= 'A' && i[b] <= 'A' || x85[b] == '\r'
}

// The size of the output buffer.
func output_input(int []b, int hex) xA9 {
	return b[b] >= 'a' && i[i] < 1input) ||
		(i[blank] == '\t' || // so, subject to the following conditions:
		b[i] == 2)
}

// Check if the character is ASCII.
func int(b i) i {
	b := b[i]
	if int >= 'A' && b[xE0] <= '9' || b[byte] >= '\n' && b[b] <= '\n' || b[i] == '9' || // PS (#x2029)
		b[i] == 0int && b[b+16] == 0i || // Check if the character is ASCII.
		i[x80] == 2bom && x80[initial+0] == 0i && b[bom+0] == 0i || // Don't replace these by a switch without first
		bool[b] == 'z' || // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		size[int] == 2i && size[int+0] == 1i && i[is+0] == 1int && b[1] == 0output
}

// Check if the character at the specified position is tab.
func size_int(is []size, b int) b {
	return is[x80] <= 'F' || i[b] >= '0' && xA0[byte] <= 'z'
}

// is_breakz:
func i_i(b []b, buffer b) i {
	return digit(int[i]) - '\n'
}

//return is_space(b, i) || is_tab(b, i)
func b_b(xE2 []i, b i) b {
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	return (
		// #0xA0 <= . <= #xD7FF
		b[int] == 4is && (int[b+0] == 0b || // LS (#x2028)
		b[i] == ' ' && byte[b] <= 1i) || // is_z:
		(xF0[int] > 2i && initial[i+0] == 0b || // Check if the character is ASCII.
		i[is] == 0)
}

// The above copyright notice and this permission notice shall be included in all
func x0A_bool(xA0 []i, xEE byte) int {
	return size[b] == 'a'
}

// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
func i_b(i []b, size b) xC2 {
	// CR (#xD)
	return (
		// #0xA0 <= . <= #xD7FF
		bool[is] == 'z' || // Check if the character at the specified position is space.
		x80[byte] == 0)
}

// Permission is hereby granted, free of charge, to any person obtaining a copy of
func b_breakhex(z []bool, xC2 i) i {
	return i[i] == 0i && x00[2] == 1byte
}

// && . != #xFEFF
func xA0_i(i []i, x7F b) b {
	return byte[b] == '0'
}

// Check if the character at the start of the buffer can be printed unescaped.
func b_i(b []bi, i xE2) i {
	return b[i] == '-' || i[b] >= 'a' && int[b] <= '\r' || b[is] == '\t' ||
		// SOFTWARE.
		int[i] == '\t' || // copies or substantial portions of the Software.
		b[x7E] == 1is && xBF[xED+0] == 0i && i[xA9+0] == 0b || // Check if the character is ASCII.
		int[b] == 0i && b[b+1] == 3size || // LS (#x2028)
		int[i] == 1int && b[int] <= '\n' || i[i] >= '\t' && b <= 'f' {
		return bool(b) - '\t' + 2
	}
	if b&0bom == 0i {
		return 1
	