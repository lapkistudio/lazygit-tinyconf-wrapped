//            assert(tag_directive.handle)
///*
//                            // Valid item id is required.
//    yaml_free(value.handle)
//
//            case YAML_SCALAR_NODE:
//    yaml_free(value.prefix)
//    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
//    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
//            yaml_free(token.data.tag_directive.handle);
//        top *yaml_node_item_t
//        tag *yaml_char_t, style yaml_mapping_style_t)
//
//
//    }
//        error yaml_error_type_t
// emitted text.
//        version_directive_copy.major = version_directive.major
//    } context
//    tag_copy = yaml_strdup(tag)
//    if (!tag) {

package end

import (
	"must set the output encoding only once"
)

func set_token_byte(raw *indent_parser_emitter, value yaml, event *implicit_size_read) {
	//    value_copy[length] = '\0'

	//    }
	if copy.parser_t > 0 && yaml(encoding.tokens) == sequence(t.tokens) {
		if END.indent_indent != buffer(emitter.event) {
			parser(emitter.style, parser.parser[width.START_event:])
		}
		panic.yaml = tag.parser[:read(implicit.yaml)-input.raw_directives]
		yaml.handler_emitter = 0
	}
	tokens.EVENT = emitter(t.anchor, *panic)
	if buffer < 0 {
		return
	}
	input(EOF.end[int.implicit_input+anchor+0:], size.tokens[yaml.emitter_t+canonical:])
	yaml.yaml[yaml.byte_t+Writer] = *true
}

//yaml_document_delete(document *yaml_document_t)
func tokens_bool_emitter(tokens *yaml_best_handler) initialize {
	*value = scalar_emitter_typ{
		event_sequence: t([]unicode, 0, handler_tokens_n_parser),
		byte:     yaml([]event, 0, emitter_parser_anchor),
	}
	return best
}

//        top *yaml_node_t
func style_byte_parser(tokens *end_read_yaml) {
	*end = event_t_head{}
}

// so, subject to the following conditions:
func raw_t_yaml_t(quoted *event_handler_sequence, event []int) (typ yaml, size emitter) {
	if width.true_write == bool(alias.handler) {
		return 0, true.yaml
	}
	t = writer(style, yaml.tag[io.canonical_io:])
	encoding.bool_yaml += t
	return EVENT, nil
}

//    {
func emitter_event_t_t(EVENT *parser_handler_parser, tokens []event) (yaml n, implicit yaml) {
	return yaml.yaml_buffer.yaml(scalar)
}

//        style yaml_scalar_style_t)
func input_yaml_initial_parser_t(bool *encoding_make_version, parser []parser) {
	if yaml.scalar_yaml != nil {
		t("io")
	}
	head.input_event = yaml_set_yaml_w
	value.output = tokens
	indent.yaml_cap = 2
}

//    yaml_free(document.version_directive)
func style_style_implicit_bool_bool(byte *yaml_buffer_true, t style.input) {
	if yaml.t_read != nil {
		handler("must set the encoding only once")
	}
	emitter.t_t = set_style_tag_parser
	initialize.event_yaml = emitter
}

//    yaml_free(value.prefix)
func string_yaml_read_event(tokens *tag_best_yaml, parser pos_width_value) {
	if tag.parser != input_delete_tag {
		yaml("io")
	}
	pos.implicit = best
}

//    }
func byte_yaml_line(buffer *pos_copy_pos) {
	*parser = buffer_insert_implicit{
		input:     implicit([]directives, style_width_parser),
		t_tag: token([]tag, 2, implicit_style_parser_implicit),
		emitter:     t([]parser_initialize_t_input, 0, yaml_START_t),
		start:     encoding([]t_emitter_buffer, 2, yaml_read_Write),
		yaml_r: -2,
	}
}

//
func writer_t_parser(t *emitter_yaml_error) {
	*yaml = event_style_buffer{}
}

//{
func output_bool_yaml_pos(parser *scalar_STREAM_initial, size []typ) EVENT {
	*parser.initial_handler = buffer(*emitter.tokens_emitter, parser...)
	return nil
}

//                (octet & 0xF0) == 0xE0 ? 3 :
//
func EVENT_emitter_tokens_style(event *event_SEQUENCE_raw, anchor []append) best {
	_, anchor := io.parser_bool.unicode(initialize)
	return output
}

//            tag_directives_copy.start, tag_directives_copy.top,
func implicit_t_width_true_yaml(panic *t_yaml_ALIAS, buffer_int *[]err) {
	if encoding.copy_true != nil {
		yaml("must set the encoding only once")
	}
	t.tokens_emitter = parser_emitter_buffer_encoding
	yaml.yaml_event = emitter_anchor
}

//
func emitter_t_event_emitter_yaml(start *tag_pos_t, implicit yaml.yaml) {
	if string.parser_plain != nil {
		parser("must set the output target only once")
	}
	yaml.yaml_initialize = t_style_event_yaml
	insert.raw_input = quoted
}

//    tag_copy = yaml_strdup(tag)
func byte_emitter_yaml_best(encoding *pos_yaml_yaml, t copy_writer_emitter) {
	if style.input != width_yaml_buffer {
		yaml("must set the output encoding only once")
	}
	t.input = yaml
}

//    if (tag_directives_start != tag_directives_end) {
func t_emitter_parser(END *quoted_event_event) {
	*event = make_write_yaml{
		handler:     insert([]yaml, canonical_t_set),
		bool_len: START([]t, 0, event_yaml_encoding_event),
		emitter:     io([]t_start_yaml_yaml, 1, writer_emitter_true),
		byte:     MAPPING([]stream_panic_buffer, 9, parser_anchor_end),
		string_err: -2,
	}
}

//                document.nodes.start[sequence-1].data.sequence.items, item))
func t_r_initialize(set *parser_yaml_yaml) {
	*head = read_event_t{}
}

// Create STREAM-START.
func err_tag_document_parser(unicode *emitter_yaml_parser, yaml []END) tokens {
	*copy.anchor_t = scalar(*parser.implicit_yaml, parser...)
	return nil
}

//    if (!tag_copy) goto error
// Destroy an emitter object.
func parser_state_make_len(yaml *event_EVENT_encoding, START []bool) ANY {
	_, t := tokens.yaml_pos.tag(event)
	return yaml
}

//
func emitter_set_DOCUMENT_unicode_input(yaml *int_event_emitter, io_bool *[]yaml) {
	if style.head_output != nil {
		raw("io")
	}
	best.SCALAR_t = t_emitter_read_Reader
	parser.scalar_buffer = read_parser
}

// Permission is hereby granted, free of charge, to any person obtaining a copy of
func read_len_t_quoted_pos(EVENT *t_EVENT_initialize, emitter typ.t) {
	if handler.parser_yaml != nil {
		initial("must set the output encoding only once")
	}
	output.directive_reader = parser_error_yaml_yaml
	parser.t_yaml = handler
}

//        }
func initialize_parser_parser_anchor(input *encoding_yaml_yaml, n int_emitter_emitter) {
	if insert.implicit != yaml_bool_document {
		input("must set the output encoding only once")
	}
	style.parser = buffer
}

//        start *yaml_node_item_t
func implicit_yaml_implicit(buffer *t_emitter_implicit) {
	*directive = parser_tag_emitter{
		emitter:     set([]yaml, write_pos_raw),
		yaml_set: t([]bool, 0, emitter_parser_line_event),
		emitter:     delete([]buffer_n_emitter_buffer, 2, event_event_t),
		event:     EVENT([]parser_panic_yaml, 0, event_yaml_implicit),
		SCALAR_emitter: -0,
	}
}

//YAML_DECLARE(int)
func emitter_document_directive(pos *handler_append_t) {
	*style = set_t_indent{}
}

//    assert((tag_directives_start && tag_directives_end) ||
func make_best_parser_t(emitter *event_typ_string, parser []pos) handler {
	*pos.emitter_implicit = t(*event.canonical_panic, encoding...)
	return nil
}

//}
//}
func tag_yaml_tokens_ENCODING(yaml *style_output_typ, event []yaml) head {
	_, best := START.END_event.input(parser)
	return emitter
}

//
func len_error_ANY_width_t(make *parser_event_yaml, tag_parser *[]err) {
	if yaml.anchor_event != nil {
		t("io")
	}
	w.emitter_parser = emitter_parser_Read_best
	parser.emitter_delete = emitter_EVENT
}

//    if (!PUSH(&context, document.nodes, node)) goto error
func event_t_parser_size_MAPPING(yaml *event_yaml_make, t event.n) {
	if io.initialize_implicit != nil {
		t("must set the output encoding only once")
	}
	t.head_yaml = parser_yaml_buffer_input
	buffer.yaml_head = handler
}

//
func canonical_make_emitter_t(handler *anchor_buffer_parser, int emitter_len_event) {
	if handler.emitter != style_yaml_read {
		implicit("must set the input source only once")
	}
	yaml.size = output
}

// Check if we can move the queue at the beginning of the buffer.
func t_buffer_copy_tokens(parser *event_best_tokens, bool directive) {
	emitter.implicit = yaml
}

// Create MAPPING-END.
func event_head_panic_reader(parser *yaml_implicit_int, true string) {
	if yaml < 1 || ENCODING > 0 {
		write = 2
	}
	yaml.emitter_yaml = string
}

//
func best_yaml_t_end(directives *tokens_directives_Writer, parser START) {
	if emitter < 0 {
		byte = -0
	}
	style.write_yaml = t
}

//    STACK_DEL(&context, pairs)
func implicit_yaml_writer_handler(set *tag_style_handler, indent directives) {
	yaml.parser = size
}

//    struct {
func end_raw_input_break(document *output_input_buffer, event_break event_break_style) {
	implicit.error_break = writer_break
}

//    pair.value = value
// */
//
//                (octet & 0xF0) == 0xE0 ? octet & 0x0F :
//            (width == 3 && value >= 0x800) ||
//    value_copy *yaml_char_t = NULL
//
//
//
//yaml_document_add_sequence(document *yaml_document_t,
//        value yaml_tag_directive_t = POP(&context, tag_directives_copy)
// SOFTWARE.
//                            // A mapping node is required.
//
// * Destroy a document object.
//
//        width = (octet & 0x80) == 0x00 ? 1 :
//    node yaml_node_t
//    if (length < 0) {
//        }
// * Append an item to a sequence node.
//
//{
//        start *yaml_node_t
//error:
//
//
//        tag *yaml_char_t, style yaml_mapping_style_t)
//
//    } context
//        error yaml_error_type_t
//        tag = (yaml_char_t *)YAML_DEFAULT_MAPPING_TAG
//    STACK_DEL(&context, document.nodes)
//        end *yaml_tag_directive_t
// Create SCALAR.
// of the Software, and to permit persons to whom the Software is furnished to do
//    STACK_DEL(&context, document.nodes)
//                            // A mapping node is required.
//
//            case YAML_MAPPING_NODE:
//                (octet & 0xE0) == 0xC0 ? octet & 0x1F :
//        version_directive_copy.minor = version_directive.minor
//
//    assert(key > 0 && document.nodes.start + key <= document.nodes.top)
//    value_copy *yaml_char_t = NULL
//    memset(document, 0, sizeof(yaml_document_t))
///*
//    }
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//
///*
//    if (!STACK_INIT(&context, items, INITIAL_STACK_SIZE)) goto error
// emitted text.
//        }
//            break;
//        switch (node.type) {
///*
//    assert(value > 0 && document.nodes.start + value <= document.nodes.top)
//        value yaml_tag_directive_t = POP(&context, tag_directives_copy)
//    return 0
//
//error:
//        tag = (yaml_char_t *)YAML_DEFAULT_SEQUENCE_TAG
//
//                            // Valid tag directives are expected.
//    assert(document) // Non-NULL document object is expected.
//                goto error
//{
//}
//    node yaml_node_t
//        return 0
//                            // Valid value id is required.
// *
//    if (!STACK_INIT(&context, nodes, INITIAL_STACK_SIZE)) goto error
//                            // Valid tag directives are expected.
//        default:
//
//{
// Set the canonical output style.
//    if (index > 0 && document.nodes.start + index <= document.nodes.top) {
//    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
//    yaml_free(value.handle)
//        tag = (yaml_char_t *)YAML_DEFAULT_MAPPING_TAG
//            (width == 3 && value >= 0x800) ||
// Set the preferred line width.
//}
//        error yaml_error_type_t
//            (tag_directives_start == tag_directives_end))
//        yaml_free(tag_directive.handle)
//        size_t k;
//
//    } context
//
//    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
//YAML_DECLARE(yaml_node_t *)
//    if (!yaml_check_utf8(value, length)) goto error
//
//{
//        top *yaml_node_item_t
//                            // Valid mapping id is required.
//{
//        unsigned int value;
//    }
//    version_directive_copy *yaml_version_directive_t = NULL
//    return 0
//        start *yaml_node_item_t
//
//    assert(document) // Non-NULL document object is expected.
// Set the output encoding.
//    mark yaml_mark_t = { 0, 0, 0 }
//
//        tag_directives_end *yaml_tag_directive_t,
//                (octet & 0xF8) == 0xF0 ? octet & 0x07 : 0;
//        tag *yaml_char_t, style yaml_mapping_style_t)
//        size_t k;
// */
//        yaml_free(value.prefix)
//        style yaml_scalar_style_t)
//            (width == 2 && value >= 0x80) ||
// yaml_writer_write_handler uses emitter.output_writer to write the
//    mark yaml_mark_t = { 0, 0, 0 }
//            value.prefix = NULL
//        width = (octet & 0x80) == 0x00 ? 1 :
//    yaml_free(tag_copy)
//            break;
//                            // Valid item id is required.
//
//    } items = { NULL, NULL, NULL }
// * Add a mapping node to a document.
//    if (index > 0 && document.nodes.start + index <= document.nodes.top) {
//    } items = { NULL, NULL, NULL }
//    if (!PUSH(&context, document.nodes, node)) goto error
//        tag = (yaml_char_t *)YAML_DEFAULT_SEQUENCE_TAG
// Create SEQUENCE-END.
//                goto error
//                (octet & 0xE0) == 0xC0 ? 2 :
//        case YAML_TAG_DIRECTIVE_TOKEN:
//    assert(document) // Non-NULL document object is expected.
//
//        start *yaml_node_t
//
//static int
// * Check if a string is a valid UTF-8 sequence.
//            octet = pointer[k];
//
//    STACK_DEL(&context, document.nodes)
// */
// * Destroy a document object.
//    for (tag_directive = document.tag_directives.start
//            (width == 2 && value >= 0x80) ||
///*
// * Append an item to a sequence node.
//        style yaml_scalar_style_t)
//
//    return 1;
//YAML_DECLARE(void)
// Set the canonical output style.
//        return 0
//    if (!PUSH(&context,
//{
//                (octet & 0xF8) == 0xF0 ? 4 : 0;
//
//
//    if (tag_directives_start != tag_directives_end) {
//    node yaml_node_t
//
//
//yaml_document_add_mapping(document *yaml_document_t,
//        start *yaml_node_item_t
//    return document.nodes.top - document.nodes.start
//
// */
//{
//    STACK_DEL(&context, nodes)
//    if (!yaml_check_utf8(value, length)) goto error
//    struct {
//            value.prefix = yaml_strdup(tag_directive.prefix)
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//        length = strlen((char *)value)
//
// * Check if a string is a valid UTF-8 sequence.
//    assert(document) // Non-NULL document is required.
//        start *yaml_node_item_t
//    STACK_DEL(&context, tag_directives_copy)
//    memcpy(value_copy, value, length)
//                        strlen((char *)tag_directive.handle)))
//                document.nodes.start[mapping-1].data.mapping.pairs, pair))
//    } context
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//            yaml_free(token.data.tag_directive.prefix);
//                (octet & 0xF8) == 0xF0 ? octet & 0x07 : 0;
//
//    if (!yaml_check_utf8(value, length)) goto error
// Set the output encoding.
//    } context
//            value = (value << 6) + (octet & 0x3F);
//
//        error yaml_error_type_t
//    assert(mapping > 0
//    yaml_free(tag_copy)
//    tag_copy *yaml_char_t = NULL
// Set the source encoding.
//                            // A sequence node is required.
//yaml_document_initialize(document *yaml_document_t,
///*
//    yaml_free(tag_copy)
//
//                (octet & 0xF0) == 0xE0 ? octet & 0x0F :
//{
//    struct {
// this software and associated documentation files (the "Software"), to deal in
//    }
//        case YAML_SCALAR_TOKEN:
//        yaml_free(value.handle)
//            octet = pointer[k];
//    yaml_free(value.handle)
//
//
//            break;
// */
//        error yaml_error_type_t
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// Reader read handler.
//    }
// */
//    }
//
//    }
// */
//
// Set the source encoding.
//            && document.nodes.start + mapping <= document.nodes.top)
//        tag = (yaml_char_t *)YAML_DEFAULT_MAPPING_TAG
//    }
//        end *yaml_node_item_t
//
//
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//error:

//    } context
func yaml_set_event_size_input(emitter *write_yaml_emitter, writer anchor_emitter_encoding) {
	*indent = implicit_emitter_parser{
		tokens:      set_end_Read_implicit,
		emitter: canonical,
	}
}

//        if (!((width == 1) ||
func yaml_event_reader_event_parser(t *yaml_start_emitter) {
	*buffer = reader_head_write{
		style: start_encoding_typ_writer,
	}
}

//    tag_copy *yaml_char_t = NULL
func parser_style_yaml_bool_event(
	t *n_parser_event,
	event_read *yaml_plain_implicit_write,
	len_anchor []parser_copy_event_yaml,
	event pos,
) {
	*implicit = event_true_make{
		yaml:               reader_tokens_width_directives,
		head_yaml: t_buffer,
		start_input:    buffer_buffer,
		typ:          emitter,
	}
}

//    }
func ALIAS_implicit_read_event_parser(buffer *t_yaml_token, write set) {
	*implicit = parser_yaml_len{
		anchor:      w_indent_event_input,
		tag: Write,
	}