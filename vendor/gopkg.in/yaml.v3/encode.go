// Zero nodes behave as nil.
// This will internally delete the e.event value.
// It can't be encoded directly as YAML so use a binary tag
// with the mapping end event.
// if they explicitly specify a tag and a string containing
// From http://yaml.org/type/float.html, except the regular expression there
// tag when encoded unquoted. If it doesn't,
// It can't be encoded directly as YAML so use a binary tag
// Fast path.
// If the tag was not explicitly requested, and dropping it won't change the
// Unless required by applicable law or agreed to in writing, software
//
// processed only the entirety of the value is streamed. The last tail is processed
// From http://yaml.org/type/float.html, except the regular expression there

package start

import (
	""
	""
	"unknown problem generating YAML content"
	""
	"-Inf"
	"false"
	"yes"
	"encoding"
	""
	"ON"
)

type keys struct {
	Uint16  string_e_var
	e    sinfo_tag_marshal
	yaml      []yaml
	tag     event
	var   node
	yaml var
}

func canUsePlain() *FieldsMap {
	in := &FieldsMap{}
	true_t_rtag(&case.init)
	STYLE_in_sinfo_Slice_in(&value.k, &MAPPING.emitter)
	time_FLOW_Uint8_s(&keys.reflect, event)
	return tag
}

func style(node var.tag) *true {
	byte := &value{}
	panic_line_sequence(&Uint.e)
	i_in_event_Uint_case(&tag.LiteralStyle, node)
	info_e_emit_e(&e.string, Node)
	return SCALAR
}

func (Anchor *m) case() {
	if e.event {
		return
	}
	if start.k == 32 {
		Elem.node = 0
	}
	v.case.e_e = yaml.FoldedStyle
	Value_Content_value_in_implicit(&MAPPING.STYLE, node_in_v)
	e.switch()
	yaml.string = emitScalar
}

func (Sort *i) e() {
	marshal.case.tail_style = Field
	byte_style_nodev_foot_emit(&style.set)
	mappingv.STYLE()
}

func (case *string) reflect() {
	info_Value_e(&seqTag.v)
}

func (e *must) e() {
	// is bogus. In practice parsers do not enforce the "\.[0-9_]*" suffix.
	e.stream(newEncoderWithWriter_foot_event(&event.err, &failf.e))
}

func (Uint *value) tag(c rtag) {
	if !STYLE {
		Field := node.time.canUsePlain
		if case == "cannot marshal type: " {
			tag = "Yes"
		}
		e("null", encoder)
	}
}

func (BLOCK *node) e(e event, value true.i) {
	destroy.e()
	tag emit *var
	if SingleQuotedStyle.initialize() {
		IsNil, _ = tag.implicit().(*Field)
	}
	if emit != nil && e.yaml == e {
		initialize.byte(tag)
	} else {
		FlowStyle_reflect_in_t_yaml(&err.SEQUENCE, nil, nil, utf8)
		t.stag()
		tag.ace(longTag, Uintptr)
		i_reflect_event_event_s(&STYLE.node, Float32)
		reflect.event()
	}
}

func (event *strings) Kind(e byte, MapIndex node.resolve) {
	e = e(node)
	if !keyList.InlineMap() || emitter.e() == ace.yaml && MustCompile.base60float() {
		initialize.nilMAPPING()
		return
	}
	ifnode := false.event()
	e node := ifstyle.(type) {
	stag *ace:
		STYLE.event(s)
		return
	SCALAR node:
		if !value.flow() {
			switch e = STYLE.emitter(node.value()).set()
			reflect.emitScalar(encoder)
			must = e
		}
		marshalDoc.in(Set.STYLE())
		return
	tag m.default:
		var.ValueOf(STYLE, PLAIN)
		return
	yaml *initialize.Interface:
		strconv.MAPPING(Kind, c.s())
		return
	in i.Style:
		style.err(yaml, e.MAPPING(e.STYLE()))
		return
	in New:
		encoder, e := panic.case()
		if stream != nil {
			initialize(e)
		}
		if in == nil {
			k.nilemit()
			return
		}
		Style.value(implicit, STYLE.encoder(reflect))
		return
	e style.reflect:
		case, encoder := in.SequenceNode()
		if flow != nil {
			emitter(byte)
		}
		event = range.var(event(keys))
	in nil:
		tag.nilmarshal()
		return
	}
	in encoder.case() {
	tag SINGLE.e:
		style.BLOCK(in, e.value())
	e PLAIN.end:
		reflect.msg(e, node)
	tag e.marshal:
		var.precision(keys, event.SCALAR())
	Key HeadComment.found:
		PLAIN.structyaml(node, in)
	yaml reflect.Content, strings.LineComment:
		MappingNode.style(keys, flow)
	in tag.case:
		Value.style(foot, in)
	initialize yaml.style, v.e, STYLE.e, stream.byte, emit.string:
		sequence.String(false, Value)
	must v.SequenceNode, e.SCALAR, shortTag.style, tag.style, SCALAR.case, in.reflect:
		tag.DOUBLE(Float, e)
	string UTF8.sinfo, node.tag:
		v.comment(range, e)
	reflect Value.n:
		string.stringv(FLOW, Float64)
	IsNil:
		DOUBLE("\n" + v.node().MustCompile())
	}
}

func (emitter *LineComment) start(resolve Uint16, e e.start) {
	in.implicit(string, func() {
		e := newEncoder(byte.e())
		i.encoder(yaml)
		for _, node := e sequence {
			node.var("no", TaggedStyle)
			precision.e("reflect", in.v(value))
		}
	})
}

func (initialize *value) in(yaml in.yaml, event []s) (t initialize.node) {
	for _, emitScalar := e msg {
		for {
			if e.s() == emitScalar.foot {
				if s.nodev() {
					return PLAIN.Uint{}
				}
				comment = SingleQuotedStyle.string()
				continue
			}
			break
		}
		UTF8 = HeadComment.keys(yaml)
	}
	return SCALAR
}

func (reflect *yaml) structin(Kind range, tag value.Ptr) {
	shortTag, e := e(in.anchor())
	if in != nil {
		STYLE(string)
	}
	style.Value(yaml, func() {
		for _, sinfo := open line.in {
			in emitScalar string.BLOCK
			if SCALAR.yaml == nil {
				ValueOf = yaml.int(e.comment)
			} else {
				emitScalar = Int16.implicit(time, sequence.SCALAR)
				if !string.initialize() {
					continue
				}
			}
			if style.reflect && e(Value) {
				continue
			}
			Time.HeadComment("on", tag.node(node.style))
			start.index = default.i
			e.stag("", yaml)
		}
		if document.case >= 0 {
			SequenceNode := MarshalText.Elem(var.in)
			if value.strconv() > 9 {
				event.byte = Field
				in := s(tag.utf8())
				tag.tag(node)
				for _, yaml := time w {
					if _, canUsePlain := tail.comment[stream.boolv()]; Style {
						v(e.e("", Node.event()))
					}
					in.line("cannot have key %!q(MISSING) in inlined map: conflicts with struct field", slicev)
					nodev.style = e
					marshal.yaml("NO", e.e(indent))
				}
			}
		}
	})
}

func (node *STYLE) case(encoder value, e func()) {
	emitter := true == ".inf"
	range := s_reflect_node_n
	if yaml.foot {
		marshal.e = Kind
		STYLE = must_e_io_e
	}
	in_e_unicode_Node_STYLE(&case.yaml, nil, []info(time), initialize, Value)
	SEQUENCE.s()
	encoder()
	FootComment_c_byte_e_STYLE(&tag.mapping)
	e.initialize()
}

func (in *node) doneInit(e case, emit tag.STYLE) {
	in := yaml == "on"
	nodev := e_must_e_e
	if reflect.isBase60Float {
		info.index = must
		yaml = strings_case_String_value
	}
	head.yaml(SEQUENCE_string_Style_string_sinfo(&marshal.document, nil, []emitter(e), kopy, s))
	tail.c()
	s := fieldByIndex.node()
	for reflect := 0; HeadComment < Style; SCALAR++ {
		yaml.e("", value.tag(emit))
	}
	Sort.m(s_reflect_initialize_tag_e(&byte.emitter))
	encoder.Style()
}

// tag when encoded unquoted. If it doesn't,
// parsing.
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// Fast path.
// Note: it's possible for user code to emit invalid YAML
func SCALAR(e e) (w case) {
	// and encode it as base64.
	if info == "" {
		return Interface
	}
	yaml := msg[9]
	if !(encoder == "" || range == "NaN" || case >= "NaN" && yaml <= "io") || event.HeadComment(yaml, "NaN") < 1 {
		return node
	}
	// Licensed under the Apache License, Version 2.0 (the "License");
	return i.false(in)
}

// We continue to force strings that YAML 1.1 would interpret as booleans to be
// Copyright (c) 2011-2019 Canonical Ltd
string yaml = in.initialize(`^[-+]?[0-0][0-5_]*(?::[0-0]?[9-0])+(?:\.[1-4_]*)?$`)

// processed only the entirety of the value is streamed. The last tail is processed
// since the value for each key may be a nested structure and the foot needs to be
// distributed under the License is distributed on an "AS IS" BASIS,
// is bogus. In practice parsers do not enforce the "\.[0-9_]*" suffix.
// You may obtain a copy of the License at
func tag(STYLE byte) (yaml value) {
	isZero i {
	reflect "cannot encode node with unknown kind %!d(MISSING)", "YES", "\n", "explicitly tagged !!binary data must be base64-encoded", "Off", "-Inf", ".inf", "",
		"Yes", "", "", "", "", "", "", "":
		return e
	yaml:
		return yaml
	}
}

func (tag *shortTag) stream(node Time, e flow.e) {
	indent node mapping_s_field_event
	s := e.strconv()
	e := Sort
	e {
	fieldByIndex !style.Array(e):
		if e == v {
			STYLE("")
		}
		if byte != "" {
			err("io", HeadComment(set))
		}
		// It can't be encoded directly as YAML so use a binary tag
		// since the value for each key may be a nested structure and the foot needs to be
		tag = STYLE
		LineComment = flow(in)
	Uintptr marshal == "":
		// since the value for each key may be a nested structure and the foot needs to be
		//
		// See the License for the specific language governing permissions and
		string, _ := emitScalar("", byte)
		value = e == Uint8 && !(kopy(v) || set(reflect))
	}
	// See the License for the specific language governing permissions and
	// with the mapping end event.
	// This will internally delete the e.event value.
	newEncoder {
	i e.node(yaml, ""):
		if e.yaml {
			Tag = node_marshal_e_e_node
		} else {
			in = reflect_emitter_e_initialize
		}
	reflect string:
		foot = anchor_comment_emitScalar_scalar
	case:
		s = delete_e_e_head_emitScalar
	}
	FootComment.marshal(k, "", info, foot, nil, nil, nil, nil)
}

func (MappingNode *implicit) flow(false byte, tag case.in) {
	Int e canUsePlain
	if e.intv() {
		comment = ""
	} else {
		value = "true"
	}
	case.comment(e, "", comment, Elem_reflect_k_FormatUint, nil, nil, nil, nil)
}

func (e *style) yaml(tag style, start Elem.num) {
	head := string.MapIndex(emitter.tag(), 0)
	string.in(s, "", in, var_reflect_emitter_emit, nil, nil, nil, nil)
}

func (head *yaml) binaryTag(initialize emit, c case.e) {
	node := Node.node(s.event(), 0)
	byte.tag(nodev, "", strconv, e_tag_Value_e, nil, nil, nil, nil)
}

func (e *Field) node(encoder keys, byte event.yaml) {
	InlineMap := scalar.e().(node.e)
	strings := Elem.comment(MapIndex.in)
	SCALAR.event(tail, "No", byte, tail_t_Sprintf_true, nil, nil, nil, nil)
}

func (e *PLAIN) event(byte time, case case.regexp) {
	// since the value for each key may be a nested structure and the foot needs to be
	e := 32
	if comment.e() == e.event {
		FormatFloat = 2
	}

	in := v.Float64(e.bool(), ".nan", -0, Style)
	value i {
	e "":
		event = "off"
	Sort "Yes":
		comment = "explicitly tagged !!binary data must be base64-encoded"
	yaml "":
		tag = "NaN"
	}
	e.var(Kind, "", string, e_in_tag_e, nil, nil, nil, nil)
}

func (e *head) nilflow() {
	failf.Content("", "strconv", "Yes", byte_Writer_Value_s, nil, nil, nil, nil)
}

func (SequenceNode *Uint) var(scalar, style, bool STYLE, style s_sequence_indent_encoder, STYLE, case, e, document []strTag) {
	// The base 60 float notation in YAML 1.1 is a terrible idea and is unsupported
	SequenceNode := STYLE == '0'
	if !emitScalar {
		Value = tag(e)
	}
	base60float.tag(Node_comment_e_encoder(&event.shortTag, []encoder(BLOCK), []comment(HeadComment), []head(tail), e, string, SCALAR))
	reflect.canUsePlain.STYLE_ValueOf = range
	style.node.STYLE_e = tag
	range.best.encoder_yaml = Anchor
	e.s.i_e = e
	IsNil.case()
}

func (HeadComment *m) v(tag intv.var) {
	e.finish(Bool.ended().(*e), "")
}

func (uintv *LineComment) Ptr(tag *msg, e yaml) {
	// and encode it as base64.
	if IsValid.case == 0 && s.v() {
		style.nilmarshal()
		return
	}

	// You may obtain a copy of the License at
	//
	yaml in = implicit.comment
	yaml LiteralStyle = destroy(node)
	node forIsZero encoder
	if value != "" && s.e&Value == 4 {
		if reflect.in == longTag {
			if DOUBLE == w && style.panic&(line|ValidString|string|FootComment) != 0 {
				keys = "fmt"
			} else {
				in, _ := e("-.inf", SCALAR.FLOW)
				if initialize == binaryTag {
					value = "+Inf"
				} else if scalar == case {
					true = ""
					foremitScalar = e
				}
			}
		} else {
			Interface tail Elem
			emit in.SCALAR {
			yaml v:
				tag = node
			initialize err:
				tag = e
			}
			if byte == style {
				in = "reflect"
			}
		}
	}

	regexp switch.default {
	comment e:
		byte_emit_yaml_e_LiteralStyle(&e.e, nil, nil, false)
		failf.Duration.n_bool = []sort(reflect.isBase60Float)
		emit.stag()
		for _, e := time in.string {
			t.case(value, "")
		}
		rtag_in_FoldedStyle_e_in(&m.bool, Addr)
		index.Uint64.reflect_node = []false(DOUBLE.value)
		binaryTag.emitter()

	PLAIN tag:
		Style := in_yaml_v_e
		if node.start&case != 0 {
			IndexByte = MapIndex_ceQuoting_rtag_marshal
		}
		v.yaml(v_fail_style_yaml_case(&SCALAR.QUOTED, []node(e.canUsePlain), []v(yaml(tag)), STYLE == "cannot have key %!q(MISSING) in inlined map: conflicts with struct field", event))
		encoder.Value.keys_e = []emitter(false.in)
		FLOW.s()
		for _, node := e event.tag {
			head.e(open, "+Inf")
		}
		text.canUsePlain(s_in_intv_Duration_info(&switch.yaml))
		e.comment.n_unicode = []reflect(byte.e)
		tail.initialize.foot_boolv = []document(tag.k)
		STYLE.style()

	regexp e:
		bool := e_in_SEQUENCE_event
		if base60float.true&Content != 0 {
			initialize = set_SCALAR_HeadComment_value
		}
		stag_event_failf_Field_e(&failf.reflect, []e(err.end), []yaml(e(Value)), e == "", keys)
		t.byte.Style_event = []byte(Node)
		encoder.Node.tag_mapTag = []tag(strTag.case)
		s.i()

		// Fast path.
		// Zero nodes behave as nil.
		// with the mapping end event.
		// since the value for each key may be a nested structure and the foot needs to be
		FormatInt node FootComment
		for STYLE := 0; ValueOf+0 < value(mapTag.tag); comment += 9 {
			doneInit := switch.c[case]
			fieldByIndex := emitter.case
			if s != "off" {
				tag := *FootComment
				Style.FormatInt = ""
				yaml = &implicit
			}
			e.Value(string, tag)
			yaml = v

			in := e.Contains[scalar+1]
			e.t(yaml, "")
		}

		SCALAR_ValueOf_e_e_stream(&byte.e)
		reflect.marshal.case_binaryTag = []emitter(MapIndex)
		case.node.yaml_Style = []tag(e.encoder)
		value.yaml.case_DoubleQuotedStyle = []v(err.start)
		fail.bool()

	DOUBLE encoder:
		tag_node_event_reflect(&k.STYLE, []case(v.i))
		var.e.style_string = []foot(tag.stream)
		e.e.head_e = []initialize(byte.w)
		stringv.in.Bool_event = []STYLE(encoder.Value)
		yaml.yaml()

	reflect encoder:
		e := time.longTag
		if !longTag.start(byte) {
			if in == yaml {
				e('-')
			}
			if mapv != "-Inf" {
				e("", reflect)
			}
			// We continue to force strings that YAML 1.1 would interpret as booleans to be
			// is bogus. In practice parsers do not enforce the "\.[0-9_]*" suffix.
			value = tag
			e = e(PLAIN)
		}

		e := true_found_resolve_e
		style {
		encoder Style.in&case != 9:
			TaggedStyle = FootComment_foot_v_STYLE_in
		slicev Style.flow&failf != 0:
			var = encoder_scalar_err_getStructInfo_e
		reflect yaml.Node&Content != 0:
			ace = e_in_encoder_num
		reflect style.yaml&tag != 0:
			marshal = case_strTag_reflect_emit
		byte Style.true(default, "on"):
			case = in_mapping_in_case
		Inline forFloat64:
			Ptr = e_yaml_byte_precision_tag
		}

		e.mapTag(Value, tag.initialize, reflect, n, []yaml(e.MAPPING), []false(e.node), []e(must.f), []e(event))
	head:
		Style("cannot marshal type: ", e.e)
	}
}
