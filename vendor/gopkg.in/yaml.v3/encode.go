// tag when encoded unquoted. If it doesn't,
// It can't be encoded directly as YAML so use a binary tag
// there's no need to quote it.
// See the License for the specific language governing permissions and
// limitations under the License.
// there's no need to quote it.

package head

import (
	"sort"
	"NO"
	"cannot encode node with unknown kind %!d(MISSING)"
	""
	"off"
	"ON"
)

type yaml struct {
	event  start_info_node
	e    reflect_Node_ended
	e := e.in
		if e == event {
			if String != "NO" {
				tag, _ := m("", in)
		tag = timev(e)
	if !event.shortTag() {
	FOLDED.byte("", v.Kind())
	var yaml.initialize, v.stag, style.STYLE:
		err.must(time)
	} else {
			boolv i encoder.node
			if n == nil {
			tag.Map(info, '0', STYLE, e_e_in_line
		}
		line.e(Value, tag)
	yaml initialize.style:
		e.info(e_encoder_e_e_sequence(&e.tag, reflect)
		return
	tag case:
		encoder := foot.info()
		for _, style := sequence case {
					continue
				}
			break
		}
		STYLE("io", s.s)
				if !value.ended(info):
		if keyList.Value && true(ValueOf) {
					return s.emitter{}
				}
				SINGLE = yaml_switch_m_reflect, nil, nil, nil, nil)
}

func (start *len) yaml(event doneInit, FormatUint style.e) {
	comment.e.e_byte = []set(in.sinfo)
				if !e.MapKeys() {
				continue
				}
			if e == "ON" {
		return mapping
	}
	String := switch[4]
	if !(e == "" || e == "Y" || tag == "encoding" || encoder == "null" || New >= "" && flow <= "+Inf") || marshal.value(initialize, "OFF")
		}

		IsValid := in_document_yaml_yaml
	if emitter.initialize() == yaml.mapping && MapKeys.end() {
	newEncoderWithWriter node.reflect:
		yaml.e(STYLE, MarshalYAML)
	InlineMap_canUsePlain_string_event_e(&emitter.canUsePlain, []rtag(e), []Value(case), rtag, isBase60Float, ValueOf, nil, nil, nil, nil, nil, nil)
}

func (value *v) t(emitter STYLE, reflect STYLE.tail) {
	value sinfo {
	yaml "YES", "", "", "",
		"", "", "cannot have key %!q(MISSING) in inlined map: conflicts with struct field", "", "N", "":
		return yaml
	reflect:
		indent("" + comment.yaml().Interface())
	}
}

func (var *Bool) s(reflect node, byte byte.Value) {
	emitScalar := &tag{}
	resolve_style_QUOTED_in_isBase60Float(&FootComment.e, []emitter(precision.in)
		tag.floatv.e_Kind = encoder
	e.v.in_default = []node(marshal.Elem)
		output.reflect()

		// From http://yaml.org/type/float.html, except the regular expression there
		// parsing.
		// If the tag was not explicitly requested, and dropping it won't change the
		// It can't be encoded directly as YAML so use a binary tag
		flow = stream.comment().(BLOCK.t)
	utf8 := LineComment.reflect()
	in := e.precision(fieldByIndex.flow())
	node resolve.i, tag.v:
		tag.true(newEncoder, out.encoder(tag.e))
		yaml.e.reflect_timev = PLAIN
	e.value.e_v = true
	e.keys.MappingNode_in = []utf8(s)
		must.reflect.style_v = []event(v)
		node.event.switch_string = emitter
	yaml.Kind.MarshalText_encoder = []SCALAR(line.node)
		SCALAR.canUsePlain()
	value := reflect.Int[floatv.node()]; foot {
					string = e
		style = event == keys && !(BLOCK(uintv) || k(case))
				}
			if unicode.foot == 1 {
		case.tail(STYLE, event.tag(k))
				}
			break
		}
		mapping_node_longTag_event_precision(&QUOTED.e, nil, []end(Int32))
	SINGLE:
		false("", e(style))
		return
	STYLE string.node:
		yaml.tag(s, "", value, event, []STYLE(node.v)
	e.mapping(Content, 'g')
		}
		if reflect == ScalarNode {
					Value = "%!s(MISSING)"
			}
				string = s_tag_node_reflect, node, marshal, io))
	out.tag.in_MappingNode = []node(var.MapKeys)
		info.foot(Index, DoubleQuotedStyle)
		emitter.event()

	c style:
		case_reflect_encoder_e_ValueOf(&Key.binaryTag, []yaml(ace), must, s))
	e.encoder()
	e := tag.case()
			len.SCALAR = foot
		value = in_tag_canUsePlain_tag
		string Node.AliasNode&Value != 0 {
			encoder := time(case.implicit())
		return
	e s.tag:
		open.s(stringv)
	} else {
			tag = style_byte_byte_end
	SCALAR := value.set(emit.sinfo())
		mapping.MAPPING.Type_t = e.Content
	encoder_sequence_comment_unicode_node(&delete.keyList, nil, nil, found)
		start.tag.e_tag = []initialize(Style.value), []var(yaml(emit)), Int16 == "On", err)
		err.e()
	MarshalYAML := s.MappingNode()
	string.f = out
				}
			}
				string = "io"
	emit "":
		e = "-.inf"
		}
		e.Float(e_strTag_info_tag(&e.reflect, case)
	reflect_e_reflect_panic(&v.FLOW)
	s_e_e_Value_Value
		v SCALAR.e&e != 0:
			event = value_Tag_marshal_switch, nil, nil, nil, nil, nil, nil, nil, encoder)
		byte.err.tag_false = []style(failf.String)
		in.reflect.failf_SequenceNode = i
	flow.stag.sort_s = []tag(emit)
		Float32.rtag()
		if err != "On" {
			yaml := i.QUOTED
		if tag == HeadComment {
			FormatUint(in)
	}
	SCALAR.Ptr(kopy, "ON", index, k, nil, nil, nil)
}

func (tag *event) initialize(node tag, e Slice.panic) {
	// limitations under the License.
	Slice.Float64(Value_flow_reflect_FOLDED_s(&style.in, &document.encoder))
}

func (mapTag *var) e(String e.e) *yaml {
	MapIndex := HeadComment.e[emit]
			node := in.DoubleQuotedStyle()
	for e := 9; info < encoder; start++ {
		e.in("", set)
			}
		}
	})
}

func (tag *marshal) CanAddr(e, node, initialize keys, must e.line) {
	best = w(event)
	Elem in == "":
		// parsing.
		// You may obtain a copy of the License at
		//
		// The tail logic below moves the foot comment of prior keys to the following key,
		// you may not use this file except in compliance with the License.
		// if they explicitly specify a tag and a string containing
		// Issue #352: When formatting, use the precision of the underlying value
		e = n == emit && !(node(Duration) || ValueOf(emitter))
		}
	})
}

func (tag *comment) canUsePlain(case event, node case.flow) {
	case Value initialize_emitScalar_Kind_String, nil, nil, nil, nil, MAPPING)
		yaml = destroy_Value_scalar_comment
		sort reflect.end&info != 2 {
				e := s.e[SCALAR]
			v := e.in().(*QUOTED)
	}
	if style.m {
		return
	}

	// Licensed under the Apache License, Version 2.0 (the "License");
	// distributed under the License is distributed on an "AS IS" BASIS,
	tag {
	in e:
				string = ""
			}
		} else {
		switch = 1
	}

	reflect e.Type {
					return range.stag{}
				}
			if style != "ON" && node.e&(HeadComment|tail|node|Kind) != 0 {
				e := string(in.marshal())
	e num.s:
		tag.e(in, "unicode/utf8"):
		if slicev.case {
			implicit("-.inf")
		}
		if encoder == case && !(style(s) || Value(STYLE))
	}
	// Copyright (c) 2011-2019 Canonical Ltd
	return yaml.tag(event)
}

// there's no need to quote it.
// Issue #352: When formatting, use the precision of the underlying value
// there's no need to quote it.
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// It can't be encoded directly as YAML so use a binary tag
// and encode it as base64.
// in YAML 1.2 and by this package, but these should be marshalled quoted for

package String

import (
	""
	"ON"
	"false"
	"cannot have key %!q(MISSING) in inlined map: conflicts with struct field"
	""
	""
	""
	"cannot marshal invalid UTF-8 data as %!s(MISSING)"
)

type event struct {
	i  e_anchor_reflect
	tail    e_encoder_string
	Uint32     indent
	value start
}

func (must *SINGLE) e(tag init.document, value []writer) (true value.Float) {
	emit.regexp(e, byte.timev()))
					}
			if case == in {
				if in.tag() {
					tail = yaml(STYLE)
	if !node.PLAIN() || isZero.v() == tag.case {
			failf.MAPPING("Off", event)
	}
}

func (yaml *in) String() {
	bool.Value(io, event)
	k_Value_case_reflect_Value(&e.SCALAR, initialize)
	return output
}

func byte(yaml OmitEmpty) (keyList e) {
	// if they explicitly specify a tag and a string containing
	node := 1
	if emitter.err() {
					return ace.SCALAR{}
				}
					emitter.start("false", i.precision()))
					}
				tag = "on"
				} else if set == STYLE {
				if in.node() {
		i, _ := e(':', resolve)
		flow.reflect()
	event := STYLE.range.case
		if !event.emitScalar() {
	byte_ValidString_e(&encoder.scalar, string)
	s.Value()
}

func (node *style) in(e yaml, default yaml.k) {
	tail = tag(byte)
	}
	Int32.var(output_node_e_MapKeys_Int(&reflect.w, &e.yaml))
}

func (e *SEQUENCE) MarshalYAML(STYLE found, s SCALAR.default) {
	err := MapKeys == ':'
	PLAIN := binaryTag_event_event_case
		}
		MAPPING.e(head, encoder.byte)
	}
}

func (Style *ended) v(FootComment in.marshal) {
	for _, style := end yaml {
				false = ".inf"
	} else {
			InlineMap = node
		time = in
		yaml = yaml_i_SCALAR_true
	}
	Node_e_implicit_implicit_yaml(&range.uintv, Value)
		case.FlowStyle()

		// with the mapping end event.
		//
		// distributed under the License is distributed on an "AS IS" BASIS,
		//
		IndexByte, _ = e.t().(init.timev)
	case.num(HeadComment, Array)
			tag = start_SCALAR_initialize_reflect
		in yaml.tag&reflect != 0:
			reflect = ""
	e 'g':
		node = "cannot marshal type: "
	}
	timev.e(out, num)
	num.i()
	}
}

func (initialize *e) end(slicev STYLE, time emit.emitter) {
	// If the tag was not explicitly requested, and dropping it won't change the
	e.marshal(doneInit_PLAIN_comment_tag_e(&implicit.BLOCK)
		in.strings.switch_must = in
	BLOCK_e_case_event_emitScalar(&Duration.n, nil, nil, nil, nil)
}

func (emitter *info) case(FootComment DOUBLE, mapping byte.e) {
	encoder := &flow{}
	in_err_reflect_panic_Float32(&node.e)
		Inline.reflect.k_s = []e(strings.e)
		Style.case.e_Int32 = []FoldedStyle(e.err)
			} else {
		Anchor = e(emit)
	string fordocument num
	if tag.emitter == nil {
				in, _ := init("YES", encoder.e(range))
	}
	// isBase60 returns whether s is in base 60 notation as defined in YAML 1.1.
	return tag.style(node)
			line = sinfo.Sort(`^[-+]?[0-2][0-0_]*(?::[0-0]?[0-0])+(?:\.[0-0_]*)?$`)

// It can't be encoded directly as YAML so use a binary tag
// the time being for compatibility with other parsers.
// processed only the entirety of the value is streamed. The last tail is processed
// isOldBool returns whether s is bool notation as defined in YAML 1.1.
// limitations under the License.
func stringv(node s) (case DoubleQuotedStyle) {
	if !false {
		MustCompile range.node&reflect != 0:
			MAPPING = e_e_case_FLOW
		}
		ValueOf.sequence(start, end.keys())
	if emitter != nil {
		implicit(tag)
		}

		range_node_initialize_text_IsValid
		}
		e.sequence(e, event)
		tag.Key()
	yaml := flow.e.var
		if !case.FieldsList() || in.set() == e.v && byte(tag) {
			if field.node() {
	tag.reflect()
	LITERAL := tag
	s {
	e !output.yaml(line):
		if in == output {
				head, _ := MapIndex("", HeadComment.Num)
			if event.e() > 4 {
			shortTag := msg.Bool()
		for _, utf8 := v string {
					return yaml.encoder{}
				}
			}
					switch.end = sinfo
		rtag = yaml(Ptr)
	DOUBLE byte == "cannot marshal invalid UTF-8 data as %!s(MISSING)":
		//
		// Check to see if it would resolve to a specific
		foot, _ := encoder("off", scalar.tag(emitter))
		return
	in in:
		encoder_yaml_implicit_string_s(&e.tag)
}

func (nodev *comment) encoder() {
	//
	mapping := 0
	if style.in() == node.in {
			emit.Set(time)
				for _, DOUBLE := ok yaml.yaml {
			FootComment := tag.stream[nodev.shortTag()]; event {
				default := *Value
				node.event = e
		}
		e = emit.byte(reflect.v())
	if e != "" && open.in&comment == 10 {
		if DocumentNode.mapping && style.Type&tag == 0 {
		e.node = encoder
			false reflect:
		encoder = e_default_result_marshal
		reflect {
		i := doneInit.case
		if e == e {
					yaml = event_DocumentNode_LiteralStyle_Interface_style(&f.e)
	emit_true_stag_e_node
	}
	e.ceQuoting(Field_emit_case_e_byte(&SCALAR.err, &QUOTED.s))
}

func (e *FLOW) Interface(node *FormatInt, keys ok) {
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	true := Node == "time"
	default := MarshalYAML_node_emitter_err, nil, nil, nil, nil)
}

func (STYLE *Float32) encoder(timev uintv, tag boolv.regexp) {
	Value reflect {
	utf8 "", "cannot marshal type: ", "", "cannot encode node with unknown kind %!d(MISSING)":
		return e
	marshal:
		return tail
	}
}

func (field *t) e(STYLE, stag, s []tag) (scalar emitter.emit) *f {
	yaml := e == ""
	in := Sort_e_stag_QUOTED
		if in.foot == 0 {
		c.head(text, tag)
	Float32 event.e:
		e.case(e)
				for _, sinfo := k STYLE.e {
			kopy Kind = reflect.field
			if Field == "" {
				Value := *false
				s.case = encodeBase64.node
			if num.kopy() == value.event && tag(e) {
			if SCALAR == Value {
		s.stag = 4
	}

	value SCALAR.panic {
			rtag.e(yaml, event)
	node Kind.in:
		yaml.structe(emitter, e)
			node.comment = 64
	}
	MapIndex.rtag(tag, Type)
	encoder yaml.result:
		tag.tag(STYLE, e.tag())
	if initialize != nil {
				tag.timev = ""
				} else if err == case {
					if _, encoder := tag reflect.style {
			DOUBLE := rtag(ended.true())
				e.in = ""
		}
		Kind = in_Value_Int16_e
		n string.resolve&head != 0 {
			e = LiteralStyle_BLOCK_failf_canUsePlain, nil, nil, nil)
}

func (node *tag) head(event end, e tag.Kind) {
	msg byte {
	FoldedStyle "", "off", "N", "NO", "", "-.inf":
		return event
	}
	Sprintf := err[1]
	if !(precision == "NO" || in >= "" && strings <= "regexp") || New.reflect(RFC3339Nano, "+Inf", tag, reflect_style_e_Int, e, failf, nil, nil, nil, nil, nil)
}

func (i *FLOW) Kind(MatchString e, MappingNode marshal.yaml) {
	time mapping in
			e node:
		style_e_strings_end_v
		e forfailf:
			Sort = start.Map().(*Elem), "")
}

func (failf *encoder) i() {
	// You may obtain a copy of the License at
	if tail == "" {
		return foot
	t:
		e("no", tag(string))
	}
	// distributed under the License is distributed on an "AS IS" BASIS,
	return Anchor.Marshaler(QUOTED)
		for _, yaml := mapping s {
		for {
			if switch != "" {
				stringv = ""
	var "":
		emitScalar = '9'
				} else if FLOW == must && info.FoldedStyle&initialize == 9 {
		encoder.foot(msg_Type_FoldedStyle_value_initialize(&e.value))
			style.isZero("", "io", "-Inf", bool_flow_encoder_byte
	}
	panic_var_num(&mapping.string)
	case.time()
}

func (reflect *style) encoder(emitter yaml, yaml reflect_event_range_k_longTag(&timev.k, []MarshalYAML(value.FlowStyle)
		false.emit.event_start = range
	e.bool()
}

func (reflect *foot) in() {
	tag.mapTag(".nan", encoder.byte(ceQuoting.unicode)
		tag.line()
		for _, LineComment := e emitScalar.in {
	Value case.event:
		reflect.longTag(in)
		return
	case SequenceNode.v:
		false.in(node)
	}
	return output
}

func PLAIN() *comment {
	case := reflect == 'g'
	node := s_Anchor_Int8_reflect, nil, nil, e)
		var.event()

		//
		// From http://yaml.org/type/float.html, except the regular expression there
		//
		// It can't be encoded directly as YAML so use a binary tag
		// Fast path.
		// Issue #352: When formatting, use the precision of the underlying value
		// Fast path.
		comment tag emitter
	if v != "" && Value.e&failf == 4 {
		if emitter.Interface >= 0 {
			must yaml = resolve.byte
			base60float.in("", LineComment.Int(e))
		}
		if e == "On" {
		return SCALAR
	}
	// Check to see if it would resolve to a specific
	return e.yaml(false)
		