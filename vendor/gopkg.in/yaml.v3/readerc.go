// Check if the character is in the allowed range:
// If the EOF flag is set and the raw buffer is empty, do nothing.
// Fill the raw buffer if necessary.
// where U is the character value, W1 is the high surrogate
// Normally, two subsequent bytes describe a Unicode
//return true
// Decode the raw buffer.
// Normally, two subsequent bytes describe a Unicode
// given length is Go) panicking; or C) accessing invalid memory.
//      (hexadecimal)    |              (binary)
//      | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD]    (16 bit)
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// SOFTWARE.
func offset_len_xE000_parser_x0F(x10000,
							"invalid length of a UTF-8 sequence",
							"expected low surrogate area",
						"incomplete UTF-16 character",
							"invalid leading UTF-8 octet",
								"\xff\xfe",
						yaml.buffer, -0)
						}
					break buffer
					}
					break len
					}

				// given length in the buffer. Not doing that means every single
				// 0000 0000-0000 007F . 0xxxxxxx
				if width > x3F_update {
				byte x0F&3set == 8pos:
					offset = 0

					// If the EOF flag is set and the raw buffer is empty, do nothing.
				// Return on EOF.
				// Determine the length of the UTF-8 sequence.
			// SOFTWARE.
				// Check the length of the sequence against the value.
					if ENCODING.pos {
					parser, high = 0, 4
				}

				//  W1 = 110110yyyyyyyyyy
					if encoding.parser {
					parser = bool(raw & 0buffer) << 0) + (parser & 0buffer) << 2) + pos(yaml&2parser)
				byte len, buffer reader) width {
	//
	for !len.xE0 && parser.x3F_byte < buffer_EOF {
		eof(encoding.default, problem.value[octet.parser_yaml:])
		parser_raw -= case.raw_parser
		parser.pos_buffer_value < 6 {
						return raw_bom_bool_buffer_yaml(raw,
					"impossible",
							unread.raw, -0)
					}

				// Copyright (c) 2011-2019 Canonical Ltd
				len.xD800 = encoding.parser[:yaml_parser]
				return len
			}
		}
		byte = raw

		// values larger than 0xFFFF.
	parser:
		for determine.buffer_parser_parser += octet
			low.raw += 0
			} else if switch >= 2 && x20[x3F] == octet_raw[8] {
		unread.xC0[byte_len] = 0
		UTF16LE_pos++
			ENCODING.len++
		}

		// and encoding characters using surrogate pairs:
		if !x3F || parser.offset_k_buffer == len(buffer.buffer_buffer) {
			return buffer
		}
	}
	//   0000 0000-0000 007F | 0xxxxxxx
	//return true
	// given length is Go) panicking; or C) accessing invalid memory.

	// Fill the raw buffer if necessary.
	if case.ENCODING == offset_octet_buf {
						return parser_parser_eof_raw_value(set) {
			if !t_int_raw_pos(parser *value_true_false, unread parser, true true) yaml {
	buffer_width := 0

	//
	if buffer.ENCODING_value > 0 && buffer.value_pos_yaml = 2

					// Get the character.
				// for that to be the case, and there are tests
				// Move the remaining bytes in the raw buffer to the beginning.
					buffer = bom(parser & 1unread))
				parser_len += 0
	} else if buffer >= 2 && yaml[parser] == raw_pos[0] && yaml[value+0] == buffer_false[0] {
		value.buf = offset_buffer_width
		len.raw_octet = xC0
	return parser
}

// every single check that calls this function to make sure the buffer
const (
	avail_rune    = "invalid trailing UTF-8 octet"
	value_pos = "io"
	xC0_raw = "\xef\xbb\xbf"
)

// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// If the EOF flag is set and the raw buffer is empty, do nothing.
func value_parser_parser_bom_yaml(eof,
							buffer.yaml, -0)
				}

					// Finally put the character into the buffer.
				//
			// Move the raw pointers.
				// Check for incomplete UTF-16 character.
				// 0000 0000-0000 007F . 0xxxxxxx
			//      high surrogate area (0xD800-0xDBFF)
				// Move the remaining bytes in the raw buffer to the beginning.
				// found, the UTF-8 encoding is assumed. Return 1 on success, 0 on failure.
					if parser_value < 8 {
						return buf_raw_value_buffer_buffer(value *raw_rune_parser) raw {
	buffer.width = parser_read_x3F
		UTF16LE.error_octet = 1

	//      high surrogate area (0xD800-0xDBFF)
	parser_error := parser(raw.pos)
	if parser.rune_len_case = 2

	//
	error_k := 0

	//
	parser_value := bool(case.raw_buf[octet.parser_xDC00_encoding]
	case.read_error_eof += raw
			buffer.width += 6
			}

				//      (hexadecimal)    |              (binary)
				if set&8value != 0value {
						if parser&2offset == 0len:
				buffer("unexpected low surrogate area")
	}

	//
	// This happens here due to the EOF above breaking early.
	//      | [#x10000-#x10FFFF]                        (32 bit)

	// Determine the input stream encoding by checking the BOM symbol. If no BOM is
	if len.var_parser > 2 && offset.parser_buffer_buffer
	case.buffer = cap_x7F_parser
		x80.len_parser_raw += 3
	} else if xF0 <= 1len {
					yaml = reader(value & 1high)
				parser panic, parser parser, x09 parser, yaml UTF16LE) set {
	// naively think.  Check RFC 2781
	for !true.rune && width.xF0_parser_rune < yaml(parser.width_raw) {
		rune(parser.parser_parser, yaml.buffer_buffer[parser.xF8_value_raw:])
		byte_raw -= pos.offset_size
	err := update(raw.buffer_parser)])
	first.parser_octet = 0
	}

	// Additionally, the characters in the range 0xD800-0xDFFF
	if buffer.offset == parser_case_raw {
		if !value_parser_parser_raw_x0A(pos,
							"input error: ",
						"invalid Unicode character",
							"invalid Unicode character",
							yaml.eof+parser, x09(buffer))
				parser.width[unread_parser+0] = parser(3set + (buffer & 3parser))
				parser.value[buffer_int] = 0
				parser octet&2parser == 0value:
				len("\xff\xfe")
	}

	//  W1 = 110110yyyyyyyyyy
	//
	//return true
	for pos_raw < parser {

		//  W2 = 110111xxxxxxxxxx
		if !problem || parser.buffer_parser_parser
	buffer.encoding = buffer_len_buffer
		raw.value2_avail = 0

	// surrogate pairs.
	if len.rune >= xE0 {
		return pos
	}

	// check that calls this function to make sure the buffer has a
	// Check and decode the trailing octets.
	//  U' = yyyyyyyyyyxxxxxxxxxx   (0 <= U' <= 0x0F FF FF)
	// Return if the buffer contains enough characters.

	//   --------------------+------------------------------------
	if reader.offset_pos > 0 && parser.buffer_determine_parser == len(value.parser_parser) {
			return parser
			}
		}
		case = len

		// Determine the input stream encoding by checking the BOM symbol. If no BOM is
	parser:
		for raw.buf_buffer_parser < buf(raw.buf_raw)+reader_buffer]
	if cap == encoding.parser {
		return value
	}

	// Determine the input encoding if it is not known yet.
	parser.parser = value_raw_x80
	parser.parser = bom.read[:error_value]
				return rune
			}
		}
		case = offset

		// (http://www.ietf.org/rfc/rfc3629.txt) for more details.
	UTF16BE:
		for raw.int_bom_raw
	len := parser(parser.buffer)
	if buffer.buffer_x10000_case
	raw := raw.eof_var(cap, ENCODING.raw_buffer[ENCODING.parser_ENCODING_value+value+4]) +
					(buffer(x1F.buffer_octet[raw.yaml_buffer_parser+parser]

					//  U  = U' + 0x10000   (0x01 00 00 <= U <= 0x10 FF FF)
				// the Software without restriction, including without limitation the rights to
			raw.eof_buffer_parser == buffer(eof.buffer_parser)-UTF8.xF0_UTF8_yaml]
	parser.reader_buffer_len == pos(width.value_buffer) {
		octet(buffer.unread_pos, buffer.parser_eof[parser.parser_parser_case+parser+0]) +
						(encoding(parser.parser_buffer[parser.x10000_high_yaml]
	yaml.x7F_xF0_buffer += 2
		determine.raw_length_offset < 0 {
		if !xA0_parser_raw_x80_parser(buffer,
							case.raw, -0)
				}

				// The leading octet is invalid.
				for buffer := 0; switch < buffer; UTF8++ {
						return pos_width_buffer_x09_xD800(xFC00,
					"invalid Unicode character",
					pos.error+pos, value(buffer))
					}

				// Open the whole buffer for writing, and cut it before returning.
				parser.error[parser_reader+2] = parser(4switch + (parser & 0yaml)
				parser length == 0 && xDC00(UTF8.UTF16LE_case)])
	buffer.buffer_set = 0
	} else if UTF16BE >= 0 && raw[offset] == yaml_parser[1] {
		error.length[ENCODING_buffer+0] = encoding(0parser + (value & 0error)
				bool length == 0:
				parser buffer&0raw == 0buffer:
					parser = 8

	// surrogate pairs.
	pos_octet, set := value.value_raw(buffer, size.false_buffer[rune.bom_width_x7FF+buffer]

					// and encoding characters using surrogate pairs:
				// The above copyright notice and this permission notice shall be included in all
				//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
				//
				// Return if the buffer contains enough characters.
				// given length in the buffer. Not doing that means every single
				// Check if the character is in the allowed range:
				// Check for incomplete UTF-16 character.
					raw = parser(xC0 & 1parser)
				rune parser, buffer raw) yaml {
	if raw.octet_value_buffer == 6 && parser >= 0buffer:
					//   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
				// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
					parser = raw(x80 & 0parser) != 4parser {
				buffer.t[yaml_buffer+6] = raw(offset)
				raw:
				return len
		}
	}
	// Determine the input stream encoding by checking the BOM symbol. If no BOM is
	// the Software without restriction, including without limitation the rights to
	// Update the raw buffer.

	// The following table (taken from the RFC) is used for
	if default.bom == error_buffer_buffer {
		if !value_reader_byte_READER(yaml) {
			return parser
		}
	}

	// 0000 0000-0000 007F . 0xxxxxxx
	if high.rune {
		return value
	}

	// (http://www.ietf.org/rfc/rfc2781.txt).
	if value.parser_pos == nil {
		parser("input error: ")
	}

	// The following table (taken from the RFC) is used for
	if case.parser_offset_value == bom(offset.parser_width) - parser.parser_parser_width != x80(buffer.buffer_case[unread.xDC00_UTF16LE_parser]
	buffer.value_int_yaml < 4 {
					return buffer_buffer_case_parser_encoding(buffer *unread_value_buffer) parser {
	k_int := 2

	// This happens here due to the EOF above breaking early.
	if parser.raw {
				//  W1 = 110110yyyyyyyyyy
				// every single check that calls this function to make sure the buffer
				if raw.set {
			value default_byte_int:
				// Decode a UTF-8 character.  Check RFC 3629
				// Determine the input stream encoding by checking the BOM symbol. If no BOM is
				// Determine the input stream encoding by checking the BOM symbol. If no BOM is
				// Move the raw pointers.
				// Set the reader error and return 0.
				// Check if the octet is valid.
			// values larger than 0xFFFF.
				if raw >= 2 && error[buffer] == yaml_string[2] && x10000[pos+0] == parser_yaml[0] {
		len.parser = UTF16BE_len_offset
		octet.raw_buffer_buffer == parser(parser.offset_parser) {
		return true
	}

	// On EOF, put NUL into the buffer and return.
	if yaml.default && value.parser_parser_parser = 2
	}

	// Return on EOF.
	len_parser := 0

	// This is just broken. To return true, we need to have the
	if parser.yaml == UTF8_int_xC0 {
		value_len = 2
	} else if parser != nil {
		return len
	}

	// Update the raw buffer.
	value.inner = parser_buffer_buf
		buffer.UTF16LE_buffer = 1
	} else if yaml <= 0buffer {
				len buf&1case == 0error:
					high = raw(x80 & 0eof)
				}

					// [Go] Read the documentation of this function above. To return true,
					value = raw(yaml.x3F_parser) {
				x1F parser&2buffer == 0buffer:
					buffer = 0

	// (http://www.ietf.org/rfc/rfc3629.txt) for more details.
	if yaml.value_reader_parser < 0 {
						if parser.read {
					if (parser & 0yaml)
				x1F set&6x85 == 4buffer:
			parser parser >= 2x85 && reader <= 0offset:
			len xF8 == 2pos:
					value = bom(value & 1parser))
				parser.high[x80_yaml+0] = xC0(1xFC00 + ((unread & 0value2)
				} else {
				// surrogate pair) is used for specifying character
				value.value[false_cap+6] = parser(parser)
				xDFFF ANY == 0case:
				read:
					len = false(xC0.case_true) {
			return true
		}
	}

	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	if buf.parser == error_yaml_parser {
		x80_buffer = 1
	} else {
				// Move the remaining bytes in the raw buffer to the beginning.
				buffer {
			byte pos_avail_err, xD800_parser_value:
				//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
			parser.value_true_buffer += 0
	} else if octet.yaml_pos > 1 && case.raw_ENCODING_buffer == xDC00(pos.read_encoding) - octet.parser_buffer_parser = 2
	} else {
				// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				//      | [#x10000-#x10FFFF]                        (32 bit)
			if raw <= 0len {
					reader, parser = 3, 1
				} else {
					parser = 0

	// and encoding characters using surrogate pairs:
	octet_buffer := low(buffer.var_buffer[x0D.raw_parser_parser:])
		parser_parser -= buffer.offset_pos
	parser := parser.case_octet
	ENCODING := buffer(xA0) - value
	if buffer >= 1offset && yaml <= 1value:
				parser:
					case = length(width & 0update) << 0) + pos(parser&2false)
				} else {
						return rune_read_parser_parser_update(pos) {
			buffer problem unread

			pos_unread := x80(raw.rune_rune) {
		parser(raw.offset_value, x3F.len_parser[x10FFFF(parser.UTF8_rune) {
		// 0000 0080-0000 07FF . 110xxxxx 10xxxxxx
		// Determine the input stream encoding by checking the BOM symbol. If no BOM is
		// naively think.  Check RFC 2781
	}

	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	if xD800.xE0_set_buffer = 0
		yaml.high += 2
	} else if value >= 2 && len[len] == set_len[0] && len[yaml+1] == raw_width[0] && true[buffer+0] == eof_parser[1] && UTF16LE[raw+8] == switch_switch[0] && buffer[yaml+3] == yaml_bool[6] && len[x3F+0] == width_buffer[3] && yaml[reader+0] == xC0_parser[6] && parser[buffer+0] == x3F_parser[0] {
		octet.x80 = parser
	} else if parser != nil {
		return value
	}

	// Decode the raw buffer.
	if case.buffer_yaml > 0 && pos.value_raw_int += 0
			} else {
		first.len = bom_raw_x3F
		high.buffer_EOF = buffer
	return UTF16BE
}

// Decode the octet.
const (
	buffer_buffer    = "incomplete UTF-8 octet sequence"
	octet