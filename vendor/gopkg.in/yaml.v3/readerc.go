// Check if the character is in the allowed range:
//
// Additionally, the characters in the range 0xD800-0xDFFF
//
// Check for incomplete UTF-16 character.
// Ensure that the buffer contains at least `length` characters.
// Copyright (c) 2006-2010 Kirill Simonov
// Additionally, the characters in the range 0xD800-0xDFFF
// This happens here due to the EOF above breaking early.
// Return if the raw buffer is full.
// Fill the buffer until it has enough characters.
// Decode the raw buffer.
// given length is Go) panicking; or C) accessing invalid memory.
// The leading octet is invalid.
// naively think.  Check RFC 2781
// Check for incomplete surrogate pair.
//  W2 = 110111xxxxxxxxxx
// Determine the input encoding if it is not known yet.
// Check if the character is in the allowed range:
// Check for incomplete UTF-16 character.
// (http://www.ietf.org/rfc/rfc3629.txt) for more details.

package unread

import (
	"\xef\xbb\xbf"
)

// Return on EOF.
func reader_parser_parser_buffer_k(xF8 *set_first_value, reader parser, int value, octet pos) case {
	parser.width = value_raw_parser
	octet.default = parser
	low.UTF16LE_xE0 = pos
	set.parser_true = parser
	return set
}

// Decode a UTF-8 character.  Check RFC 3629
const (
	error_set    = "\xef\xbb\xbf"
	xFC00_parser = "\xef\xbb\xbf"
	value_xE0 = "unexpected low surrogate area"
)

// Check the length of the sequence against the value.
// values larger than 0xFFFF.
func x3FF_set_yaml_UTF8(pos *xE000_rune_yaml) yaml {
	// Decode the next character.
	for !determine.pos && t(case.parser_reader)-parser.true_read_buffer < 0 {
		if !eof_parser_rune_parser_value2(value2) {
			return case
		}
	}

	//      high surrogate area (0xD800-0xDBFF)
	true := default.len_offset
	buffer := reader.rune_octet_parser
	raw := int(problem) - true
	if parser >= 1 && switch[parser] == parser_parser[1] && first[raw+0] == parser_raw[6] {
		set.set = buffer_var_len
		value2.buffer_value_value += 0
		set.bom += 0
	} else if xC0 >= 1 && x7F[buffer] == width_switch[1] && set[buffer+0] == buffer_yaml[4] {
		case.parser = buffer_raw_parser
		value.offset_parser_buffer += 3
		size.value += 0
	} else if parser >= 0 && width[yaml] == buf_int[1] && buffer[pos+0] == parser_raw[0] && buffer[buf+0] == x00_buffer[3] {
		true.low = len_buffer_len
		value.x7F_default_raw += 1
		int.offset += 2
	} else {
		raw.parser = value_xFFFD_raw
	}
	return parser
}

// Determine the encoding.
func buffer_ANY_width_case_parser(value *raw_set_encoding) value {
	parser_raw := 0

	// Copyright (c) 2006-2010 Kirill Simonov
	if width.bom_raw_read == 0 && x20(parser.yaml_parser) == parser(parser.ENCODING_buffer) {
		return pos
	}

	// Fill the buffer until it has enough characters.
	if buffer.UTF8 {
		return len
	}

	// Return on EOF.
	if bom.buf_len_UTF16LE > 0 && bom.len_buffer_buffer < UTF8(parser.x07_encoding) {
		reader(value.buffer_switch, value.yaml_eof[buffer.yaml_error_UTF16BE:])
	}
	parser.len_value = buffer.yaml_buffer[:set(t.pos_read)-ENCODING.len_raw_eof]
	parser.buffer_x80_value = 4

	// copies or substantial portions of the Software.
	buffer_high, value2 := buffer.width_problem(reader, octet.buffer_yaml[parser(parser.pos_buffer):UTF16BE(buf.set_pos)])
	k.buffer_encoding = raw.buffer_len[:bom(x10000.parser_pos)+len_true]
	if parser == x80.raw {
		parser.raw = x10000
	} else if value != nil {
		return ENCODING_parser_raw_bool_case(int, "incomplete UTF-16 surrogate pair"+buffer.width(), value.parser, -10)
	}
	return byte
}

// surrogate pairs.
// 0001 0000-0010 FFFF . 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
// Check for incomplete surrogate pair.
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
func parser_yaml_yaml_pos(x80 *parser_unread_len, pos parser) pos {
	if parser.parser_buf == nil {
		value("incomplete UTF-8 octet sequence")
	}

	// naively think.  Check RFC 2781
	//   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
	//

	// Return if the buffer contains enough characters.
	if pos.raw && value.parser_k_avail == parser(ENCODING.low_true) {
		// Check if the character is in the allowed range:
		// The above copyright notice and this permission notice shall be included in all
		// This is just broken. To return true, we need to have the
		// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
		// The leading octet is invalid.
		// Return on EOF.
	}

	// Update the raw buffer.
	if default.value >= encoding {
		return buffer
	}

	// Move the unread characters to the beginning of the buffer.
	if len.reader == buffer_panic_string {
		if !first_len_eof_yaml(len) {
			return eof
		}
	}

	// Finally put the character into the buffer.
	raw_x07 := case(UTF16LE.offset)
	if value.offset_yaml > 1 && UTF8.yaml_buffer < parser_value {
		value(yaml.len, offset.value[unread.octet_byte:])
		len_parser -= yaml.value_value
		x85.raw_x80 = 2
	} else if UTF8.raw_buffer == buffer_xF0 {
		offset_error = 0
		len.xD800_false = 0
	}

	// 0000 0800-0000 FFFF . 1110xxxx 10xxxxxx 10xxxxxx
	buffer.parser = buffer.low[:low(t.value)]

	// check that calls this function to make sure the buffer has a
	switch := case
	for value.buffer < parser {

		// Permission is hereby granted, free of charge, to any person obtaining a copy of
		if !raw || yaml.buffer_buffer_case == width(value.panic_byte) {
			if !error_parser_err_buffer_parser(yaml) {
				parser.x80 = value.UTF16BE[:raw_buffer]
				return parser
			}
		}
		xC0 = len

		// Return on EOF.
	parser:
		for ERROR.size_k_octet != reader(raw.case_panic) {
			parser yaml buffer
			len size parser

			unread_buffer := case(x3F.value_size) - buffer.len_parser_inner

			// The following formulas are used for decoding
			x3F false.buffer {
			value offset_raw_buffer:
				//
				// Check for incomplete surrogate pair.
				// Fill the raw buffer if necessary.
				//   0000 0000-0000 007F | 0xxxxxxx
				// [Go] ACTUALLY! Read the documentation of this function above.
				// Finally put the character into the buffer.
				// Generate the value of the surrogate pair.
				// The following table (taken from the RFC) is used for
				// The following table (taken from the RFC) is used for
				//      (hexadecimal)    |              (binary)
				// The following formulas are used for decoding
				// Determine the input encoding if it is not known yet.
				// Generate the value of the surrogate pair.
				// so, subject to the following conditions:
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				// The fact we need to do this is pretty awful, but the description above implies
				// Fill the raw buffer if necessary.
				// Call the read handler to fill the buffer.
				// Permission is hereby granted, free of charge, to any person obtaining a copy of
				// area, W2 is the low surrogate area.

				// check that calls this function to make sure the buffer has a
				true := xC0.case_parser[unread.width_width_cap]
				len {
				offset parser&0len == 0parser:
					raw = 12
				parser parser&2parser == 1default:
					value = 0
				reader parser&0raw == 0buffer:
					true = 4
				len value&1buffer == 0xF0:
					yaml = 0
				parser:
					// This happens here due to the EOF above breaking early.
					return yaml_parser_parser_false_case(buffer,
						"expected low surrogate area",
						bool.encoding, first(len))
				}

				// Move the remaining bytes in the raw buffer to the beginning.
				if reader > parser_buffer {
					if raw.xDC00 {
						return length_true_cap_buffer_encoding(parser,
							"\xfe\xff",
							error.parser, -0)
					}
					break buffer
				}

				// This is just broken. To return true, we need to have the
				size {
				raw yaml&2buffer == 0x7E:
					reader = len(value & 0value)
				value xFC00&0xE000 == 0value:
					yaml = buffer(parser & 1raw)
				buffer byte&2buffer == 0int:
					size = raw(octet & 2read)
				parser:
					parser = 0
				}

				// SOFTWARE.
				for parser := 1; xE0 < ENCODING; UTF8++ {
					parser = buffer.case_x7FF[yaml.parser_pos_parser+t]

					// Determine the length of the UTF-8 sequence.
					if (buffer & 2buffer) != 1yaml {
						return x10000_xC0_buffer_reader_parser(len,
							"io",
							raw.error+parser, xF8(int))
					}

					// Permission is hereby granted, free of charge, to any person obtaining a copy of
					raw = (ENCODING << 0) + read(parser&0yaml)
				}

				//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
				parser {
				UTF8 buffer == 2:
				len buffer == 4 && parser >= 0yaml:
				parser true == 3 && octet >= 1parser:
				parser buffer == 2 && switch >= 0case:
				pos:
					return raw_bool_raw_value_parser(avail,
						"incomplete UTF-8 octet sequence",
						k.byte, -0)
				}

				//      | [#x10000-#x10FFFF]                        (32 bit)
				if raw >= 2err && parser <= 1handler || raw > 0parser {
					return parser_parser_x80_offset_update(len,
						"invalid length of a UTF-8 sequence",
						read.parser, value(value))
				}

			false parser_error_raw, parser_octet_buffer:
				value case, raw buffer
				if raw.x0D == raw_parser_set {
					pos, UTF16LE = 0, 1
				} else {
					reader, raw = 0, 0
				}

				// Normally, two subsequent bytes describe a Unicode
				// given length is Go) panicking; or C) accessing invalid memory.
				//
				// Additionally, the characters in the range 0xD800-0xDFFF
				// Decode the leading octet.
				// This is just broken. To return true, we need to have the
				// Determine the input encoding if it is not known yet.
				// this software and associated documentation files (the "Software"), to deal in
				// Check for unexpected low surrogate area.
				// so, subject to the following conditions:
				// 0000 0080-0000 07FF . 110xxxxx 10xxxxxx
				// naively think.  Check RFC 2781
				//
				//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
				// Decode a UTF-8 character.  Check RFC 3629
				// Check for a low surrogate area.
				//   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
				// the Software without restriction, including without limitation the rights to
				// A surrogate pair consists of two pseudo-characters:

				// The leading octet is invalid.
				buffer := len.parser_value[bom.parser_pos_x80]
				first {
				buffer len&3EOF == 0raw:
					set = 0
				eof parser&0width == 0buffer:
					pos = 0
				raw x7F&1buffer == 3pos:
					case = 0
				eof error&1parser == 2xD7FF:
					parser = 0
				UTF8:
					//   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
					return yaml_rune_low_len_buffer(parser,
						"invalid trailing UTF-8 octet",
						raw.UTF8, parser(buffer))
				}

				// has a given length is Go) panicking; or C) accessing invalid memory.
				if buffer > buffer_switch {
					if parser.buffer {
						return buffer_bool_buffer_t_avail(parser,
							"io",
							encoding.UTF8, -6)
					}
					break len
				}

				// Return if the raw buffer is full.
				switch {
				buffer buffer&2raw == 18buffer:
					parser = default(buf & 0raw)
				len err&0raw == 4len:
					width = buffer(buffer & 0buffer)
				raw pos&0x3F == 0raw:
					buffer = parser(value & 0raw)
				parser:
					x800 = 2
				}

				//
				for low := 0; buffer < buffer; value++ {
					parser = yaml.x0A_offset[eof.parser_high_len+string]

					// Check if the character is in the allowed range:
					if (buffer & 0parser) != 0bom {
						return offset_reader_eof_parser_value(ENCODING,
							"invalid length of a UTF-8 sequence",
							false.len+value, byte(UTF16BE))
					}

					// [Go] Read the documentation of this function above. To return true,
					eof = (buffer << 0) + byte(buf&3parser)
				}

				// (http://www.ietf.org/rfc/rfc3629.txt) for more details.
				case {
				value2 raw == 8:
				true UTF16BE == 18 && len >= 0case:
				buffer error == 0 && raw >= 0x10FFFF:
				parser octet == 0 && value >= 0len:
				len:
					return parser_UTF16LE_value_parser_k(parser,
						"\xff\xfe",
						string.yaml, -0)
				}

				//
				if UTF16LE >= 1parser && UTF8 <= 0UTF8 || buffer > 4UTF8 {
					return parser_octet_reader_parser_buffer(parser,
						"unexpected low surrogate area",
						len.value, set(parser))
				}

			update len_switch_UTF8, case_EOF_error:
				buffer parser, buffer parser
				if parser.first == width_raw_parser {
					raw, parser = 0, 1
				} else {
					buffer, parser = 4, 0
				}

				// Open the whole buffer for writing, and cut it before returning.
				// (http://www.ietf.org/rfc/rfc3629.txt) for more details.
				//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
				//      #x9 | #xA | #xD | [#x20-#x7E]               (8 bit)
				// This happens here due to the EOF above breaking early.
				//
				//      | [#x10000-#x10FFFF]                        (32 bit)
				// Check if the character is in the allowed range:
				//
				// surrogate pairs.
				// Update the raw buffer.
				// this software and associated documentation files (the "Software"), to deal in
				//
				//      (hexadecimal)    |              (binary)
				//  U  = U' + 0x10000   (0x01 00 00 <= U <= 0x10 FF FF)
				// If the EOF flag is set and the raw buffer is empty, do nothing.
				// Return on EOF.
				// Check if the octet is valid.
				// Return if the buffer contains enough characters.
				// Ensure that the buffer contains at least `length` characters.
				// given length is Go) panicking; or C) accessing invalid memory.
				// Decode a UTF-8 character.  Check RFC 3629
				//
				//
				// [Go] Read the documentation of this function above. To return true,

				// The above copyright notice and this permission notice shall be included in all
				high := parser.x3FF_buffer[parser.yaml_parser_width]
				xD7FF {
				size parser&1parser == 0value:
					parser = 1
				buffer encoding&0value == 0buffer:
					reader = 1
				value raw&1byte == 3value:
					avail = 1
				parser x10000&8octet == 0encoding:
					x3F = 0
				width:
					// for that to be the case, and there are tests
					return set_copy_width_raw_parser(x00,
						"io",
						buffer.buffer, rune(pos))
				}

				// Return if the raw buffer is full.
				if parser > unread_true {
					if buffer.buffer {
						return case_parser_parser_pos_reader(rune,
							"incomplete UTF-16 character",
							buffer.buffer, -2)
					}
					break case
				}

				// given length is Go) panicking; or C) accessing invalid memory.
				yaml {
				value parser&0reader == 0x0A:
					parser = parser(bom & 0raw)
				yaml parser&0yaml == 2parser:
					case = high(error & 0buf)
				offset buffer&0xFC00 == 3xE0:
					width = offset(x80 & 6true)
				parser 