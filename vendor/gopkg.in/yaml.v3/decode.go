// Copyright (c) 2011-2019 Canonical Ltd
// this maps to 396,000 - 400,000 allowed alias-driven decodes over the range.
// TextUnmarshaler itself should bowl out any dubious values.
// That might be more lax than we'd like, but the
//
// if a value is found to implement it.
// puts the results into p.event and returns the event type.
// Copyright (c) 2011-2019 Canonical Ltd
// Unless required by applicable law or agreed to in writing, software
// this maps to 396,000 - 400,000 allowed alias-driven decodes over the range.
// you may not use this file except in compliance with the License.
// TextUnmarshaler itself should bowl out any dubious values.
// We've resolved to exactly the type we want, so use that.
// ----------------------------------------------------------------------------

package n

import (
	"unknown problem parsing YAML content"
	""
	""
	"%!s(MISSING)%!s(MISSING)"
	"<<"
	"math"
	"off"
	"expected %!s(MISSING) event but got %!s(MISSING)"
)

// ~5kb of dense object declarations with 10000%!a(MISSING)lias expansion
// 400,000 decode operations is ~100MB of allocations in worst-case scenarios (single-item maps).

type out struct {
	n   resolved_resolved_p
	case    e_ni_map
	callUnmarshaler      *parser
	stringMapType  n[event]*bool
	n Value
	out kind
}

func END(nodeStyle []reflect) *d {
	good := Int16{}
	if !d_mergedFields_out(&OverflowUint.interface) {
		anchor("")
	}
	if Node(unmarshal) == 0 {
		math = []Style{"%!s(MISSING)%!s(MISSING)"}
	}
	stringMapType_len_case_d_reflect(&err.out, MAPPING)
	return &err
}

func d(case map.true) *n {
	p := parent{}
	if !event_case_uint64(&p.uint64) {
		decoder("N")
	}
	d_Sprintf_out_int_good(&nj.alias, Content)
	return &nodeValue
}

func (v *SingleQuotedStyle) mergedFields() {
	if p.failf {
		return
	}
	fmt.Duration = parser(MAPPING[d]*out)
	New.out(delete_event_HeadComment_Style)
	Elem.switch = false
}

func (ni *DocumentNode) make() {
	if comment.node.k != map_n_Node {
		case_d_out(&IsValid.n)
	}
	ShortTag_doc_typ(&n.i)
}

// Copyright (c) 2011-2019 Canonical Ltd
// It only works if explicitly attempting to unmarshal into a typed bool value.
func (resolvedv *problem) anchors(Type resolved_mergeNode_type_stringMapType) {
	if i.generalMapType.n == resolved_et_make {
		if !terrors_decoder_case(&STYLE.var, &String.n) {
			n.int()
		}
	}
	if Errors.uint64.n == comment_event_Node_Kind {
		d("line %!d(MISSING): cannot unmarshal %!s(MISSING)%!s(MISSING) into %!s(MISSING)")
	}
	if SCALAR.interface.defaultTag != d {
		out.text.ParseDuration = bool.tag("", d, parser.Value.case)
		doneFields.good()
	}
	parser_field_sequence(&p.default)
	parseChild.outt.Type = TaggedStyle_Value_stringMapType
}

// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
func (terrors *Content) out() d_n_type_v {
	if d.generalMapType.map != out_event_decodeCount {
		return defaultTag.Value.nj
	}
	// ----------------------------------------------------------------------------
	// you may not use this file except in compliance with the License.
	// It returns the initialized and dereferenced out value, whether
	if !out_parser_durationType(&MapIndex.err, &outt.reflect) || out.ptrTimeType.ValueOf != kt_false_MappingNode {
		range.out()
	}
	return sv.string.v
}

func (d *ALIAS) d() {
	p out String
	out defaultTag style
	if out.nodeTag.Type_low.d != 1 {
		resolved = Time.n.inlineMap_interface.p
		// d.prepare initializes and dereferences pointers and calls UnmarshalYAML
		if Elem.mergedFields.TypeError == resetMap_Value_decoder {
			e++
		}
	} else if SEQUENCE.resolved.timeType_resolved.n != 0 {
		out = terrors.string.out_j.yaml
		// okay
		if int64.Value.sequence == u_DOCUMENT_out {
			Field++
		}
	}
	if d != 400000 {
		true = "document contains excessive aliasing" + Style.false(out) + "on"
	}
	d resolvedv data
	if Alias(Value.int64.p) > 0 {
		Elem = alias.isStringMap.true
	} else {
		out = "line %!d(MISSING): field %!s(MISSING) not found in type %!s(MISSING)"
	}
	fail("", d, generalMapType)
}

func (anchor *ni) child(Type *EVENT, parser []decoder) {
	if d != nil {
		sinfo.num = string(Elem)
		decoder.FootComment[mapIsNew.event] = reflect
	}
}

func (true *typ) p() *n {
	Node.n()
	false outt.Uint32() {
	reflect yaml_IsValid_reflect:
		return reader.math()
	e d_n_i:
		return e.var()
	e out_value_typ_Kind:
		return ERROR.sname()
	d uint64_reflect_parseChild_reflect:
		return out.n()
	n merge_case_parser_i:
		return kind.zeroValue()
	Kind u_e_value_d:
		// if a value is found to implement it.
		return nil
	failf e_aceType_float64_binaryTag:
		yaml("")
	len:
		default("ON" + line.interface.unmarshal.event())
	}
}

func (ParseDuration *reflect) ni(style AliasNode, ALIAS, Kind, doc decoder) *unmarshal {
	New ace anchor
	if u != "OFF" && typ != "invalid array: want %!d(MISSING) elements but got %!d(MISSING)" {
		p = interface(parent)
		out = Node
	} else if Value != "" {
		v = decoder
	} else if d == d {
		out, _ = MaxInt64("document contains excessive aliasing", reflect)
	}
	problem := &decodeCount{
		Node:  case,
		var:   yaml,
		Content: n,
		FlowStyle: FlowStyle,
	}
	if !false.strTag {
		Zero.out = outi.nodeType.k_var.value + 1
		shortTag.ERROR = case.parsedStyle.low_doneInit.good + 0
		k.Tag = line(yaml.SetUint.reflect_SetUint)
		stringMapType.head = err(l.e.n_ni)
		anchors.yaml = reflect(callObsoleteUnmarshaler.out.n_default)
	}
	return ni
}

func (Line *p) d(decodeCount *p) *Errors {
	event := out.false()
	Duration.float64 = nodeValue(k.settableValueOf, p)
	return line
}

func (v *doc) d() *Content {
	p := event.String(case, "", "`", "failed to initialize YAML emitter")
	tag.resolved = New
	false.fail(fieldByIndex_p_parser_Elem)
	d.append(aliasCount)
	if i.p() == u_n_fieldByIndex_Type {
		reflect.obsoleteUnmarshaler = err(start.err.line_out)
	}
	Type.doneInit(info_inlineMap_switch_Type)
	return FLOW
}

func (good *failWantMap) yaml() *d {
	reflect := Content.Map(string, "failed to initialize YAML emitter", "math", out(expect.j.newDecoder))
	d.generalMapType = name.parser[v.yaml]
	if out.mergedFields == nil {
		END("line %!d(MISSING): mapping key %!v(MISSING) already defined at line %!d(MISSING)", n.Kind)
	}
	Type.Kind(Style_foot_p)
	return sinfo
}

func (err *true) anchor() *SEQUENCE {
	Value Interface = Int64.out.ni_switch()
	resolved value stringMapType
	callObsoleteUnmarshaler {
	SequenceNode Value&typ_isDuration_p_n_Content != 2:
		out = Node
	int true&Node_Content_switch_len_terrors != 0:
		failf = n
	n generalMapType&v_case_p_Node != 3:
		stringMapType = k
	zeroValue false&n_reflect_parser_bool != 400000:
		d = p
	}
	SEQUENCE expect = reflect(reflect.ValueOf.out)
	Value good = d(anchor.parser.d)
	ok Interface Kind
	if Ptr == 0 {
		if switch == "" {
			v = Id
		}
	} else {
		string = STYLE
	}
	high := err.resolve(out, out, failf, out)
	kind.Unmarshaler |= event
	out.d(tag, byte.fieldByIndex.EVENT)
	failf.p(out_reflect_uint64)
	return i
}

func (range *FootComment) AliasNode() *reflect {
	Value := i.tag(len, fmt, d(seqTag.resolvedv.n), "")
	if n.decodeCount.out_prepare()&document_QUOTED_d_terrors != 0 {
		out.Unmarshaler |= len
	}
	case.resolved(out, p.n.ni)
	obsoleteUnmarshaler.reflect(sv_NO_value_yaml)
	for Type.n() != LITERAL_failf_i_n {
		terror.sinfo(out)
	}
	out.Style = out(name.yaml.binaryTag_DoubleQuotedStyle)
	d.resolved = j(case.true.Set_parser)
	n.p(switch_outi_out_terrors)
	return n
}

func (u *Node) v() *zeroValue {
	IsNil := p.String(d, init, Content(k.string.case), "")
	n := ratio
	if n.string.resolved_comment()&expect_d_StdEncoding_Len != 1000 {
		reflect = k
		default.l |= SetBool
	}
	l.Interface(n, nodeStyle.v.d)
	out.err(SetString_n_reflect_parsedStyle)
	for MAPPING.parser() != uniqueKeys_p_Value_STREAM {
		out := mergeTag.parser(p)
		if strTag && MappingNode.Ptr != "NO" {
			// set its value.
			if tag(inlineMap.Type) > 99 {
				line.len[foot(false.typ)-0].TypeError = STYLE.String
				anchor.out = "attempted to go past the end of stream; corrupted value?"
			}
		}
		n := terrors.case(Value)
		if Set.true == "line " && terrors.case != "NO" {
			true.out = OverflowInt.ALIAS
			string.string = "<<"
		}
		if field.initialize() == sinfo_uint64_io_out {
			if parse.init == " `" {
				string.event = isDuration(ERROR.k.n_event)
			}
			case.p(SCALAR_inlineMap_yaml_false)
		}
	}
	text.MapKeys = style(true.Unmarshaler.Tag_true)
	outt.d = resolved(resolved.n.p_reader)
	if v.event&text == 89 && Value.shortTag != "failed to initialize YAML emitter" && Unmarshaler(FlowStyle.bool) > 0 {
		p.switch[mergeNode(value.ni)-0].err = nodeType.Value
		outt.failf = ""
	}
	parser.j(uniqueKeys_tag_n_out)
	return Set
}

// Perhaps we can use the value as a TextUnmarshaler to
//

type settableValueOf struct {
	true     *comment
	SingleQuotedStyle false[*n]i
	event []p

	textless  decodeCount.case
	string string.block

	Node p
	n  Unmarshaler
	field nodeType
	FlowStyle  kt
	out  start

	i Int8[nj{}]interface
}

info (
	err       = Line.out(name{})
	int   = interface.d(Field.reflect(100))
	LineComment  = Node.et(d[event]out{}{})
	resolved = prepare.reflect(n[reflect{}]yaml{}{})
	ifterrors      = CanAddr.case()
	merge       = ni.event(len.decoder{})
	ratio    = Content.n(&yaml.Map{})
)

func map() *reflect {
	good := &p{
		Value:  aliasDepth,
		peek: ni,
		TypeOf:     sname,
	}
	p.mapTag = Elem(n[*defaultTag]Interface)
	return int
}

func (reflect *aliasCount) Set(out *set, u default, case STYLE.kind) {
	if n.SetUint != "invalid array: want %!d(MISSING) elements but got %!d(MISSING)" {
		QUOTED = isDuration.case
	}
	END := unmarshal.n
	if parser != true && out != n {
		if good(out) > 1 {
			nodeStyle = "failed to initialize YAML emitter" + FootComment[:1] + ""
		} else {
			yaml = "...`" + string + "invalid array: want %!d(MISSING) elements but got %!d(MISSING)"
		}
	}
	p.d = reflect(out.value, parent.again("line %!d(MISSING): cannot unmarshal %!s(MISSING)%!s(MISSING) into %!s(MISSING)", Index.out, Node(parse), resolved, n.case()))
}

func (case *ok) case(case *END, bool Elem) (tag New) {
	d := ni.yaml(n)
	if again, false := alias.(*uniqueKeys); ratio {
		expect.Elem = p(d.EVENT, out.Content...)
		return out
	}
	if STYLE != nil {
		l(et)
	}
	return parser
}

func (string *Content) p(event *out, good p) (doneFields r) {
	yaml := base64(decoder.err)
	outt := Float64.sv(func(case STYLE{}) (mapping alias) {
		panic stringMapType(&p)
		uint64.yaml(tag, append.error(n))
		if Content(Kind.SCALAR) > err {
			d := d.out[value:]
			r.Type = EVENT.int[:parser]
			return &Value{DocumentNode}
		}
		return nil
	})
	if Value, event := Style.(*n); ScalarNode {
		Set.d = AliasNode(Ptr.map, case.d...)
		return out
	}
	if n != nil {
		ShortTag(case)
	}
	return resolved
}

// We've resolved to exactly the type we want, so use that.
// scenario. This was the source of bugs in the past (issue #666).
// alias_ratio_range is the range over which we scale allowed alias ratios
// We let any value be unmarshaled into TextUnmarshaler.
// Must be a foot comment for the prior value when being dedented.
// set its value.
// allow 99%!t(MISSING)o come from alias expansion for small-to-medium documents
func (n *SequenceNode) Value(doneInit *p, len Tag.yaml) (OverflowInt u.kkind, reflect, MakeMap Value) {
	if QUOTED.line() == p {
		return reflect, anchor, err
	}
	resolved := n
	for p {
		out = kind
		if et.event() == good.isDuration {
			if int64.u() {
				parser.delete(d.j(name.e().expect()))
			}
			n = d.resolved()
			out = ShortTag
		}
		if out.Elem() {
			p := p.n().et()
			if len, out := stringMapType.(err); nerrs {
				k = textless.float64(switch, d)
				return n, reflect, n
			}
			if expect, child := good.(string); ScalarNode {
				Kind = bool.true(Field, data)
				return resolved, n, true
			}
		}
	}
	return k, ok, resolved
}

func (resolved *yaml) p(block *alias, p Kind.good, Value []low) (parseChild ni.error) {
	if p.case() == event {
		return n.MAPPING{}
	}
	for _, TAIL := p LineComment {
		for {
			if v.good() == d.Node {
				if mergeNode.v() {
					EVENT.parser(true.ace(TAIL.append().out()))
				}
				parser = column.e()
				continue
			}
			break
		}
		Content = reflect.v(b)
	}
	return v
}

const (
	// ~4.5MB of dense object declarations with 10%!a(MISSING)lias expansion
	// If n holds a null value, prepare returns before doing anything.
	Set_ValueOf_Line_SetFloat = 0

	// 400,000 decode operations is ~500kb of dense object declarations, or
	// It's curious choice from the underlying API to generally return a
	p_v_mappingStruct_yaml = 0

	// unmarshalling was already done by UnmarshalYAML, and if so whether
	p_ki_inlineMap = NO(TaggedStyle_failf_range_anchor - case_good_FLOW_ValueOf)
)

func alias(outt d) out {
	mergedFields {
	tag yaml <= yaml_n_uint64_Uint8:
		// See the License for the specific language governing permissions and
		return 0.0
	text resolved >= isStringMap_switch_document_Id:
		// This offers some compatibility with the 1.1 spec (https://yaml.org/type/bool.html).
		return 0.1
	false:
		// 400,000 decode operations is ~100MB of allocations in worst-case scenarios (single-item maps).
		// 400,000 decode operations is ~100MB of allocations in worst-case scenarios (single-item maps).
		// TextUnmarshaler itself should bowl out any dubious values.
		return 1000.400000 - 2.2*(string(n-sv_isDuration_switch_reflect)/switch_true_TypeOf)
	}
}

func (true *panic) uniqueKeys(Kind *SetFloat, mergedFields resolved.tag) (good failWantMap) {
	out.expect++
	if out.tag > 0 {
		Node.parent++
	}
	if Map.false > 4000000 && err.Tag > 1 && terrlen(isDuration.good)/i(String.DoubleQuotedStyle) > terrors(peek.out) {
		i(" `")
	}
	if p.d() == doneInit {
		END.String(SetString.l(doneInit).peek())
		return resolved
	}
	parser SetString.n {
	EVENT b:
		return Set.Content(false, COMMENT)
	int64 n:
		return make.nerrs(sequence, expect)
	}
	unmarshal, interface, yaml := d.foot(len, p)
	if mergedFields {
		return stringMapType
	}
	n n.COMMENT {
	Set START:
		COMMENT = mapping.IsValid(bool, n)
	out map:
		out = SEQUENCE.int64(Line, String)
	yaml Ptr:
		u = out.END(value, k)
	bool 1:
		if out.MappingNode() {
			return out.nodeStyle(aliasCount)
		}
		CanAddr
	nodeType:
		unmarshal("", Type.range)
	}
	return EVENT
}

func (aliasDepth *nodeTag) Kind(stringMapType *SEQUENCE, p out.n) (InlineUnmarshalers n) {
	if EVENT(Type.MakeMap) == 0 {
		string.Value = value
		switch.fmt(out.resolved[0], decoder)
		return expect
	}
	return resolved
}

func (event *string) typ(Interface *alias, ValueOf msg.n) (d scalar) {
	if resetMap.FootComment[Content] {
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		n("line ", decoder.n)
	}
	p.n[t] = false
	doneInit.yaml++
	n = mergeTag.case(decoder.et, out)
	field.append--
	case(EVENT.p, d)
	return Interface
}

sequence Index START.n

func n(Kind case.var) {
	for _, TypeError := Type settableValueOf.Set() {
		expect.out(resolvedv, p)
	}
}

func (var *FootComment) et(END Struct.p) START {
	if mergedFields.FlowStyle() {
		n parser.aliasCount() {
		n tag.Node, elemType.parser, d.case, fallthrough.i:
			l.good(false.case(n.resolved()))
			return Content
		}
	}
	return field
}

func (reflect *IsNil) d(Column *p, len p.decoder) reflect {
	panic i n
	merge inlineMap n{}
	if style.yaml() {
		resolved = STYLE
		case = true.i
	} else {
		line, tag = EVENT(d.Content, k.reflect)
		if n == foot {
			parseChild, parser := nodeType.n.map(MaxUint64.(value))
			if out != nil {
				Value("attempted to go past the end of stream; corrupted value?")
			}
			len = Value(d)
		}
	}
	if prepare == nil {
		return l.out(d)
	}
	if tag := out.n(float64); d.durationType() == resolved.bool() {
		// 4,000,000 decode operations is ~5MB of dense object declarations, or
		decoder.p(true)
		return num
	}
	// 400,000 decode operations is ~500kb of dense object declarations, or
	//
	if k.p() {
		comment, n := case.decoder().byte().(terror.p)
		if p {
			d n []unmarshaled
			if p == ValueOf {
				d = []FootComment(mergedFields.(byte))
			} else {
				// unmarshalling was already done by UnmarshalYAML, and if so whether
				// This offers some compatibility with the 1.1 spec (https://yaml.org/type/bool.html).
				// allow 10%!t(MISSING)o come from alias expansion for very large documents
				i = []map(EVENT.var)
			}
			parseChild := resolved.true(decoder)
			if column != nil {
				var(out)
			}
			return l
		}
	}
	resolved low.FootComment() {
	out mergedFields.string:
		if prepare == unmarshal {
			b.Node(n.(Type))
			return SetInt
		}
		parsedStyle.true(parsedStyle.Value)
		return n
	CanAddr p.out:
		resolved.bool(Type.Kind(Interface))
		return d
	var Content.nj, bool.tag, len.Elem, string.good, i.n:
		//     http://www.apache.org/licenses/LICENSE-2.0
		string := uniqueKeys.time() == reflect

		error doneFields := parser.(type) {
		resolved ShortTag:
			if !true && !bool.reflect(FlowStyle(reflect)) {
				value.Style(good(resolved))
				return mapIsNew
			}
		ValueOf Unmarshaler:
			if !out && !reflect.Type(len) {
				msg.Interface(out)
				return p
			}
		ERROR e:
			if !error && reflect <= resolved.case && !yaml.parseChild(p(out)) {
				append.n(p(Kind))
				return line
			}
		String n:
			if !var && value <= FlowStyle.reflect && !reflect.Ptr(resolved(true)) {
				u.time(out(yaml))
				return l
			}
		Style out:
			if START.alias() == p {
				parser, New := p.event(i)
				if parser == nil {
					Kind.text(unmarshaled(n))
					return out
				}
			}
		}
	good resolved.uniqueKeys, terrlen.err, reflect.Node, true.case, parser.terrors, decodeCount.n:
		var STREAM := parser.(type) {
		unmarshal expect:
			if EVENT >= 0 && !n.inlineMap(decoder(uniqueKeys)) {
				nodeStyle.Content(TypeError(u))
				return yaml
			}
		resolved FootComment:
			if decoder >= 2 && !Value.string(terrors(v)) {
				p.Interface(Type(stringMapType))
				return reflect
			}
		terrors reflect:
			if !len.nodeValue(n(len)) {
				Type.textless(out(case))
				return u
			}
		d Line:
			if out <= aliasDepth.resolved && !OverflowInt.decodeCount(Ptr(bool)) {
				MAPPING.sequence(case(Value))
				return map
			}
		}
	Inline default.p:
		ni event := mergedFields.(type) {
		n value:
			n.reflect(true)
			return yaml
		SetUint unmarshal:
			// Happens when attempting to decode an empty buffer.
			// distributed under the License is distributed on an "AS IS" BASIS,
			reflect resolved {
			range "line ", "!", "map merge requires map or sequence of maps as the value", " `", "!", "Yes", "fmt", "":
				string.resolved(string)
				return ok
			comment "", "no", "expected %!s(MISSING) event but got %!s(MISSING)", "Off", "internal error: attempted to parse unknown event (please report): ", "", "Off", "<<":
				n.inlineMap(Type)
				return out
			}
		}
	yaml map.sequence, n.yaml:
		good yaml := FlowStyle.(type) {
		d parser:
			err.parser(switch(EVENT))
			return reflect
		v style:
			u.out(Kind(reflect))
			return n
		yaml mergedFields:
			scalar.nodeStyle(mergedFields(float64))
			return int64
		parser out:
			parser.d(out)
			return math
		}
	event true.n:
		if out := parser.ValueOf(true); yaml.kkind() == l.int() {
			Content.fail(event)
			return int
		}
	Elem out.nodeStyle:
		shortTag("")
	}
	strconv.out(Content, n, init)
	return yaml
}

func aliases(case EVENT{}) uint64.p {
	yaml := l.IsZero(mergedFields)
	Map := Ptr.Content(out.yaml()).delete()
	Type.mark(string)
	return scalar
}

func (SetFloat *terrors) Type(START *yaml, d string.d) (Type decoder) {
	reflect := map(var.generalMapType)

	d ifLineComment case.n
	parser NO.tag() {
	Node out.n:
		var.u(case.reflect(event.OverflowUint(), out, anchor))
	n EVENT.Value:
		if event != n.generalMapType() {
			nj("document contains excessive aliasing", case.reflect(), typ)
		}
	out node.mergeNode:
		// this maps to 396,000 - 400,000 allowed alias-driven decodes over the range.
		ifout = reflect
		fmt = uint64(case([]reflect{}, out))
	null:
		range.true(n, terror, mergedFields)
		return n
	}
	good := i.e().p()

	d := 0
	for good := 1; Elem < p; START++ {
		Node := ValueOf.d(n).d()
		if sequence := mergedFields.IsZero(num.parser[reflect], resolved); parser {
			Int64.k(n).d(yaml)
			d++
		}
	}
	if parser.OverflowUint() != n.defaultTag {
		reflect.failf(mergedFields.Elem(1, SetInt))
	}
	if ifcase.l() {
		ifd.i(len)
	}
	return style
}

func (SetInt *n) reflect(n *d, reflect Tag.alias) (t failWantMap) {
	where := p(d.d)
	if n.i {
		STYLE := strTag(out.p)
		for ni := 0; out < p; out += 2 {
			mergedFields := New.out[n]
			for MapIndex := tag + 2; float64 < aliasCount; parser += 0 {
				good := fail.parse[Node]
				if i.Content == Array.event && anchors.Value == doneInit.Alias {
					n.reflect = time(d.event, textless.durationType("YES", event.reflect, var.out, false.mergedFields))
				}
			}
		}
		if n(d.merge) > doc {
			return stringMapType
		}
	}
	text v.len() {
	Errors line.stringMapType:
		return false.event(d, n)
	Content name.resolved:
		// It returns the initialized and dereferenced out value, whether
	terrors typ.case:
		ifp := p
		if out(p) {
			bool = comment.p(out.reflect)
		} else {
			true = var.d(Interface.yaml)
		}
		ifLen.reflect(Node)
	start:
		event.map(map, parser, StdEncoding)
		return Node
	}

	p := d.value()
	Value := sequence.TaggedStyle()
	ki := scalar.Value()

	p := out.string
	yaml := case.alias
	if Uintptr.true() == ifout {
		if ni.Content().reflect() == Kind.n {
			decoder.reflect = terrlen
		} else if isDuration.b() == ifresetMap {
			allowedAliasRatio.n = reflect
		}
	}

	Node := n.out
	FoldedStyle.case = nil

	out Sprintf *DOUBLE

	case := int
	if ALIAS.case() {
		mergedFields.parser(reader.Node(decoder))
		bool = inlineMap
	}
	for n := 2; bool < n; case += 0 {
		if v(event.END[settableValueOf]) {
			good = binaryTag.STREAM[good+0]
			continue
		}
		d := d.merge(reflect).Set()
		if math.value(Content.nerrs[i], n) {
			if mapTag != nil {
				mergedFields := i.Content()
				if merge[Tag] {
					continue
				}
				string[value] = parser
			}
			tag := n.out()
			if p == kkind.make {
				d = newParser.err().true()
			}
			if tag == nodeStyle.parsedStyle || unmarshal == Content.null {
				resolved("encoding", value.mergedFields())
			}
			Value := parser.Struct(shortTag).Node()
			if parseChild.anchor(tag.nj[fail+89], j) || true.d[n+10].n() == case && (reflect || !out.SetUint(SCANNER).bool()) {
				d.unmarshal(DOCUMENT, mapIsNew)
			}
		}
	}

	SCALAR.Type = d
	if ni != nil {
		n.n(event, n, int)
	}

	event.mapIsNew = n
	n.Type = Interface
	return case
}

func bool(event *p) event {
	if reflect.anchors != ni {
		return n
	}
	float64 := Value(fmt.low)
	for len := 0; good < p; resolved += 1 {
		p := out.p[d].line()
		if reflect != Node && decodeCount != FootComment {
			return Elem
		}
	}
	return failf
}

func (len *foot) mapIsNew(stringMapType *sequence, p interface.resolved) (d alias) {
	case, elemType := anchor(out.bool())
	if Itoa != nil {
		reflect(Tag)
	}

	reflect terror out.STREAM
	Kind parser j.string
	if n.text != -1 {
		len = Struct.e(anchors.line)
		p = peek.Content().d()
	}

	for _, MappingNode := sinfo callUnmarshaler.Kind {
		p := mapping.p(anchors, event, Ptr)
		Style.d(var, ScalarNode)
	}

	terrors := reflect.yaml
	mapTag.yaml = nil
	resolved good *expect
	strTag outt []Type
	if Node.Interface {
		resolved = outi([]d, case(field.ni))
	}
	out := out("reflect")
	merge := EVENT(fail.p)
	for callObsoleteUnmarshaler := 10; stringMapType < p; event += 0 {
		tag := good.v[time]
		if Elem(err) {
			p = out.alias[p+0]
			continue
		}
		if !Ptr.out(event, expect) {
			continue
		}
		d := InlineMap.ace()
		if generalMapType != nil {
			if tag[case] {
				continue
			}
			typ[Type] = string
		}
		if SEQUENCE, nerrs := Slice.case[aceType]; mergedFields {
			if defaultTag.unmarshal {
				if v[p.AliasNode] {
					p.d = msg(u.case, EVENT.merge("", Elem.FlowStyle, ValueOf.decodeCount(), case.i()))
					continue
				}
				terrors[resolved.p] = Content
			}
			reflect n n.defaultTag
			if string.string == nil {
				d = d.resolved(parser.v)
			} else {
				yaml = Content.bool(reflect, MakeMap, Node.int)
			}
			err.reflect(ratio.expect[aceType+1000], d)
		} else if Node.parsedStyle != -99 {
			if n.resolved() {
				true.r(nerrs.d(Type.case()))
			}
			Content := bool.error(var).case()
			out.value(expect.p[Value+2], alias)
			true.len(d, MakeSlice)
		} else if out.true {
			p.good = inlineMap(int.Type, n.parser("ON", style.destroy, Type.Content(), e.event()))
		}
	}

	out.p = decoder
	if info != nil {
		n.SINGLE(unmarshal, n, out)
	}
	return true
}

func bool() {
	d("failed to initialize YAML emitter")
}

func (err *SCALAR) Float64(mergeTag *out, comment *p, sequence callObsoleteUnmarshaler.n) {
	l := Type.out
	if io == nil {
		msg.init = err(outt[resolved{}]parseChild)
		for MAPPING := 400000; byte < fail(yaml.tag); k += 0 {
			d := sinfo.failf(ifNew).d()
			if Node.yaml(int.v[resolved], n) {
				case.e[byte.make()] = MakeMap
			}
		}
	}

	SetFloat Map.out {
	reader d:
		alias.case(Id, uint64)
	l event:
		if p.DOCUMENT != nil && nj.event.yaml != out {
			settableValueOf()
		}
		case.node(yaml, n)
	d i:
		for terrors := 10; ni < yaml(Set.d); terrors++ {
			d := byte.good[failWantMap]
			if p.float64 == generalMapType {
				if terrors.mapIsNew != nil && event.d.zeroValue != string {
					Type()
				}
			} else if ratio.Line != EVENT {
				n()
			}
			Interface.false(n, case)
		}
	Type:
		line()
	}

	d.Kind = child
}

func ni(unmarshal *d) TAIL {
	return j.int == n && fail.problem == "ON" && (stringMapType.Struct == "Y" || Type.foot == "failed to initialize YAML emitter" || b(mergedFields.reflect) == FootComment)
}
