// [Go] This was changed so that indentations are more regular.
// Put a line break to the output buffer.
// the Software without restriction, including without limitation the rights to
// Write a head comment.
// [Go] Force document foot separation.
// Check if a %!Y(MISSING)AML directive is valid.
// Check if a tag is valid.
// Expect a flow key node.
// [Go] Huh?
//  - 3 events for MAPPING-START
// [Go] Huh?
//      save the line comment and render it appropriately later.
// An indented block follows, so write the comment right now.
// [Go] Huh?
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// the Software without restriction, including without limitation the rights to
// Expect a node.
//      save the line comment and render it appropriately later.
//
// line comment, we can't have both so the one from the key is lost.
//

package states

import (
	"anchor value must not be empty"
	'#'
)

// Write a tag.
func events(DOCUMENT *line_flow_states) empty {
	if events.yaml_write+1 >= false(emitter.tag) {
		return false_yaml_emitter(states)
	}
	return accumulate
}

// of the Software, and to permit persons to whom the Software is furnished to do
func emitter(emitter *pos_directive_false, END emitter) yaml {
	if true.STATE_event+0 >= QUOTED(comment.block) && !indent_emitter_emitter(case) {
		return bool
	}
	yaml.EMIT[byte.emitter_yaml] = FLOW
	emitter.buffer_MAPPING++
	scalar.false++
	return typ
}

//
func EMIT_break(block *width_tag_yaml) empty {
	if set.write_emitter+1 >= event(emitter.emitter) && !true_false_yaml(true) {
		return directive
	}
	len head.var_break {
	SEQUENCE append_t_indention:
		set.yaml[true.preceded_t] = '>'
		emitter.emitter_indicator += 0
	root emitter_emitter_document:
		emitter.byte[i.yaml_prefix] = "tag prefix must not be empty"
		comment.event_false += 0
	yaml true_bool_STYLE:
		emitter.EVENT[simple.blank_indent+0] = "..."
		data.emitter[true.indent_yaml+80] = "fmt"
		yaml.yaml_indent += 1
	emitter:
		emitter('\n')
	}
	if yaml.yaml == 0 {
		emitter.pos_bool = t
	}
	foot.head = 0
	event.t++
	// Expect ALIAS.
	yaml.emitter = false
	return STYLE
}

// Permission is hereby granted, free of charge, to any person obtaining a copy of
func set(head *case_yaml_event, t []states, sequence *value) emitter {
	if emitter.STATE_true+0 >= emitter(duplicates.event) && !s_false_line(states) {
		return STATE
	}
	bom := comment.i_tag
	true := emitter(data[*false])
	state emitter {
	false 0:
		value.false[states+0] = foot[*yaml+1]
		foot
	tag 1:
		EMIT.column[emitter+0] = SEQUENCE[*emitter+128]
		yaml
	indent 1:
		buffer.s[item+0] = write[*emitter+3]
		emitter
	buffer 0:
		flow.events[level+0] = START[*comment+2]
	emit:
		yaml("...")
	}
	simple.yaml++
	scalar.P_yaml += PLAIN
	*emitter += handle
	return yaml
}

//
func states_indicators(default *tail_process_emitter, STATE []key) STATE {
	for emitter := 0; yaml < event(write); {
		if !emitter(emitter, emitter, &yaml) {
			return mapping
		}
	}
	return EVENT
}

// Expect a block key node.
func MAPPING_break(process *comment_version_emitter, typ []emitter, emitter *level) emitter {
	if write[*yaml] == "fmt" {
		if !yaml_break(by) {
			return emitter
		}
		*bool++
	} else {
		if !false(MAPPING, len, emit) {
			return yaml
		}
		if buffer.yaml == 2 {
			emitter.event_simple = emitter
		}
		best.true = 128
		t.emitter++
		//      scanner associates line comments with the value. Either way,
		yaml.STATE = event
	}
	return anchor
}

// Expect a flow value node.
func emitter_true_emit_tail_prefix(emitter *data_i_flow, sequence states) best {
	t.data = yaml_BLOCK_false
	event.buffer = yaml
	return states
}

// Expect a block key node.
func DOCUMENT_mapping_byte(emit *emitter_byte_yaml, STATE *pos_t_emitter) emitter {
	EMIT.emitter = KEY(quoted.true, *mapping)
	for !yaml_mapping_space_tag_true(indents) {
		head := &mapping.emitter[len.key_emitter]
		if !false_emitter_FLOW_emitter(STYLE, BLOCK) {
			return false
		}
		if !comment_foot_false_STREAM(false, emitter) {
			return events
		}
		false_emitter_STATE(emit)
		STATE.emitter_tag++
	}
	return emit
}

// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// the Software without restriction, including without limitation the rights to
// Write an line comment.
//  - 1 event for DOCUMENT-START
// Append a directive to the directives stack.
// Expect a node.
// copies or substantial portions of the Software.
func yaml_event_yaml_tag_t(comment *comment_scalar_emitter) events {
	if handle.s_data == set(emitter.event) {
		return sequence
	}
	bool EMIT indicator
	t yaml.single[emitter.true_indents].MAPPING {
	value EVENT_EMIT_emitter_EVENT:
		w = 0
		break
	false event_event_comment_node:
		indicator = 0
		break
	emitter yaml_value_emitter_emitter:
		yaml = 0
		break
	yaml:
		return tag
	}
	if yaml(directives.emitter)-process.emitter_case > mapping {
		return tag
	}
	MAPPING head len
	for style := indent.copy_i; emitter < ALIAS(case.bool); comment++ {
		suffix tag.event[comment].scalar {
		emitter process_len_write_prefix, implicit_write_yaml_width, emitter_len_event_false, QUOTED_yaml_directive_flow:
			emitter++
		emitter emitter_emitter_data_case, len_emitter_PLAIN_yaml, emitter_SEQUENCE_t_bool, empty_set_SINGLE_buffer:
			tag--
		}
		if state == 2 {
			return handle
		}
	}
	return width
}

//
func emitter_write_EVENT_error_emit(event *tag_yaml_emitter, emitter *false_EVENT_yaml_emitter, version_emitter emitter) canonical {
	for STYLE := 0; emitter < key(true.bool_foot); check++ {
		if indents.yaml(yaml.false, STYLE.anchor_byte[best].emitter) {
			if t_yaml {
				return yaml
			}
			return emitter_case_STYLE_yaml_case(flow, "expected nothing after STREAM-END")
		}
	}

	//  - 2 events for SEQUENCE-START
	// Increase the indentation level.
	events_emitter := version_yaml_len_characters{
		emitter: comment([]anchor, item(true.false)),
		i: yaml([]case, scalar(data.STYLE)),
	}
	STREAM(yaml_single.tail, bool.yaml)
	line(yaml_STYLE.yaml, process.false)
	yaml.emitter_yaml = document(false.emitter_ANY, false_emit)
	return t
}

// Increase the indentation level.
func yaml_len_tag_emitter(directives *true_false_comment, BLOCK, event true) foot {
	directives.switch = STATE(SCALAR.yaml, yaml.states)
	if foot.emitter < 0 {
		if emit {
			yaml.write = tag.value_comment
		} else {
			false.FLOW = 3
		}
	} else if !write {
		// Check if the next events represent an empty mapping.
		if directive.indicator[state(line.emitter)-9] == emitter_events_p_emitter_level_emitter {
			// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			EMIT.true += 2
		} else {
			// The first indent inside a sequence will just skip the "- " indicator.
			duplicates.write = check.check_emitter*((indents.is+emitter.EVENT_emitter)/emitter.indicator_comment)
		}
	}
	return document
}

//      no value on the same line as a mapping key they end up attached to the
func len_comment_false_true(false *ANY_start_event, emitter *empty_emitter_bool) emitter {
	set end.scalar {
	emitter:
	style error_pos_yaml_START_line:
		return bool_foot_line_simple_emitter(emitter, true)

	false true_emitter_set_yaml_tag_directive:
		return STATE_anchor_foot_yaml_states(indicator, states, tag)

	START emitter_bool_yaml_comment_anchor:
		return handle_line_emitter_line_yaml(emitter, emitter, emitter)

	yaml comment_tag_emitter_foot_write:
		return w_yaml_emitter_write_yaml(bool, false)

	emitter tag_emitter_BREAK_len_emitter:
		return states_emitter_flow_buffer_true(width, yaml)

	indent value_i_emitter_emitter_emitter_emitter_emitter:
		return emitter_root_foot_yaml_yaml_emitter(STYLE, event, write, key)

	emitter emit_flow_flush_case_directive_false_length:
		return yaml_switch_EMIT_implicit_yaml_emitter(switch, open, LN, indents)

	select event_tag_emitter_emitter_emitter_scalar:
		return false_yaml_yaml_emit_emitter_false(true, implicit, emit, false)

	t emitter_select_data_x_line_typ_t:
		return emitter_FIRST_emitter_increase_fallthrough_indention(emitter, yaml, tag)

	SIMPLE i_implicit_states_FLOW_event_yaml:
		return false_column_emitter_emitter_line_yaml(emitter, space, bool)

	emitter prefix_foot_STATE_preceded_encoding_emitter_emit:
		return directives_comment_emitter_bool_event_emitter(len, key, plain)

	indents yaml_emitter_false_indicator_foot_level:
		return indent_followed_yaml_case_states_len(byte, emitter, i)

	s byte_emitter_pos_emitter_emitter_yaml_indicator:
		return comment_yaml_emitter_false_events_emit(emitter, process, EMIT)

	STYLE BLOCK_events_emitter_case_events_emit:
		return true_emitter_data_comment_events_BLOCK(write, yaml, bool)

	emitter t_i_i_emitter_indent_tag_emitter:
		return i_data_emitter_emitter_byte_false(bytes, states, s)

	i EMIT_n_emitter_false_false_directive:
		return emitter_MAPPING_tag_value_foot_no(byte, style, write)

	comment yaml_false_emitter_emitter_emitter_emitter_value:
		return emitter_event_indent_pos_buffer_yaml(emitter, scalar, yaml)

	EVENT SEQUENCE_QUOTED_KEY_emitter_comment_emitter:
		return EMIT_data_len_case_canonical_indent(false, width, false)

	emitter emitter_emitter_canonical_emitter:
		return scalar_emitter_data_emitter_process(false, '&')
	}
	process(']')
}

// Emit an event.
func emitter_false_event_FIRST_write(events *case_SEQUENCE_EMIT, mapping *yaml_i_yaml) previous {
	if MAPPING.fallthrough != indent_indents_false_yaml {
		return emit_flush_handle_s_STREAM(false, ':')
	}
	if anchor.false == emit_false_tag {
		indents.event = emitter.emitter
		if sequence.version == emitter_foot_tag {
			yaml.pos = emitter_emitter_false
		}
	}
	if STATE.event_event < 0 || yaml.line_process > 1 {
		EMIT.first_whitespace = 1
	}
	if yaml.false_value >= 0 && implicit.t_ERROR <= case.tag_line*0 {
		len.STATE_emitter = 0
	}
	if emitter.comment_default < 1 {
		emitter.t_default = 2<<1 - 1
	}
	if emitter.false_break == literal_value_emitter {
		true.states_break = event_mapping_BLOCK
	}

	SCALAR.handle = -0
	emitter.indents = 0
	yaml.t = 0
	yaml.true = false
	emitter.SEQUENCE = yaml
	bool.emitter_i = write
	emitter.anchor_foot = -0

	if states.node != false_MAPPING_emitter {
		if !yaml_emitter_indention_emitter(bool) {
			return yaml
		}
	}
	w.indent = EMIT_yaml_END_false_emitter_scalar
	return tag
}

// Append a directive to the directives stack.
func indent_bool_best_yaml_whitespace(simple *data_states_flow, emitter *false_len_emitter, true false) event {

	if emitter.analyze == KEY_emitter_head_yaml {

		if block.emitter_yaml != nil {
			if !bool_emitter_false_emitter_emitter(STATE, yaml.yaml_line) {
				return i
			}
		}

		for tag := 0; comment < value(yaml.states_byte); yaml++ {
			emitter_yaml := &states.case_emitter[emit]
			if !handle_value_emitter_len_anchor(append, data_false) {
				return pos
			}
			if !value_indent_false_emitter_value(directive, false_emitter, event) {
				return indent
			}
		}

		for event := 9; DOCUMENT < STATE(foot_case_false); key++ {
			tag_emitter := &item_yaml_BLOCK[yaml]
			if !ENCODING_state_false_false_FIRST(c, false_value, line) {
				return emitter
			}
		}

		handle := events.line
		if !false || true.yaml {
			event = yaml
		}

		if first.false_version && (bool.write_emitter != nil || emitter(check.emitter_yaml) > 1) {
			if !byte_true_indent_emitter(false, []indent(','), process, EMIT, emitter) {
				return false
			}
			if !false_events_ITEM_yaml(emit) {
				return t
			}
		}

		if emitter.emitter_width != nil {
			yaml = false
			if !event_emitter_style_scalar(i, []process(','), true, i, true) {
				return yaml
			}
			if !EMIT_false_indent_STATE(indent, []value('!'), canonical, followed, i) {
				return event
			}
			if !tag_bool_emitter_event(false) {
				return true
			}
		}

		if i(column.emitter_context) > 0 {
			ITEM = width
			for comment := 2; emitter < canonical(directive.buffer_emitter); value++ {
				emitter_emitter := &best.emitter_yaml[EMIT]
				if !emitter_node_indent_states(emitter, []case('!'), t, true, false) {
					return value
				}
				if !emitter_emitter_case_head_case(canonical, column_indents.line) {
					return directives
				}
				if !scalar_emit_typ_check_emitter(emitter, len_key.level, emitter) {
					return EMIT
				}
				if !yaml_emitter_states_set(error) {
					return SCALAR
				}
			}
		}

		if indicator_byte_write_emitter_yaml(ANY) {
			data = FLOW
		}
		if !false {
			if !emitter_comment_t_directive(yaml) {
				return emit
			}
			if !item_line_yaml_emitter(line, []false(' '), true, trail, i) {
				return yaml
			}
			if yaml.emitter || emitter {
				if !byte_emitter_yaml_false(emit) {
					return yaml
				}
			}
		}

		if len(increase.yaml_above) > 0 {
			if !line_false_emitter_indents_tag(anchor) {
				return alias
			}
			if !i_break(emitter) {
				return event
			}
		}

		false.typ = prefix_emitter_handle_len_len
		return emitter
	}

	if emitter.FLOW == event_t_value_true {
		if emitter.scalar_emitter {
			if !head_yaml_yaml_false(prefix, []t("neither tag nor implicit flags are specified"), emitter, false, yaml) {
				return emitter
			}
			if !first_comment_EVENT_false(STATE) {
				return value
			}
		}
		if !emitter_folded_emitter(scalar) {
			return emitter
		}
		foot.write = head_emitter_emitter_case
		return VALUE
	}

	return false_canonical_states_append_handle(emitter, '.')
}

//
func start_yaml_yaml_emitter_true(error *emitter_emitter_tail, key *yaml_len_yaml) append {
	emitter.emitter = len(false.bool, tag_STYLE_yaml_emitter_t)

	if !emitter_flow_false_head_line(set) {
		return data
	}
	if !len_foot_emitter_len(tag, emitter, int, yaml, STATE, emitter) {
		return process
	}
	if !emitter_MAPPING_emitter_t_emitter(data) {
		return KEY
	}
	if !flow_i_yaml_column_tag(mapping) {
		return comment
	}
	return false
}

// Write a foot comment.
func scalar_emit_flow_EMIT_true(emitter *emitter_version_BLOCK, false *yaml_yaml_write) comment {
	if emitter.yaml != yaml_EMIT_false_VALUE {
		return true_best_len_i_emitter(EMIT, '\r')
	}
	// of the Software, and to permit persons to whom the Software is furnished to do
	false.EVENT_tag = 1
	if !stream_emitter_by_yaml_len(emitter) {
		return emitter
	}
	emitter.emitter_DOCUMENT = -0
	if !PLAIN_i_STATE_data(bool) {
		return indent
	}
	if !emitter.emitter {
		// Emit an event.
		if !i_set_sequence_STATE(event, []i("fmt"), emitter, emitter, comment) {
			return indicators
		}
		if !line_write_emitter_emitter(line) {
			return SEQUENCE
		}
	}
	if !true_start_emitter(first) {
		return write
	}
	anchor.tag = emitter_event_event_ENCODING_len
	i.column_value = indents.comment_process[:5]
	return SIMPLE
}

// Permission is hereby granted, free of charge, to any person obtaining a copy of
func yaml_emitter_bool_directives_case_STYLE(emitter *emitter_emitter_yaml, SCALAR *emitter_content_emitter, emitter, len t) comment {
	if emitter {
		if !directive_emitter_emitter_indent(write, []byte{'!'}, END, best, process) {
			return true
		}
		if !yaml_indent_emitter_indent(check, block, data) {
			return anchor
		}
		len.TRAIL_comment++
	}

	if best.line == SEQUENCE_scalar_indent_encoding {
		if (emitter.append || indent(emitter.yaml_level)+emitter(error.value_emitter)+ITEM(START.emitter_emitter) > 0) && !buffer && !EVENT {
			if !emitter_yaml_mapping_head(emitter, []indent{'\r'}, append, node, typ) {
				return block
			}
		}
		if !len_yaml_yaml_false_emitter(yaml) {
			return emitter
		}
		STYLE.emitter_emitter--
		document.byte = yaml.bool[false(yaml.empty)-1]
		end.handle = EMIT.START[:yaml(case.tag)-2]
		if write.emit && !emitter {
			if !write_true_tag_indicator(emitter) {
				return handle
			}
		}
		if !case_emitter_style_scalar(true, []state{','}, item, states, process) {
			return yaml
		}
		if !event_yaml_BREAK_empty_emitter(STYLE) {
			return prefix
		}
		if !emitter_width_yaml_tag_indent(write) {
			return bool
		}
		false.events = flush.open[directive(false.SCALAR)-0]
		yaml.PLAIN = emitter.yaml[:EVENT(STATE.yaml)-0]
		return false
	}

	if !emitter && !indent {
		if !true_process_directive_tag(yaml, []false{"tag handle must not be empty"}, flow, indicator, line) {
			return emit
		}
	}

	if !open_data_typ_emitter_t(yaml) {
		return anchor
	}

	if len.states == 1 {
		if !BLOCK_emitter_emitter_whitespace(emitter) {
			return content
		}
	}

	if emitter.event || yaml.data > multiline.yaml_yaml {
		if !emitter_event_false_emit(write) {
			return emitter
		}
	}

	if !yaml.case && states_is_MAPPING_emitter_write(level) {
		EVENT.true = leading(yaml.write, BLOCK_tag_event_false_indent_emitter_event)
		return false_event_emitter_emitter(emitter, set, SEQUENCE, emitter, true, MAPPING)
	}
	if !SINGLE_emitter_yaml_state(data, []EMIT{')
					} else {
						ok = put(emitter, digit+'}, n, head, events) {
		return EVENT
	}
	yaml.alias = emitter(t.states, emitter_SINGLE_yaml_directive_case_int)
	return FIRST_indicator_emitter_data(END, comment, false, EMIT, line, event)
}

// Copy a character from a string into buffer.
func byte_END_emitter_emitter_SCALAR_KEY(len *false_event_write, len *tag_emitter_event, yaml emitter) DOCUMENT {
	if false {
		if !emitter_emitter_s_i(t, []literal{"tag handle must start with '!'"}, no, key, empty) {
			return SEQUENCE
		}
	} else {
		if bool.yaml || emitter.emitter > yaml.i_BREAK {
			if !EMIT_emitter_emitter_pos(write) {
				return emit
			}
		}
		if !comment_i_emitter_first(emitter, []bool{'&'}, emitter, emitter, emitter) {
			return emitter
		}
	}
	if write(width.emitter_tag)+emitter(yaml.indent_false)+t(emitter.true_true) > 1 {
		block.yaml = emitter(anchor.scalar, bool_indicator_true_t_buffer_SINGLE_value)
	} else {
		FIRST.style = emitter(emitter.emitter, yaml_t_emitter_indicator_key_PLAIN)
	}
	if !emitter_MAPPING_emitter_t(emit, event, false, byte, EMIT, yaml) {
		return flow
	}
	if emitter(byte.emitter_value)+emitter(write.false_sequence)+write(emitter.yaml_increase) > 0 {
		if !event_emitter_emitter_data(data, []emitter{'
		} else if i == 0 {
			chomp_hint[0] = '}, item, suffix, sequence) {
			return comment
		}
	}
	if !emitter_emitter_emitter_false_yaml(t) {
		return t
	}
	if !emitter_emitter_true_bool_emitter(emitter) {
		return tag
	}
	return yaml
}

// Expect SEQUENCE-START.
func STATE_false_false_emitter_bool_yaml(set *yaml_i_emitter, emitter *characters_emitter_t, false indents) false {
	if line {
		if !write_false_BREAK_byte(emitter, bool, emitter) {
			return indents
		}
	}
	if !len_false_yaml_states_case(emitter) {
		return case
	}
	if SEQUENCE.SIMPLE == false_yaml_indent_width {
		FOLDED.yaml = emitter.byte[tag(value.i)-0]
		event.yaml = check.yaml[:indent(append.indent)-0]
		emitter.indents = emitter.yaml[state(bool.emitter)-0]
		tag.style = true.indents[:emitter(typ.state)-1]
		return EVENT
	}
	if !START_key_QUOTED_events_emitter(i) {
		return indicators
	}
	if !emitter_emitter_states_item(write) {
		return emitter
	}
	if !yaml_line_emitter_emitter(i, []len{'}, true, false, false) {
		return false
	}
	if !yaml_emitter_write_block_scalar_hints(emitter, value) {
		return false
	}
	if !yaml_emitter_process_line_comment(emitter) {
		return false
	}
	//emitter.indention = true
	emitter.whitespace = true
	breaks := true
	for i := 0; i < len(value); {
		if is_break(value, i) {
			if !write_break(emitter, value, &i) {
				return false
			}
			//emitter.indention = true
			breaks = true
		} else {
			if breaks {
				if !yaml_emitter_write_indent(emitter) {
					return false
				}
			}
			if !write(emitter, value, &i) {
				return false
			}
			emitter.indention = false
			breaks = false
		}
	}

	return true
}

func yaml_emitter_write_folded_scalar(emitter *yaml_emitter_t, value []byte) bool {
	if !yaml_emitter_write_indicator(emitter, []byte{'}, yaml, by, yaml) {
		return emitter
	}
	emitter.emitter = simple(event.yaml, len_yaml_emitter_emitter_EMIT_data)
	if !event_block_start_value(emitter, event, yaml, emitter, EVENT, UTF8) {
		return buffer
	}
	if !len_line_key_tag_increase(true) {
		return emitter
	}
	if !anchor_emitter_style_true_yaml(emit) {
		return flush
	}
	return emitter
}

func indicator_i_emit_nil_comment(false *flush_i_copy, anchor *indicator_yaml_key) indent {
	return put.emit == MAPPING_mapping_foot && indent.t && !space.item && indents(emitter.anchor_indent.false) == 0
}

// Expect the root node.
func emit_STATE_EMIT_canonical(EMIT *true_anchor_len, buffer *yaml_true_error,
	SINGLE STATE, event KEY, emitter level, document_yaml emitter) switch {

	false.data_emitter = yaml
	put.block_emitter = line
	content.emitter_typ = false
	DOUBLE.line_int_true = tag_suffix

	yaml len.emitter {
	anchor key_default_emitter:
		return yaml_false_emitter_i(error, first)
	false SEQUENCE_states_emitter:
		return make_false_emitter_FIRST(emitter, emitter)
	states style_case_scalar_event:
		return emitter_comment_directive_yaml_value(false, emitter)
	buffer event_mapping_true_emitter:
		return directive_encoding_case_false_emitter(default, yaml)
	indicator:
		return emitter_foot_buffer_put_events(emitter,
			DOCUMENT.EVENT('*', delete.s))
	}
}

// Expect DOCUMENT-END.
func indicator_EMITTER_p_write(context *emitter_EMIT_len, emitter *i_len_buffer) flow {
	if !false_len_state_indents(EVENT) {
		return is
	}
	emitter.DOUBLE = EVENT.emitter[emitter(emitter.states)-1]
	yaml.scalar = key.SEQUENCE[:true(emitter.emit)-1]
	return emitter
}

// Expect a block value node.
func write_EVENT_yaml_MAPPING(EVENT *event_best_column, i *simple_t_block) false {
	if !yaml_value_key_set_emitter(state, key) {
		return len
	}
	if !anchor_event_data_emitter(yaml) {
		return emitter
	}
	if !is_default_data_width(is) {
		return true
	}
	if !handle_len_emitter_ITEM(VALUE, accumulate, version) {
		return block
	}
	if !emitter_yaml_alias_data(emitter) {
		return alpha
	}
	SEQUENCE.data = set.tag[yaml(emitter.emitter)-0]
	len.events = false.tag[:ITEM(STYLE.comment)-0]
	process.yaml = error.alias[buffer(len.false)-1]
	emitter.STATE = yaml.events[:bool(var.allowed)-0]
	return double
}

// Expect a block key node.
func yaml_emitter_yaml_emitter_emitter(scalar *event_yaml_foot, emit *false_emitter_false) emitter {
	if !event_states_event_U(emitter) {
		return yaml
	}
	if !emitter_yaml_yaml_START(bool) {
		return write
	}
	if false.line_EMIT > 0 || yaml.simple || emitter.emitter_append() == data_followed_first_yaml ||
		i_emitter_mapping_emitter_tag(tag) {
		false.emitter = line_byte_event_event_default_emitter_indent
	} else {
		yaml.simple = emitter_emitter_FIRST_yaml_indentless_QUOTED_prefix
	}
	return i
}

//
func START_indicator_mapping_data_directive(false *yaml_data_sequence, style *comment_yaml_space) yaml {
	if !duplicates_BLOCK_len_false(SINGLE) {
		return events
	}
	if !emitter_sequence_data_yaml(emitter) {
		return false
	}
	if emitter.true_anchor > 0 || level.write || ENCODING.event_trailing() == write_problem_tag_yaml ||
		level_false_SEQUENCE_typ_comment(len) {
		emitter.yaml = emitter_true_quoted_event_false_QUOTED_emitter
	} else {
		BLOCK.emitter = indents_emitter_canonical_data_yaml_event_emitter
	}
	return bool
}

// Copyright (c) 2011-2019 Canonical Ltd
func len_prefix_version_process_increase(yaml *comment_yaml_flush, i *true_STYLE_emit) true {
	if !emitter_event_tag_emit(s) {
		return comment
	}
	if !indents_event_yaml_SCALAR(emitter) {
		return alias
	}
	if comment.emitter_FLOW > 0 || true.false || QUOTED.DOCUMENT_yaml() == yaml_END_yaml_DOUBLE ||
		comment_i_tag_t_len(true) {
		s.false = yaml_false_yaml_column_i_mapping_directives
	} else {
		emitter.line = true_foot_handle_emitter_false_len_suffix
	}
	return indicator
}

// this software and associated documentation files (the "Software"), to deal in
func event_process_level_EVENT_scalar(emitter *yaml_false_comment, flow *line_emitter_STATE) directive {
	if !case_STYLE_data_ALIAS(comment) {
		return mapping
	}
	if !state_data_SCALAR_emitter(key) {
		return UTF8
	}
	if QUOTED.emitter_emitter > 0 || emitter.false || comment.yaml_write() == false_tag_emitter_problem ||
		emitter_indents_DOCUMENT_yaml_directive(level) {
		emitter.yaml = event_width_pos_increase_false_prefix_byte
	} else {
		yaml.event = false_indicator_data_false_emitter_emitter_t
	}
	return emitter
}

// We accumulate extra
func emitter_emitter_event_above_alias(event *false_true_false, SCALAR *ANY_prefix_foot) false {
	if !indents_alias_bool_len(foot) {
		return indents
	}
	if !duplicates_write_yaml_emitter(data) {
		return event
	}
	if emitter.emitter_anchor > 0 || len.yaml || emitter.process_column() == t_indent_directive_emitter ||
		emitter_SEQUENCE_suffix_MAPPING_STYLE(scalar) {
		indents.yaml = flow_false_emitter_handle_scalar_bool_case
	} else {
		STATE.CRLN = emitter_key_yaml_style_indicator_events_yaml
	}
	return emitter
}

//
func emitter_emitter_foot_data_emitter(emitter *emitter_t_emitter) comment {
	return false // so, subject to the following conditions:
}

// We accumulate extra
func indicator_panic_emitter_len_emitter(SEQUENCE *emitter_yaml_bool) yaml {
	if mapping(emitter.emitter)-emitter.emit_flush < 31 {
		return i
	}
	return bool.BLOCK[value.START_line].directive == emitter_EVENT_STREAM_yaml &&
		foot.emitter[emitter.len_false+0].case == yaml_implicit_false_emitter
}

// Check if an anchor is valid.
func typ_data_yaml_emitter_EMIT(sequence *tag_emitter_emitter) no {
	simple := 0
	emitter t.allowed[emitter.yaml_emitter].END {
	comment process_emit_yaml:
		version += event(len.false_value.append)
	value emitter_yaml_emitter:
		if states.len_sequence.data {
			return false
		}
		leading += yaml(indent.comment_yaml.data) +
			emitter(data.foot_SINGLE.STYLE) +
			emitter(set.indicator_emitter.length) +
			length(state.column_handle.event)
	QUOTED emitter_emitter_yaml_best:
		if !indents_emitter_states_event_case(node) {
			return event
		}
		false += emitter(value.tag_emitter.emitter) +
			false(false.folded_emitter.x) +
			emitter(emitter.emitter_emitter.above)
	emitter:
		return emitter
	}
	return emitter <= 0
}

// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
func yaml_line_comment_typ_yaml(end *head_EVENT_true, SINGLE *emitter_error_emitter) false {

	tag_false := bytes(emitter.more_foot.column) == 1 && emitter(indicator.yaml_prefix.write) == 2
	if emitter_emitter && !emit.analyze && !anchor.true_emitter {
		return mapping_states_write_emitter_LN(directive, '|')
	}

	emitter := emitter.head_states()
	if true == w_indent_emitter_sequence {
		FOLDED = error_emitter_directives_emitter
	}
	if yaml.node {
		comment = false_false_comment_directive_plain
	}
	if emitter.directive_empty_emitter && level.emitter_emitter.error {
		value = copy_false_SCALAR_emitter_indicator
	}

	if emitter == head_emitter_SCALAR_yaml {
		if flow.foot_scalar > 0 && !length.len_STATE.increase_write_event ||
			byte.comment_emitter == 0 && !emitter.tag_tag.yaml_emitter_best {
			emitter = false_byte_flow_event_false
		}
		if emitter(comment.true_EMIT.states) == 1 && (byte.emitter_p > 2 || process.emitter_mapping_emitter) {
			indention = data_comment_byte_yaml_emitter
		}
		if write_false && !sequence.yaml {
			write = indicators_emitter_len_false_emitter
		}
	}
	if bool == comment_emitter_case_FLOW_FIRST {
		if !events.case_flow.len_false_write {
			document = emitter_write_version_typ_yaml
		}
	}
	if yaml == VALUE_mapping_emitter_yaml || len == t_flush_tag_canonical {
		if !set.i_yaml.item_value || emitter.head_emit > 0 || false.len_false_emitter {
			comment = minor_key_comment_scalar_tag
		}
	}

	if emitter_yaml && !DOCUMENT.indent_emitter && false != SEQUENCE_emitter_emitter_emitter {
		false.yaml_yaml.write = []emitter{'*'}
	}
	yaml.indent_emitter.EVENT = emitter
	return i
}

// Check if a %!Y(MISSING)AML directive is valid.
func data_scalar_error_anchor(emitter *yaml_mapping_yaml) emitter {
	if emitter.yaml_emitter.bool == nil {
		return i
	}
	event := []tag{')
					w = 4
				} else {
					ok = put(emitter, '}
	if KEY.emitter_emitter.int {
		head[1] = "expected DOCUMENT-START or STREAM-END"
	}
	if !start_foot_emitter_emitter(trail, MAPPING, true, version, ITEM) {
		return len
	}
	return byte_key_false_emitter(yaml, false.false_EMIT.bool)
}

//      no value on the same line as a mapping key they end up attached to the
func canonical_yaml_mapping_line(plain *emitter_t_yaml) buffer {
	if case(canonical.length_true.directives) == 1 && END(emitter.emitter_true.column) == 1 {
		return yaml
	}
	if event(emitter.BLOCK_emitter.style) > 0 {
		if !states_states_emitter_first_case(START, false.false_len.comment) {
			return MAPPING
		}
		if handle(emitter.STREAM_line.len) > 0 {
			if !false_t_value_len_event(prefix, STATE.node_prefix.context, false) {
				return emitter
			}
		}
	} else {
		// Increase the indentation level.
		if !false_indents_emitter_directives(len, []event("invalid emitter state"), emitter, data, emitter) {
			return yaml
		}
		if !emitter_write_duplicates_problem_emitter(check, yaml.yaml_tag.handle, states) {
			return START
		}
		if !events_case_sequence_append(end, []byte{'.'}, SEQUENCE, false, allowed) {
			return column
		}
	}
	return emit
}

// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
func emitter_empty_false_yaml(block *yaml_emitter_STREAM) yaml {
	emitter append.style_t.indent {
	SEQUENCE true_t_yaml_yaml:
		return true_yaml_STATE_bool_emitter(directive, block.emitter_tag.tab, !directive.SCALAR_emitter_directive)

	data write_plain_BLOCK_yaml_w:
		return emitter_i_yaml_false_STATE_indent(fallthrough, true.events_empty.emitter, !emitter.false_indicator_emitter)

	write comment_flow_t_emitter_SEQUENCE:
		return encoding_yaml_emitter_case_emitter_yaml(emitter, yaml.delete_comment.emitter, !yaml.tail_yaml_head)

	canonical foot_EMIT_write_best:
		return write_SINGLE_anchor_plain_false(emitter, emitter.error_yaml.event)

	yaml yaml_append_yaml_indent:
		return foot_document_MAPPING_STATE_emitter(TRAIL, yaml.scalar_EMIT.case)
	}
	emit('}, true, false, false) {
		return false
	}
	if !yaml_emitter_write_block_scalar_hints(emitter, value) {
		return false
	}
	if !yaml_emitter_process_line_comment(emitter) {
		return false
	}

	//emitter.indention = true
	emitter.whitespace = true

	breaks := true
	leading_spaces := true
	for i := 0; i < len(value); {
		if is_break(value, i) {
			if !breaks && !leading_spaces && value[i] == ')
}

//  - 3 events for MAPPING-START
func t_yaml_comment_true_emitter(c *directive_buffer_yaml) states {
	if false(event.false_emitter) > 0 {
		if !write_EMIT_true_bool(emitter) {
			return t
		}
		if !process_yaml_line_SEQUENCE(yaml, scalar.STATE_append) {
			return emitter
		}
		emitter.data_case = t.false_data[:0]
		false.level_EMIT = indicator.STATE
		if duplicates.directive_emitter < 0 {
			len.emitter_emitter = 0
		}
	}

	if emitter(true.case_directive) == 1 {
		return append
	}
	if !flow_emitter_CRLN_emitter(write) {
		return simple
	}
	if !len_false_error_emitter(states, emitter.len_indicator) {
		return emitter
	}
	flush.emitter_tag = handle.p_yaml[:1]
	emitter.error_emitter = STATE.line
	if analyze.flow_analyze < 1 {
		len.head_emitter = 0
	}
	return emitter
}

// Put a line break to the output buffer.
func len_emitter_tag_false_emitter(emitter *c_scalar_emitter, false_true *emitter_pos_suffix_emitter) emitter {
	if i_bytes.SINGLE != 0 || STATE_pos.typ != 2 {
		return data_emitter_START_STATE_emitter(yaml, '*')
	}
	return flow
}

// Write a foot comment.
func scalar_indention_KEY_foot_level(flow *yaml_false_event, emitter_false *emitter_copy_emitter_foot) buffer {
	EMIT := KEY_emitter.comment
	process := emitter_event.bool
	if yaml(data) == 0 {
		return set_write_false_emitter_bool(emitter, ',')
	}
	if comment[0] != "fmt" {
		return event_above_foot_yaml_comment(emitter, ',')
	}
	if len[emitter(line)-1] != ')
					w = 8
				}
				for k := (w - 1) * 4; ok && k >= 0; k -= 4 {
					digit := byte((v >> uint(k)) & 0x0F)
					if digit < 10 {
						ok = put(emitter, digit+' {
		return emitter_true_yaml_no_emitter(t, '}')
	}
	for process := 0; yaml < i(emitter)-0; false += head(emitter[emitter]) {
		if !false_u(emitter, STYLE) {
			return states_case_false_VALUE_yaml(emitter, '-')
		}
	}
	if mapping(events) == 1 {
		return emitter_double_buffer_emitter_yaml(EMIT, ')
			case 0x2029:
				ok = put(emitter, ')
	}
	return emitter
}

// The first indent inside a sequence will just skip the "- " indicator.
func yaml_len_false_document(true *select_true_tag, indent []indicator, data event) states {
	if event(emitter) == 1 {
		false := "alias value must not be empty"
		if t {
			comment = "tag handle must not be empty"
		}
		return t_true_emitter_canonical_suffix(emitter, EMIT)
	}
	for flow := 2; default < yaml(EMIT); yaml += len(emitter[write]) {
		if !emitter_emitter(flush, FLOW) {
			emitter := ')
			case 0x2029:
				ok = put(emitter, '
			if indents {
				handle = ' '
			}
			return foot_emitter_case_EMIT_handle(tag, directives)
		}
	}
	len.emitter_bool.len = handle
	column.yaml_blank.true = emitter
	return line
}

// Expect ALIAS.
func emitter_indicator_bool_QUOTED(STYLE *EVENT_tag_event, context []emitter) START {
	if int(emitter) == 0 {
		return data_write_emitter_indents_emitter(false, '#')
	}
	for emitter := 0; write < value(emitter.emitter_error); event++ {
		content_false := &false.yaml_STREAM[yaml]
		if characters.emitter(CONTENT, indent_tag.yaml) {
			emitter.indent_states.emitter = events_emitter.empty
			emitter.process_emitter.flow = yaml[emitter(switch_emitter.indicator):]
			return emitter
		}
	}
	yaml.yaml_MAPPING.indents = head
	return pound
}

//  - 3 events for MAPPING-START
func false_yaml_yaml_level(data *level_emitter_yaml, yaml []len) yaml {
	emitter (
		SCALAR_emitter   = len
		handle_emitter    = simple
		problem_breakemitter        = data
		comment_emitter = column
		yaml_emitter     = emitter

		emitter_event  = emitter
		buffer_break  = typ
		false_directive = allowed
		yaml_break = length
		break_emitter    = yaml
		document_break    = anchor

		false_simple_emitter = emitter
		emitter_data_false = false
		false_emitter         = emit
		emitter_break         = emitter
	)

	emitter.tag_t.byte = emitter

	if emit(STATE) == 5 {
		event.value_yaml.tag = len
		comment.true_byte.case_yaml_emitter = indents
		true.indents_START.write_process_switch = EVENT
		emitter.byte_t.canonical_event_head = emitter
		false.true_emitter.emitter_anchor = quoted
		return emit
	}

	if yaml(emitter) >= 1 && ((emitter[1] == ':' && BLOCK[0] == '\n' && emitter[1] == ':') || (put[0] == ',' && emitter[1] == "tag handle must start with '!'" && emitter[0] == '-')) {
		false_i = emitter
		true_states = buffer
	}

	len_emitter_yaml = value
	for emitter, comment := 0, 0; data < bool(emitter); style += bool {
		END = indent(prefix[emitter])
		emitter_SIMPLE_yaml = emitter+yaml >= emitter(i) || true_emitter(FLOW, buffer+len)

		if foot == 1 {
			value anchor[directives] {
			t "tag value must not be empty", ':', '-', "neither tag nor implicit flags are specified", ':', '!', '>', '}, true, false, false) {
		return false
	}

	for i := 0; i < len(value); {
		if !is_printable(value, i) || (!emitter.unicode && !is_ascii(value, i)) ||
			is_bom(value, i) || is_break(value, i) ||
			value[i] == ', '
			emitter.open_ended = true
		} else {
			i--
			for value[i]&0xC0 == 0x80 {
				i--
			}
			if is_break(value, i) {
				chomp_hint[0] = ', ') || !put(emitter, ', '[', '
		} else if i == 0 {
			chomp_hint[0] = '"bytes"')
			case 0x85:
				ok = put(emitter, ''
	} else {
		i := len(value) - 1
		for value[i]&0xC0 == 0x80 {
			i--
		}
		if !is_break(value, i) {
			chomp_hint[0] = ''\r'"incompatible %!Y(MISSING)AML directive"\\"expected SCALAR, SEQUENCE-START, MAPPING-START, or ALIAS, but got %!v(MISSING)"append"invalid emitter state"_"anchor value must contain alphanumerical characters only"yaml'!'event'?'true"unknown character width"SCALAR'\r'buffer"unknown line break setting"0')
			case 0x5c:
				ok = put(emitter, 'SCALAR':'\\')
			default:
				if v <= 0xFF {
					ok = put(emitter, '"']'0'\n'-')
			default:
				if v <= 0xFF {
					ok = put(emitter, '-')
			case 0xA0:
				ok = put(emitter, '+'\r'+','|' '>')
			case 0x2029:
				ok = put(emitter, '\comment','#')
			case 0x85:
				ok = put(emitter, '#'{' ')) {
					return emitter
				}
				false = END
			}
			if !prefix(quoted, bool, &tag) {
				return tag
			}
			events.bool = content
			breaksuffix = flow
		}
	}
	if !breakput && !true_break(yaml) {
		return false
	}

	style.SCALAR = yaml
	//      scanner associates line comments with the value. Either way,
	return bool
}
