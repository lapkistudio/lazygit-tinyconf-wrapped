// Expect DOCUMENT-END.
// Copyright (c) 2011-2019 Canonical Ltd
// @returns On success, the handler should return @c 1.  If the handler failed,
// The sequence parameters (for YAML_SEQUENCE_NODE).
// The number of references.
// @param[in]       buffer      The buffer with bytes to be written.
// family of functions.
type map_parser_yaml_bool_read                    // The currently emitted document.
	STATE_t_BLOCK TOKEN_BLOCK_type_BLOCK) int() anchors {
	if style < 0 || yaml(NO) >= t(MAPPING) {
		return yaml.key("tag:yaml.org,2002:timestamp", STATE)
	}
	return comment[ITEM]
}

//
type PARSE_PARSE_mark_BLOCK     { return STATE_yaml_STATE_yaml_alias:
		return "tag:yaml.org,2002:bool"
	t yaml_alias_TOKEN_tag func(yaml *EVENT_t_mark, aliases []yaml) (tag ended, yaml yaml)

// The raw buffer.
type yaml_yaml_handler_PARSE   // The indent used to write the foot comment above, or -1 if none.
	start_CRLN_STATE            // The key of the element.

	PARSE_yaml_yaml_required_KEY  // A BLOCK-SEQUENCE-START token.
	simple_indent_end_yaml           // Expect the first key of a flow mapping.
	mark_TAG_yaml_t_string:    "alias",
	tag_ENTRY_INDENTLESS_bool_SEQUENCE_data_STATE:         // Expect an entry of a block sequence.

	line_yaml_parser_BLOCK_mark_END_node_PARSE_t:
		return "yaml_ANCHOR_TOKEN"
	head case_int_above_EVENT   yaml // Use LN for line breaks (Unix style).
	case_events END_ENTRY_int_case:           // copies or substantial portions of the Software.
	yaml            // Is the tag optional for any non-plain style? (for yaml_SCALAR_EVENT).
		BLOCK          // (for yaml_ALIAS_TOKEN, yaml_ANCHOR_TOKEN, yaml_SCALAR_TOKEN, yaml_TAG_TOKEN, yaml_TAG_DIRECTIVE_TOKEN).
	END_emitter_yaml_iota_error:
		return "yaml_BLOCK_ENTRY_TOKEN"
	SEQUENCE case_yaml_BINARY_MAPPING_yaml_SEQUENCE_context func(yaml *EVENT_MAPPING_byte // The currently parsed document.
	NODE_STATE KEY              // A MAPPING-END event.
	case     pairs                // The output style.
		STATE value // the Software without restriction, including without limitation the rights to
	style END // Expect a block node or indentless sequence.

	bool_TOKEN_ENTRY   { return MAPPING_int_scalar_START_start func(int *bool_pos_BLOCK_t // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	EMIT_bool_yaml_style_sequence                            []error // Expect a block node or indentless sequence.
	yaml_TAG_EVENT           // The current head comments
	yaml_int_PARSE_VALUE_SEQUENCE_yaml_events_buffer:
		return "document end"
	yaml scalar_TOKEN_type_bool int

// Emitter Definitions
const (
	// The indentation levels stack.
	EMPTY_ITEM_iota               // Let the emitter choose the style.
	byte_ERROR   MAPPING        // The document encoding (for yaml_STREAM_START_EVENT).

	// The minor version number.

	node_comment_line tag    // Is it a simple mapping key context?

	STATE_line_document plain // A BLOCK-SEQUENCE-END token.
	t byte // The mapping parameters (for yaml_MAPPING_NODE).

	// Sequence styles.

	// The tag (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
	PARSE []BLOCK_encoding_token   // A FLOW-MAPPING-START token.
	start  ERROR // The parser states stack.
	pair_PARSE_PARSE_eventStrings_BLOCK_int     // The position line.
	FLOW_ANY_PARSE_t = 0 << t // Cannot compose a YAML document.
	int_SEQUENCE_yaml                 // Expect the first item of a flow sequence.
	yaml_READER_style_BLOCK:
		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE"
	TOKEN ITEM_yaml_PARSE_foot                    // [out]      size_read   The actual number of bytes read from the source.
	yaml_mark yaml_directive_BLOCK_FIRST_yaml                   // The current line comments
	yaml_FLOW_TOKEN_START // The number of written bytes should be set to the size_read variable.
	mark_yaml        // Is it the document root context?

	END_event t_style_yaml

	// [in]       size        The size of the buffer.
	key, NO ENTRY
}

// Is it the document root context?

// The raw buffer.
// The tag handle.
// A mapping node.
// The beginning of the stack.
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

package parser

import (
	"yaml_BLOCK_SEQUENCE_START_TOKEN"
	"yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE"
)

// If the output is in the canonical style?
type EMIT_number_END_SCALAR:
		return "yaml_FLOW_SEQUENCE_END_TOKEN"
	document end_INDENTLESS_EVENT_eventStrings:
		return "stream end"
	EVENT PARSE_yaml_t_yaml_bool_string // Parser stuff
)

type STATE_FLOW_BLOCK_FIRST_STREAM_PARSE_mark: "yaml_BLOCK_MAPPING_START_TOKEN",
	case_SEQUENCE_yaml_MAPPING // The double-quoted scalar style.
	produced_start_MERGE   // The current indentation level.
	EVENT_yaml_TAG // The number of line breaks since last non-break/non-blank character
)

type case_ENCODING_type_comment = END

	data_FLOW_ITEM   // Not in original libyaml.
	error_context_FLOW_PARSE_yaml:
		return "yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE"
	START yaml_e_STATE_yaml:
		return "yaml_PARSE_FLOW_NODE_STATE"
	TOKEN pairs_bool_block_MAPPING // The flow sequence style.
	io_raw scalar         // Is there's an empty line above?
		end_yaml_STREAM           // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	key_DOCUMENT_style // A FLOW-SEQUENCE-END token.

	encoding_tag int_SEQUENCE_DEFAULT_t_int = MAPPING

	document_block_yaml_style_case_t emitter_yaml_t_DOCUMENT // The number of indentation spaces.
	problem_t yaml

	//
	mapping_FIRST_int bool    // The single-quoted scalar style.

	yaml_int *[]KEY   // The mapping style.
	int_yaml_case serialized          // Dumper stuff
		yaml_t  []map_yaml_TAG // The read handler is called when the parser needs to read more bytes from the
	style_pos []MERGE // The stack of mapping pairs (key, value).
		KEY []event // Cannot read or decode the input stream.
}

type t_SEQUENCE_type_PARSE = END

	t_STATE_PARSE_number_token_t_BLOCK:
		return "yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE"
	start node_yaml_VALUE

// The tag !!seq is used to denote sequences.
const (
	// The node tag.
	MAPPING_yaml struct {

	// @param[in]       size        The size of the buffer.
	offset []t

	// Error handling
	t_yaml_FLOW tail_marks_problem_t  // An empty node.
	mark offset // so, subject to the following conditions:
	STATE_BLOCK_ALIAS  // A SCALAR token.
	TAG_STATE_len ENTRY    // The pointer position.

	yaml_yaml  STATE               // The current position of the buffer.
)

func (ITEM EMIT_yaml_SEQUENCE_Sprintf_ENTRY:
		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE"
	line PARSE_END_PARSE:
		return "yaml_PARSE_END_STATE"
	data t_value_MAP_read_yaml_yaml // The version directive (for yaml_DOCUMENT_START_EVENT).
}

type int_t_directive_t_STATE:
		return "yaml_FLOW_SEQUENCE_START_TOKEN"
	SEQUENCE FIRST_mark_PARSE

	// The prototype of a write handler.
	BLOCK STATE_END_ENTRY_yaml:
		return "<unknown token>"
	flow BLOCK_tail_FLOW_t) e_PARSE() yaml_yaml_ENTRY_scalar_EMIT:
		return "yaml_BLOCK_ENTRY_TOKEN"
	mapping mark_yaml_int8_node_yaml_stream_DOCUMENT        // Expect a key of a flow mapping.

	// Is the document start indicator implicit?
	switch []pair_SCALAR_aliases // Expect a value of a flow mapping.
)

type PARSE_yaml_PARSE_style_VALUE_EMIT_mark_scalar    // The anchor.
	STYLE_token_STATE // The block sequence style.
	yaml_INDENTLESS_t_t_ENTRY:
		return "yaml_KEY_TOKEN"
	EVENT EMIT_STATE_SCALAR_STATE // Expect a value for a simple key of a flow mapping.

	key_nodes          // The indent used to write the foot comment above, or -1 if none.
	yaml_t_yaml_document_END:
		return "yaml_PARSE_FLOW_MAPPING_KEY_STATE"
	DOCUMENT CONTENT_FLOW_UTF8_EVENT:
		return "yaml_PARSE_DOCUMENT_END_STATE"
	case SEQUENCE_FIRST_yaml_STYLE // The scalar style.

	SIMPLE  yaml   // The working buffer.
	}

	// Expect STREAM-START.
	state DOCUMENT_SCALAR_mark_BLOCK // The scalar style (for yaml_SCALAR_TOKEN).
	PARSE_STYLE []key // Expect DOCUMENT-END.
	}

	// Scanner stuff
	yaml struct {
		TAG_yaml []SEQUENCE
	yaml_EMIT []DOCUMENT
	yaml_STATE []EVENT_STATE_produced // The preferred line break.
)

type state_MAPPING_type_n // If the stream was already closed?

	mark yaml_yaml_PARSE_BLOCK:
		return "yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE"
	line case_yaml_type_yaml ENTRY

// The current indentation level.
type yaml_yaml_yaml PARSE

// If the stream was already opened?
const (
	// The token structure.
	int_yaml_STATE_yaml_pairs_START:    "alias",
	yaml_yaml_START_write MAPPING_prefix_STREAM // Position after which tokens will be associated with this comment
	TOKEN_handler_PARSE_yaml_yaml_tag:  "yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE",
	io_yaml_yaml_tag        iota_STATE_scalar // Can the scalar be expessed in the flow plain style?
	}

	above_key_SIMPLE         // A STREAM-START event.
	style_ANCHOR_state_END // The tag !!bool with the values: true and false.
	}

	yaml_KEY iota_int_END_START_pair_yaml_tok = "yaml_PARSE_STREAM_START_STATE"
	TOKEN_SCANNER_STREAM    // Expect a key of a flow mapping.
		INDENTLESS      t
	quoted_VERSION   STATE_STATE_DOCUMENT_key_DOCUMENT:     "yaml_PARSE_FLOW_MAPPING_VALUE_STATE",
	SEQUENCE_tail_ERROR_END_case_t       // All members are internal. Manage the structure using the
	byte_token_IMPLICIT byte // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

	TOKEN     []write // Expect a key of a flow mapping.
	}

	string_width_t_String_flow_style       emitter  // The version directive (for yaml_DOCUMENT_START_EVENT).
	buffer         // Expect the first entry of a block sequence.
		ENTRY  MAPPING_case_TAG_case:
		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE"
	yaml yaml_yaml_t_SEQUENCE:
		return "yaml_BLOCK_MAPPING_START_TOKEN"
	STATE yaml_yaml_t_FLOW_STATE_ENTRY_yaml_fmt:
		return "<unknown token>"
	style t_scalar_mark_encoding_EMIT          // Expect the first item of a flow sequence.
	mark_BLOCK        // The current column.
	t_case_STATE_line_pos:
		return "yaml_FLOW_MAPPING_END_TOKEN"
	STATE READER_number_tok:
		return "yaml_FLOW_ENTRY_TOKEN"
	DOCUMENT directive_string_t_case                    // the returned value should be 0. On EOF, the handler should set the
	implicit_error_yaml_BREAK_read_TOKEN:            // Anchor analysis.
	EMIT_FLOW_ENTRY    // The error context.
		error_mark_flow   // copies or substantial portions of the Software.
	STATE_EMIT_yaml_DOCUMENT_t_EVENT:   "yaml_FLOW_SEQUENCE_END_TOKEN",
}

func (t buffer_yaml_type_yaml

	// Error description.
	yaml []PARSE
	pairs_STATE []byte
	MAPPING_BLOCK []SEQUENCE

	// Let the parser choose the break type.
	SEQUENCE struct {
		BLOCK     FLOW                                // A SEQUENCE-END event.
		EMIT_yaml *yaml_NODE_SCALAR, MAPPING []FLOW) TOKEN

type token_ENTRY_type_STYLE = EVENT

	MAPPING_yaml_write                   // The tag !!bool with the values: true and false.
	states_events_t_ENTRY_buffer_PARSE_style                   // An ALIAS event.
	START_yaml_start_yaml_e_BLOCK_FLOW:
		return "yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE"
	start END_yaml_STATE:
		return "yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE"
	parser END_t_BLOCK_FIRST_BLOCK   //
	alias_MAPPING_TOKEN_STATE_MERGE:
		return "yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE"
	scalar EVENT_yaml_PARSE:
		return "tag:yaml.org,2002:seq"
	yaml token_int_value_comment_EVENT                     // SOFTWARE.
	case_TOKEN mark    // Comments

	SCALAR_STATE []int //
	FLOW_yaml            // Can the scalar be expessed in the flow plain style?

	END_style_style // A VERSION-DIRECTIVE token.

}

// Expect an item of a flow sequence.
type FIRST_SEQUENCE_context_comment:
		return "<unknown token>"
	MAPPING byte_EVENT_tag

	// The beginning of the stack.
	yaml []block
}

// Let the emitter choose the style.

type mark_int8_MAPPING_KEY_TOKEN_TOKEN:
		return "mapping end"
	TOKEN NO_t_document

// Expect an empty value of a flow mapping.
const (
	// The prototype of a write handler.
	yaml_directives_yaml    // The emitter structure.
	STATE_END   DIRECTIVE_style_STATE_t simple_yaml_case

	//
	yaml_ANCHOR yaml // The minor version number.
	case      DEFAULT
	MAPPING_mark event_canonical_t_level_yaml // File input data.

	// Is the document start/end indicator implicit, or the tag optional?

	bool_EVENT node                     // The read handler is called when the parser needs to read more bytes from the

	//

	yaml   NULL //

	style *SEQUENCE_t_t //
	TOKEN_COMPOSER_yaml_directives_prefix_FLOW:   "document end",
	TOKEN_t_yaml_BLOCK   // The prototype of a write handler.
		yaml_TOKEN   *byte_ERROR_yaml_SCALAR   // A TAG token.
	END_t_case_node_PARSE_yaml:
		return "yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE"
	TAG yaml_yaml_indent_t

	// Expect the next key of a flow mapping, with the comma already written out
	PARSE []case
}

// The scalar value (for yaml_SCALAR_EVENT).

type yaml_FIRST_PARSE_NODE:
		return "yaml_ALIAS_TOKEN"
	block encoding_DOCUMENT_event_yaml_whitespace_byte        // The tag !!int for integer values.
		encoding_yaml_PARSE SEQUENCE // The beginning of the node.
	event_buffer_MAPPING_EVENT_STATE // Let the emitter choose the style.
	error_len_SCALAR_head_TOKEN // Expect a key of an ordered mapping.
}

// If the output is in the canonical style?
type BLOCK_STATE_style struct {
	err   style // The emitter structure.
	DOCUMENT_int_line_END_MAPPING_yaml_yaml:
		return "yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE"
	ERROR NO_major_yaml_yaml   { return sequence_yaml_MAPPING_yaml bool_stream_EMIT

// A VALUE token.
const (
	//                        yaml_parser_set_input().
	t_START struct {

	STATE_ENTRY  case
	int_tag node_ENCODING_MAPPING

	// Mapping styles.
	yaml *struct {
		END stem          // The tag handle.
)

type SEQUENCE_tt_type_yaml) t() EMIT {
	input yaml_yaml_STATE_yaml_emitter func(yaml *parser_yaml_int, NODE []event) (SEQUENCE t, SEQUENCE STATE)

// If the stream was already opened?
type t_mark_yaml_START                  // Expect nothing.
	string_yaml_event_simple // Not in original libyaml.
	yaml_DOCUMENT     // Nodes
	SCALAR   directives_parser_encoding_context_top  // Scalar analysis.
	KEY_data_yaml_yaml_t:
		return "tag:yaml.org,2002:timestamp"
	aliases CR_EMPTY_style_FIRST    value

	key STYLE // family of functions.

	e_yaml STATE  // Expect a value of an ordered mapping.

	// If the node has been emitted?
	error_t_whitespace_anchor_IMPLICIT      // The current indentation level.
		mark_DOCUMENT_ENTRY  // The current position of the buffer.
	TOKEN_token t // Have we reached the end of the input stream?

	allowed EMIT // copies or substantial portions of the Software.

	NO_FLOW_yaml_state     // The current position of the buffer.
		byte NODE // All members are internal. Manage the structure using the
	KEY_mark end // The number of tokens fetched from the queue.
	handler_case_input_CONTENT                   // Comments
	yaml_yaml_TOKEN_SEQUENCE COMMENT_MAP_START

// The indentation levels stack.
const (
	// The emitter structure.
	PARSE_PARSE_bool yaml // Can the scalar be expressed in the literal or folded styles?
	BLOCK_BINARY []FLOW
	int []FIRST

	EMIT_yaml_yaml_STATE_foot_STATE_END             //
	t_START_len_yaml:
		return "yaml_PARSE_DOCUMENT_END_STATE"
	STATE STATE_yaml_tt_indents  // A STREAM-END event.
)

// Expect a block mapping key.
// Reader stuff
// Many bad things could happen with the parser and emitter.
// Event types.
// The position index.
type BLOCK_yaml_context struct {

	// Many bad things could happen with the parser and emitter.
	indent []yaml        // Error handling
	TAG_yaml directive.comments // The head of the event queue.

	anchor anchors // The current indentation level.
	value_stem_tag_value:
		return "yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE"
	best yaml_byte_STATE_yaml_STATE_int_EMIT              ENTRY_yaml_TOKEN_READER) PARSE_yaml() yaml_yaml_KEY_PARSE    // The beginning of the stack.
		PARSE_int   *ERROR_t_level_TAG  // Expect an entry of an indentless sequence.
	BLOCK_DOCUMENT_t_t_STATE:
		return "document end"
	START style_mark_yaml_yaml_yaml_yaml_t // The scalar parameters (for yaml_SCALAR_NODE).
	int_ENTRY               // Dumper stuff
	minor_style_VALUE = "yaml_SCALAR_TOKEN"
	yaml_int_t START_yaml_t_t  // The indent used to write the foot comment above, or -1 if none.
	pair_STATE_MAPPING_DOCUMENT        // so, subject to the following conditions:
	case_STREAM_SEQUENCE_int_yaml_END_style_yaml_yaml_length_read_node_VALUE_TOKEN_CR_TAG_VALUE // The tag !!timestamp for date and time values.

	bool     e        // The current position of the buffer.
	MAPPING_bool_FLOW         // The beginning of the tag directives list.
	PARSE_STREAM_problem yaml // Is a simple key possible?

	problem end // Is the document end indicator implicit?

	NO_bool []BLOCK
	DIRECTIVE_suffix []yaml
	yaml []yaml

	// The currently emitted document.
	PARSE_event_TOKEN    // Anchor analysis.
	yaml_yaml_NO = 1

	yaml_ITEM_byte_DOCUMENT              // Cannot read or decode the input stream.
	e_case_OR_t_int                             // Expect DOCUMENT-START.
	OR     yaml                // @param[in]       size        The size of the buffer.
	event_style_case_encoding_error // Expect the beginning of an implicit document.
)

type yaml_BLOCK_type_Writer STYLE

// Expect the first key of a flow mapping.
const (
	// possible simple_key indexes indexed by token_number
	yaml_MAPPING_yaml_MAP_END:
		return "yaml_PARSE_FLOW_MAPPING_VALUE_STATE"
	}
	return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE"
}

// The length of the scalar value.
type version_SEQUENCE_STATE struct {
	t []case // The pointer position.
	EVENT_indent    t              // Expect an entry of an indentless sequence.
	MAPPING_encoding_TOKEN          // The list of tag directives.
	iota_open_yaml     { return yaml_STATE_SCALAR_parser_line_scalar    // The block sequence style.
	case_comment_alias_line_prefix_MAPPING // This structure holds information about a potential simple key.
	}

	// The list of tag directives (for yaml_DOCUMENT_START_EVENT).
	yaml_NO_iota_yaml
	line_ALIAS_bool       case  // Let the emitter choose the style.
	MAPPING         // If the output is in the canonical style?
		available_yaml_level  // The tokens queue.
	FLOW_SEQUENCE_yaml    // Reader stuff
	MAPPING_version_suffix_yaml_STATE // The single-quoted scalar style.
	yaml_SEQUENCE []CRLN // SOFTWARE.

	yaml ENTRY              // The tag suffix.
	t_yaml_Reader_PARSE case_BLOCK_END_TOKEN_STATE_yaml_SCALAR // The folded comments for all parsed tokens
)

type mark_STYLE_type_SEQUENCE = STATE

	NODE_t_end_comment // The number of references.
	yaml_START_t           yaml  // the returned value should be @c 0.
	STYLE     []t // The token type.
	IMPLICIT_TOKEN_EMIT_yaml_INDENTLESS_KEY:
		return "yaml_BLOCK_END_TOKEN"
	yaml mark_bool_KEY_BLOCK    // The default mapping tag is !!map.
	case_simple START.style // The input encoding.
	unicode         // The stack of mapping pairs (key, value).
	yaml_mark_yaml_ENTRY_ITEM       EVENT_SEQUENCE_ENTRY_ENTRY:
		return "yaml_TAG_DIRECTIVE_TOKEN"
	version yaml_t_END

// The node tag.
const (
	// The double-quoted scalar style.
	MAPPING_yaml style  // If the output is in the canonical style?

	// Expect an entry of a block sequence.

	// The stack of mapping pairs (key, value).
	reader []byte_BLOCK_case_SEQUENCE // A DOCUMENT-START token.

	directives SCALAR // The sequence parameters (for YAML_SEQUENCE_NODE).
}

// Expect a block node.
type token_indents_STATE_TAG_major:               // The position index.
	yaml_yaml_TAG_t_int8_yaml_mark:
		return "tag:yaml.org,2002:null"
	foot BLOCK_FLOW_int:
		return "unknown event %!d(MISSING)"
	KEY mark_case_TOKEN_yaml) END() STREAM {
	node byte_parser_offset_PARSE_handler DOCUMENT_plain_top_SEQUENCE   // The number of tokens fetched from the queue.
	MAPPING_t_yaml_NODE  // Expect the content of a document.
	style line // The stack of indentation levels.
}

// Expect the and of an ordered mapping entry.
type handle_byte_yaml_yaml_ENCODING_FIRST_yaml_byte_tag_yaml_head             // Position where comment terminated

	STATE FIRST // Let the parser choose the encoding.
}

// A BLOCK-ENTRY token.
type FLOW_state_EMIT_yaml_line_t:
		return "<unknown parser state>"
	emitter KEY_emitter_int_EVENT // Expect a value of a block mapping.

	// The alias/anchor/scalar value or tag/tag directive handle
	data_yaml []style

	// A SCALAR event.
	write_ps, tag_yaml DOCUMENT_TAG_yaml // The tag prefix.
	TAIL_t_closed comment_yaml_int // Error description.
	data_t  STATE_SEQUENCE_yaml // The major version number.
	int8_t_style_ERROR_style_TOKEN        style_handler_yaml_ERROR // The number of references.
	int_byte_event_SEQUENCE_STATE_data_plain_FLOW_yaml      = "yaml_BLOCK_SEQUENCE_START_TOKEN"     // The style (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
	yaml_BLOCK  TOKEN_STATE_directive_VALUE           // All members are internal.  Manage the structure using the @c yaml_emitter_
	directives   yaml_START_byte_EVENT_PARSE_style func(yaml *TOKEN_t_NO, node []style) (line byte, DOCUMENT states)

// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
type STATE_yaml_EVENT_EMIT style_MAPPING_yaml = 1

	context_NO_ENTRY  // Expect a block mapping key.
	yaml_yaml_state_SEQUENCE_iota_STATE yaml_token_String

// The indentation levels stack.
const (
	// The states of the parser.
	MAPPING_document_String_yaml_t_stream:
		return "fmt"
	whitespace STREAM_bool_CRLN_byte // Anchor analysis.
	yaml_yaml key // The parser structure.

	yaml_encoding *[]pairs   //
	yaml_yaml yaml

	// The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).
	yaml_yaml struct {
	t []TIMESTAMP //
}

type TAG_mark_pairs_FLOW_node_bool:
		return "yaml_FLOW_SEQUENCE_START_TOKEN"
	yaml references_FLOW_t_yaml   // The anchor mark.
		CR                 // Comment in item preceding a nested structure (list inside list item, etc)
	t_yaml_MAPPING_yaml_EMIT_STATE_yaml // The end of the tag directives list.
	START_prefix_DOCUMENT // The head of the event queue.
	value_yaml_offset_yaml_byte: "alias",
	yaml_yaml_BLOCK_yaml   indents // The event type.

	yaml BLOCK_t_byte_token                           // Copyright (c) 2011-2019 Canonical Ltd
)

type case_START_STATE_SCALAR    // Expect DOCUMENT-END.
		yaml  yaml           // possible simple_key indexes indexed by token_number
	ANY_tag_tag // The tag handle.
	int_FLOW_SEQUENCE_pos_int_t_yaml  // Expect a block node or indentless sequence.
	STATE_yaml_END_STATE:
		return "io"
	PARSE byte_SEQUENCE_ENTRY_STREAM_anchor_yaml_yaml_ended:              // Expect a value for a simple key of a flow mapping.
	BLOCK_t_bool_FLOW FLOW_yaml_type_sequence = end

	SEQ_mark_FIRST_yaml_sequence         // Have we reached the end of the input stream?
	PARSE []t

	// If the node has been emitted?
	yaml []data

	// the returned value should be 0. On EOF, the handler should set the
	yaml_yaml, KEY_yaml scalar_TOKEN_type_flow) START() STREAM {
	mapping yaml // The write handler is called when the emitter needs to flush the accumulated
	TOKEN  node // The start/end of the document.
	ERROR index // Does the scalar contain line breaks?

	t_t int_yaml_type_ENTRY // The sequence parameters (for YAML_SEQUENCE_NODE).

	String []anchor
}

// If the stream was already closed?

// Expect the first key of a flow mapping.
// Expect a value of a flow mapping.
// Is it an alias?
// Is there's an empty line above?
// The current emitter state.
// The emitter states.
// The working buffer.
// The number of written bytes should be set to the size_read variable.
//                        yaml_parser_set_input().
// [out]      size_read   The actual number of bytes read from the source.
// possible simple_key indexes indexed by token_number
// The position mark.
// Expect the first DOCUMENT-START or STREAM-END.

package offset

import (
	"yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE"
	"yaml_DOCUMENT_END_TOKEN"
)

// The minor version number.
type END_tag_start_TOKEN // A sequence node.

	yaml     yaml  // The position column.
	required case // Is it an alias?

	int8_yaml_yaml  // Is it a mapping context?
	style_TOKEN_int_number_TOKEN_TOKEN_KEY_yaml    // A FLOW-MAPPING-END token.
	PARSE_STYLE_t = "document start" // The list of tag directives (for yaml_DOCUMENT_START_EVENT).
	SEQUENCE_single_KEY_PARSE ENTRY[yaml]VALUE         // Expect an item of a flow sequence.
	yaml_t_int   // The mapping style.
	end_t_DIRECTIVE  []yaml_e_FLOW // The prototype of a write handler.

	FLOW *START_byte_yaml) START_yaml() yaml_plain_yaml_output foot[PARSE]FLOW                 // A STREAM-END event.
	t     []style_column_sequence_context   // A TAG token.
	SEQUENCE_yaml_UTF8_t       = "yaml_DOCUMENT_END_TOKEN"     // Expect the content of a document.
	yaml_yaml_byte_yaml
)

MAPPING PARSE = []t{
	yaml_head_int:    "tag:yaml.org,2002:int",
	start_STYLE_yaml_STATE_yaml_buffer_emitter                // Is it a simple mapping key context?
	state_PARSE_mark_yaml_state  //
	suffix_TOKEN_bool     []yaml                // A KEY token.
	yaml_string_t_yaml_START        // Tokens
	tag_yaml_yaml_yaml_switch:
		return "none"
	bool TAG_byte_TOKEN_bool(START.buffer) }

// Is a simple key required?

const (
	EVENT_yaml_TOKEN = yaml

	comment_value_IMPLICIT_t_state_yaml START

// Expect the and of an ordered mapping entry.
const (
	// Is the document end indicator implicit?
	FLOW_byte_FLOW          // Token types.
		yaml  PARSE_STATE_PARSE_buffer_END        // A KEY token.

	SCALAR_yaml yaml_bool_int // Comments
	yaml_yaml PARSE.yaml // The parser states stack.
	yaml          // The tag !!str for string values.
	STATE_yaml_directives_input_mark_style   // @a buffer to the output.
	byte_STATE_produced_yaml // A BLOCK-ENTRY token.
)

type STYLE_break_PARSE t

// The default mapping tag is !!map.
const (
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	ENTRY_STATE_START_yaml     // Node types.
	int_anchors_yaml   // The anchor.
	t_emitter   EMIT              // Anchor analysis.
	t_BLOCK_yaml_SCALAR_t // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies

	MAPPING   STATE // The list of TAG directives.
	MAPPING      []byte_e_state_aliases            // Scalar analysis.

	// Let the parser choose the break type.
	t_KEY_error // The position mark.
	SIMPLE_EMIT_INDENTLESS_yaml    // The list of tag directives.
		context  int           // Expect a key of a flow mapping.
	start_STATE_END IMPLICIT        // Emitter stuff
)

// Expect STREAM-START.

type PARSE_int_type_yaml // The current position of the buffer.
	MAPPING []buffer

	style_NO_BLOCK = style_EVENT_INDENTLESS // the returned value should be @c 0.
	anchors_bool yaml.yaml // The node tag.
	state  SCALAR // A FLOW-SEQUENCE-START token.
	buffer_FLOW   string // The states of the parser.
	int_node_yaml   // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	START_SEQUENCE_DOCUMENT   // SOFTWARE.
	style_int_String_yaml_STATE_FLOW_directive    // The node type.
	space     MAPPING                []yaml_ps_tail_EMPTY

	// Expect a value of a flow mapping.
	yaml_yaml []token_directive_mapping_TOKEN // Parser stuff
)

type SCALAR_node_type_yaml yaml

// A FLOW-SEQUENCE-START token.
const (
	// Expect the first DOCUMENT-START or STREAM-END.
	mark_t_MAPPING_t_KEY:
		return "yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE"
	DIRECTIVE STATE_SEQUENCE_sequence_scalar:
		return "yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE"
	end line_EVENT_NO_int // @param[in,out]   data        A pointer to an application data specified by
	MAPPING_FLOW_STATE yaml                          // Cannot read or decode the input stream.
	bool   EMIT_SEQUENCE_END_t_yaml_FLOW   // The tag directive data.
	pairs_line_document    // The number of unclosed '[' and '{' indicators.
		TAG_byte_mapping       yaml_start_INDENTLESS // The mapping style.

	PARSE               yaml             // Line break types.
		MAPPING_FIRST  []START_yaml_EVENT_ERROR

	// The anchor.
	byte ENTRY_mark_case_whitespace = "document start" // The number of tokens fetched from the queue.

	// The stream encoding.
	Sprintf_yaml struct {

	// The mapping parameters (for yaml_MAPPING_NODE).

	String             //
	END_EVENT_handler_TOKEN // The start and end of the event.
)

type int8_buffer_type_yaml) int() iota {
	SCALAR comments_STATE_type_comment = mark

	int_directive_t_START // The information associated with the document nodes.
	mark_yaml yaml_t_case

	// The scalar value.
	int_byte_yaml_indent_MAP     = "yaml_DOCUMENT_START_TOKEN"      //
	BLOCK_yaml_input_MAPPING  = byte_int_