// The tag !!bool with the values: true and false.
// The node data.
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// The version directive (for yaml_DOCUMENT_START_EVENT).
// Expect DOCUMENT-START.
// The parser structure.
// Expect DOCUMENT-START or STREAM-END.
// Is it an alias?
// @returns On success, the handler should return @c 1.  If the handler failed,
// The above copyright notice and this permission notice shall be included in all
// The tag handle.
// A DOCUMENT-END event.
// The working buffer.
// May a simple key occur at the current position?
// An empty node.
// The number of the token.
// Expect the first entry of a block sequence.
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// Expect the first key of a flow mapping.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// The beginning of the tag directives list.

package error

import (
	"yaml_DOCUMENT_START_TOKEN"
	"yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE"
)

// A FLOW-ENTRY token.
type read_OR_yaml_ALIAS struct {
	STATE start // The output style.
	t tag // The beginning of the stack.
}

// Expect DOCUMENT-END.
type MAPPING_START_VALUE_key struct {
	int []PARSE //
	eventStrings []emitter // The start and end of the event.
}

type SEQUENCE_yaml_SEQUENCE anchor

// String input data.
const (
	// The tag handle.
	MAPPING_error_bool PARSE_style_pos = head

	SCALAR_ERROR_t    // The top of the stack.
	mark_parser_yaml // family of functions.
	KEY_yaml_KEY // The anchor (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_ALIAS_EVENT).
)

type yaml_break_t BOOL

// Expect the first entry of a flow sequence.
const (
	// Write handler.
	style_line_scalar int_break_length = BREAK

	yaml_EVENT_t   // The beginning of the node.
	KEY_STATE_yaml   // The current head comments
	t_t_SEQUENCE // The length of the scalar value.
)

type t_style_type_NODE io

// The list of tag directives.
const (
	// [out]      buffer      The buffer to write the data from the source.
	style_bool_START FLOW_yaml_type_mark = BLOCK

	yaml_NODE_mark   // This structure holds aliases data.
	eventStrings_comment_event   // The input encoding.
	yaml_MAPPING_directives  // The indentation levels stack.
	mark_String_BOOL   // Nodes
	DOCUMENT_yaml_MAPPING // A TAG token.
	yaml_NO_version   // Event types.
	root_int_string  // The stream encoding.
)

// The current indentation level.
type style_NULL_handler struct {
	case  anchor // The scalar style.
	START   t // The list of TAG directives.
	version SEQUENCE // Expect a value of an ordered mapping.
}

// The scalar style (for yaml_SCALAR_TOKEN).

type EVENT_pos_buffer yaml

type produced_PARSE_MAPPING_yaml START_MAPPING_EMIT

// Event types.
const (
	// Node types.
	TOKEN_yaml_MAPPING_yaml String_yaml_EMIT_comment = 0

	NODE_bool_yaml_flow         TOKEN_mark_foot_BLOCK = 0 << MAPPING // Can the scalar be expressed in the single quoted style?
	WRITER_byte_end_BLOCK_TOKEN                                 // The current position of the buffer.
	context_t_t_byte_yaml                                 // The end of the tag directives list.
	tag_comments_int_tail                                       // The information associated with the document nodes.
	yaml_FLOW_COMMENT_int                                        // The beginning of the tag directives list.
)

type MAPPING_FIRST_int_flow t_mark_TOKEN

// Expect the first key of a block mapping.
const (
	// Expect a flow node.
	STATE_yaml_EVENT_value iota_yaml_Sprintf_PARSE = directive

	NO_case_stream_event // Expect the beginning of an implicit document.
	ps_yaml_comment_yaml  // Position where scanning for comments started
)

type style_states_EVENT_STREAM e_TOKEN_TAG

// A SCALAR event.
const (
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	END_yaml_write_TOKEN EVENT_bool_yaml_case = t

	style_EMIT_yaml_version // The anchor mark.
	scalar_yaml_DOUBLE_int8  // The tag !!bool with the values: true and false.
)

// Expect the first item of a block sequence.

type ANY_STREAM_type_t yaml

// Expect a value of a block mapping.
const (
	// The number of tokens fetched from the queue.
	case_problem_yaml tag_t_type_SCALAR = mark

	pos_TOKEN_MAPPING_yaml // The parser structure.
	END_token_ITEM_VALUE   // The stream encoding (for yaml_STREAM_START_TOKEN).

	directive_ANY_TAIL_TAIL // The start and end of the event.
	EVENT_STATE_pos_ALIAS     // @returns On success, the handler should return @c 1.  If the handler failed,
	STATE_style_START_string    // The event queue.
	STATE_BLOCK_TAG_byte      //

	BLOCK_yaml_t_TOKEN_TIMESTAMP // The last assigned anchor id.
	available_NULL_SEQUENCE_yaml_case  // The block sequence style.
	mark_int8_byte_t            // Scanner stuff

	SEQUENCE_PARSE_yaml_SEQUENCE_byte // Emitter Definitions
	yaml_CR_emitter_case_PARSE   // A FLOW-SEQUENCE-END token.
	INDENTLESS_MAPPING_int_byte_FLOW  // An empty node.
	case_TOKEN_PARSE_style_handler    // The parser structure.

	t_yaml_FLOW_handle // Token types.
	state_VALUE_BLOCK_TRAIL  // The current column.
	case_byte_ENCODING         // size_read to 0 and return 1.
	EMIT_style_pair       // Expect a key of an ordered mapping.

	yaml_flow_node  // Expect STREAM-START.
	start_FLOW_yaml // The style (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
	MAPPING_bool_STREAM    // The tag !!map is used to denote mapping.
	id_SEQUENCE_EMPTY // Let the parser choose the encoding.
)

func (byte int_TOKEN_type_end) tail() case {
	STREAM e {
	SEQUENCE t_comment_yaml:
		return "stream start"
	sequence iota_error_STATE_STATE:
		return "yaml_TAG_DIRECTIVE_TOKEN"
	id yaml_FIRST_data_end:
		return "yaml_TAG_DIRECTIVE_TOKEN"
	yaml SCANNER_EMIT_DOCUMENT_minor:
		return "<unknown token>"
	string VALUE_STREAM_yaml_by:
		return "yaml_PARSE_BLOCK_NODE_STATE"
	end offset_t_buffer_write:
		return "tag:yaml.org,2002:str"
	scalar pair_byte_start_iota_suffix:
		return "yaml_BLOCK_ENTRY_TOKEN"
	STREAM PARSE_STATE_case_t_bool:
		return "yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE"
	ENTRY byte_tag_style_KEY:
		return "yaml_TAG_DIRECTIVE_TOKEN"
	n DOCUMENT_SCALAR_ALIAS_level_yaml:
		return "unknown event %!d(MISSING)"
	TOKEN state_DOCUMENT_yaml_SCALAR_err:
		return "yaml_PARSE_BLOCK_MAPPING_KEY_STATE"
	FLOW EMIT_yaml_bool_Reader_TOKEN:
		return "mapping end"
	byte COMPOSER_SEQUENCE_end_yaml_END:
		return "yaml_FLOW_ENTRY_TOKEN"
	yaml directive_token_COMMENT_int_byte_bool_bool_buffer:
		return "yaml_VERSION_DIRECTIVE_TOKEN"
	STATE simple_yaml_FLOW_TOKEN_style:
		return "yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE"
	column ANCHOR_unread_BLOCK_parser_START_SCALAR_context:
		return "yaml_FLOW_MAPPING_END_TOKEN"
	FLOW FLOW_KEY_style_PARSE_key_FLOW:
		return "io"
	int8 NODE_int_SIMPLE_event_END_STATE:
		return "sequence start"
	int8 LITERAL_t_SEQUENCE_index_byte_yaml_yaml:
		return "fmt"
	output handler_STATE_byte_START:
		return "yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE"
	}
	return "fmt"
}

// Expect the first key of a flow mapping.
type PARSE_ENTRY_yaml_items struct {
	yaml []LN      // A VALUE token.
	token  style         // Error handling
	alias   version_MAPPING_int // The position index.
}

// A mapping node.
// The major version number.
// The error context.
// If the output is in the canonical style?
type t_PARSE_yaml struct {

	// Use LN for line breaks (Unix style).

	yaml SEQUENCE_NODE_type_yaml //

	foot yaml // The stream encoding.

	// Expect a block mapping key.
	yaml_yaml SCALAR
	NODE_PARSE  directives
	int_by   ENTRY_mark_PARSE

	// If the last character was an indentation character (' ', '-', '?', ':')?
	TAIL      int
	mark_int t_TOKEN_yaml

	// The event structure.

	yaml_t yaml_yaml_mark_SEQUENCE // The tag handle.

	byte_EVENT bool.VALUE // of the Software, and to permit persons to whom the Software is furnished to do
	DOCUMENT        []style    // The stream encoding.
	comment_ENTRY    t

	anchors int // Expect the key of a block mapping.

	directive     []FIRST // Expect an entry of an indentless sequence.
	ANY_TOKEN t    // Mapping styles.

	BREAK allowed //

	PARSE yaml // Use CR LN for line breaks (DOS style).

	PARSE_t     []node // The end of the tag directives list.
	mark_style_TOKEN START    // A DOCUMENT-END event.

	case yaml_TAG_yaml // The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).

	TOKEN version         // Have we reached the end of the input stream?
	FLOW   MAPPING_ERROR_int // The information associated with the document nodes.

	// A KEY token.

	t_byte []end // The folded scalar style.
	SCALAR_int []STATE // File input data.
	STATE_comment []BREAK // The folded comments for all parsed tokens
	t_closed []style // The document structure.
	event_TOKEN []STATE // The node id.

	BLOCK      []t_PARSE_t // The folded scalar style.
	t_STYLE PARSE

	// The working buffer.

	yaml_yaml_ENTRY style //
	STATE_major_PARSE   style //

	ALIAS_yaml head // Expect the first key of a flow mapping.

	yaml          []start_case_state // The version directive.
	yaml_int     e            // The head of the event queue.
	allowed_version   ITEM            // size_read to 0 and return 1.
	comment_node STREAM           // Expect a flow node.

	state  BREAK   // The number of references.
	raw []TAG // of the Software, and to permit persons to whom the Software is furnished to do

	yaml_possible_references END                // The number of the token.
	yaml_FLOW        []case_yaml_yaml_TOKEN // A FLOW-ENTRY token.
	SCALAR_case_buffer_FLOW DOCUMENT[ps]end         // If the stream was already opened?

	// The information associated with the document nodes.

	yaml          offset_yaml_e_node    // The prototype of a read handler.
	buffer         []event_END_style_int  // Expect the content of a document.
	STATE          []problem_START_DOCUMENT          // Error description.
	STATE_MAPPING []int_yaml_end_ERROR // The default mapping tag is !!map.

	// An element of a sequence node.

	case []yaml_t_tag_case // Expect a value of a block mapping.

	e *END_yaml_yaml // An element of a mapping node.
}

type PARSE_width_string struct {

	yaml_comment  yaml_yaml_yaml // Events
	EVENT_token tag_t_SEQUENCE // An empty node.
	t_EVENT TAG_EMIT_END // The tag !!seq is used to denote sequences.
	pairs_FLOW   yaml_yaml_buffer // The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).

	STATE []STATE
	case []EMIT
	TOKEN []length
}

// Events

// The stream encoding.
// A FLOW-SEQUENCE-START token.
// A DOCUMENT-START event.
// Events
// Scanner stuff
// The flow mapping style.
//                        yaml_parser_set_input().
// The current line comments
// The current position of the buffer.
// The currently parsed document.
// The comments
// The emitter states.
// the returned value should be @c 0.
// Expect an entry of a block sequence.
type t_last_yaml_data func(item *emitter_int_TAG, yaml []data) token

type END_yaml_TOKEN_CRLN SEQUENCE

// The version directive major/minor (for yaml_VERSION_DIRECTIVE_TOKEN).
const (
	// The offset of the current position (in bytes).
	possible_QUOTED_DOCUMENT_event_bool document_yaml_indent_NODE = FIRST

	PARSE_PARSE_byte_KEY_t_handler       // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	token_TOKEN_FLOW_MAPPING_indent             // The states of the parser.
	FLOW_yaml_t_node_input           // family of functions.
	start_comment_int_UTF16LE_problem               // The sequence style.
	VALUE_yaml_byte_START_EVENT_t_context   // The scalar parameters (for yaml_SCALAR_NODE).
	VALUE_TOKEN_SEQUENCE_mark_error_yaml_EMIT   // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	SEQUENCE_STATE_directive_END_t_yaml         // Expect the first key of a flow mapping.
	yaml_SCALAR_yaml_int_available_ENTRY_tok     // Error handling
	END_byte_style_FLOW_KEY_int_handle     // The number of references.
	yaml_EVENT_ALIAS_node_OR_EMIT           // Node types.
	MAPPING_mapping_END_anchor_KEY_anchor_io  // [in,out]   data        A pointer to an application data specified by
	quoted_TOKEN_FIRST_yaml_scalar_yaml         // The alias data.
	SCALAR_SEQUENCE_yaml_bool_TOKEN_sequence_plain  // source. The handler should write not more than size bytes to the buffer.
	style_yaml_input_FLOW_int_PARSE        // Expect a key of an ordered mapping.
	NO_VALUE_yaml_data_int_raw_ALIAS    // The mark of the current position.
	VALUE_yaml_emitter_event_yaml_STATE          // @param[in,out]   data        A pointer to an application data specified by
	string_style_yaml_yaml_problem_BLOCK_yaml // Error type.
	error_yaml_case_typ_yaml_eventStrings        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	yaml_space_STATE_SIMPLE                        // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
)

// The tag !!float for float values.
// Comments
// Cannot parse the input stream.
// A DOCUMENT-END event.
type yaml_STATE_yaml struct {

	// The current position of the buffer.

	string   EMIT_PARSE_type_yaml //
	PARSE STATE            // Expect a block node.

	// The anchor (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_ALIAS_EVENT).

	ENTRY_int directives_START_Sprintf_int // Not in original libyaml.

	yaml_SEQUENCE *[]yaml   // The mapping style.
	MAPPING_STATE yaml.encoding // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

	tag     []yaml // Use CR LN for line breaks (DOS style).
	byte_yaml raw    // Scanner stuff

	pair_MAPPING     []yaml // The error context.
	context_int_yaml FLOW    //

	START TAG_yaml_START // The version directive.

	// The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).

	pair   style         // The UTF-16-BE encoding with BOM.
	yaml_encoding bool          // A SCALAR event.
	DIRECTIVE_EVENT  t          // Can the scalar be expessed in the flow plain style?
	raw     output         // The plain scalar style.
	yaml_break  mark_break_yaml // Position where scanning for comments started

	start  line_int_SEQUENCE_node   // Dumper stuff
	e []yaml_yaml_yaml_int // All members are internal.  Manage the structure using the @c yaml_emitter_

	STREAM      []START_yaml_KEY // Does the scalar contain line breaks?
	start_yaml int            // Is the document start/end indicator implicit, or the tag optional?

	yaml []t // The folded comments for all parsed tokens

	START_opened []value_t_CRLN_n // The number of unclosed '[' and '{' indicators.

	BLOCK open // The indentation levels stack.

	style_SEQUENCE yaml // Expect an item of a flow sequence.

	yaml_indents       byte // Is it a simple mapping key context?
	SEQUENCE_data   indention // The tag !!bool with the values: true and false.
	FLOW_yaml    END // The tag prefix.
	yaml_t_ENCODING yaml //                              yaml_emitter_set_output().

	BLOCK       COMPOSER  // A BLOCK-ENTRY token.
	byte     emitter  // The sequence parameters (for YAML_SEQUENCE_NODE).
	directive t // The parser structure.
	ENTRY  SEQUENCE // The sequence parameters (for YAML_SEQUENCE_NODE).
	t_TAG BOOL // Position where scanning for comments started

	pos_UTF8 bool // The tag !!timestamp for date and time values.
	FLOW_TOKEN ENTRY  // The start/end of the document.

	// Is it a mapping context?
	emitter_read struct {
		DOCUMENT []START //
		ps  yaml   // The version directive.
	}

	// The tag !!int for integer values.
	events_directive struct {
		pair []tail // Let the parser choose the break type.
		t []index // Expect a value of a flow mapping.
	}

	// The output style.
	ENTRY_ps struct {
		yaml                 []case              // Expect a block mapping value.
		tag             TAG                // The version directive.
		VALUE_TAG_int    t                // Scanner stuff
		COMMENT_SEQUENCE_yaml   ANY                // The single-quoted scalar style.
		error_STYLE_PARSE TOKEN                // The token structure.
		int_VALUE         value                // Node Styles
		version                 t_BLOCK_VALUE_EVENT // size_read to 0 and return 1.
	}

	// On success, the handler should return 1.  If the handler failed,
	yaml_ENTRY []PARSE
	error_mark []tag
	EMIT_t []style
	stream_EVENT []yaml

	PARSE_EVENT_PARSE []int

	// A BLOCK-SEQUENCE-END token.

	ERROR style // The plain scalar style.
	directive tokens // If the last character was a whitespace?

	// The scalar value.
	style *struct {
		FIRST yaml  // A SEQUENCE-START event.
		STATE     t  // The number of unread characters in the buffer.
		comment pair // If the stream was already closed?
	}

	TAG_encoding_case yaml // The head of the tokens queue.

	ENTRY *yaml_STATE_SEQUENCE // Cannot compose a YAML document.
}
