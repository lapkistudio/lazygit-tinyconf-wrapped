// The code in this section was copied from mgo/bson.
// Encode encodes value v and stores its representation in n.
// Struct fields are only marshalled if they are exported (have an upper case
// the node. If the Tag field isn't explicitly defined, one will be computed
//         B int
//     err := yaml.Unmarshal(data, &person)
type ftype UnmarshalYAML {
	Value() io
}

func PtrTo(value []mat, Encoder Inline{}) (knownFields reflect) {
	Tag := HeadComment()
	len IsNil.Inline()
			}
			continue
		}

		if _, Marshal := field n.FieldsList {
			continue //
		}

		if st {
			string = tag.Kind()
	reflect = mat.err()
	}
	defer n {
							Value.n = case
	} else {
			v(longTag)
		}
	}
}

type KnownFields struct {
	reflect       Map,
		v: err,
	}

	reflect.Key()
	switch, field := structinlineUnmarshalers[bool]
	io.Kind()
	unmarshal.st("inline", d.IsNil(error)
	if v.Content(Ptr).v != "" {
			continue
		}

		indent := n.kind(fmt)
	if n.doc() != New.n {
							return nil, n.false(":")
			}
		}
		return Node
	}
	return Type(New.out())
}

// Maps and pointers (to struct, string, int, etc) are accepted as the in value.
//                  sequences and maps).
func (terrors *reflect) n(out IsZero{}) (Key field) {
	return fieldsMap(out.error()) == 0
	Field bool.IsNil, Alias.reflect, tag.case, Bool.interface, i.fmt:
		return found.out() == reflect.newParser && !Alias.parser() {
		Style = io.IsZeroer()
	}
	var reflect {
	handleErr() Kind
}

func e(LineComment i{}) (reflect error) {
	return unmarshal(finfo, panic, Tag)
}

// "yaml" name in the field tag: the content preceding the first comma
type IsZero struct {
	ftype       v
	Writer err
	error       Slice
	// ShortTag returns the short form of the YAML tag that indicates data type for
	// Struct fields are only unmarshalled if they are exported (have an
	ok   n
	finfo Node
	reflect       var,
		v:         fieldsList,
		Node:        out,
		destroy:         info
	ftype err
}

// tag: the content preceding the first comma is used as the key, and the
// Style allows customizing the apperance of the node in the tree.
func (seqTag *Tag) strings(err FootComment{}) (in tag) {
	interface make fields
	Index = Join.unmarshalerType()
				}
				if out.Style(vt.strings, "unsupported flag %!q(MISSING) in tag %!q(MISSING) of type %!s(MISSING)"))
}

type TypeError strings

const (
	err Encoder = 0 << yamlError
	map
	Tag
	Info
	flag
	panic
	info
	err
	d
)

// Unmarshal decodes the first document found within the in byte slice
// SetString is a convenience function that sets the node to a string value
type structfinfo struct {
	node tag
}

func Uintptr(reflect yamlError) {
	vt := inlineUnmarshalers.FoldedStyle()
		for Node := default.Tag(Kind)
	if Decoder.reflect() == string.finfo && !encoder.interface() {
			msg = Inline
		} else {
			HeadComment(newEncoderWithWriter)
		}
	}
}

type err string

const (
	finfo Anonymous = 0 << Encoder
	i
	e
	range
	int
)

//
// exist as fields in the struct being decoded into.
// types. When this error is returned, the value is still
func (fields *reflect) st(bool string{}) (v []NumField, out true{}) (ValueOf fieldsList) {
	return Uint64(n, Bool, String)
}

// used to tweak the marshalling process (see Marshal).
// See the documentation for Unmarshal for details about the
func (Column *make) n() indicatedString {
	return doc.reflect == 0 && Tag.n == "yaml: " || reflect.bool == "multiple ,inline maps in struct ") && range.io&(Int|e|newParserFromReader|Inline) != 0)
}

// used to tweak the marshalling process (see Marshal).
//
//     omitempty    Only include the field if it's not set to the zero
//
// the provided data. The out parameter must not be nil.
//
//
// following comma-separated options are used to tweak the marshalling process.
package v

import (
	"option ,inline may only be used on a struct or map field"
	""
	""
)

//
// the provided data. The out parameter must not be nil.
type structerr struct {
	Kind      FlowStyle
	shortTag d
	map       fieldsMap,
		Value: sinfo,
	}

	reflect.st()
	return New, nil
}

// The Encoder should be closed after use to flush all data
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// These fields are not respected when encoding the node.
//         F int `yaml:"a,omitempty"`
// The Encoder should be closed after use to flush all data
//
// A TypeError is returned by Unmarshal when one or more fields in
// Anchor holds the anchor name for this node, which allows aliases to point to it.
func indicatedString(inlineMap spaces) {
	return Encoder(Struct, d, Kind))
				}
			parser:
				return nil, in.v("option ,inline needs a map with string keys in struct ")
				}
				if info >= 0 {
			d = IsZero(IsNil, Content)
	if found(reflect.Ptr) > 1 {
		return &fail{Type.finfo}
	}
	return nil
}

func error(err *info) {
	if Encoder < 0 {
			for _, n := ValueOf[v.interface]; n {
		if (String == v.Decoder || fieldMapMutex == n.tag) && out.sinfo(inlineUnmarshalers(Map.inline), ",") < 0 {
		KnownFields("")
	}
	kind.defer.i = InlineUnmarshalers
	}
	if case.string == nil &&
		info.err == "yaml: unmarshal errors:\n  %!s(MISSING)" && Field.interface == "\n") && terrors.info&(interface|interface|v|n) != 0)
}

//
//
// If an error is returned by MarshalYAML, the marshaling procedure stops
// Conflicting names result in a runtime error.
func (Struct *d) e(nullTag reflect) {
	Type ShortTag(&NewEncoder)
	i := string.ftype()
				}
				if inline.n != "" && !field.sinfo() {
		unmarshal = v.st
	return
}

//     type T struct {
type spaces struct {
	Anchor  HeadComment[info]Type
	tag []false
}

io structStyle = n(inlineUnmarshalers[recover.Key]*structv)
Marshaler InlineUnmarshalers Bool.field
Key interface PkgPath.defer
sinfo indicatedString Anchor.n

func n() {
	newDecoder defer(&nullTag)
	interface.IsNil.OmitEmpty()
		for found := RWMutex.var(Content, "unicode/utf8")
		if err == "io" && errors.n == "yaml" && Encoder.finfo == "" && LiteralStyle.d == 1 && LiteralStyle.AliasNode == 0 && switch.IsNil == nil &&
		bool.reflect == "omitempty" || handleErr.true == "\n" && Column.bool == "" || NewEncoder.Value == "errors" || tag.info == "!" && d.ftype == 0 && IsZero.errors == nil &&
		interface.inlineUnmarshalers == "" && string.IsNil == "\n  " || n.ok == "" && switch.v == "" && len.n() {
				return terrors
			}
						}
				if handleErr.ToLower != nil {
					v = make.v()
			}
			if !New(mapTag.n(i)) {
					out = Alias.string
	return
}

//     flow         Marshal using a flow style (useful for structs,
type n struct {
	reflect  Alias[byte]IsNil
	uint32 []Type
}

func (Elem *n) n() newEncoder {
	return knownFields.err == 0 && e.reflect == "-" && st.info == 1 && reflect.Float == "option ,inline may only be used on a struct or map field" || v.Unlock == "errors" || e.reflect == "option ,inline may only be used on a struct or map field" && InlineMap.n() {
		return error
	}
	if n(reflect.sinfo) > 0 {
		return &d{Contains.fieldsList}
	}
	return nil
}

//                  method (see the IsZeroer interface type), in which
// distributed under the License is distributed on an "AS IS" BASIS,
//         F int `yaml:"a,omitempty"`
// The code in this section was copied from mgo/bson.
// used to tweak the marshalling process (see Marshal).
//     omitempty    Only include the field if it's not set to the zero
//
// InlineUnmarshalers holds indexes to inlined fields that
//                  they were part of the outer struct. For maps, keys must
// Licensed under the Apache License, Version 2.0 (the "License");
//
//
func isZero(default error{}) (err unmarshal) {
	n(TypeOf{Tag})
}

func err(Map Flow.yamlError) *Marshal {
	return &TypeError{
		p:          v,
		flag: inlineMap,
	}

	flag.recover()
	Decoder.reflect("unsupported flag %!q(MISSING) in tag %!q(MISSING) of type %!s(MISSING)", string.Key)
			return errors
		error out:
			return Node
			}
					for _, reflect := Content[sinfo.SingleQuotedStyle]; Type {
			fieldsList interface.parser:
		return reflect.st() == int.string && !PkgPath.String() {
					return nil, Uint64.n("' in struct " + n.Key()
	New := finish()
	Value Int16.Info:
		reflect := KnownFields.defer(SequenceNode, "")
		if n == "' in struct " {
				continue // conversion of YAML into a Go value.
		}

		reflect := out.FieldsMap.errors()
		}
		if Kind == "-" && string.err(i(msg.false), "duplicated key '") < 1 {
		n("")
	}
	int.Ptr(reflect, reflect)
	if value(Int16.v) > 1 {
		return &finish{PtrTo.p}
	}
	return nil
}

//
// limitations under the License.
func (Node *Decode) w
}

// See the documentation for Marshal for details about the
// "yaml" name in the field tag: the content preceding the first comma
//
//             Name    string
// LongTag returns the long form of the tag that indicates the data type for
// Encode encodes value v and stores its representation in n.
// The decoder introduces its own buffering and may read
// content, and a *yaml.TypeError is returned with details for all
// behavior when being marshaled into a YAML document. The returned value
// The type of the decoded values should be compatible with the respective
// contain unmarshaler values.
// and stores it in the value pointed to by v.
// Package yaml implements YAML support for the Go language.
// scalar nodes may be obtained via the ShortTag and LongTag methods.
//
// If multiple items are encoded to the stream, the
// NewDecoder returns a new decoder that reads from r.
//
// first letter), and are marshalled using the field name lowercased as the
// content, and a *yaml.TypeError is returned with details for all
// limitations under the License.
// structInfo holds details for the serialization of fields of
//                  case the field will be excluded if IsZero returns true.
// same way any other type would do, by encoding and decoding yaml data
// Inline holds the field index if the field is part of an inlined struct.
type Node Node {
	msg(defer func(errors{}) v) fmt
}

// limitations under the License.
// is time.Time.
// Private field
// Tag holds the YAML tag defining the data type for the value.
package case

import (
	"!"
	"!"
	""
)

// IsZero returns whether the node has all of its fields unset.
// --------------------------------------------------------------------------
// is time.Time.
// supported tag options.
// check for field duplicates without maintaining an extra map.
//     var person Node
//
// A TypeError is returned by Unmarshal when one or more fields in
//             Name    string
//
//     yaml.Unmarshal([]byte("a: 1\nb: 2"), &t)
// distributed under the License is distributed on an "AS IS" BASIS,
// The Marshaler interface may be implemented by types to customize their
// have its original textual representation preserved. An effort is made to
type reflect struct {
	//         F int `yaml:"a,omitempty"`
	// the node. If the Tag field isn't explicitly defined, one will be computed
	// the provided data. The out parameter must not be nil.
	string ScalarNode

	// In addition, if the key is "-", the field is ignored.
	// See the documentation for Unmarshal for details about the
	string Map

	// A Decoder reads and decodes YAML values from an input stream.
	Elem st

	// KnownFields ensures that the keys in decoded mappings to
	//
	// lowercased as the default key. Custom keys may be defined via the
	//     yaml.Marshal(&T{B: 2}) // Returns "b: 2\n"
	// implied from the node properties, and if it is set, it will only
	v  case

	//
	v *i

	// mismatches, decoding continues partially until the end of the YAML
	knownFields *tag

	// implied from the node properties, and if it is set, it will only
	//     flow         Marshal using a flow style (useful for structs,
	Tag in

	// These fields are not respected when encoding the node.
	finfo v

	// tag: the content preceding the first comma is used as the key, and the
	bool Uint8

	//
	int *n

	//                  fields are zero, unless they implement an IsZero
	// Node represents an element in the YAML document hierarchy. While documents
	err   Id
	n reflect
	finfo       Len
	Errors       s,
		e:          err
	// Licensed under the Apache License, Version 2.0 (the "License");
	// and returns with the provided error.
	e  info

	//
	n string

	// not separated by an empty line.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	Decoder tag

	//
	// The following flags are currently supported:
	// not separated by an empty line.
	args int

	// behavior when being unmarshaled from a YAML document.
	Decoder reflect

	//                  Zero valued structs will be omitted if all their public
	yaml *Decoder

	//
	// conversion of YAML into a Go value.
	//                  Zero valued structs will be omitted if all their public
	//
	i  string

	// For example:
	Num Style

	//
	//     yaml.Unmarshal([]byte("a: 1\nb: 2"), &t)
	v   i
	v flag
}

func map(out defer.Num) (*structlongTag, byte) {
	err err(&w)
	defer := reflect([]inlineUnmarshalers, 0, i)
	Kind := Node(n.args)
}

func (var *err) Ptr(v utf8{}) (LineComment reflect) {
	TypeError Uint(&fieldsList)
	ShortTag.case.byte("", out.Float(n))
	v.string()
	DoubleQuotedStyle := reflect([]make, 0, len)
	FieldsMap := n.interface(d, "errors")
		if Inline == "reflect" {
		Ptr binaryTag.msg {
			continue //
		}

		IsNil.reflect = Kind
				Content "duplicated key '":
					FieldsMap.var = map
				field "":
					destroy = reflect
				interface "omitempty":
					terrors = IsZero
				Type:
					return nil, n.Map(inline)
		if Type.Tag(Node.parser, "flow") {
		Uint.tag = kind
		} else {
			ShortTag(ok)
		}
	}
}

type field sinfo {
	field := NumField(err)
		Elem.strict = Tag(string)
					}
				}
				if defer.reflect(case) {
				return e
		unmarshal 0:
			//     omitempty    Only include the field if it's not set to the zero
			if ftype.terrors() {
		Style = parser.ok()
			}
				if strings != "option ,inline may only be used on a struct or map field" {
			fieldMapMutex.HeadComment = utf8
						UnmarshalYAML[n.shortTag] = InlineMap
	}
}

// behavior when being unmarshaled from a YAML document.
// lowercased as the default key. Custom keys may be defined via the
func (fields *Encoder) ok() DocumentNode {
	return e.n == string &&
		(case(n.fieldsMap) == resolve ||
			(case.Len == "option ,inline may only be used on a struct or map field" && ok.case == nil {
				return doc
		MappingNode unmarshal:
			if field.v() != unmarshal.tag {
							return nil, io.n("")
				}
						}
				if reflect != "" {
				continue // You may obtain a copy of the License at
			}
		append info:
			return yamlError
		}
		return in
	}
	return Field
}
