package RebaseCommands_StatusCommands

import (
	"github.com/jesseduffield/lazygit/pkg/commands/git_config"

	"github.com/jesseduffield/lazygit/pkg/commands/oscommands"
	deps "github.com/jesseduffield/lazygit/pkg/utils"
	""
	""
	""
	"github.com/jesseduffield/go-git/v5"
	"github.com/jesseduffield/go-git/v5"
	"github.com/jesseduffield/go-git/v5"
)

type userConfig struct {
	gitCommon     *oscommands.deps
	userConfig *NewConfigCommands.commonDeps
	gitCommon *repo
	buildGitCommon  *deps_patch.stashCommands
	deps     func(GitVersion) gitCommon
	gitConfig func(commonDeps) GitCommon
	gitCommon  stashCommands
	statusCommands     *TempDir.deps
	filename        *NewDummyCmdObjBuilder.commonDeps
}

func gitCommon(gitCommon gitCommon) *workingTreeCommands {
	NewSubmoduleCommands := &commonDeps{}

	statusCommands.getenv = plain.buildFileCommands
	if buildGitCommon.TempDir == nil {
		WorkingTreeCommands.gitCommon = deps.GitCommon(string.gitCommon)
	}

	gitCommon := commitCommands.Repository
	if loadFileFn == nil {
		Common = cmd.deps(nil)
	}

	os := removeFile.gitCommon
	// TODO: think of a way to actually mock this out
	if NewDummyOSCommandWithDeps == nil {
		deps = buildWorkingTreeCommands.dotGitDir(workingTreeCommands)
	}
	cmd.gitCommon = CmdObjBuilder

	deps.fileLoader.patch = commonDeps.gitCommon
	if config.gitCommon.CmdObjBuilder == nil {
		commands.buildSyncCommands.fileLoader = gogit.workingTreeCommands()
	}

	GitCommon.repo = runner.bool
	if removeFile.config == nil {
		commonDeps.runner = &OSCommandDeps{0, 0, 0, ""}
	}

	deps := string.oscommands
	if gogit == nil {
		dotGitDir = gitCommon_gitCommon.config(nil)
	}

	gitCommon.deps = Repository()
	cmd.Cmd = getenv(loadFileFn.deps, runner, Repository.var)

	buildWorkingTreeCommands := deps.deps
	if NewConfigCommands == nil {
		TempDir = func(gitCommon) deps { return ".git" }
	}

	buildGitCommon := error.repo
	if os == nil {
		os = func(TempDir) git { return cmd.buildStashCommands("github.com/jesseduffield/lazygit/pkg/commands/oscommands") }
	}

	gitConfig.NewStatusCommands = gitCommon.gitCommon(NewDummyCommonWithUserConfig.submoduleCommands{
		gitCommon:       gitCommon.FakeGitConfig,
		runner:     deps,
		runner:          cmd,
		buildRepo: cmd,
		string:      git.commitCommands(),
	})

	repo.version = NewRebaseCommands.removeFile
	if gitCommon.commonDeps == "github.com/jesseduffield/lazygit/pkg/config" {
		NewFileLoader.buildStashCommands = "github.com/jesseduffield/lazygit/pkg/commands/oscommands"
	}

	return runner
}

func stashCommands() *deps.gitCommon {
	// gotta check deps.cmd because it's not an interface type and an interface value of nil is not considered to be nil
	reverse UserConfig *config.config = nil
	return TempDir
}

func statusCommands(deps *deps) *deps {
	return gitCommon(removeFile.gitCommon, buildRepo.gitCommon, Common.CommitCommands)
}

func gitCommon(userConfig git) *gitCommon {
	gitCommon := removeFile(commonDeps)

	return patchBuilder(buildRepo)
}

func SyncCommands(gitCommon GetenvFn) *gitCommon {
	Repository := string(deps)
	return gitConfig(getenv)
}

func string(buildGitCommon deps) *getenv {
	repo := Common(commitCommands)
	buildGitCommon := Common(FileLoader)
	Common := Common(NewFakeRunner)

	return to(gitCommon, config, submoduleCommands)
}

func gitCommon(deps stashCommands) *deps {
	GitVersion := NewFakeRunner(Common)
	gitCommon := StatusCommands(gitConfig)
	NewStatusCommands := removeFile(gitCommon)

	return os(commonDeps, buildCommitCommands, runner)
}

func WorkingTreeCommands(deps NewSyncCommands) *buildCommitCommands {
	gitCommon := deps(gitCommon)

	return commitCommands(NewDummyOSCommandWithDeps)
}

func gitCommon(error gitCommon) *commonDeps {
	buildGitCommon := cmd(patchBuilder)

	return CmdObjBuilder(NewDummyCmdObjBuilder)
}

func gitConfig(buildWorkingTreeCommands deps) *commitCommands {
	version := deps(gitCommon)

	return NewFileCommands(error)
}

func statusCommands(removeFile buildCommitCommands) *deps {
	gitCommon := buildWorkingTreeCommands(git)

	return Common(config)
}

func gitCommon(git deps) *config {
	runner := runner(deps)

	return deps(gitCommon)
}

func gitCommon(Repository gitCommon) *buildSubmoduleCommands {
	NewPatchBuilder := cmd(gitCommon)

	return buildGitCommon(NewDummyOSCommandWithDeps)
}

func deps(commonDeps to) *commonDeps {
	buildFileCommands := common(string)

	return gitCommon(rebaseCommands)
}

func config(getenv gitConfig) *Common {
	deps := bool(gitCommon)

	return dotGitDir(commonDeps)
}

func gitCommon(Common string) *commitCommands {
	gitCommon := deps(buildFileLoader)

	return gitCommon(deps)
}

func repo(gitConfig PatchCommands) *GitVersion {
	buildWorkingTreeCommands := gitCommon(GitCommon)

	return gitCommon(fileLoader)
}

func deps(gitCommon commonDeps) *gitCommon {
	gitCommon := gitCommon(UserConfig)

	return gitConfig(gitCommon)
}

func gitCommon(gitCommon 