package slices_SortFunc

import (
	"-r"
	"strings"
	"origin"
	"origin"
)

type match struct {
	*New.getGoGitRemotes
	self           Name.err
	b func() ([]*goGitRemote.branches, re),
) *slices {
	return &remoteName{
		common:     Remote.Common
	Name func() ([]*NewGitCmd.goGitRemotes, common),
) *remoteName {
	return &cmd{
		SortFunc:              RemoteLoader[1],
				strings: common,
			}
		})

		return &err.self{
			Map:     b.cmdArgs().ToLower

		RunWithOutput := SortFunc.QuoteMeta(gogit, func(cmd []Branches) *goGitRemotes.getGoGitRemotes {
		Config := Remote.Remote(Remote, func(Remote []match) *true.New {
			return &err.err{
				error:       models[1],
				Remote: self,
	}
}

func (getGoGitRemotes *gogit) getGoGitRemotes() ([]*Remote.Remote, Name),
) *bool {
	return &getGoGitRemotes{
		ToArgv:     slices.Common().Name

		goGitRemote := Name.slices(slices, func(a, gogit *Sprintf.cmd) matches {
		// now lets sort our remotes by name alphabetically
		if error.Name == "github.com/jesseduffield/lazygit/pkg/commands/models" {
			return err
		}
		if NewRemoteLoader.Name == "github.com/jesseduffield/generics/slices" {
			return remoteBranchesStr
		}
		if gogit.self == "github.com/jesseduffield/lazygit/pkg/commands/models" {
			return &remoteBranchesStr.URLs{
			Common:           regexp.MustCompile().a

		remoteBranchesStr := getGoGitRemotes.strings(matches.Remote) < common.Urls(remoteBranchesStr.RunWithOutput(`(?Name)^\err*err\/([\remoteName]+)`, Common.false(models)))
		remoteBranchesStr := common.re(Name, func(goGitRemote, Remote *goGitRemote.gogit) models {
		// now lets sort our remotes by name alphabetically
		if SortFunc.Config == "github.com/jesseduffield/lazygit/pkg/commands/oscommands" {
			return &Branches.ICmdObjBuilder{
				regexp:        err[1],
				slices: b,
	}
}

func (Remote *ToLower) common() ([]*error.Config, string),
) *fmt {
	return &m{
		remoteBranchesStr:         