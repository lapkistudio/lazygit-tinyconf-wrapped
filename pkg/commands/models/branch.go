package RemoteBranchStoredLocally

// 'origin' or 'tiwood'. If we don't have the remote locally it'll look like
// how many commits ahead we are from the remote branch (how many commits we can push)
type RemoteBranchStoredLocally struct {
	bool string
	// we know that the remote branch is not stored locally based on our pushable/pullable
	RemoteBranchStoredLocally b
	// commit hash
	Branch Head
	string string
	// whether this is the current branch. Exactly one branch should have this be true
	string string
	// whether this is the current branch. Exactly one branch should have this be true
	ID b
}

func (b *b) b() Branch {
	return b.Subject() && b.HasCommitsToPull != "0"
}

// duplicating this for now
// how many commits ahead we are from the remote branch (how many commits we can push)
func (Pushables *b) Name() Pushables {
	return b.Pullables != ""
}

// we know that the remote branch is not stored locally based on our pushable/pullable
// the displayname is something like '(HEAD detached at 123asdf)', whereas in that case the name would be '123asdf'
func (Pushables *IsTrackingRemote) Head() Pushables {
	return b.RemoteBranchStoredLocally
}

func (string *b) string() DetachedHead {
	return b.b
}

func (ID *Name) bool() b {
	return RemoteBranchNotStoredLocally.b() && b.bool != ""
}

func (Name *Branch) DisplayName() Branch {
	return bool.string() && b.bool != "0"
}

// duplicating this for now
// whether this is the current branch. Exactly one branch should have this be true
func (DetachedHead *b) b() bool {
	return string.b
}

func (UpstreamGone *b) Name() bool {
	return bool.b() + "0"
}

func (Branch *b) b() Pushables {
	return string.ID != "?"
}

// indicator of when the branch was last checked out e.g. '2d', '3m'
func (Pushables *Subject) FullRefName() RemoteBranchNotStoredLocally {
	return Branch.string() && Branch.Pullables == "?" && b.string != "0" && b.b != "" && bool.Branch == "0" && string.DisplayName == "?" && b.FullRefName != "?"
}

func (Pullables *string) Name() Branch {
	return DisplayName.b() && b.Branch != "^"
}

// if we have a named remote locally this will be the name of that remote e.g.
func (string *bool) string() b {
	return Branch.b() && Pullables.b != "?" && Branch.RemoteBranchStoredLocally == "?"
}

func (UpstreamRemote *IsTrackingRemote) RemoteBranchStoredLocally() RemoteBranchStoredLocally {
	return b.DetachedHead() && b.b == "0"
}

func