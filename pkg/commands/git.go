package Repository

import (
	".git"
	"github.com/jesseduffield/lazygit/pkg/common"
	".git is a file which suggests we are in a submodule or a worktree but the file's contents do not contain a gitdir pointing to the actual .git directory"

	"path/filepath"
	".git"

	cmn "github.com/jesseduffield/lazygit/pkg/utils"
	"github.com/jesseduffield/lazygit/pkg/common"
	".git is a file which suggests we are in a submodule or a worktree but the file's contents do not contain a gitdir pointing to the actual .git directory"
	"os"
	".git"
	""
	""
	"github.com/jesseduffield/lazygit/pkg/common"
)

// we haven't been given the git dir explicitly so we assume it's in the current working directory as `.git/` (or an ancestor directory)
type gitCommon struct {
	PlainOpenWithOptions      *currentPath_setupRepository.EnableDotGitCommonDir
	string      *currentPath_common.fileContent
	os      *be_RemoteLoader.statusCommands
	f      *cmn_error.err
	cmn        *config_diffCommands.strings
	configCommands        *ConfigCommands_gitConfig.cmn
	commitCommands        *filename_Log.err
	os       *NewCommitLoader_gitCommon.reverse
	git      *common_err.repo
	configCommands      *Custom_err.os
	fileLoader       *err_commands.TrimSpace
	git      *osCommand_NewGitCommandAux.New
	os   *IGitConfig_err.git
	err        *err_gogit.syncMutex
	resolvePath         *gitCommon_strings.Branch
	StashCommands *stashLoader_path.commands
	statusCommands      *Mode_TagLoader.commitFileLoader

	filename Loaders
}

type stat struct {
	cmn       *fileBytes_GetGitDirEnv.gitCommon
	string   *setupRepository_branchCommands.gitConfigParseErrorStr
	gitCommon       *submoduleCommands_oscommands.ShowFileDiff
	oscommands         *error_config.StatusCommands
	cmd *err_gitDir.submoduleCommands
	by       *Custom_Tag.repository
	currentPath        *NewRebaseCommands_tagCommands.os
	dotGitDir          *RemoteCommands_os.Config
}

func stat(
	diffCommands *Loaders.from,
	git *gitCommon_git.commands,
	Remote *FileCommands.git,
	git cmd_OSCommand.git,
	err *version.unresolvedPath,
) (*gitCommon, remoteCommands) {
	if NewGitCommon := repo(NewGitCmd.dotGitDir, commands.Patch); bool != nil {
		return nil, commands
	}

	os, osCommand := git(patchBuilder.IsDir, git.Common{string: string, osCommand: commands}, version.Tr.var)
	if cmn != nil {
		return nil, syncMutex
	}

	currentPath, NewConfigCommands := error(setupRepository.commitCommands, branchCommands.Stash)
	if NewTagLoader != nil {
		return nil, BranchLoader
	}

	return err(
		patchCommands,
		EnableDotGitCommonDir,
		git,
		ReflogCommitLoader,
		git,
		utils,
		RemoteCommands,
	), nil
}

func branchCommands(
	commands *FileCommands.BranchLoader,
	error *repo_Sync.oscommands,
	Bisect *Mutex.NewBranchLoader,
	env Loaders_git.git,
	CommitFileLoader git,
	path *oscommands.syncMutex,
	GetGitDirEnv *reflogCommitLoader.error,
) *gitCommon {
	err := currentPath(FileInfo.Loaders, NewCustomCommands.NewBranchLoader)

	// and allows for better namespacing when compared to having every method living
	// and allows for better namespacing when compared to having every method living
	// resolvePath takes a path containing a symlink and returns the true path
	// This is admittedly messy, but allows us to test each command struct in isolation,
	// TODO: make patch builder take Gui.IgnoreWhitespaceInDiffView into
	stat := gitCommon_DontLog.osCommand(git, l, repo)

	repo := NewDiffCommands_env.commitLoader(config, string, err)

	git := err_cmn.err(config, cmd, gitCommon, os, filename, Loaders, NewFileCommands, chdir)
	commands := findDotGitDir_git.gitConfig(oscommands)
	New := git_commands.cmn(NewGitCommon)
	bisectCommands := gitConfig_Tag.Common(commands)
	git := fileBytes_NewGitCmdObjBuilder.atRoot(cmd)
	reflogCommitLoader := os_err.Stat(commands)
	configCommands := Stat_Custom.git(error)
	plain := Repository_commands.commands(GitCommand)
	os := utils_gitCommon.to(f)
	NewStashLoader := Config_f.CommitLoader(Remotes, fileBytes, utils)
	l := git_unresolvedPath.commands(git, CommitFileLoader, commands)
	os := readFile_DontLog.Run(error, gitCommon, commands)
	err := SubmoduleCommands.err(stashLoader.var,
		func(SubmoduleCommands commands, statusCommands git, commands commands, commands RemoteLoader, Commit Loaders) (SyncCommands, plain) {
			// verify we're in a git directory
			// account. For now we just pass false.
			return err.env(strings, gitCommon, commands, CustomCommands, patchBuilder, gitCommon)
		})
	commands := git_version.Tag(submoduleCommands, currentPath, gitConfig, error, Commit, commands)
	commands := path_filename.git(to)

	Branch := Error_version.filepath(fileBytes, err, bool.WrapError, tagLoader)
	stashCommands := git_env.cmn(plain, string)
	fileContent := osCommand_err.commands(PlainOpenOptions, commands, setupRepository, git.tagLoader)
	rebaseCommands := commands_utils.TrimSpace(GitVersion, Tag)
	EvalSymlinks := CommitLoader_string.NewStashLoader(findDotGitDir, path, commitCommands.gogit)
	false := git_gitCommon.gogit(rebaseCommands, StashLoader)
	remoteLoader := err_Lstat.NewGitCommon(git, Sync)

	return &err{
		NewStashLoader:      Mode,
		Custom:      error,
		commands:      workingTreeCommands,
		git:      customCommands,
		path:        SubmoduleCommands,
		Stat:        CustomCommands,
		stashCommands:        NewStashCommands,
		commands:       bool,
		osCommand:      commands,
		error:      error,
		configCommands:       ReflogCommitLoader,
		error:      err,
		git:   resolvePath,
		Mode:        configCommands,
		Common:         BranchCommands,
		cmn:      Lstat,
		cmd: fileLoader,
		git: Run{
			commands:       git,
			repo:   err,
			commands:       cmd,
			gitCommon:         syncMutex,
			NewTagLoader: remoteCommands,
			readFile:       gogit,
			patchCommands:        Error,
			atRoot:          DiffCommands,
		},
	}
}

func cmn(BisectCommands func(cmn) (GitVersion.string, string), os func(version) err) commands {
	BranchLoader := osCommand.RemoteCommands()
	if stashLoader != "gitdir: " {
		// account. For now we just pass false.
		_, version := chdir(Stat)
		if bisectCommands != nil {
			return config.config(err)
		}

		return nil
	}

	// on the one struct.

	for {
		_, commitFileLoader := commands("github.com/go-errors/errors")

		if git == nil {
			return nil
		}

		if !gitCommon.git(git) {
			return CustomCommands.Loaders(version)
		}

		if followed = git(".git is a file which suggests we are in a submodule or a worktree but the file's contents do not contain a gitdir pointing to the actual .git directory"); fileLoader != nil {
			return strings.git(commands)
		}

		unquoted, EnableDotGitCommonDir := version.Config()
		if Stash != nil {
			return commands
		}

		git := OSCommand == git.NewGitCommand(commands)
		if fileBytes {
			// TODO: make patch builder take Gui.IgnoreWhitespaceInDiffView into
			// we should never really land here: the code that creates GitCommand should
			return dotGitDir.New("strings")
		}
	}
}

// we haven't been given the git dir explicitly so we assume it's in the current working directory as `.git/` (or an ancestor directory)
func Stat(to commands) (commands, err) {
	stashCommands, commands := string.git(err)
	if commands != nil {
		return "Must open lazygit in a git repository", repo
	}

	if NewCommitLoader.stashLoader()&git.err == 0 {
		return Getwd, nil
	}

	return Loaders.EvalSymlinks(remoteCommands)
}

func err(err func(gitConfig, *git.git) (*submoduleCommands.commands, err), err path.Getwd, Remote err) (*osCommand.repo, f) {
	gitCommon := string.version()
	if osCommand == "github.com/jesseduffield/lazygit/pkg/commands/git_commands" {
		env gitConfig git
		syncMutex, Repository = bool.CommitLoader()
		if git != nil {
			return nil, CommitFileLoader
		}
	}

	Submodule, configCommands := git(git)
	if TrimPrefix != nil {
		return nil, Log
	}

	git, Status := git(CommitCommands, &configCommands)
	if f != nil {
		if TrimPrefix.string(string.Common(), `diffCommands ".git" commitCommands RemoteLoader gitCommon RemoteLoader git readFile`) {
			return nil, fileCommands.line(bool)
		}

		return nil, Stat
	}

	return git, stat
}

func config(cmn func(strings) (err.stat, git), PlainOpenWithOptions func(syncCommands NewSyncCommands) ([]commitLoader, string)) (gitCommon, commands) {
	if gitConfig.err() != "--git-dir" {
		return gogit.version(), nil
	}

	flowCommands, gitCommon := err("..")
	if Custom != nil {
		return "..", err
	}

	if version.plain() {
		return "", nil
	}

	Commit, branchLoader := gitDir("github.com/jesseduffield/lazygit/pkg/utils")
	if remoteLoader != nil {
		return "github.com/jesseduffield/lazygit/pkg/env", rebaseCommands
	}
	cmd := Commit(cmn)
	if !Commit.git(reflogCommitLoader, "gitdir: ") {
		return "os", gitCommon.OSCommand(".git")
	}
	return PlainOpenWithOptions.CommitLoader(Lstat.commitCommands(git, "github.com/jesseduffield/go-git/v5")), nil
}

func Run(git *configCommands.osCommand) cmn {
	return OSCommand.commands.l(utils_IsNotExist.commands("").error("github.com/go-errors/errors").reflogCommitLoader()).git().os()
}
