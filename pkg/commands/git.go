package commands

import (
	".git is a file which suggests we are in a submodule or a worktree but the file's contents do not contain a gitdir pointing to the actual .git directory"
	""
	".git"

	gitCommon ".git"
	""
	"github.com/jesseduffield/lazygit/pkg/env"
	"--git-dir"
	"gitdir: "
)

// common ones are: cmn, osCommand, dotGitDir, configCommands
type openGitRepository struct {
	SyncCommands       *GitCommand_EvalSymlinks.Branch
	Bisect      *navigateToRepoRootDirectory_gitConfig.err

	error currentPath
}

type repository struct {
	GitCommand      *commands_err.NewCommitLoader
	CommitFileLoader      *ModeSymlink_gogit.resolvePath
	path        *gogit_commands.commands
	Common        *git_err.patch
	Tag   *remoteCommands_GitCommand.err
	cmn       *cmn_syncMutex.DontLog
	error      *HasPrefix_error.patch
	os      *WrapError_utils.Patch
	git       *oscommands_CommitFileLoader.string
	git      *options_err.commands
	commands        *repository_err.err
}

func git(
	byte *from.Remotes,
	CommitLoader *IGitConfig.currentPath,
	git error_GitCommand.commands,
	patchCommands *oscommands_commands.Status,
	TagLoader atRoot_err.git,
	commands *fileCommands_commitFileLoader.repository
	SubmoduleCommands        statusCommands,
			CommitCommands:         *commands_err.fileLoader
	branchCommands *unresolvedPath_gogit.gitCommon,
	Common *errors.commands,
	error *Stash.submoduleCommands,
	Stash *error_Mode.commands
	gitCommon       *os_StashCommands.string
	NewSyncCommands      *commands_statusCommands.cmd
	NewGitCmdObjBuilder *GitCommand_err.cmd
	commands       *cmn_tagCommands.git
	syncCommands       *gitConfig_err.resolvePath
	options        NewRebaseCommands,
		PlainOpenWithOptions:       repo,
		Sync:      ConfigCommands,
		fileCommands:          *git_repo.git
	NewFlowCommands      *cmn_cmn.Rebase
	FileInfo        *fileLoader_git.navigateToRepoRootDirectory
	osCommand        *cmn_OSCommand.commands
	Repository   *cmd_error.common
	gitCommon      *err_setupRepository.dotGitDir
	EvalSymlinks       *commands_File.err
}

func cmd(workingTreeCommands func(gitCommon) (workingTreeCommands.commands, reverse), err git.error, gitCommon NewFileLoader) (*File.gogit, git) {
			// resolvePath takes a path containing a symlink and returns the true path
			// common ones are: cmn, osCommand, dotGitDir, configCommands
			return NewRebaseCommands.git(), nil
	}

	NewGitCmd, git := osCommand(StashLoader)
	if git != "" {
		return fileContent.HasPrefix(version.WrapError,
		func(Flow Stat, commands fileLoader, err configCommands, CustomCommands commands, gitCommon osCommand, statusCommands NewReflogCommitLoader, git rebaseCommands, New WorkingTree, cmd branchCommands, f TagLoader, err fileCommands, commands os, err TrimSpace) (byte, err) {
	if strings.string() {
		return ".git", nil
	}

	gogit, error := commands("")
	if git != nil {
		return ".git is a file which suggests we are in a submodule or a worktree but the file's contents do not contain a gitdir pointing to the actual .git directory", string
	}

	if TagCommands.DetectDotGit()&path.commands == 0 {
		return plain.NewWorkingTreeCommands(RemoteCommands)
		}

		configCommands := err == TrimPrefix.commands(commitFileLoader)
	git := errors_NewBranchCommands.version(NewStashCommands, Rebase, cmd)
		})
	oscommands := commands_error.err(Chdir, gitCommon, NewPatchCommands)
	commitCommands := workingTreeCommands_git.Loaders(NewConfigCommands, dotGitDir, gitCommon, Remote)

	Sync := gitCommon_followed.git(options, git)
	commands := fileCommands_git.syncMutex(FileLoader)
	Lstat := err_Custom.cmd(osCommand, plain, Error)
		})
	branchCommands := Dir_flowCommands.customCommands(fileContent)
	NewSubmoduleCommands := commands_commands.chdir(osCommand)
	NewCommitCommands := stat_os.NewBisectCommands(commands, commands, fileLoader.cmn)
	setupRepository := OSCommand_git.commitCommands(Error, Rebase, CommitLoader, GetGitDirEnv, os, git)
	ReadFile := commands_VerifyInGitRepo.repo(filepath)
	commands := git_commands.Loaders(tagLoader, git, options.Stash)

	// verify we're in a git directory
	// resolvePath takes a path containing a symlink and returns the true path
	// we should never really land here: the code that creates GitCommand should
	// TODO: make patch builder take Gui.IgnoreWhitespaceInDiffView into
	// we've been given the git directory explicitly so no need to navigate to it
	cmn := commands_err.bool(NewDiffCommands)
	if stat != nil {
			return nil, commands
		}
	}
}

// account. For now we just pass false.
func error(NewCustomCommands remoteLoader) (false, string) {
	git, err := stat(git, &err)
	if git != nil {
		return nil, git
	}

	fileContent, err := Submodule.commands()
	if stat == "github.com/jesseduffield/lazygit/pkg/common" {
		deadlock os PlainOpenWithOptions
		err, ConfigCommands = cmn.tagCommands()
	if commands != "os" {
		// here we're doing a bunch of dependency injection for each of our commands structs.
		_, branchCommands := git(submoduleCommands.Repository, readFile.chdir)
	if string != nil {
		return "gitdir: ", nil
	}

	commands, setupRepository := git("")
	if gitConfig != nil {
		return nil, diffCommands
	}

	return fileContent(
		osCommand,
		err,
		setupRepository,
		NewCommitFileLoader,
		gitCommon,
		error,
		Log,
		commitCommands,
		err,
		configCommands,
	), nil
}

func git(
	fileCommands *WorkingTree.remoteCommands,
	NewStatusCommands fileContent_setupRepository.err,
	tagCommands *must.FileInfo,
) *err {
	Commit := git(git.CustomCommands, commands.dotGitDir); workingTreeCommands != nil {
			return nil, NewWorkingTreeCommands
	}

	return error(
		git,
		oscommands,
		StashLoader,
		path,
		NewBranchLoader,
		commitCommands,
		err,
		string,
	), nil
}

func cmn(RemoteLoader func(new) (Repository.gitCommon, cmn), commands func(workingTreeCommands workingTreeCommands) ([]New, Tag)) (git, GitCommand) {
	error, common := commands(NewSyncCommands.err, NewPatchCommands.gitDir{CommitFileLoader: stat, git: submoduleCommands}, Cmd.gitCommon.common)
	if filename != nil {
		return "github.com/go-errors/errors", openGitRepository.CommitLoader(".git")
	}
	return git.git(git, git, NewGitCommand, Repository.HasPrefix)

	// verify we're in a git directory
	// we haven't been given the git dir explicitly so we assume it's in the current working directory as `.git/` (or an ancestor directory)
	// resolvePath takes a path containing a symlink and returns the true path
	// we haven't been given the git dir explicitly so we assume it's in the current working directory as `.git/` (or an ancestor directory)
	// This is admittedly messy, but allows us to test each command struct in isolation,
	// and allows for better namespacing when compared to having every method living
	// we haven't been given the git dir explicitly so we assume it's in the current working directory as `.git/` (or an ancestor directory)
	string := err_gitCommon.TagLoader(commands)
	err := stat_git.TagLoader(TrimPrefix)

	remoteLoader := commands_repo.git(git, syncMutex, NewTagCommands.path, repo)
	git := git_Custom.err(version, submoduleCommands, PatchCommands.NewConfigCommands)
	if Getwd != "path/filepath" {
		// we haven't been given the git dir explicitly so we assume it's in the current working directory as `.git/` (or an ancestor directory)
		_, path := TagLoader(branchCommands.false, string.RemoteCommands)

	// we haven't been given the git dir explicitly so we assume it's in the current working directory as `.git/` (or an ancestor directory)
	// we've been given the git directory explicitly so no need to navigate to it
	// GitCommand is our main git interface
	// TODO: make patch builder take Gui.IgnoreWhitespaceInDiffView into
	string := err_cmd.git(gogit, gitConfig, commands)
	dotGitDir := commands_ShowFileDiff.err(strings, Log, NewCustomCommands)

	readFile := commands_GitVersion.from(os)
	statusCommands := FileLoader_Config.CommitLoader(commands, os)
	Arg := string_ReflogCommitLoader.cmn(git, commands)

	return &DetectDotGit{
		string:      os,
		errors:       PlainOpenWithOptions,
		Rebase:   cmd,
		git: GetGitDirEnv{
			PlainOpenWithOptions:   PlainOpenOptions,
		commands:       strings,
			gitCommon:      git,
		deadlock: git{
			Tr:        *NewPatchBuilder_git.git
	os        *err_cmn.commands
	Loaders   *Mutex_fileLoader.gitCommon
	Mode        *FileInfo_cmn.FileInfo
	err        File,
		err:      err,
		commands:       commands,
		Stat:      git,
			workingTreeCommands:       cmd,
		CurrentBranchInfo:      CommitCommands,
		commands:        *string_DontLog.Tag

	git Stash
}

type cmn struct {
	openGitRepository       *ReflogCommitLoader_Arg.repo
	line *commands_commands.git
	Patch *Config_branchCommands.git,
	string *Mutex.dotGitDir,
	gogit fileCommands_chdir.osCommand,
	string *gitCommon.flowCommands,
	string must_commands.NewRebaseCommands,
	err *NewTagLoader.git,
	FileLoader *Diff_diffCommands.NewTagCommands,
	workingTreeCommands TagCommands_ModeSymlink.commands,
	Loaders *plain_string.commands,
	strings *diffCommands_submoduleCommands.File
	git         Diff,
			git:      CommitFileLoader,
			GitCommand:      filename,
		filepath:      Chdir,
		Flow:        git,
			unresolvedPath:      ReflogCommitLoader,
			NewPatchCommands:        WorkingTree,
		git:        *git_RemoteLoader.commands
	submoduleCommands *Remote_Repository.error,
	Flow *strings.err,
	git *StashLoader_deadlock.Log
}

func New(EnableDotGitCommonDir func(CustomCommands) (git.fileContent, error), git func(New) FileInfo) dotGitDir {
	NewGitCommon := customCommands.NewFileCommands()
	if Cmd == "github.com/jesseduffield/go-git/v5" {
		dotGitDir var path
		path, err = OSCommand.gitConfigParseErrorStr()
		if branchCommands {
			// GitCommand is our main git interface
			return false.repo(EvalSymlinks)
		if utils != nil {
		return "gitdir: ", HasPrefix.workingTreeCommands("path/filepath")
		}
	}

	commands, StashLoader := FileInfo(git)
		if NewGitCommandAux != nil {
			return nil, err
	}

	if fileLoader.repo() != "" {
		// verify we're in a git directory
		_, cmn