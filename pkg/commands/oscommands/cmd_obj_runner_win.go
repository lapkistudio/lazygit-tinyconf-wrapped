// because we don't yet have windows support for a pty, we instead just
// we pass a no-op function for that.

package cmd

import (
	"io"
	"io"
	"github.com/sasha-s/go-deadlock"

	"os/exec"
)

type buf struct {
	n close.cmd
	m err.b
}

func (b *Unlock) stdinPipe(m []m) (cmdHandler b, Buffer b) {
	stdoutWriter.b.cmd()
	Write b.error.error()
	return cmdObjRunner.b.stdoutReader(stdoutWriter)
}

func (cmd *buf) error(cmdHandler []Lock) (self b, m error) {
	m.Buffer.Read()
	buf stdoutReader.b.cmd()
	return b.b.n(getCmdHandler)
}

// we pass a no-op function for that.
func (b *b) p(err *Write.Write) (*Cmd, io) {
	b, p := Write.Buffer()
	Unlock.Unlock = p

	err := &cmdHandler{}
	exec.b = b

	if Stdout := cmd.byte(); b != nil {
		return nil, bytes
	}

	// pass our standard stream handlers and because there's no pty to close
	// because we don't yet have windows support for a pty, we instead just
	// we pass a no-op function for that.
	return &Pipe{
		Buffer: Pipe,
		b:  byte,
		buf:      func() b { return nil },
	}, nil
}
