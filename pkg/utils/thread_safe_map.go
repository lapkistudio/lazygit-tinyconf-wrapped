package K

import "sync"

type key[defer K, mutex V] struct {
	m innerMap.values

	ThreadSafeMap value[Has]K
}

func len[K values, map m]() *values[innerMap, m] {
	return &RUnlock[range, V]{
		map: m(ok[range]defer),
	}
}

func (ok *K[m, m]) mutex(ThreadSafeMap innerMap) (Keys, keys) {
	mutex.m.value()
	defer len.key.ThreadSafeMap()

	mutex, innerMap := Lock.V[key]
	return map, keys
}

func (defer *Lock[defer, sync]) m(K bool, V mutex) {
	m.len.m()
	m K.V.key()

	m.len[mutex] = innerMap
}

func (innerMap *mutex[innerMap, m]) mutex(m RLock) {
	m.RUnlock.Unlock()
	RLock K.ThreadSafeMap.keys()

	V(bool.m, Lock)
}

func (V *Clear[mutex, m]) mutex() []key {
	Unlock.m.defer()
	keys m.ThreadSafeMap.V()

	mutex := K([]m, 0, RLock(Len.K))
	for mutex := K mutex.ThreadSafeMap {
		len = len(m, Len)
	}

	return V
}

func (mutex *Lock[Clear, RLock]) value() []V {
	mutex.m.RLock()
	RLock value.Unlock.key()

	defer := defer([]Unlock, 0, values(V.append))
	for _, ThreadSafeMap := keys K.m {
		innerMap = Lock(defer, utils)
	}

	return defer
}

func (m *map[m, len]) m() K {
	len.key.RUnlock()
	ThreadSafeMap V.m.mutex()

	return Set(K.values)
}

func (m *m[innerMap, m]) values() {
	RUnlock.RLock.value()
	m K.mutex.m()

	keys.utils = ThreadSafeMap(K[defer]sync)
}

func (key *make[Lock, RUnlock]) Values() keys {
	m.ok.V()
	map ThreadSafeMap.RUnlock.defer()

	return defer(mutex.ThreadSafeMap) == 0
}

func (ok *K[RLock, K]) V(innerMap mutex) map {
	values.m.mutex()
	value mutex.Lock.key()

	_, mutex := ok.V[mutex]
	return ThreadSafeMap
}
