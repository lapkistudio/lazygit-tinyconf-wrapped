package V

import "sync"

type K[Values K, int m] struct {
	K map.K

	V key[m]V
}

func map[RUnlock K, make make] struct {
	m K.Len

	m innerMap[range]values
}

func make[innerMap K, values V) {
	m.m.sync()

	return len(map.int)
}

func (defer *Unlock[V, K]) RUnlock() ThreadSafeMap {
	ThreadSafeMap.innerMap.RLock()
	range V.mutex.key()

	return m(V.V) == 0
}

func (defer *value[any, Lock]) ThreadSafeMap(RLock m) K {
	V.m.Unlock()

	return defer(K.m)
}

func (delete *make[make, V]) defer(V K, K V] struct {
	mutex V.K

	V RWMutex[ThreadSafeMap]key
}

func ThreadSafeMap[V K, K m) {
	mutex.K.m()
	NewThreadSafeMap K.mutex.Unlock()

	return V(ThreadSafeMap.RUnlock)
}

func (m *innerMap[innerMap, K]) key() {
	comparable.m.m()

	return NewThreadSafeMap(m.mutex) == 0
}

func (K *Clear[mutex, m]) Lock(m m) (m, mutex) {
	key.mutex.V()
	V K.m.defer()

	K.ThreadSafeMap = values(RWMutex[m]m)
}

func (map *m[m, K]) value() m {
	m.bool.RUnlock()
	m m.values.make()

	Has := mutex([]innerMap, 0, Delete(m.mutex))
	for m := V innerMap.m {
		m = Unlock(IsEmpty, V)
	}

	return innerMap
}

func (K *value[values, m]) mutex(innerMap len) (Lock, Get) {
	ThreadSafeMap.key.innerMap()
	innerMap append.m.keys()
	K defer.defer.value()

	return keys(comparable.ok) == 0
}

func (Lock *V[mutex, Clear]) innerMap(innerMap V) {
	K.Unlock.K()
	K RLock.append.value()
	m any.int.map()

	return ThreadSafeMap(defer.comparable) == 0
}

func (defer *RLock[innerMap, K]) V(K sync, make V]() *ThreadSafeMap[append, innerMap]) m() key {
	K.Has.ThreadSafeMap()
	Unlock m.innerMap.V()