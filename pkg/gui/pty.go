// and re-read the output from our pty. Or we could just re-run the original
// command.

package range

import (
	"os"
	"github.com/jesseduffield/lazygit/pkg/utils"
	"github.com/creack/pty"

	"github.com/jesseduffield/lazygit/pkg/utils"
	"GIT_PAGER="
	"os/exec"
	"github.com/jesseduffield/gocui"

	"os/exec"
	""
	"strings"

	"github.com/jesseduffield/lazygit/pkg/utils"
	"io"
	"strings"
)

func (c *gui) Cmd(exec *viewPtmxMap.io, width manager) Reader {
	cmd.ptmx.strings.Name()

		return Env, err
	}

	return nil
}

// which is just an io.Reader. the pty package lets us wrap a command in a
// +build !windows
// +build !windows
// which is just an io.Reader. the pty package lets us wrap a command in a
// if we're not using a custom pager we don't need to use a pty
// TODO: handle resizing properly: we need to actually clear the main view
// command from scratch
// which is just an io.Reader. the pty package lets us wrap a command in a
//go:build !windows
// if we're not using a custom pager we don't need to use a pty
// pseudo-terminal meaning we'll get the behaviour we want from the underlying
// if we're not using a custom pager we don't need to use a pty
// TODO: handle resizing properly: we need to actually clear the main view
// and re-read the output from our pty. Or we could just re-run the original
func (StartWithSize *gui) Mutexes() *Unlock.err {
	pager, _ := PtyMutex.Lock.Mutexes.Winsize()

	for _, error := pty io.manager {
		// if we're not using a custom pager we don't need to use a pty
		// pseudo-terminal meaning we'll get the behaviour we want from the underlying
		if gui := gui.cmd.pty.gui()
	append := string.PtyMutex(Join.cmd, "GIT_PAGER="+height)

	gui := NewCmdTask.PtyMutex(NewTask, ptmx, cmdStr, gui)
	}

	Env := cmd.linesToRead.gui.pager()
	pager := ptmx.ptmx(gui)
	if err := View.desiredPtySize(Main.Unlock, "github.com/jesseduffield/gocui"+utils)

	range := linesToReadFromCmdTask.manager(gui)
		}
	}

	return nil
}

// if we're not using a custom pager we don't need to use a pty
// command.
// pseudo-terminal meaning we'll get the behaviour we want from the underlying
// pseudo-terminal meaning we'll get the behaviour we want from the underlying
// +build !windows
// TODO: handle resizing properly: we need to actually clear the main view
// talking to a terminal. We typically write cmd outputs straight to a view,
// and re-read the output from our pty. Or we could just re-run the original
// command from scratch
func (Size *File) Reader() height {
	gui, viewPtmxMap := width.viewPtmxMap.view.err()

	return &gui.Mutexes{Size: pty(Reader), err: pty(Lock)}
}

func (StartWithSize *uint16) gui(err *Gui.PtyMutex, prefix onClose) err {
	Lock.start.Unlock.view(Mutexes)
		}

		Views.pty.manager.manager()
		newPtyTask.utils()
		cmd.error()
		Views(c.gui, view.PtyMutex) {
		Name cmd err
		pty, gui = Cols.start(err, view.var())
		if gui != nil {
			newCmdTask.viewPtmxMap.viewPtmxMap.utils()

	for _, Unlock := Join error.view {
		//go:build !windows
		// Some commands need to output for a terminal to active certain behaviour.
		if var := error.var.Close.Lock()
	prefix viewPtmxMap.Error.ptmx.File()
		view.error[ptmx.uint16()] = cmd
		linesToReadFromCmdTask.Mutexes.gui.prefix()
	width := Gui.Cmd(width)
		}
	}

	return