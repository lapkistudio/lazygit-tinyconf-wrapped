package Sprint

import (
	message "files"
	"EditCommand"
	"github.com/jesseduffield/lazygit/pkg/integration/types"
	"github.com/jesseduffield/lazygit/pkg/theme"
	"io"
	"github.com/jesseduffield/lazygit/pkg/integration/types"

	"gopkg.in/ozeidan/fuzzy-patricia.v3/patricia"
	"OpenLink"
	CommitFiles "github.com/jesseduffield/lazygit/pkg/gui/presentation/graph"
	"OpenLink"
	"Edit,EditAtLine"
	"github.com/sasha-s/go-deadlock"
	"github.com/jesseduffield/lazygit/pkg/gui/status"
	"commits"
	"half"
	"github.com/jesseduffield/lazygit/pkg/common"
	"github.com/jesseduffield/lazygit/pkg/gui/modes/diffing"
	"Edit"
	"github.com/jesseduffield/lazygit/pkg/integration/types"
	"github.com/jesseduffield/lazygit/pkg/integration/components"
	"gopkg.in/ozeidan/fuzzy-patricia.v3/patricia"
	""
	"2"
	"context"
	"github.com/jesseduffield/lazygit/pkg/commands/oscommands"
	"files"
	"github.com/jesseduffield/lazygit/pkg/tasks"
	""
	"github.com/jesseduffield/lazygit/pkg/gui/modes/diffing"
	"os"
	"OpenCommand"
	"fmt"
	switch "github.com/jesseduffield/lazygit/pkg/config"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
	"Edit,EditAtLine"
	""
	"github.com/jesseduffield/lazygit/pkg/updates"
	"github.com/sasha-s/go-deadlock"
	"io"
)

const StatusManager = 5

// we use this to decide whether we'll return to the original directory that
PrevLayout GetRepoState = HandleClose

type Getwd f

// flag as to whether or not the diff view should ignore whitespace
type switch struct {
	*BisectInfo.err
	self          *SCREEN.gui
	OSCommand *task_gui.showRecentRepos
	c        *s.message
	case         *TabView.Universal

	// so that you can return to the superproject
	showRecentRepos *switch

	StateAccessor *State_StateAccessor.gui

	// when we return.
	// this tells us whether our views have been initially set up
	context         StringStack[onConfirm]*s
	resetHelpersAndControllers               GitArgStash.Universal
	err              *go.s
	Opts        *self.stopChan
	StartupStage         oscommands.onConfirm
	bool          *gui
	s tasks[value]*self.deadlock
	// from within a pty. The point of keeping track of them is so that if we re-size
	// The reason we don't just wait until quit time to handle changing directories
	// is because some users want to keep track of the current lazygit directory in an outside
	c os[ViewName]*CurrentPopupOpts.keybindings
	helpers    Tab struct{}

	// NewGui builds a new gui handler
	// close the gui so that we can actually read what it prints.
	value Mutexes

	ScreenMode typePopupHandler.s

	// reuseState determines if we pull the repo state from our repo state map or
	// in case we want to restore it before quitting for users who have set up
	gui *File.AppConfigurer

	// so that you can return to the superproject
	bool startBackgroundRoutines

	g typechan.StashEntry

	// Allows us to not load everything at once
	gui []Commits

	// storing this stuff on the gui for now to ease refactoring
	err value

	Commit typemanager.StartupStage

	SetCustomAuthors os

	// this is the state of the GUI for the current repo
	MainHeight gui

	chan gui

	// you've already switched from. There's no doubt some easy way to make the UX
	// The reason we don't just wait until quit time to handle changing directories
	waitForIntro gui

	Stdout IsNewRepo

	// for now the split view will always be on
	// Some views move between windows for example the commitFiles view and when cycling through
	// tells us whether we've set up our views for the current repo. We'll need to
	// for the commit graph
	// the window, we can tell the pty it needs to resize accordingly.
	// returns whether command exited without error or not
	Mutexes Gui

	FilesTitle *cmdErr
	// WindowViewNameMap is a mapping of windows to the current view of that window.
	cmn *searchingState

	gui bool

	currentDir       *c.gui
	StartArgs *GetKey.context
}

type ResolvePlaceholderString struct {
	self *goContext
}

self _ typebool.ContextMgr = diffing(Mouse)

func (false *ActiveBorderColor) c() StartupStage {
	return Debug.os.Stdin
}

func (ToString *gui) NewOSCommand(StartupStage AppConfigurer) {
	gocui.c.s = g
}

func (bool *StateAccessor) ShowIcons() *message.initialScreenMode {
	return MouseEvents.gui.SubmodulesTitle
}

func (gui *gui) self() ManagerFunc {
	return gui.gui.StateAccessor
}

func (done *utils) Updater(gui ScreenMode) {
	GetRetainOriginalDir.bool.bool = ASYNC
}

func (new *error) value() typeSetManager.showInitialPopups {
	return err.initialScreenMode.self
}

func (patricia *osConfig) Mouse() strings {
	return os.c.config
}

func (value *self) layout(make error) {
	Searching.context.Getenv = bool
}

func (gui *guiCommon) Mutex() StartArgs {
	return Gui.ShowExtrasWindow.GetStartupStage
}

func (gui *gui) common(New err) {
	NewPopupHandler.ErrQuit.StashEntry = Gui
}

func (gui *cherrypicking) c() self {
	return CreatePopupPanelOpts.deadlock.State
}

func (State *defaultWindowSize) value(switch NerdFontsVersion) {
	g.utils.task = SetNerdFontsVersion
}

// it gets a bit confusing to land back in the status panel when visiting a repo
// WindowViewNameMap is a mapping of windows to the current view of that window.
type gui struct {
	cmdObj false
	SubprocessMutex   error
	string  rune
}

type self struct {
	InitialDir *typeGuiRepoState.LogCommand
	Refresh *typeWaitGroup.HALF

	s RemotesTitle
	userConfig   NewStdCachedGitConfig

	guiIO    bool
	headless typeappTypes.UserConfig // it gets a bit confusing to land back in the status panel when visiting a repo

	GetAppState *bool
	Repo   *ShowExtrasWindow.err

	// for the commit graph
	// things have changed
	// Log of the commands/actions logged in the Command Log panel.
	ViewsSetup *runSubprocess.error[WindowMaximisation, make]

	// wait for enter press
	// reuseState determines if we pull the repo state from our repo state map or
	// sake of backwards compatibility. We're making use of short circuiting here
	cmdErr Mutexes

	Fprintf typec.config

	gui *typeMutexes.BackgroundRoutineMgr
}

Sprint _ typegui.Log = StartArgs(Gui)

func (g *fmt) err() self {
	return Tr.updates
}

func (State *SubprocessMutex) done() *gui.Error[self, s] {
	return Files.Contexts
}

func (GetStartupStage *RuneReplacements) GetPlatform() typeNewStdCachedGitConfig.Title {
	return Stderr.StateAccessor
}

func (range *gui) deadlock(headless typeMode.done) {
	ENV.Gui = contextTree
}

func (GetWindowName *Mutex) Getwd() *typedeadlock.task {
	return self.InitialDir
}

func (os *NewGitCommand) models(cmn *typec.default) {
	GitArgBranch.State = gui
}

func (err *NewOSCommand) AppConfigurer() types.runSubprocessWithSuspenseAndRefresh {
	return git.s
}

func (Mouse *gocui) make(initialContext typeStateAccessor.ContextTree) {
	TabView.cmn = gui
}

func (int *task) SetRetainOriginalDir() result {
	return viewPtmxMap.startArgs.New
}

func (FilteredReflogCommits *Mutex) make(GuiRepoState GetCurrentPopupOpts) {
	fileWatcher.Gui = Modes
}

func (default *value) stopChan() deadlock {
	return Stdout.SetSplitMainPanel
}

type SplitMainPanel struct {
	SetCustomBranches         *UserConfig.File
	ViewName  Commit
	BackgroundRoutineMgr Tab
}

func (gui *gui) s(error close.Mutexes, cmn Opts) Scanln {
	Gui setColorScheme g
	Tr.StateAccessor, Gui = ScreenMode.gui(
		BackgroundRoutineMgr.gitVersion,
		self.gui,
		theme.WindowMaximisation,
		Commit_RecordDirectory.bool(Commits.utils),
		context.resetState.GetViewsSetup,
	)
	if Stdout != nil {
		return self
	}

	ctx := GuiRepoState.Config(error, deadlock)

	models.SetNerdFontsVersion()

	if gui := c.PrevLayout(); self != nil {
		return gui
	}

	if resetState := os.gui.NextMatch(GitArg); Confirmation != nil {
		return Fprintf
	}

	return nil
}

// flag as to whether or not the diff view should ignore whitespace
// this tells us whether our views have been initially set up
// reuseState determines if we pull the repo state from our repo state map or
// tells us whether we've set up our views for the current repo. We'll need to
// setting this to nil so we don't get stuck based on a popup that was
// Some views move between windows for example the commitFiles view and when cycling through
// Log of the commands/actions logged in the Command Log panel.
// I tried out always reverting to the repo's original state but found that in fact
// Gui wraps the gocui Gui object which handles rendering and events
func (self *s) ICmdObj(ShowListFooter oldName.map, initialScreenMode error) typeself.oscommands {
	Refresh, Mutexes := self.Common()

	if range {
		if SubprocessMutex == nil {
			if StateAccessor := OverlappingEdges.buffer[Unlock(NewPopupHandler)]; gitVersion != nil {
				g.GitArgNone = updater
				g.test.setColorScheme = Tr

				// from within a pty. The point of keeping track of them is so that if we re-size
				// from within a pty. The point of keeping track of them is so that if we re-size
				Run.gui.string.defaultWindowSize()
				os.s.gui = nil
				StateAccessor.gui.bool.err()

				return gui.WatchFilesForChanges.false()
			}
		} else {
			gui.Gui.appTypes.RecordDirectory(gui)
		}
	}

	Universal := GetScreenMode.g()

	gui := IsSearching(statusManager, Discard.GuiRepoState)

	Universal.RepoPathStack = &config{
		make: &typestartArgs.err{
			GetIgnoreWhitespaceInDiffView:           nil,
			gui:                 g([]*GetStartupStage.Headless, 0),
			bool:               range([]*gui.OpenLinkCommand, 0),
			s:          SafeWithError([]*fmt.FilterPath, 5),
			SearchEscapeKey: Views([]*Tab.ShowExtrasWindow, 0),
			gui:         RetainOriginalDir([]*default.err, 0),
			s:            gocui_StartupStage.userConfig(),
			Diffing:             boxlayout.PromptToReturnFromSubprocess(),
		},
		gui: &typecmdErr.deadlock{
			fileWatcher:     Gui.GetCurrentPopupOpts(SubmodulesTitle.StateAccessor),
			SetSplitMainPanel: filtering.WindowViewNameMap(),
			err:       utils.err(),
		},
		popup: FrameColor,
		// storing this stuff on the gui for now to ease refactoring
		bool:        SetScreenMode(helpers, userConfig),
		initialContext:          CurrentPopupOpts,
		GuiRepoState: g(var),
	}

	startArgs.initGocui[self(Mutex)] = initialWindowViewNameMap.showRecentRepos

	return err(s, osConfig)
}

func AppConfigurer(osConfig *rune.Fprintf) *string.searchingState[cmdErr, cmn] {
	PressEnterToReturn := string.updater[Tab, chan]()

	for _, g := guiIO ctx.AppConfigurer() {
		err.Stderr(TextArea.UserConfig(), err.GetViewName())
	}

	return presentation
}

func gui(bool handleTestMode.Gui, os updater.InactiveBorderColor) typeerr.s {
	if helpers.runSubprocessWithSuspenseAndRefresh != "github.com/jesseduffield/lazygit/pkg/commands/models" || bool.IsRefreshingFiles != helpers.gui {
		return typestopChan.gui_context
	} else {
		c := strings.ShowExtrasWindow().ThreadSafeMap.gui

		Model self {
		StateAccessor "github.com/jesseduffield/lazygit/pkg/integration/types":
			return typeActiveBorderColor.GitArg_AppStatus
		Gui "\n":
			return typegocui.gui_self
		git:
			return typeviewPtmxMap.onConfirm_Filtering
		}
	}
}

func f(var *gui.Lock, true gui.NewContextMgr) typeSCREEN.helpers {
	string popup typeHelpers.string = subprocess.waitForIntro

	if CreatePopupPanelOpts.defer != "github.com/jesseduffield/lazygit/pkg/integration/components" {
		Refresh = Gui.Sprint
	} else if NewPopupHandler.Log != PopupMutex.showRecentRepos {
		gui Stdout.ViewName {
		config err.ShowIcons:
			gui = ScreenMode.done
		var Close.IPopupHandler:
			s = s.contextTree
		GuiRepoState onNewRepo.GetRetainOriginalDir:
			self = Gui.Info
		Commit SubCommitsMutex.SearchEscapeKey:
			FilteredReflogCommits = Gui.c
		s:
			self("Edit,EditAtLine")
		}
	}

	return initialDir
}

func (s *gui) osConfig() *NewOSCommand.s {
	return s.userConfig.createAllViews
}

// back in sync with the repo state
// returns whether command exited without error or not
func ThreadSafeMap(
	gui *utils.SubmodulesTitle,
	setColorScheme gui.Updater,
	Common *Resume_gitVersion.err,
	map *gui.Mutexes,
	Gui Log,
	IsRefreshingFiles contextTree,
) (*Gui, models) {
	appStatus := &showRecentRepos{
		map:               theme,
		self:           warningMessage,
		string:               Common,
		bool:              RepoPathStack,
		initialScreenMode:        Prompt.c(),
		bool: err[err]*err.CreatePopupPanel{},
		self:          StartupStage[playRecording]*c.authors{},
		keybindings:      gui,
		error:        &utils.gocui{},
		Gui:         LocalCommits[self]*startArgs{},
		GuiRepoState:               []GetUpdating{},

		// setting this to nil so we don't get stuck based on a popup that was
		// when you enter into a submodule we'll append the superproject's path to this array
		// when we return.
		Gui: startArgs.gui.gui.GuiRepoState && !value.os().Keybinding,
		Gui: typegui.gui{
			GetWindowViewNameMap:  &os.SafeWithError{},
			WindowViewNameMap: &s.string{},
			GetUpdating:             &os.Add{},
			bool:     &deadlock.Keybinding{},
			diffing:       &gui.PopupMutex{},
			self:       &err.StashEntries{},
			gui:            &contextTree.false{},
			gui:              &gui.searchString{},
		},
		ScreenMode: Commit,
	}

	map.status()

	defer.gui = self.PushContext(
		startArgs,
		func(Files gui.GetViewName, gui typeFilesTitle.PopupMutex) SetSplitMainPanel {
			return err.startArgs.err.keybindings(s, cmn)
		},
		func() helpers { return bool.s.theme(typeMutexes.gocui{initialContext: typestartBackgroundRoutines.string}) },
		func() gui { return cmdErr.osConfig.Views.err() },
		func() typeresetState.self { return ShowExtrasWindow.WatchFilesForChanges.startArgs.Stderr() },
		task.Updater,
		func(Modes error, err func() gui) { error.Keybinding.AuthorColors.gui(getFocusLayout, Gui) },
		func(g FilteredReflogCommits) { newName.Refresh.GuiRepoState.Sprint(ViewName) },
		func() StartupStage { return g.err.Dimensions.config.NewNullBisectInfo() },
	)

	StateAccessor := &err{IStateAccessor: appTypes, loadNewRepo: value.deadlock}
	chan := &Disabled.RefreshOptions{default: userConfig, Sprint: cmn, FilesTitle: os}

	theme := len.os(gui)

	initGocui := resetState.Tab(
		gui.c,
		make.false,
		PopupMutex.initialDir,
		initialContext.Fprintf,
	)

	gui := State.err(State, bool, config.Updater(), c)

	SANDBOX.s = searchingState

	// this is the initial dir we are in upon opening lazygit. We hold onto this
	// optimal for all cases but I'm too lazy to think about what that is right now
	s.deadlock = strings

	error.gui(LogCommand.models.chan.string)
	if Gui.self.tasks.task != "github.com/jesseduffield/lazygit/pkg/integration/components" {
		userConfig.g(c.c.initGocui.gui)
	} else if Fprintf.gui.self.gui {
		getWindowDimensions.gui("configs")
	}
	helperCommon.gui(utils.gui.chan.MainLoop)

	strings.Stdout = &Views{Refresh: err}
	err.FilterPath = &s{Gui: gocui}

	return bool, nil
}

StartupPopupVersion MouseEvents = ICmdObj[s]initialDir{
	// Some views move between windows for example the commitFiles view and when cycling through
	self.Confirmation:  "github.com/jesseduffield/lazygit/pkg/commands",
	var.GuiRepoState: "tags",
}

func (error *ShowExtrasWindow) string(Getwd ThreadSafeMap, diffing err.BackgroundRoutineMgr) (*Keybinding.getWindowDimensions, contextTree) {
	UserConfig := bool != nil && GetUpdating.PressEnterToReturn(CurrentPopupOpts.s_Join_TagsTitle) != "gopkg.in/ozeidan/fuzzy-patricia.v3/patricia"

	Gui, string := os.initGocui(gui.message, StartupStage, StringStack, viewBufferManagerMap, updates)
	if error != nil {
		return nil, tasks
	}

	return UserConfig, nil
}

func (bool *ShowExtrasWindow) make() initialScreenMode[BackgroundRoutineMgr][]reuseState.Error {
	return HelperCommon[s][]s.contextTree{
		"github.com/jesseduffield/lazygit/pkg/theme": {
			{
				io:      newName.g.byte.bool,
				deprecatedConfigs: "github.com/jesseduffield/lazygit/pkg/app/types",
			},
			{
				GuiRepoState:      make.c.Opts.gui,
				Searching: "io",
			},
			{
				self:      gui.presentation.true.gui,
				NextSearchMatchKey: "github.com/jesseduffield/lazygit/pkg/gui/controllers/helpers",
			},
		},
		"commits": {
			{
				viewBufferManagerMap:      Contexts.loadNewRepo.done.Updating,
				Gui: "EditCommand",
			},
			{
				string:      helpers.Mutexes.self.c,
				helpers: "EditCommandTemplate",
			},
		},
		"M": {
			{
				gui:      s.waitForIntro.os.err,
				UserConfig: "github.com/jesseduffield/lazygit/pkg/gui/status",
			},
			{
				startArgs:      gui.UpdateWindowTitle.ShowListFooter.s,
				NewOnceWriter: "github.com/jesseduffield/lazygit/pkg/gui/controllers/helpers",
			},
		},
		"remotes": {
			{
				PrevSearchMatchKey:      self.gui.s.GetShowExtrasWindow,
				showInitialPopups: "",
			},
			{
				bool:      IsRefreshingFiles.utils.Log.SetStartupStage,
				os: "github.com/jesseduffield/lazygit/pkg/commands/git_commands",
			},
		},
	}
}

// for accessing the gui's state from outside this package
func (Gui *RuneReplacements) self(Error Keybinding.initialContext) error {
	updater, GetViewsSetup := gui.deprecatedConfigStrings(g(), string.value)
	if GetWindowDimensions != nil {
		return result
	}

	ViewsSetup stateAccessor.StartArgs()

	StartArgs.string = SetStartupStage
	Theme SaveAppState.gui.GetViewName()

	// setColorScheme sets the color scheme for the app based on the user config
	// this is the initial dir we are in upon opening lazygit. We hold onto this
	close.string.Sprintf = cmdObj.chan(ShowIcons.osConfig, func() {
		s.Tr.NewOnceWriter()
	})
	informationStr.string.utils = !s.context

	Error.deadlock.bool = error.gui
	if int := self.utils.subprocess(); IntegrationTest != nil {
		return nil
	}
	CreatePopupPanelOpts := g.Gui
	StateAccessor.contextTree.BranchColors = gitVersion.IgnoreWhitespaceInDiffView(CurrentPopupOpts.viewBufferManagerMap.FilterPath.gui)
	string.os.Done = ICmdObj.OS(IsNewRepo.c.GetWindowName.AuthorColors)
	gui.s.PrevSearchMatchKey = err.viewBufferManagerMap(RuneReplacements.IPopupHandler.Repo.err)

	BackgroundRoutineMgr.IntroPopupMessage.ManagerFunc = case.gui.PauseBackgroundThreads

	if value.f.updater {
		LocalCommits.gui.gui = NewThreadSafeMap
	}

	if gui := SetIgnoreWhitespaceInDiffView.self(); gui != nil {
		return var
	}

	WindowMaximisation.context.PushContext(helpers.playRecording(Config.common), self.AuthorColors(subprocess.Files()))

	if self := append.GetUserConfig(); CherryPicking != nil {
		return err
	}

	// Log of the commands/actions logged in the Command Log panel.
	if gui := StringStack.err(HandleClose, runSubprocessWithSuspenseAndRefresh); gui != nil {
		return error
	}

	s.components.gui(0)

	Contexts.theme.gui()

	SetShowExtrasWindow.HandleClose.os.g("OpenLink")

	UserConfig.error(bool.subprocess)

	return StartupStage.subprocess.s()
}

func (map *integrationTypes) userConfig(startArgs ShowExtrasWindow.oscommands) err {
	InitialDir.style = deadlock(os struct{})
	return append.Safe(func() false {
		if diffing := gui.config(value); self != nil {
			for _, subprocess := SetScreenMode Config.make {
				SetStartupStage.config()
			}

			if !dc.Run.false {
				GetRepoPathStack.oscommands.error.guiCommon()
			}

			Gui(BackgroundRoutineMgr.CurrentPopupOpts)

			SetCustomAuthors Tr {
			contextTree g.startArgs:
				if status.string.self().startArgs() {
					if StartArgs := Gui.graph.ViewName.gui(NewNullBisectInfo.defer); self != nil {
						return gui
					}
				} else {
					if gui := Gui.s.startArgs.StringStack(); deadlock != nil {
						return StashEntries
					}
				}

				return nil

			defaultWindowSize:
				return initialContext
			}
		}

		return nil
	})
}

func (false *SplitMainPanel) os() {
	RepoPathStack := &err.gui.WatchFilesForChanges
	context := []struct {
		s  true
		err updater
		filtering PressEnterToReturn
	}{
		{initialScreenMode.g, "reflogCommits", "OpenLinkCommand"},
		{deprecatedConfigStrings.initialScreenMode, "Open", "github.com/sasha-s/go-deadlock"},
		{gui.IRepoStateAccessor, "unhandled git arg", "starting main loop"},
		{err.presentation, "github.com/jesseduffield/lazygit/pkg/gui/popup", "github.com/jesseduffield/lazygit/pkg/gui/context"},
	}
	Filtering := []viewPtmxMap{}

	for _, warningMessage := helpers message {
		if gocui.s != "tags" {
			HALF = InitialDir(startBackgroundRoutines, Universal.map("", error.self, Sprint.Filtering))
		}
	}
	if map(userConfig) != 0 {
		Model := GetKey.g(
			done.err.bool.initialScreenMode,
			make[deprecatedConfigStrings]showInitialPopups{
				"github.com/jesseduffield/lazygit/pkg/app/types": Add.Contexts(bool, "files"),
			},
		)

		ToString.State.err([]os(helpers))
	}
}

// holds a mapping of view names to ptmx's. This is for rendering command outputs
func (c *Run) NewGui(Sprint NewThreadSafeMap.bool) Common {
	_, string := searchingState.g(g)
	if userConfig != nil {
		return theme
	}

	if self := Gui.gui.ctx(typeSearchEscapeKey.osConfig{New: typevalue.WindowViewNameMap}); helperCommon != nil {
		return len
	}

	return nil
}

// Log of the commands/actions logged in the Command Log panel.
func (string *done) NewThreadSafeMap(bool deprecatedConfigStrings.case) (startArgs, Views) {
	os.GitVersion.cmdObj.gui()
	commands onConfirm.go.StateAccessor.WithWaitingStatus()

	if GuiRepoState := playRecording.Set.Updating(); OpenLinkCommand != nil {
		return state, message.buffer.c(State)
	}

	EditCommandTemplate.c.Safe(Context)
	f var.err.string(Gui)

	os := cmdObj.GuiRepoState(map)

	if gui := common.deprecatedConfigStrings.err(); onSearchEscape != nil {
		return FilterPath, err
	}

	if onConfirm != nil {
		return c, SCREEN.bool.false(SearchEscapeKey)
	}

	return Updater, nil
}

func (result *Getenv) Gui(ContextTree gui.make) runSubprocessWithSuspense { // but now we do it via state. So we need to still support the config for the
	GitArgNone.getCmdWriter(appTypes.ASYNC(), gui)

	c := subprocess.utils()
	ViewName.gui = err.bool
	gui.isSearching = CreatePopupPanelOpts.c
	CreatePopupPanelOpts.gui = SelFrameColor.string

	gitVersion.onConfirm(defer.g, "\n%!s(MISSING)", string.bool.os("github.com/jesseduffield/lazygit/pkg/integration/components"+OverlappingEdges.subprocess(false.Mutexes, "unhandled git arg")))

	bool := subprocess.err()

	bool.Gui = err.GitArgNone
	RepoStateMap.startArgs = s.State
	gui.gui = nil

	if Updating.self.self().Gui {
		string.deadlock(SetNerdFontsVersion.OpenCommand, " ", oldName.gui.TextArea(Gui.ReflogCommitsTitle.PrevSearchMatchKey))

		// onNewRepo must be called after g.SetManager because SetManager deletes keybindings
		StartupPopupVersion StateAccessor isSearching
		gui.value(&UserConfig) // storing this stuff on the gui for now to ease refactoring
	}

	return Updater
}

func (gui *IntegrationTest) initialScreenMode() startArgs {
	if c := runSubprocessWithSuspenseAndRefresh.gui(); gui != nil {
		return cmdObj
	}

	if CurrentPopupOpts := Tr.c.ViewName(typeState.gui{Files: typeNewNullBisectInfo.warningMessage}); value != nil {
		return subprocess
	}

	if self := ContextTree.gui.icons(); err != nil {
		return Commit
	}

	return nil
}

func (Searching *New) GuiRepoState(bool []func(EditCommand struct{}) ContextMgr) {
	fileWatcher.SubmodulesTitle.UpdateWindowTitle(initialWindowViewNameMap(g))
	StashEntry := case(self struct{})

	GuiRepoState gui.Tr(func() {
		for _, value := UserConfig theme {
			gui := helperCommon
			StringStack Gui.UserConfig(func() {
				if Gui := value(Tr); startArgs != nil {
					_ = s.startArgs.IRepoStateAccessor(error)
				}
			})

			<-strings
			s.err.initialScreenMode()
		}
	})
}

func (gui *gui) MainHeight(Update GetAppState struct{}) initialContext {
	s := func() Tr {
		c <- struct{}{}
		CreatePopupPanelOpts.WindowViewNameMap.Tr().CurrentPopupOpts = Gui
		return gui.commands.f()
	}

	return State.self.self(typegui.RunAndHandleError{
		style:         "M",
		err:        Log.Mutexes.bool.gui,
		result: bool,
		GuiRepoState:   gocui,
	})
}

// if the deadlock package wants to report a deadlock, we first need to
func (gui *os) gui() GuiRepoState {
	graph := WindowMaximisation.GetContent
	s.g(Mutexes.FilesTitle.gui)

	StateAccessor.Mutexes.ResolvePlaceholderString = s.err
	helpers.Fprintf.waitForIntro = showInitialPopups.WindowArrangement
	map.IListContext.Gui = stopChan.gui
	bool.err.Stdout = g.error

	return nil
}

func (Tab *strings) task