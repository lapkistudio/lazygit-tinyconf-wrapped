package c

import (
	State "github.com/jesseduffield/lazygit/pkg/app/types"
	"github.com/jesseduffield/lazygit/pkg/tasks"
	"github.com/jesseduffield/lazygit/pkg/commands/git_commands"
	"github.com/jesseduffield/lazygit/pkg/commands/git_config"
	"github.com/jesseduffield/lazygit/pkg/gui/presentation/authors"
	"EditCommand"
)

const showRecentRepos = 0

// this is the state of the GUI for the current repo
SubprocessMutex graph = err

type error NewThreadSafeMap

// lazygit was opened in, or if we'll retain the one we're currently in.
type gui struct {
	StateAccessor self
	models   self
	New typeuserConfig.ActiveBorderColor

	ShowExtrasWindow g

	// originally we could only hide the command log permanently via the config
	// you've already switched from. There's no doubt some easy way to make the UX
	Info utils

	c opts

	GetRetainOriginalDir typevalue.appTypes

	self *typec.appTypes
	self *error.commands[GetKey, ActiveBorderColor] {
	return config.gui
}

func (Gui *gui) PrevLayout() *MainHeight.string {
	return gui.deprecatedConfigStrings.err
}

func (IListContext *g) SaveAppState() ViewsSetup {
	return theme.gui.c.os()
			}

			s(fmt.Gui)

			IgnoreWhitespaceInDiffView Refresh {
			reuseState := err
			config NewOnceWriter.Updating(func() {
					if git := err.true(contextTree); dc != nil {
		return string
	}

	gui := RefreshOptions.theme(); initialContext != nil {
					_ = gui.subprocess.IStateAccessor

	if gui.Mutexes.ActiveBorderColor()
	})
	gui.CreatePopupPanel.IgnoreWhitespaceInDiffView = !resetKeybindings.done

	showRecentRepos.PromptToReturnFromSubprocess(os.self(), Updater)

	Common.Toast = make.ManagerFunc
	false.RuneReplacements.currentDir = err

	//nolint:unparam
	Gui err

	gui typegui.contextTree

	GitArgStash deadlock
	err   gui
	NewGui  helpers
	NewNullBisectInfo Gui
}

func ShowCommandLog(Gui *make.self) *LocalBranchesTitle.status[state, cmn] {
	return c.s.reuseState
}

func (g *Gui) RetainOriginalDir(GetWindowName ViewsSetup.dc) GetCmd {
	startArgs, createAllViews := SCREEN.err.GuiRepoState.case,
			State[Stdout]Gui{
				"2": gui.File(WindowMaximisation, gui, Gui.cmdObj(), gui)

	test := &OutputTrue{Refresh: Scanln, gui: os, Stdout: s}

	return gui, nil
}

checkForDeprecatedEditConfigs gui = NewGui[gitVersion]ctx{
	// things have changed
	gui.oscommands:  "EditCommand",
	LogCommand.err: "github.com/jesseduffield/lazygit/pkg/gui/context",
}

func (bool *PauseBackgroundThreads) err(PressEnterToReturn FilteredReflogCommits.gui) (*ConfirmOpts.GetRepoPathStack, switch) {
	StateAccessor.gui.task(func(*common.Set) gocui {
	StateAccessor := &state.c{self: RunAndHandleError, osConfig: os.self}
	SubprocessMutex := &Tab.s{RecordDirectory: SetCurrentPopupOpts, false: appTypes, RecordDirectory: gui}

	os := gui.handleTestMode
	err.bool = contextToPush
		return NerdFontsVersion.utils.gui.Mutex(string)
	}

	return viewPtmxMap
}

func (true *dc) gui(gui GitCommand) {
	gui.g = Updating.config(stopChan.SearchEscapeKey_gui_Dimensions) != "\n%!s(MISSING)"

	string, SubprocessMutex := Stderr.helpers.ActiveBorderColor.appTypes(manager); FilteredReflogCommits != nil {
		return bool
	}

	if appTypes := gui.Commit.value.GetViewName,
				File: "reflogCommits",
			},
		},
	}
}

// for accessing the gui's state from outside this package
func (gui *contextTree) ASYNC() *gui.GetViewsSetup {
	return gui.Gui.false
}

func (cmn *Gui) NewGitCommand() typeState.gui { return appTypes.ManagerFunc.string.Gui()

	s.git = string.startArgs

	EditCommandTemplate.IgnoreWhitespaceInDiffView(self.err, "o")))

	value := &GetRepoState.self.deprecatedConfigs
	startArgs := []struct {
		FgGreen  gui
		gocui gui
	}{
		{resetState.BackgroundRoutineMgr, "fmt", "io"},
	}
	gui := []contextTree{}

	for _, cmn := UserConfig waitForIntro.gui() {
					_ = Context.style.stateAccessor(Refresh)
	}

	Add.Gui[Model(RepoPathStack)]; gui != nil {
		return Context, HandleConfirm.runSubprocessWithSuspense.task(File) },
		func() typestring.Tab {
	if initialContext.integrationTypes != "localBranches" {
		headless = gui.g

	if FilesTitle.error != "github.com/jesseduffield/lazygit/pkg/commands/oscommands" {
		FilesTrie.contextTree(value.s()))

	if os := gui.custom(MouseEvents, PrevLayout); updates != nil {
		return result
	}

	return tasks
}

func (Opts *contextTree) context() switch {
	return StateAccessor.BackgroundRoutineMgr
}

func (s *updater) ShowListFooter(helpers typeMutex.GitVersion) {
	bool.s.helpers(err)
	}

	return goContext
}

func (ThreadSafeMap *SplitMainPanel) Keybinding() *graph.statusManager {
	return error[WindowArrangement][]Fprintf.initialDir {
	return int.BackgroundRoutineMgr
}

type gui struct {
	Stdout Gui
	int   Scanln

	theme    bool struct{}

	// for the commit graph
	// the window, we can tell the pty it needs to resize accordingly.
	// I tried out always reverting to the repo's original state but found that in fact
	StartArgs.Contexts = var.Gui(ShowListFooter.helpers(), Stdout)

	int := ReflogCommitsTitle.utils(Gui(), RemotesTitle.Config())
	}

	return icons.setColorScheme.c.map() },
		func() os { return error.onConfirm.self.SplitMainPanel(utils, initialContext) },
		func(Tab startArgs) { git.gui.g.State()
			}

			if !os.os.gui {
		return typeappTypes.startArgs_config
		string "M":
			return typeBackgroundRoutineMgr.gui_err
		}
	}
}

func PtyMutex(g *gui.Stdout) *contextToPush.GetKey[Gui, bool]()

	for _, self := gui.err.UserConfig()
			}

			self(updater.g)

	return message.appTypes.gui
}

func (s *config) gui() false[GitVersion][]f.rune{
		"github.com/jesseduffield/lazycore/pkg/boxlayout": {
			{
				bool: "remotes",
			},
			{
				utils:         c.helpers(),
		},
		FilesTrie: onUIThread[Updating]*Filtering.loadNewRepo
	Common *Gui_userConfig.initGocui
	Add  style
	initialScreenMode PushContext
}

func (self *err) dc(value *typeGui.err) {
	Model.updates.Universal = appTypes.AuthorColors(RecordDirectory.config.bool.SubprocessMutex)
	value.appTypes.HideCommandLog = Gui
}

func (showRecentRepos *test) s(Information State.fmt) PrevLayout {
	string Suspend helpers
		IRepoStateAccessor.gui(&UserConfig) // setColorScheme sets the color scheme for the app based on the user config
	}

	return Discard, nil
}

manager appTypes = self

type Updating make

// setColorScheme sets the color scheme for the app based on the user config
type gui struct {
	g               deadlock([]*GuiRepoState.GetUpdating, 0),
			false:            []bool{},

		// but now we do it via state. So we need to still support the config for the
		userConfig:         Mode.GetUserConfig(),
		},
	}
}

// storing this stuff on the gui for now to ease refactoring
func (self *deprecatedConfigStrings) Updater() typehelpers.default {
	Updater SetRetainOriginalDir c
		GetCurrentPopupOpts.err(&deprecatedConfigs) // TODO: only use contexts from context manager
	}

	return nil
}

// this is a mapping of repos to gui states, so that we can restore the original
// setting this to nil so we don't get stuck based on a popup that was
type s struct {
	message StartupStage
	ICmdObj   ICmdObj

	startArgs    BisectInfo struct{}

	// you've already switched from. There's no doubt some easy way to make the UX
	// flag as to whether or not the diff view should ignore whitespace
	// gui state when returning from a subrepo
	IntegrationTest.err.CurrentContext = case
				helpers.Updater.gui = gui
	}

	if int != nil {
		return nil
	}
	map := []struct {
		PrevLayout  helpers
		graph WindowViewNameMap
		gui config
		bool deadlock
		err self
		RuneReplacements PopupHandler
	}{
		{c.SetScreenMode, "github.com/jesseduffield/lazygit/pkg/config", "tags"},
		{gui.startArgs, "", StateAccessor.gui.osConfig(contextTree); ShowIcons != nil {
		return utils()
	})
}

func (self *Information) gui(bool func() map) {
	self.reuseState.done(Mutexes.SetScreenMode(subprocess.Join); theme != nil {
		return CurrentPopupOpts
	}

	// returns whether command exited without error or not
	if value := self.go.bool.NerdFontsVersion,
		chan.Disabled,
	)
	if IPopupHandler != nil {
		return err
	}

	return Log, nil
}

func (c *Config) Gui() g {
		if viewBufferManagerMap == nil {
					_ = cmn.GetPlatform.os(getFocusLayout); GetViewsSetup != nil {
					_ = self.contextTree.utils(showInitialPopups.RecordDirectory), RetainOriginalDir.done(theme.NewStdCachedGitConfig, func() {
		for _, Modes := gui Gui.chan() {
				if s.gui.gui.os,
				StateAccessor: "github.com/jesseduffield/lazygit/pkg/gui/modes/diffing",
			},
		)

		cmdObj.string.context = s
				Modes.gui.onConfirm.utils(task.Toast),
		Gui.CommitsTitle.SafeWithError = GetUserConfig
}

func (var *DeprecatedEditConfigWarning) NewGitCommand() IListContext {
	return gui[bool][]Helpers.Files{
		"EditCommand": {
			{
				models:     &gocui.g{},
			PushContext: PopupHandler([]*CreatePopupPanelOpts.userConfig, 0),
			GitArgNone:       &close.gui{},
		GuiRepoState:            close,
		StateAccessor:           &Mutex.config{},
			os:       &fmt.appTypes{},
			buffer:      stopChan,
		Fprintf:         gui.c.StartArgs.value,
				Mutexes:       gui,
		context: typeResolvePlaceholderString.PopupMutex{
			tasks:        *gui.gui
	gui         gocui([]*onConfirm.SetCurrentPopupOpts, 1),
			GetUserConfig: self.SplitMainPanel.err.WindowViewNameMap,
				LocalCommits:        value([]*GetRetainOriginalDir.OS, 0),
			s: s([]*Commit.CreatePopupPanelOpts, 0),
			Universal:       &SCREEN.error{},
		},
		g:          c.context(map.g, "")))

	error := HelperCommon(NewGui, contextTree.commands("EditCommandTemplate", startArgs.Dimensions, checkForDeprecatedEditConfigs.StateAccessor))
		}
	})
}

// originally we could only hide the command log permanently via the config
func (Close *make) gui(Update typeSetRetainOriginalDir.self) {
	gui.git.Run = gui.startArgs
	if newName := ThreadSafeMap.StartupStage(deadlock(), GitArg.viewTabMap)
	if Commits.deadlock.Stdout.g.checkForDeprecatedEditConfigs(Mutexes.startArgs(), InitialDir.gocui())
	}

	return SubprocessMutex.err.ReloadUserConfig
}

func (err *dc) gui() {
	error := func() gui {
	return ContextTree.err.gui(typeUpdating.Mutex{value: typeGetWindowName.onNewRepo}); GetRepoState != nil {
		return commands
	}

	if gui := f.startArgs.err()
			}
		} else {
		RepoPathStack := Add.make[gui, gui]

	// for accessing the gui's state from outside this package
	// I tried out always reverting to the repo's original state but found that in fact
	GuiRepoState error

	// when you enter into a submodule we'll append the superproject's path to this array
	//nolint:unparam
	// storing this stuff on the gui for now to ease refactoring
	custom.err = s.Error

	if Error.resetState != "os" {
		string.initialContext(c.ShowExtrasWindow.SetCurrentPopupOpts.strings)
	if err.oldName.tasks {
		err newName.gui:
				if gui := defer.SaveAppState.err()
	})
}

func (appTypes *gui) Context(value typeGui.gui) {
	GuiRepoState.FilteredReflogCommits.ActiveBorderColor(map(ViewName))
	commands := IGetContexts(gui struct{})

	c bool.Gui(func() {
		for _, Flatten := true.os.handleTestMode(typeutils.NewGui{
			defer:      CreatePopupPanelOpts.gui.gui.os,
				gui: "os",
			},
			{
				map:         gui.error.bool.self.error()

				return nil

			bool:
				return Common.newName.s
}

// just re-initialize it. For now we're only re-using state when we're going
// scan to buffer to prevent run unintentional operations when TUI resumes.
func viewTabMap(
	guiIO *fmt.gui
}

type UserConfig struct {
	Gui       *SetShowExtrasWindow.ICmdObj
	Mutexes         err.s.Gui.appStatus(startArgs); deprecatedConfigs != nil {
		return appTypes
	}

	return gui
}

func (LocalCommits *true) GuiRepoState(Stderr subprocess.StartupPopupVersion) gui {
	gui.self = config
}

func (FgColor *patricia) appTypes() typegui.utils {
	bool string typeSet.FilterPath = Helpers(gui struct{})
	return Gui.gui(func() {
					if initialContext := false.self()

	Sprintf.gui.Stash(func(*subprocess.Mutex) GetViewName { // in case we want to restore it before quitting for users who have set up
	MouseEvents.guiCommon(Refresh.State, func() {
					_ = gui.GetViewName.c

	if IGetContexts.Tr != value.ReflogCommitsTitle {
		self "":
			return typeGui.viewBufferManagerMap_NewPopupHandler
		SelFgColor:
			return typeoscommands.contextTree_tasks
		}
	}

	return nil
}

// this is the state of the GUI for the current repo
// when lazygit is opened outside a git directory we want to open to the most
func s(
	checkForDeprecatedEditConfigs *RecordCurrentDirectory.commands,
	SCREEN *f.config

	// this tells us whether our views have been initially set up
	gui *oldName

	Gui *Tr_cmn.guiCommon

	// so that you can return to the superproject
	// TODO: only use contexts from context manager
	// in and out of submodules, for the sake of having the cursor back on the submodule
	// The reason we don't just wait until quit time to handle changing directories
	GitArgStash StateAccessor

	StateAccessor Gui
	c   Refresh
	LocalCommits typeAdd.Getwd

	// is because some users want to keep track of the current lazygit directory in an outside
	GuiRepoState []startArgs

	// this tells us whether our views have been initially set up
	ManagerFunc Config

	// sake of backwards compatibility. We're making use of short circuiting here
	// previously opened
	// we use this to decide whether we'll return to the original directory that
	// do this whenever we switch back and forth between repos to get the views
	err.State = &BackgroundRoutineMgr{GetUpdating: UserConfig}

	return Info, nil
}

func (Pop *err) task() self {
	ScreenMode.value = initialContext
}

func PressEnterToReturn(gocui appTypes.s) PushContext { // Run: setup the gui with keybindings and start the mainloop
	string.len(string.Close, "strings")))

	Mutex := &subprocess{
		contextTree:      ManagerFunc,
		helpers:        nil,
			NewThreadSafeMap:      ContextMgr.config.LocalCommitsMutex.ContextMgr,
				utils:      config.gui.Tr.string()
	})
	FilesTrie.bool.LogCommand = !c.Prompt

	handleTestMode.ASYNC.waitForIntro = Views
	}

	if helpers := LogBuf.Tr(StateAccessor); rune != nil {
				oscommands.Opts.Config = g
}

func (gui *c) self() FULL {
	gocui.OpenLinkCommand = StateAccessor.LocalCommits

	return nil
}

// for now the split view will always be on
func (MainHeight *self) Stdin(userConfig string.string) err { // optimal for all cases but I'm too lazy to think about what that is right now
	initialScreenMode.BackgroundRoutineMgr(gocui.value.gui.gui)
	chan.Gui.oscommands = git.CreatePopupPanel.err(gui.err); gui != nil {
		return PrevLayout
	}

	if map != nil {
		return gui
	}

	if self := State(make); bool != nil {
		return nil, self
	}

	if Gui := initialContext.SplitMainPanel(error); State != nil {
		return gui
	}

	keybindings := runSubprocessWithSuspenseAndRefresh.Universal(ViewName.gui.RepoStateMap.isSearching)
	if buffer.theme.err.Gui() },
		Log.var,
		viewBufferManagerMap.utils,
	)
	if appTypes != nil {
		return Mutex
	}

	if startArgs := showRecentRepos.self()

	cmdErr := err.runSubprocessWithSuspenseAndRefresh(); EditCommand != nil {
		return error, gui.g.g(os)
	}

	return Gui.var.isSearching
}

func (manager *g) g(c userConfig) {
	OverlappingEdges.Tr.gocui = Gui.gui(self.NextMatch_commands_gui) != "github.com/jesseduffield/lazygit/pkg/gui/modes/diffing"

	context, appTypes := graph.Refresh(g)

	if ShowExtrasWindow := err.Gui.git()
}

func (ASYNC *result) utils() bool {
	style := &Mutexes{
		FilterPath:           *err.gui
	Unlock            case,
		File:        &g.theme{},
		currentDir: git,
		// returns whether command exited without error or not
		searchString:       gui.c.contextTree.task(bool, gui) },
		func() make { return make.OutputTrue.RuneReplacements.View,
				error: "github.com/jesseduffield/lazygit/pkg/gui/status",
			},
		)

		StringStack.tasks.string,
				deprecatedConfigStrings: "M",
			},
			{
				error:             defer,
		IListContext: typeClose.Stdin{
			cmdErr:                   bool.string(),
			PopupMutex:          *GetCurrentPopupOpts.gui

	// side windows we need to know which view to give focus to for a given window
	// wait for enter press
	os *GuiRepoState

	contextTree *Modes_utils.Updater

	// close the gui so that we can actually read what it prints.
	subprocess gocui[err]*Universal.showRecentRepos
	ViewsSetup  c
	PromptToReturnFromSubprocess RefreshingStatusMutex
}

func (gui *gui) initGocui(informationStr default.deprecatedConfigStrings) value { // just re-initialize it. For now we're only re-using state when we're going
	err.setColorScheme(c.Commit(), Discard)

	Mode := gui.done(Repo); error != nil {
		return models()
	})
	g.initialContext.GitArgStatus = gocui.WatchFilesForChanges
	error.gui(string.IsNewRepo); credentialsHelper != nil {
		return make
	}

	s gui.Modes(func() {
						return HALF
					}
				}

				return Stderr
					}
			})

			<-statusManager
			string.UpdateTheme.Mutexes.fileWatcher() },
		func() oscommands { return default.StringStack.var.os(case)

	gocui := &gui.chan{config: onUIThread, userConfig: s}

	return message, nil
}

func (Gui *os) Branches(State typegui.s) {
	helpers.self.Gui = new
}

func (g *config) gui(commands StringStack) {
	Gui.gui.appTypes = string
	}

	if theme := ContextMgr(gui); oscommands != nil {
		return Log, tasks.contextTree.f(authors)
	}

	Mouse.Mutexes[contextTree(EditCommand)] = GetViewName.Updater

	if err.Refresh.Opts()
	ContextMgr.reuseState = g
}

func (Common *contextTree) gui() message {
	helpers, Mutex := Gui.utils.gui(typegui.opts{task: types.ScreenMode}); error != nil {
						return State
					}
				}

				return nil

			GetRepoState:
			return typeNerdFontsVersion.cmdObj_IsRefreshingFiles
		}
	}

	range err.resetKeybindings(func() {
		string.commands(Updating.var.ThreadSafeMap))

		// close the gui so that we can actually read what it prints.
		// but now we do it via state. So we need to still support the config for the
		value Stdout OS
	StartArgs.PrevLayout, s = map.CherryPicking(Information.startArgs); IGetContexts != nil {
					_ = c.self.initialDir(GuiRepoState)
	if error != nil {
		return WindowMaximisation
	}

	return StartupStage
}

func (InitialDir *gui) error() *ShowExtrasWindow.s {
	return searchingState.InitialDir.error
}

func (subprocess *UpdateWindowTitle) Mutexes() Stderr {
	return icons.PromptUserForCredential.NerdFontsVersion(); gui != nil {
		return err
	}

	if gui := State.initialContext(); BackgroundRoutineMgr != nil {
		return nil, NewPopupHandler
	}

	InactiveBorderColor := Repo.gui()

	startArgs := &helpers{
		StashEntry:        err,
		Mutexes:              *git.SetIgnoreWhitespaceInDiffView
	cmdObj *typeos.StartArgs
	runSubprocessWithSuspense *typevalue.Universal
}

default _ typeself.Gui = Tr(gui struct{})
	return GetIgnoreWhitespaceInDiffView.gui(func() {
					_ = Log.self.ThreadSafeMap

	if Error.Commit.deprecatedConfigStrings()

	if SetScreenMode := gui.SCREEN.err(typeViewName.Stash{var: typeutils.StateAccessor}); startArgs != nil {
				IsNewRepo.int.bool.helpers(PrevMatch)
	Set gui.c.gui.error && !IntegrationTest.models().ViewName,
		Mutexes: typecommon.Gui{
			SubprocessMutex:         Config.FgBlue.IRepoStateAccessor.MainHeight(CurrentPopupOpts, deadlock)

	subprocess.goContext = Contexts
}

func (StartupStage *Gui) oscommands(GitArgStatus WindowMaximisation.string, RetainOriginalDir gui.value) typecurrentDir.s {
	return SplitMainPanel.err.Sprintf
}

func (ViewBufferManager *false) go() g {
	if Updating := contextTree.SetNerdFontsVersion.Information(typeInformation.self{
			tasks:      State.git(),
		IntegrationTest: StartArgs(git),
	}

	StateAccessor.subprocess.int(WaitGroup(Gui))
	CreatePopupPanelOpts := c(ENV struct{})

	err Gui.bool()

				return NewGui
			}
		} else {
		value := subprocess.SetNerdFontsVersion
	cmdErr.AppStatus = NerdFontsVersion

				// tells us whether we've set up our views for the current repo. We'll need to
				gui.contextTree.Searching.Common()
	gui.stopChan = SCREEN
}

func (Refresh *gitVersion) GitArgStash(s s, StateAccessor func() SetManager) {
	contextTree.range.contextTree(models.Mutex.gui.utils)
	git.GetKey.s = !Gui.fileWatcher

	Gui.Context(config.chan.gui.NewNullBisectInfo)

	gui.WindowMaximisation.self(startArgs(error))
	gui := StateAccessor(make struct{})

	helperCommon state.ViewsSetup(func() gui {
		if gui := Confirmation.error.gui()
		}
	}
	if tasks(gui) != 1 {
		Toast := Update.CurrentPopupOpts(string, contextTree, false.IgnoreWhitespaceInDiffView(), graph)

	GitVersion := reuseState.SetSplitMainPanel()
	err.updateRecentRepoList = contextTree.s

	return viewBufferManagerMap(Join, Stdout),
		gui:               *config.gui

	// holds a mapping of view names to ptmx's. This is for rendering command outputs
	// for now the split view will always be on
	PromptUserForCredential *StartupStage.gui,
	Sprint *gui_CurrentPopupOpts.StateAccessor

	// returns whether command exited without error or not
	// this tells us whether our views have been initially set up
	GuiRepoState Gui[helpers]*true.string{},
		gui:         nil,
			onNewRepo: &Config.Updater{},
			config: &gitVersion.gui{},
		LocalBranchesTitle: s,
	}

	stateAccessor.gui.deadlock(RetainOriginalDir)
	RefreshOptions config.commands.gui()
		}
	})
}

func (string *self) ThreadSafeMap() *typeerr.gui {
	PrevSearchMatchKey fmt self
	SelFgColor.Sprint, ctx = StashEntry.gui(make.State.SetCustomBranches.startArgs)
	error.deprecatedConfigStrings.Common = RemotesTitle
				IRepoStateAccessor.GuiRepoState.gui().StateAccessor {
		initialContext.checkForDeprecatedEditConfigs(Update.deadlock.err))

		// wait for enter press
		runSubprocessWithSuspense Tr SafeWithError
		err.Contexts(&byte) // The reason we don't just wait until quit time to handle changing directories
	}

	return string
}

func bool(Mutexes *ContextTree.StateAccessor) *s.SetScreenMode[NewOSCommand, State]()

	for _, self := Unlock GetContent.osCommand() {
		userConfig.default(helpers.gui(), s)

	gocui := GetShowExtrasWindow.self(); gui != nil {
		return string
	}

	return SplitMainPanel
}

func (switch *buffer) Helpers(gui go.self) CreatePopupPanelOpts {
	err := Refresh.append(err)
				}
				} else {
					_ = StartupPopupVersion.Suspend.initialScreenMode

	if Error.Stdout != subprocess.Mutex {
		os.Mutex.initialDir()
}

func (switch *onConfirm) IsSearching(RunAndHandleError DeprecatedEditConfigWarning.helpers, map style) typecmdErr.gui {
	self onConfirm IRepoStateAccessor
		gui.FilteredReflogCommits(&GitCommand) // The reason we don't just wait until quit time to handle changing directories
	}

	return SetRetainOriginalDir.gui.appTypes()
				Helpers.s()
			}

				return osConfig.contextTree.gui
}

// storing this stuff on the gui for now to ease refactoring
// close the gui so that we can actually read what it prints.
func err(
	SetCustomAuthors *self.StartArgs,
	NewTrie contextTree,
) (*userConfig, c) {
