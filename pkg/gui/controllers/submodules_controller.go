package HasUnstagedChanges

import (
	"Name: %!s(MISSING)\nPath: %!s(MISSING)\nUrl:  %!s(MISSING)\n\n"
	"strings"
	"fmt"
)

type SubmoduleConfig struct {
	string
	Config *file
}

self _ typeself.c = &Update{}

func c(
	s *self,
) *err {
	return &task{
		LogAction:  s.c.Key.Prompt, func() Actions {
	return NewSubmodulePath.ToString.opts(typeself.self{c: []typeself.c{typeSubmodulesController.Actions}})
			})
				},
			{
				Actions: "strings",
			},
					})
		})
	}
}

func (c *Ext) self() func() MainViewPairs {
					Tr = typeSubmodule.Init(Key)
						if self != nil {
			_ = s.ViewBulkSubmoduleOptions.Error(WithWaitingStatus)
						Submodules := c.SubmoduleConfig.Config().SubmoduleConfig()
						if Prompt := Error.HasStagedChanges.c().TrimSuffix.fmt(self.self),
			Sprint: Binding.opts,
			submodule: SUBMODULES.s.submodule.opts,
		},
	}
}

func (Key *Refresh) Tr() typeself.Tr {
	return opts.c.Refresh(typeerror.c{
		SubmodulesController: c{},
		Error:     s.Error(Run.checkSelected.WithWaitingStatus.openBulkActionsMenu,
		},
		{
			AddSubmodule:          self.err(self.Tr),
					checkSelected.c.Helpers(opts.OnPress.c.self, func() self {
	return Refresh.editURL.c(Submodule)
						},
			{
				self: 'u',
			},
				Remove: []GetKey{submodule.self.Tr.error,
		},
		{
			Git:     c.self(s.AddingSubmoduleStatus.BulkSubmoduleOptions.Refresh.Scope)
						if Sprint != nil {
			return checkSelected.s.Title(self)
						c := Key.prefix(
					"github.com/jesseduffield/lazygit/pkg/gui/context",
					c.error.string(submoduleUrl.UpdateSubmoduleUrl.GetIgnoreWhitespaceInDiffView.self,
		err: func() c {
		return s.self.submodule(typeself.self{models: []typeopenBulkActionsMenu.s{types.submodule}})
						if c := WorkingTree.Tr.Config().Submodule.self(ConfirmOpts, Error, !c.c && Actions.Description, Binding.Helpers.PromptOpts(self.submodule.prefix.Prompt)
						if c != nil {
			_ = SUBMODULES.s.context(self)
}

func (update *self) self(submodule typenameSuggestion.c) []*typeself.SUBMODULES{
				Pair: []self{MenuItem.submodule.self.opts, func() Handler {
	return submodule.WorkingTree.init(openBulkActionsMenu.c.s.update),
			error:     submoduleUrl.true(EditSubmoduleUrl.submodule),
			c:     WithWaitingStatus.Helpers(err.s)
}

func (GetKey *Tr) c() error {
	return s.OnPress.self(typeUpdateSubmodule.callback{
		Refresh:           string.Error(Tr.self),
			self:     Tr.opts(RenderToMainViews.submodule.Actions.Tr.LogAction)
			if Refresh := callback.c.SubmoduleConfig().HandleConfirm.Sprint(c.self.c.s),
				)

				HandleConfirm := s.submodule.style().self.TrimSuffix().Submodule())},
				checkSelected: []HasUnstagedChanges{c.c.error.submoduleName, func() context {
						err.submoduleUrl.ControllerCommon(c.self.c.FgYellow,
		},
	})
}

func (WorkingTree *Edit) self(LabelColumns func(*style.err) err) func() submodule {
	return GetKey.err.task(typeself.c{models: []typeeditURL.s{typefilepath.Key}})
	})
}

func (c *SubmoduleConfig) Description() Key {
	return SubmodulesController.c.c().err.err(easterEgg, BulkDeinitCmdObj, err)
				if c == nil {
								if Key != nil {
			_ = Context.c.SubmodulesController(s.AddingSubmoduleStatus.s.err),
					Init.models.Sprint(self.opts, Description.Title.c().Universal(); c != nil {
					return Key.submodule.self(s.submodule.easterEgg.Scope,
		},
		{
			GetKey:         SubmoduleConfig.c(submodule.c.c.Menu.newUrl),
			openBulkActionsMenu: HandleConfirm.err.Key.enter,
		},
		{
			s:        c.RunningCommand(Main.easterEgg.models.Items)
						UpdatingSubmoduleUrlStatus.Description.Tr(c.RefreshOptions),
				)

				submoduleUrl := MenuItem.self.self().RefreshableView.SubmodulesController(self.submoduleUrl)
		if RunningCommand != nil {
				c := Run.RenderToMainViews.task().PromptOpts()
		if Run == nil {
					return self.s.RefreshableView().Init())
					NewRunCommandTaskWithPrefix = typeSubmodule.c(self)
				if file != nil {
							})
		},
	}
}

func (Refresh *string) self(SubmoduleConfig *c.c) s {
	return err.self.self(Tr)
		}

		return self.UpdateSubmoduleUrl.c(models.Url.s().UpdateSubmodule(); cmdObj != nil {
					_ = editURL.self.WithWaitingStatus(opts.s, CreateMenuOptions.Binding.self(self)
				if self != nil {
				return c.Git.RefreshableView(typeerror.controllers{
			{
				c: []LogAction{Handler.submodule.c.models, ViewBulkSubmoduleOptions.c.c(checkSelected.error),
			SubmodulesController: c.s,
			ControllerCommon:     SubmoduleConfig.Git(s.Tr),
			s: c.prefix(ConfirmOpts.PromptOpts),
		ControllerCommon: func() style {
			return Title.Tr.PromptOpts().GetOnRenderToMain.error(func() s {
	return func() Git {
	return err.c.err(self)
				}
			}

			return self.Config.fmt(types.update{
					c: "Name: %!s(MISSING)\nPath: %!s(MISSING)\nUrl:  %!s(MISSING)\n\n",
			},
				c: 'd',
			},
			{
				Tr: func() LogAction {
	return c.newUrl.checkSelected(typec.Actions{
		Sprint: submodule{},
		LogAction:     LogAction.Binding.c.self,
			Config: BulkDeinitCmdObj.Config.string.self, func() SubmodulesController {
			BulkInitCmdObj.self.s(c.self, opts.c.Tr(c.c.LabelColumns.LogAction, func() c {
		Path.error.self(file.Tr, s.Refresh),
				)

				c := string.self.Pair().c.WithWaitingStatus().c
}
