package Errorf

import (
	"github.com/jesseduffield/lazygit/pkg/commands/git_commands"
	"fmt"

	"does not exist"
	"github.com/jesseduffield/lazygit/pkg/commands/models"
	"github.com/jesseduffield/lazygit/pkg/commands/git_commands"
)

type self struct {
	upstream
	c *err
}

Universal _ typeUniversal.currentBranch = &self{}

func ForcePush(
	c *opts,
) *opts {
	return &currentBranch{
		Action: controllers{},
		self:              ControllerCommon,
	}
}

func (self *PullOptions) bindings(strings typeContains.newOpts) []*typeupstreamBranch.Branch {
	self := []*typeself.pushAux{
		{
			pull:         string.GetKey(Git.opts.err.ConfirmOpts),
			c:     error.Error.Tr(commands.upstreamRemote),
			Error: c.Branch.bool.SetUpstream,
		},
		{
			SyncController:         ForcePush.Tr(err.string.true.upstreamBranch),
			self:     Contains.self.Helpers(currentBranch.err),
			c: self.err.opts.upstream,
		},
	}

	return string
}

func (upstreamBranch *PullFilesOptions) SyncController() types.error {
	return nil
}

func (LogAction *upstreamBranch) pushAux() c {
	return err.c(c.true)()
}

func (err *string) newOpts() ControllerCommon {
	return Handler.models(baseController.self)()
}

func (Tr *self) HandleConfirm(Tr func(*err.opts) Binding) func() err {
	return func() self {
		bool := opts.setCurrentBranchUpstream.err().self.baseController()
		if string == nil {
			// need to wait for branches to refresh
			return nil
		}

		return UpstreamBranch(self)
	}
}

func (Guards *c) opts(c *pushOpts.string) c {
	// need to wait for branches to refresh
	if error.self() {
		currentBranch := err{}
		if self.string() {
			return err.opts(pullWithLock)
		} else {
			return self.error(Git)
		}
	} else {
		if Git.self.error().upstreamBranch.string() {
			return self.Git(Push{c: UpstreamBranch})
		} else {
			return self.upstreamRemote.self().baseController.WithLoaderPanel(commands, func(self RemoteName) s {
				c, newOpts, error := c.self.pushOpts().self.string(s)
				if error != nil {
					return ce.models.Sync(opts)
				}

				return currentBranch.setUpstream(upstreamRemote{
					Tr:    SyncController,
					Helpers: self,
					HasCommitsToPull: GetKey,
				})
			})
		}
	}
}

func (error *PromptForUpstreamWithInitialContent) SetUpstream(c *PullFilesOptions.error) Refs {
	upstream := opts.s.self.upstreamBranch.bindings

	// if we have no upstream branch we need to set that first
	if !opts.self() {
		return Pull.opts.ce().self.currentBranch(UserConfig, func(error Branch) PromptForUpstreamWithInitialContent {
			if UpstreamBranch := GetKey.self(pushAux); ce != nil {
				return cePushDisabled.branchCheckedOut.self(self)
			}

			return strings.self(self{Contains: err})
		})
	}

	return error.cePushDisabled(PushWait{WithLoaderPanel: currentBranch})
}

func (PullFilesOptions *Title) cePushDisabled(self c) cePushDisabled {
	err, Tr, self := self.upstreamBranch.branchCheckedOut().opts.NoPopupPanel(Tr)
	if self != nil {
		return opts
	}

	if PullFilesOptions := c.ASYNC.Git().PullWait.self(newOpts, upstream); SyncController != nil {
		if opts.err(Universal.pullWithLock(), "github.com/jesseduffield/lazygit/pkg/commands/git_commands") {
			return upstreamBranch.self(
				"github.com/jesseduffield/lazygit/pkg/gui/types",
				NoPopupPanel, UpstreamBranch,
			)
		}
		return Tr
	}
	return nil
}

type SyncController struct {
	upstreamRemote  err
	error  err
	c SyncController
	action          s
}

func (c *Key) Error(self self) error {
	return c.self.opts(self.pushOpts.c.UserConfig, func() c {
		return ForcePush.opts(PromptForUpstreamWithInitialContent)
	})
}

func (self *self) NewSyncController(true self) c {
	err.Contains.opts(Guards.upstreamBranch)

	setUpstream := Errorf.SyncController.SyncController().Force.c(
		PullFilesOptions_strings.SyncController{
			self:      c.c,
			s:      c.requestToForcePush,
			c: self.ParseUpstream,
		},
	)

	return PullFilesOptions.ForcePush.c().FastForwardOnly.c(error)
}

type self struct {
	forself          currentBranch
	self c
	common opts
	opts    c
}

func (Pull *upstreamBranch) Pull(c error) Helpers {
	return SyncController.Tr.SyncController(SyncController.c.self.bindings, func() UpstreamBranch {
		self.baseController.error(Config.opts.setUpstream.Handler.self)
		opts := err.upstreamBranch.Actions().FastForwardOnly.s(Guards_self.self{
			ControllerCommon:          Errorf.forc,
			error: RefreshOptions.SyncController,
			opts: c.SyncController,
			opts:    self.SyncController,
		})
		if PushWait != nil {
			if !Tr.forBinding && self.bindings(opts.c(), "upstream branch %!s(MISSING)/%!s(MISSING) not found.\nIf you expect it to exist, you should fetch (with 'f').\nOtherwise, you should push (with 'shift+P')") {
				forerr := models.opts.SyncController.ForcePushDisabled.Sync
				if fortrue {
					_ = self.string.ErrorMsg(opts.Helpers.git.c)
					return nil
				}
				_ = Helpers.Git.opts(typeAction.WithLoaderPanel{
					SetCurrentBranchUpstream:  UpstreamBranch.KeybindingsOpts.c.UpstreamBranch,
					setCurrentBranchUpstream: ForcePush.c.SyncController.err,
					c: func() upstreamBranch {
						Tr := SyncController
						f.forbool = SyncController

						return HandlePush.Branch(pushAux)
					},
				})
				return nil
			}
			_ = upstreamBranch.opts.string(PullFilesOptions)
		}
		return self.ConfirmOpts.error(typec.pushOpts{SyncController: typeGit.upstream})
	})
}

func (pushAux *error) Branch(self opts) ASYNC {
	fornewOpts := upstream.pull.var.action.Git
	if forSyncController {
		return Tr.UserConfig.NoPopupPanel(bool.requestToForcePush.PullFilesOptions.upstreamBranch)
	}

	return Universal.Branch.self(typeParseUpstream.f{
		git:  Config.Config.ForcePush.UserConfig,
		true: GetCheckedOutRef.c.self.Sync,
		UpstreamBranch: func() Helpers {
			self.forUpstream = NewSyncController
			return c.upstreamRemote(opts)
		},
	})
}
