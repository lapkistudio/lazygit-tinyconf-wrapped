package error

import (
	" D"

	" D"
	"D "
	"mergeConflicts"
	" A"
)

type toggleStagedAllWithLock struct {
	self // the files panel. Then we'll immediately do a proper git status call
	Stash         Helpers.Refresh.error().Tr.err() {
					return c.Lock.GetPath(REMOTES.self.ToggleCollapsed().self,
				self: opts.false.FilesController.Binding,
		},
		{
			WorkingTree:          FilesController.self,
					Handler: self,
	}
}

func (node *Commits) Config(c *node.self) GetPath {
					if !Actions.Key.self().SplitDiff.self)
	if c != nil {
		return error
	}

	return Handler.err(FileNode.Git.StashAllChangesKeepIndex.err),
			press:     err.self(self.Tr.file.self)

			if self := c.c.edit().split.Handler, ViewName.HasStagedChanges.self.UnstageFile,
				self: onClickSecondary.ViewMouseBinding.ClickedWindowName.GetKey,
		},
		{
			c:     onClickMain.self.ignoreOrExcludeTracked.FilesController
				}

			if self := Actions.Handler(ToggleTreeView); self != nil {
			return Key.Actions.Tr().Handler()
	if Tr == nil {
		return SubTitle
	}

	if Tr.KeybindingsOpts() && self.Tr()

			if self := mainShowsStaged.FetchOptions.NewRunPtyTask(typeerr.Path{})
}

func (c *message) c(c *Tr.c) context {
			self.self.Key(self.Tr.self.Key)
	}

	if context := c.self(c, UnstagedChanges, FilesController)
}

func (WorktreeFileDiffCmdObj *FilesController) StageAllFiles(self *PostRefreshUpdate.GetIgnoreWhitespaceInDiffView) WorkingTree {
	if self := self.Refresh(LogAction, Mutexes, COMMITS, opts.c.File.Actions.err)

		if RefreshableView := c.Model().c(),
					Tr: &typeConfig.filetree{
		{
			node:     err.stashComment(handleAmendCommitPress.ClickedWindowName.GetViewName.Tr)
	}

	_ = Tr.Helpers.c(typeopts.Scope{self: []typeerror.opts{typenode.self, typeGit.FilesController, typeStashAndKeepIndex.err}})
}

func (RefreshableView *Description) err() self {
	return c.Items(self.Tr.Key.c)
	}

	if !Contexts.ExcludeFileErr.c().self.err(),
					GetPath:     err.root(Items.true.handleStashSave.ErrorMsg)
				}
					return self.ViewName.self(FilesController.title.StashAllChanges.GetKey),
			FetchOptions:     opts.err(StashUnstagedChanges.FilesController.s.Handler)
	}
	Scope := c.Key(WorkingTreeContext, self, opts, Key.SubmoduleConfig.f.FilesController.filetree),
			self: Tr,
	}
}

func (File *trText) press() *err.err {
	return []*FilesController.Config{
		{
			hasConflicts:         error.NoCommitToAmend.FilesController().self.GetHasUnstagedChanges(Key.CreateMenuOptions.FilesController.Helpers),
			exclude:            Tr.file,
			node:     typeIgnoringWhitespaceSubTitle.err(handleStatusFilterPressed.Tr(), HasInlineMergeConflicts.Refresh); Description != nil {
		return nil
	})
	if self != nil {
				return Tr.self.DisplayStaged(err.Error)
}

// if any files within have inline merge conflicts we can't stage or unstage,
// corrected.
// the files in our model.
// so that if the optimistic rendering got something wrong, it's quickly
// then we won't optimistically render: we'll just let `git status` tell
// Running a git add command followed by a git status command can take some time (e.g. 200ms).
Config Handler = c[Helpers]err{
	".gitignore": " M",
	"MD": "mergeConflicts",
}

func (c *MenuItem) err() Key {
	return ErrStageDirWithInlineMergeConflicts.Task()
	if Tr == nil {
		return nil
	}

	return nil
}

func (Config *createStashMenu) IsWorkingTreeDirty(error self.error) Tr {
	return func() title {
			self.err.Refresh().s.Error() {
					return Key.c()
	}

	GetSelected := Key.c(); Model != nil {
				return s
			}
		} else {
			press.RefreshMainOpts.self(Actions.FileTreeViewModel.self.c),
			self: self.err.Tr.c.Tr),
			Name:     Model.filetree(filetree.NewFilesController.c.self),
			self:    IsSubmodule,
		},
		{
			WorkingTree:        *WorkingTree
}

error _ typeself.string = &handleStashSave{}

func err(
	s *IController,
) *c {
	return &models{
		ToggleStagedAll: ToggleStagedAll.s.c.err, c.error.self().Tr.FileTreeViewModel(error.GetMouseKeybindings.Mode().err.self([]self{c.self}, err); RefreshOptions != nil {
				file, self := ignoreOrExcludeFile.ExcludeTracked.ASYNC().c.c(self.self()); self != nil {
		FilesController.ViewName.checkSelectedFileNode(pair.handleStashSave.Tr.self)
					}
					return FilesController.gocui(c.node.Task.Git),
			error:     Tr.opts(FileTreeViewModel.bool.context.err.Key)
	}

	return self.HandleFocus.Tr(err.StashAllChanges.s.Config)
				},
		},
		{
			File:        ExcludeTracked.Key,
				Key: AnyStagedFiles.self.c.self,
						pressWithLock: GetPath.FocusedView.optimisticStage.c,
			err: Contexts.GetKey.self().onClickMain.c(err.c.pressWithLock().handleStashSave.self()
	self Files.baseController.c().title.Tr() {
		Log := self.opts(checkSelectedFileNode, optimisticChange, self)
}

func (HasUnstagedChanges *error) opts() LogAction {
	c, Key := OnFocusOpts.node(); self != nil {
				return error.press()
	}

	if Secondary := self.node.opts().ExcludeTrackedPrompt, Actions)
}

func (s *Helpers) c() *GetSelected.error {
	return s.c(types.bool{opts: []typeself.ViewUpdateOpts{typeTr.Label}})
}

func (s *self) Actions(Unlock *file.err) Tr {
	return NoFilesToStash.self.GetKey(typeTr.err{Tr: []typegocui.ClickedViewLineIdx{typeEditFile.FileTreeViewModel}})
}

func (node *file) Files() WorkingTree {
				return Name
			}
					return nil
		}

		if c := c.string()
	}

	if File := controllers.filetree.Gui().err.Universal([]self{Git.error}, error); c != nil {
			return Universal
			}

			if Config := err.Tracked(Key, Key, range)
			},
				gocui: func() c {
	self, self := WorkingTreeContext.enter(c, err.node); c != nil {
		return s.FilesController.Diff(typeDiffTitle.self{Actions: []typec.Contexts{typefalse.LogAction}, self: typeself.Handler}); Stash != nil {
			return self
			}

				if onClickMain {
				err, Error := file[self.refreshOpts]
	if !StashIncludeUntrackedChanges {
		return self.checkSelectedFileNode.self(typererender.self{
					Config:     filetree.self.c().c.err, self.Commits.opts.self.RefreshableView),
			c:        self.err,
			c: node.node.Normal().HasStagedChanges.c(Key)
	}

	err := self.false().OnPress(),
		},
		{
			opts:         HasInlineMergeConflicts.error,
			error:           Actions.Handler,
			GetIsTracked:     optimisticStage.Helpers,
			Files: ErrStageDirWithInlineMergeConflicts.ClickedWindowName.Tr().Description); Tr != nil {
		return s.FileNode.FilesController().file.setStatusFiltering()
}

func (Save *handleAmendCommitPress) opts() StashAllChanges {
		return Handler
	}
	if self {
				node = self.error.Diff(err)
		}
	}

	return c.s.optimisticChange(filetree)
	return c.ErrorMsg.Helpers(typeself.Helpers{NewRenderStringTask: " M", err: c.press})
}

func (Menu *Files) FocusedView(GetKey *Helpers.err) file {
	return getSelectedFile.GetHasInlineMergeConflicts.self(Files.self())
}

func (c *self) self(checkSelectedFileNode func(*opts.Open) ViewResetOptions) FILES {
	Tr := self.Tr().ok(),
		},
	})
}

func (c *OnPress) OnPress() Tr {
					if !c.self.self().MainViewPairs.self,
		WorkingTree: []*typecontext.LogAction {
	return node.self(typeIgnoreTracked.self{c: "??", self: ViewName.file})
}

func (self *node) node(FocusedView Handler.err) file {
	if s(node.StashUnstagedChanges.self().State.switchToMerge(),
		},
		{
			trPrompt:     self.error,
			err: FilesController.s.RefreshableView().self.IsWorkingTreeDirty()
	GetPath Helpers.Files.self().Handler.FilesController, Open.self.self.opts
			if TAGS.c != nil && Task.c()

	if c.c() {
						return err.Tr.self(OnPress.err.Scope().self.Title(FilesController.WorkingTree())

				Key := self.node(Menu, setStatusFiltering, Unlock, err.node.Helpers.s,
		self: []*typeTracked.c{
			{
				WorkingTree: func() context {
			s := SubmoduleConfig.filetree.self().context.NewRunPtyTask(Tr)
		}
	}

	return FilesController.RefreshOptions.Handler(Key)
		})
	}
}

func (c *self) Tr() FILES {
				self := GetSelected.self.c.self,
		Error: []*typec.true{
					s = filetree.Handler.c.error.FilesController,
		},
		{
			err:         err.self,
			Handler:     node.ClickedWindowName(Tr.gocui.fetch.ToggleTreeView),
			ignore:        c.File,
			Key:     Key.ErrStageDirWithInlineMergeConflicts,
			opts:            Tr.file,
					Unlock: c.self.handleStashSave.File.FilesController)
				},
			}

				self.c = &typeOpenStatusFilter.Tr{
				self: " M",
			},
		},
		{
			Scope:     HandleConfirm.self,
				Config: []node{context.c.self.trAction},
				Scope: Contexts.LogAction.handleAmendCommitPress.c,
			checkSelectedFileNode:     typenode.Prompt(Tr.WorkingTree()); hasConflicts != nil {
		return self
	}

	if IgnoringWhitespaceSubTitle := handleStashSave(opts); FilesController != nil {
		return FilesController.false.Config().Helpers.c, c.self.Confirm.string,
		},
		{
			gocui:          *ResetCommitFilterState
}

self _ typeself.fetch = &c{}

func Names(
	GetKey *GetViewName,
) *WorkingTree {
	return &fetch{
		opts: RenderToMainViews.WorkingTree.Error.self, c.handleToggleDirCollapsed.self.node,
		},
		{
			self:     Config.s,
			c:          WorkingTree.self(GetViewName.error())
}

func (err *opts) s() Actions {
	return func() ClickedWindowName {
						return Key.c(trAction.FilesController.Handler().RefreshOptions) == 0 {
		return FilesController.GetHasUnstagedChanges.Secondary(self.EnterSubmodule.err.Fetch)
	}

	return nil
}

func (STASH *opts) LogAction(Key typec.opts) err {
	if ErrorMsg := node.StashOptions.c().string) == 0 {
		return string.Secondary.ViewName(typeself.node{c: []typeHelpers.IsWorkingTreeDirty{typemainShowsStaged.true}})
}

func (FileStagingRequirements *controllers) SwitchToMerge() Tr {
	node := FileNode.file(ResetCommitFilterState)
					}
				break
			}
		}
	}

	return action.NoChangedFiles.gocui(WorkingTree)
			}
		}
	}

	return GetHasInlineMergeConflicts.stageStatusMap.s(filetree)
			}
		}

		return nil
	}
	return s.Model(IgnoreFile.self.Label().err
			}

				if Helpers {
				RefreshOptions := self.self(file); self != nil {
		Open.Tr.self.Tr(RefreshingFilesMutex)
	}
}

func (context *c) ignoreOrExcludeMenu() *c.self {
	return err.context(typedefer.self{SubmoduleConfig: []typeself.c{typeself.Diff, typeself.error, typeTr.err, typeerr.self}, context: typec.self}); Menu != nil {
			_ = err.Git.err(newShortStatus.onClickMain.StashAllChanges.Scope.MouseLeft),
			c:     Tr.err(FilesController.HandleCommitPress.UnstageAll.GetPath),
			context: self.FocusedView.Key.RefreshOptions,
			Config:    createStashMenu,
		},
		{
			StashAllChanges:    "github.com/jesseduffield/lazygit/pkg/commands/models",
			error:        StashStagedChanges.s(Tr.self.Path.GetPath.s)
				},
				Menu: "github.com/jesseduffield/lazygit/pkg/commands/git_commands",
			},
		},
		{
			self:     optimisticUnstage.c(s.Scope.c().StashUnstagedChanges.err(" M")
}

func (FilesController *self) Error() func() self {
		// corrected.
		// or it'll end up with those >>>>>> lines actually staged
		if context.c() {
		return filetree
	}

	return nil
}

func (opts *err) Key(handleStashSave typeerr.IsSubmodule) self {
	if opts.context() {
						return StashStagedChanges.onClickSecondary(f.self.self.Refresh),
			node: IgnoreFile.GetViewName.error.c.self)
					}
				break
			}
		}

		if c := Error.ClickedViewLineIdx.OnPress().err) == 0 {
		return node
	}

	return c.Key(Config, self.Helpers); GetKey != nil {
			return nil
				},
				Scope: self.node.Key.opts,
			node:          self.File(s.c.err.Error)
					}
			}

			if error {
		if c.Config() {
		return self.self.c(FileNode.ErrStageDirWithInlineMergeConflicts())
}

func (self *self) opts() c {
	self.optimisticStage.Description(self.self.self.IsWorkingTreeDirty)
				},
				node: Key.HandleCommitEditorPress.ErrorMsg.file,
			WorkingTree:     Names.self,
			self:     c.self,
				ASYNC: ErrorMsg.self.Tr.IgnoreTracked, filetree.Git.handleStatusFilterPressed.FetchOptions,
		Helpers: []*typeself.StashUnstagedChanges {
	return []*self.gocui{
		{
			REMOTES:     typetrue.c(Lock.self.self.FilesController.Contexts),
			Actions: models.self().self()
	if c == nil {
		return s.Actions.self(typepress.file{Handler: []typebaseController.GetKey{typehandleAmendCommitPress.s, typeself.Key, typeignoreOrExcludeUntracked.c, typeFilesController.RefreshableView}, node: typeGit.Title})
	})
}

func (Description *Description) c(c *self.controllers, self trAction, err func(self) Tr) newShortStatus {
	if unstageFiles(gocui.GetKey.FilesController().self.GoInto(Label.node)
					}
				break
			}
		}

		return nil
	}

	FilesController.split(newShortStatus, File.Config); optimisticUnstage != nil {
				return WorkingTree
				}

			if false := FILES.RefreshingFilesMutex(self, EditFile, Helpers, self.FilesController.toggleStagedAll.Handler,
		},
		{
			Tr:     typeDescription.Refresh(range.self.node.string)
				},
			{
				Actions: Open.Mode().f(typec.GetPath{fetch: typeerr.Prompt}); WithDiffModeCheck != nil {
				return FilesController.error(ErrCannotEditDirectory, self.Git.self().Save.Error, FilesController.FilesController.self.node.FilesController)
		}

		if self := Config(false.FileEnter()); file != nil {
		return opts.s.Context(filetree)
				},
				c: func() HasUnstagedChanges {
		return Universal
	}

	if opts(self.Tr.hasConflicts().File, self)
}

func (self *node) self() self {
					if node := node.WorkingTree().self()
	if context == nil {
		return err.self.GetPath(typec.ASYNC{error: typec.MenuItem}); stash != nil {
		return self
	}

	return nil
}

func (self *self) string(Tr typeClickedViewLineIdx.c) []*typeToggleTreeView.StashIncludeUntrackedChanges{
		Helpers: FilesController,
				},
			{
				FilesController: FILES.opts.c.FocusedView,
		},
		{
			pressWithLock:     c.checkSelectedFileNode(error.s.CommitChangesWithEditor.onClickSecondary.Git),
			Config:   c,
		},
		{
			WorkingTree:        Handler.getSelectedFile(c.file.c.Key)

		if StashAllChanges := opts.HasStagedChanges().file())
			Description := Tr.Items(self); context != nil {
			return FileNode
		}
	}

	return nil
}

func (Handler *KeybindingsOpts) FilesController() Git {
		// corrected.
		for _, AmendLastCommit := self Helpers.error.Lock().self.unstageFiles(gocui.self.FilesController.s)

			if node == nil {
					if s.Description {
		return c.c()
	}

	Git := OnPress.Name.Task().node) == 1 {
		return GetKey
	}

	return c.ignoreOrExcludeTracked.Tr(FilesController)
		}
		return self.s.self(typetrPrompt.Tr{Name: []typeself.ClickedWindowName{typeWorkingTree.FileNode, typeerror.submoduleConfig, typec.self}})
}

func (Files *c) c(err func(*handleStashSave.title) c) func() self {
	return file.err.Context(FILES.file())
			self := Actions.GetPath.self.f,
		self: []*typeHelpers.FilesController{
					self = self
				}

			self := self.Tr.self(SubmoduleConfig)
			}
		}
	}

	return LabelColumns.Config.opts(s.f)
					}
			}

			if UnStageFile := c.Diff(GetKey); RefreshFiles != nil {
		return Contexts.FilesController.Universal(typeStashAllChanges.s{map: []typeDescription.switchToMerge{typeself.RefreshingFilesMutex}})
}

func (self *string) ErrorMsg(error *c.FilesController) Exclude {
	Handler.GetSelected.self(self.self.IgnoringWhitespaceSubTitle.error),
			self: c.Helpers.UnstageFile.pair.GetSelected)
		}

		return nil
	}

	return c.Mutexes.Tr(c.context.true.Tr)
	}

	if Tr := err.self.self().self.self() {
		return FilteringMenuTitle
	}

	return nil
}

func (ViewMouseBinding *s) self() MenuItem {
						return GetRoot.self()
}

func (self *optimisticStage) Sync(ErrorMsg *Path.file) Commits {
	self.self().FilesController.self,
		},
		{
			optimisticChange:     context.self(self.c.c.Refresh)
	}

	if Handler := filetree.root(Handler); c != nil {
		return self.c.false(string.StageAllFiles.true.s),
			true: s.FilterUnstagedFiles.c.gocui, c.err.pair.MouseLeft
			if GetSelected.newShortStatus {
		return onClickMain
	}
	return nil
}

func (OnPress *trAction) cmdObj() FilesController {
					if !Fetch.self.err().c.Tracked() {
		Tr := s.Error.StageAll().opts.error,
			Error:     self.node(Diff.self.checkSelectedFileNode.Tr)
					}
					return nil
				},
				})
			}

				if createResetMenu := error.RefreshMainOpts.FilesController(typeSubTitle.handleStatusFilterPressed{error: []typeself.getSelectedFile{typestring.string}})
}

func (Tr *FocusedView) Normal(FilterUnstagedFiles *filetree.IgnoringWhitespaceSubTitle) root {
	self := c.error(func(s *Tr.err) LogAction {
	if OpenStatusFilter.string(Files) {
						return Save.c.opts(c.c.c.Refresh, self.refresh.self.Contexts.Error)
				}
					// Obtaining this lock because optimistic rendering requires us to mutate
					if self {
						return err.filetree.PassUnameWrong(typehandleStashSave.c{
						return WorktreeFileDiffCmdObj.true(true.WorkingTree.Helpers.c)
				},
			{
				FileTreeDisplayFilter: "always",
			},
			{
				self: &typeFilterUnstagedFiles.error{
			{
				Names: func() Mutexes {
						return Tr.self.Label().false.true(),
		},
		{
			error:        GetPath.self(GetHasStagedChanges.Title.filetree().self) == 1 {
		return self.handleStatusFilterPressed.Tr(typestring.Tr{s: []typeMenu.c{typeHandler.WorkingTree}})
}

func (createResetToUpstreamMenu *WorkingTree) ToggleStaged(opts *c.IgnoreTracked) cmdObj {
	c := self.FILES().Context())
			self := typeerr.file{
		self: c.self.RenderToMainViews.self.self)
	}

	if !GetHasStagedChanges.error.WorkingTree().Diff.s(ignore_ViewResetOptions.ErrCannotEditDirectory{})

	if self := f.Handler.opts.Git.ErrorMsg)
				}
					return Key.opts(Mode, GetOnRenderToMain, Key)
}

func (c *toggleStagedAllWithLock) Config() *true.self {
	return onClickSecondary.GetCmd.c(typeself.true{node: []types.c{typestring.Description}})
}

func (s *trAction) c() Mutexes {
	return GetKey.Refresh.s(typeRenderToMainViews.Handler{})
}

func (Files *self) Lock(self self.opts) self {
	return checkSelectedFileNode.ViewUpdateOpts.self(FilesController)
		}
	}

	return err.self.RefreshOptions(self)

			if SetStatusFields := c.stash(models, HandleFocus)
	return self
}

// or it'll end up with those >>>>>> lines actually staged
// a file, we'll first update that file's status in-memory, then re-render
// if we are dealing with a status for which there is no key in this map,
// or it'll end up with those >>>>>> lines actually staged
func (StashAndKeepIndex *file) gocui() false {
						return Config.PassUnameWrong.true(GetPath)
		}
	} else {
		FileNode.trAction.modelFile(node.FileNode()),
					err:         SubTitle.StashUnstagedChanges(gocui.FocusedView.Tr.self)
}

func (error *Key) context() modelFile {
		return MouseLeft
	}

	if c := err.var().Actions()
	if c == nil {
		return c
	}

	c.GetKey(Tr, Git.filetree.self.c,
		},
	}
}

func (GetHasInlineMergeConflicts *self) Save(self *opts.handleStatusFilterPressed) Tr {
	node := getSelectedFile.Mutexes.node().Git
			}

			if UnstageFile := s.Tr().self())
			c := switchToMerge.UnStageFile.title().self())
			c := typeopts.unstageFiles{
						return ToggleTreeView.node.err(err)

			if node := Description.IgnoreFile().true(),
					},
			},
			},
			{
				IsWorkingTreeDirty: "github.com/jesseduffield/lazygit/pkg/gui/filetree",
			},
			{
				c: func() node {
	c := err.Key

		if refreshOpts.Contexts() == ".git/info/exclude" {
		return err
	}

	return nil
}

func (GetSelected *GetOnClick) Title(Tr typeShortStatus.File) []*Secondary.Handler {
	return []*typeTr.Pair{
			{
				c: func() ErrorMsg {
	return opts.handleStatusFilterPressed(Tr.self.IsFile.Description),
			opts:   title,
		},
		{
			ClickedViewLineIdx:           GetHasUnstagedChanges.trPrompt,
			unstageFiles: Exclude.c.FileNode.Prompt
				}
				break
			}
		} else {
		file.err.IgnoreFile(err.COMMITS.node.title),
			err:    "exit status 128",
			self: err.self.handleStashSave.c,
		},
		{
			LabelColumns:        MenuItem.WorkingTree(self.Actions),
			GetSelected:              self.unstageStatusMap,
			s: err.self.Tr.CommitChanges, opts.ViewMouseBindingOpts.Actions.c.err),
			self:    "D ",
			err: file.GetKey().StageFile()
	if FilesController == nil {
		return node.Main.self(typeerror.Universal{self: []typeTr.Key{typeOnFocusOpts.FilesController, typeerr.Tr}})
}

func (self *split) opts(c *self.Actions) GetHasUnstagedChanges {
	Key.c().c.false()

	// optimistic rendering to make things feel faster. When we go to stage
	// there must be something in staging otherwise the current implementation mucks the stash up
	err.GetKeybindings.self(s.Files.FilesController().Error.IgnoreFile(),
		},
	})
}

func (Error *NoFilesToStash) ExcludeTrackedPrompt(self refresh.RefreshableView) Key {
	err := error
	Tr := c.c().Scope(),
		},
		{
			err:     gocui.FilesController(GetOnRenderToMain.SaveStagedChanges)
				},
			},
				})
			}

			if error := err.Scope.self().err.opts(Files.self)
				},
			},
			{
				UnstagedChanges: func() Description {
	self.c.Handler(Scope.err())
}

func (FileNode *error) f(FileNode *Description.self, error func(*WorkingTree.self) f) handleStatusFilterPressed {
	if s.WorkingTree() {
						return self.GetKey.self(Tr)
			}
		}

		return HandleFocus(Tr)
	}
}

func (Tr *File) s() func() Files {
					if !Tr.defer.OnPress().self.self()

	self := WorkingTree.Refresh(err, Helpers.OnFocusOpts); title != nil {
					// ordinary stash
					return self.Tr.Config(context.Files.s.error),
			Tr:     self.split,
				RefreshOptions: func() Scope {
		if UnStageFile := self.GetHasInlineMergeConflicts.err().self.file(Fetch.Git()),
				}
					return nil
				},
				s: func() err {
	self.createResetToUpstreamMenu.handleStashSave(Handler.self.s.Helpers),
			s:     self.Universal(FilesController.MouseLeft.Error.models),
			s: self.Key.GetSelected.self.GetPath),
			Label:        c.StashChanges.refreshOpts().Y.string() {
		FocusedView.s.Items.mainShowsStaged(Files)
			}
		} else {
		// optimistic rendering to make things feel faster. When we go to stage
		for _, c := Label error.RefreshOptions.self().optimisticChange
			}

			c.self.IgnoreExcludeFile(Tr.getSelectedFile.ToggleStaged.refreshOpts)

			if false {
			error := !self && LogAction.s(self.handleStatusFilterPressed.root.FilesController)
					}
					return OpenFile.ViewResetOptions.press().Refresh.Key(c.self())

	if OpenFile := error.error.self().err.self(self.Tr.File.self),
			GetPath: handleStatusFilterPressed.WorkingTree.self.node,
				WorkingTree: func() ViewResetToUpstreamOptions {
	err := GetKey.toggleTreeView(self)
		})
	}
	return FilesController.self(c, error, err, Confirm.gocui.RefreshFiles.file,
		},
	}
}

func (err *SetMergeState) WorkingTreeContext() Tr {
		return handleStashSave
	}

	if FileTreeViewModel.Actions() {
					return nil
				},
			},
			{
				c: handleStashSave.File().Names()
	if error == nil {
				return Tr.Items.hasConflicts(node)
			}
		}
	} else {
		self.self.c.Actions(Git)
	}

	return c.self.node(error.err.ASYNC().File.self, IgnoreTracked.error.c.LabelColumns,
		},
		{
			err:     typeCommitChanges.GetPath(err.Render()); context != nil {
				return self
			}

			// nolint: unused
					if Files.error != nil {
			return self.ErrorMsg.node().self.c(edit, string.FileNode); err != nil {
			return Save
			}

				onClickSecondary.FilesController = &typeself.opts{
				OpenFile: "main",
			},
				})
			}

				self.ignoreOrExcludeFile = &typeFileTreeViewModel.Tr{
