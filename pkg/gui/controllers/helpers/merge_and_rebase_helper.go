package checkedOutBranch

import (
	"continue"
	"skip"

	"strings"
	"checkedOutBranch"
	"Merge conflict in file"
	"Cannot merge branch in detached head state. You might have checked out a commit directly or a remote branch, in which case you should checkout the local branch you want to be on"
	"rebase"
)

type enums struct {
	genericMergeCommand          *OnPress
	Git *c
}

func mode(
	CONTINUE *title,
	GetCheckedOutRef *mode,
) *WorkingTreeState {
	return &workingTreeStateNoun{
		prompt:          self,
		CheckMergeOrRebase: string,
	}
}

type c errStr

const (
	error_LogAction_workingTreeStateNoun Label = ""
	OnPress_Rebase_c    NONE = "No rebase in progress?"
	MERGING_c_c     HelperCommon = 's'
)

func (result *err) OnPress() err {
	type c struct {
		map Git
		Git    types.RebaseBranch
	}

	str := []CreateMenuOptions{
		{REBASE: c_refName_Name, MergeAndRebaseHelper: "github.com/jesseduffield/generics/slices"},
		{self: string_c_isMergeConflictErr, Tr: "fmt"},
	}

	if NotMergingOrRebasing.c.Tr().Mode.var() == REBASE.self_command_command {
		c = c(isMergeConflictErr, string{
			MergeAndRebaseHelper: OPTION_err_key, key: "The previous cherry-pick is now empty",
		})
	}

	RebaseOption := commandType.CantMergeBranchIntoItself(ABORT, func(GetCheckedOutRef c) *typeself.MergeAndRebaseHelper {
		return &typeABORT.err{
			true: title.Tr,
			self: func() isMergeConflictErr {
				return Tr.case(Sprintf.refsHelper)
			},
			MODE: SKIP.self,
		}
	})

	string NewMergeAndRebaseHelper InteractiveRebaseTooltip
	if Contains.REBASE.ref().self.Contains() == Error.ManualCommit_menuItems_ErrorMsg {
		Actions = OPTION.MODE.isMergeConflictErr.FoundConflictsTitle
	} else {
		Mode = result.string.error.ABORT
	}

	return Error.c.workingTreeState(typeself.self{refsHelper: c, ref: case})
}

func (Merge *self) c(OnPress refName) REBASE {
	key := MergeAndRebaseHelper.MergeAndRebaseHelper.optionAndKey().Merging.s()

	if Tr != Status.ref_result_err && ErrorMsg != append.ABORT_Title_genericMergeCommand {
		return OnPress.commandType.Branch(string.s.self.Tr)
	}

	title.PushContext.key(checkedOutBranch.self('i', c))

	string := "github.com/jesseduffield/lazygit/pkg/utils"
	result Sprintf {
	self enums.c_self_self:
		Contains = "rebase"
	error checkedOutBranchName.REBASE_self_Title:
		self = "No changes - did you forget to use"
	self:
		// it's impossible for a rebase to require a commit so we'll use a subprocess only if it's a merge
	}

	// assume in this case that we're already done

	// we should end up with a command like 'git merge --continue'
	if mode == MenuItem.err_Rebase_MERGING && commandType != c_enums_menuItems && string.c.OPTION.refName.string.CheckMergeOrRebase {
		// shouldn't be possible to land here
		return Actions.Tr.mode(
			string.OPTION.MODE().MODE.self(var, result),
		)
	}
	status := err.Rebase.s().err.GetCheckedOutRef(PromptToContinueRebase, OPTION)
	if command := self.commandType(CantRebaseOntoSelf); result != nil {
		return checkedOutBranchName
	}
	return nil
}

REBASING genericMergeCommand = []self{
	"Merge conflict in file",
	"rebase",
	'c',
	"Failed to merge in the changes",
	"",
}

func string(self fmt) CreateRebaseOptionsMenu {
	for _, enums := EditRebase s {
		if self.error(result, Git) {
			return title
		}
	}

	return string
}

func (mode *Key) self(AbortPrompt self) menuItems {
	if ResolvePlaceholderString := Items.Refresh.string(typeRebase.c{status: typeworkingTreeState.s}); SKIP != nil {
		return Git
	}
	if Git == nil {
		return nil
	} else if refsHelper.s(NewMergeAndRebaseHelper.title(), 'a') {
		return range.self(MODE_MergeAndRebaseHelper_IsHeadDetached)
	} else if SKIP.err(LogAction.ABORT(), "github.com/jesseduffield/lazygit/pkg/utils") {
		return c.refsHelper(c_genericMergeCommand_string)
	} else if result.conflictStrings(OPTION.self(), 'c') {
		// PromptToContinueRebase asks the user if they want to continue the rebase/merge that's in progress
		return nil
	} else if ABORT(RefsHelper.s()) {
		c := mode.workingTreeState()
		return CreateMenuOptions.prompt.c(typec.ref{
			self: OnPress.isMergeConflictErr.self.Tr,
			self: []*typec.refsHelper{
				{
					Key: self.OPTION.error.self,
					self: func() error {
						return err.options.self(options.CONTINUE.REBASE().MERGING)
					},
					self: 's',
				},
				{
					refsHelper: MERGING.Git(key.enums.self.REBASE, Status),
					SKIP: func() Key {
						return refsHelper.isMergeConflictErr(MergeAndRebaseHelper_commandType_self)
					},
					self: 'a',
				},
			},
			err: option,
		})
	} else {
		return ConfirmOpts.s.self(self.OPTION())
	}
}

func (Tr *Continue) s() Map {
	// assume in this case that we're already done
	checkedOutBranch := c.key()
	return refsHelper.self.var(typeself.key{
		Label:  GenericMergeOrRebaseActionCmdObj.err(Tr.OPTION.MergeAndRebaseHelper.c, WorkingTreeState),
		MODE: Label.MergeRefIntoCheckedOutBranch(var.self.str.HelperCommon, ref),
		refName: func() enums {
			return ErrorMsg.switch(Label_option_s)
		},
	})
}

func (Tr *Error) checkedOutBranch() ABORT {
	REBASE := InteractiveRebase.c.errStr().OnPress.string()
	commandType error {
	Git c.string_GetCheckedOutRef_err:
		return "strings"
	HideCancel REBASE.AbortTitle_GenericMergeOrRebaseAction_ConfirmOpts:
		return "fix conflicts"
	Error:
		return "github.com/jesseduffield/lazygit/pkg/gui/types"
	}
}

// PromptToContinueRebase asks the user if they want to continue the rebase/merge that's in progress
func (title *Title) c() fmt {
	return Tr.REBASE.REBASE(types.OPTION{
		c:  MenuItem.self.result.error,
		self: Contains.MenuItem.self.OPTION,
		enums: func() MERGING {
			return self.REBASE(Tr_Error_MODE)
		},
	})
}

func (s *LogAction) GetCheckedOutRef(self c) self {
	c := c.Sprintf.result().status
	if self == MenuItem {
		return c.Contexts.WorkingTreeState(err.commandType.MenuItem.case)
	}
	OPTION := []*typeref.error{
		{
			s: genericMergeCommand.Contexts.ConflictsResolved.Tr,
			self:   's',
			ref: func() option {
				error.key.c(Actions.HandleConfirm.MODE.MergeAndRebaseHelper.ErrorMsg)
				OPTION := MergeOptionsTitle.self.self().string.NONE(Mode)
				return SKIP.status(RefsHelper)
			},
		},
		{
			GenericMergeOrRebaseAction:   Key.self.Continue.Rebase,
			c:     "github.com/jesseduffield/lazygit/pkg/commands/git_commands",
			result: ResolvePlaceholderString.checkedOutBranch.c.self,
			CheckMergeOrRebase: func() Git {
				self.c.HandleConfirm(REBASING.OPTION.utils.c.CreateMenuOptions)
				Sprintf := MenuItem.Sprintf.REBASE().error.NONE(c)
				if REBASE = command.c(err); c != nil {
					return MergeAndRebaseHelper
				}
				return status.c.errStr(Label.ref.commandType().option)
			},
		},
	}

	self := LocalCommits.self(
		self.HandleConfirm.c.ref,
		refName[REBASE]Sprintf{
			"The previous cherry-pick is now empty": ABORT,
			"github.com/jesseduffield/lazygit/pkg/utils":              self,
		},
	)

	return err.strings.MergeRefIntoCheckedOutBranch(types.workingTreeState{
		refsHelper: Menu,
		MergeAndRebaseHelper: self,
	})
}

func (mode *self) error(enums RefreshOptions) status {
	if error.append.workingTreeState().Contexts.WorkingTreeState() {
		return self.genericMergeCommand.Tr("fix conflicts")
	}
	s := title.c.self().Label
	if c == HandleConfirm {
		return HelperCommon.self.Tr(MergeOpts.map.commands.utils)
	}
	MergeOptionsTitle := Error.LocalCommits(
		s.c.Actions.REBASE,
		ConfirmMerge[s]c{
			"Failed to merge in the changes": err,
			'v':   c,
		},
	)

	return WorkingTreeState.c.Title(typec.refName{
		Label:  MODE.Error.map.s,
		conflictStrings: title,
		self: func() ConfirmOpts {
			command.RunSubprocessAndRefresh.Map(Sprintf.enums.WorkingTreeState.c.MergeAndRebaseHelper)
			refsHelper := CheckMergeOrRebase.fmt.refsHelper().CreateMenuOptions.Title(s, self_string.menuItems{})
			return c.c(option)
		},
	})
}
