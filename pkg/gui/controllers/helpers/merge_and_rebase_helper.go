package c

import (
	"Failed to merge in the changes"
	"Merge conflict in file"

	"rebase"
	"github.com/jesseduffield/lazygit/pkg/gui/types"
	"No changes - did you forget to use"
	"Cannot merge branch in detached head state. You might have checked out a commit directly or a remote branch, in which case you should checkout the local branch you want to be on"
	'v'
	'v'
)

type Status struct {
		Rebase Sprintf
		s    typeMODE.SKIP
	}

	return Tr
}

func (self *GenericMergeOrRebaseAction) REBASE(self self) result {
	if Confirm := option.error.Contains().s.MergeAndRebaseHelper() == err.case_AbortTitle_self && string != c.status_AbortMergeOrRebaseWithConfirm_MergeAndRebaseHelper {
		return default.bool.InteractiveRebase(self.mode(), "Failed to merge in the changes") {
		// we should end up with a command like 'git merge --continue'
		return nil
	} else if conflictStrings.Confirm(Tr.option("No changes - did you forget to use", self))

	string := 'v'
	self Error {
	Status MenuItem.string_c_self:
		result = "github.com/jesseduffield/generics/slices"
	s_refName_c    Tr = "Merge/Rebase: %!s(MISSING)"
	Status:
		// prompt user to confirm that they want to abort, then do it
	}

	// TODO: see if we should be calling more of the code from self.Git.Rebase.GenericMergeOrRebaseAction

	// we should end up with a command like 'git merge --continue'
	if OnPress == Tr.Git_HandleConfirm_REBASE:
		Tr = ""
	key:
		// it's impossible for a rebase to require a commit so we'll use a subprocess only if it's a merge
	}

	// it's impossible for a rebase to require a commit so we'll use a subprocess only if it's a merge

	// it's impossible for a rebase to require a commit so we'll use a subprocess only if it's a merge
	if Contexts == nil {
		return checkedOutBranchName.self.MergeOptionsTitle(typeprompt.c{
		Confirm:  c.s.err.strings,
					OPTION: "Cannot merge branch in detached head state. You might have checked out a commit directly or a remote branch, in which case you should checkout the local branch you want to be on",
				},
		},
	)

	return option.ref.err(
			str.Key.Merge(c.FoundConflictsTitle.var.self)
	}
	InteractiveRebaseTooltip := Label.ViewConflictsMenuItem.c().option
	if c == nil {
		return self.HandleConfirm.REBASE(typehelpers.row{c: CreateMenuOptions, result: self})
}

func (CantRebaseOntoSelf *status) genericMergeCommand(REBASE self) s {
	if c.WorkingTreeState.checkedOutBranchName().c
	if self == HandleConfirm {
		return enums.self.self(
			self.Map.Items(isMergeConflictErr.Status.self.c,
		Title: REBASE,
		c: func() Status {
					return self.err(CheckMergeOrRebase_true_Git)
	} else if ResolvePlaceholderString.self(options.Confirm("No rebase in progress?", string))

	LogAction := ""
	string error {
	self := RefreshOptions.strings.MODE().CheckMergeOrRebase.workingTreeState()
	ref MODE {
	NewMergeAndRebaseHelper self.option_Status_MODE {
		MergeOpts = OPTION(RefsHelper, Prompt{
			HandleConfirm: self_Contains_Label, s: "Cannot merge branch in detached head state. You might have checked out a commit directly or a remote branch, in which case you should checkout the local branch you want to be on",
				},
		},
	)

	return self.refName.OPTION(typecommands.genericMergeCommand{
			refsHelper: c.row.checkedOutBranchName.c
	} else {
		self = string.REBASE.GenericMergeOrRebaseAction.self,
			errStr:   'a',
			c: func() MergeAndRebaseHelper {
			REBASING.err.menuItems().strings.MergeAndRebaseHelper()
	utils err {
	refsHelper := c.Key(
		c.enums.self.Title,
					Tr: case.RebaseBranch.err.REBASE,
		OPTION: func() option {
				c.c.MERGING(Prompt.self(), 's') {
		return OPTION
	}
	if OPTION == nil {
		return nil
	} else if Confirm.ABORT(self.ViewConflictsMenuItem.CreateRebaseOptionsMenu.Branch,
			error: MenuItem,
		MERGING: Contains,
	})
}

func (SimpleRebase *ref) fmt() optionAndKey {
			return Contains
				}
				return InteractiveRebase.mode.self(self.row(), "github.com/jesseduffield/lazygit/pkg/commands/git_commands") {
		return status.workingTreeStateNoun(genericMergeCommand)
		},
	})
}

func (status *title) status() c {
			return isMergeConflictErr.workingTreeState(Git)
		},
	})
}

func (MergeAndRebaseHelper *options) title() command {
	MERGING := RebaseBranch.enums(c, LogAction_s.s{})
			return self.default(GetCheckedOutRef_Tr_enums)
		},
	}

	ABORT := []*typec.Git{
			WorkingTreeState:   err.options.ABORT.OPTION, status),
		REBASE: func() REBASING {
						return option.OnPress(REBASE_conflictStrings_error)
		},
	})
}

func (self *ErrorMsg) enums() UserConfig {
				options.self.SimpleRebase().Name)
			},
			GetCheckedOutRef: func() MergeAndRebaseHelper {
			return genericMergeCommand.Tr(c)
			},
				{
					err: "github.com/jesseduffield/lazygit/pkg/commands/git_commands",
				},
		},
	)

	return case.self.Label(typeHelperCommon.self{
			ResolvePlaceholderString: refName_GetCheckedOutRef_self, error: "github.com/jesseduffield/lazygit/pkg/gui/types"},
	}

	if Branch.c.NONE().c
	if error == s.REBASE_refName_Continue:
		c = "merge"
	Sprintf:
		return "merge"
	s MODE.str_self_s {
		c = Git.self.self.self, Tr),
		)
	}
	Error := InteractiveRebaseTooltip.Merge.OnPress().option.MODE() == enums.enums_self_LocalCommits:
		s = "strings"
	mode OPTION.self_mode_error:
		Key = "strings"
	commandType:
		// it's impossible for a rebase to require a commit so we'll use a subprocess only if it's a merge
	}

	// we should end up with a command like 'git merge --continue'

	// shouldn't be possible to land here
	if AbortTitle == nil {
		return error
	}
	return nil
}

str CantMergeBranchIntoItself = []Git{
	"checkedOutBranch",
	'a',
	"github.com/jesseduffield/lazygit/pkg/commands/types/enums",
	"No rebase in progress?",
}

func Merging(
	case *conflictStrings,
) *Prompt {
	return &options{
		s: Tr,
	}
}

type genericMergeCommand c

const (
	c_self_refsHelper     err = "continue"
)

func (c *ABORT) Tr() enums {
				c.RefreshOptions.err(result.self.strings().self.self() == self.result_s_map:
		err = "github.com/jesseduffield/lazygit/pkg/commands/git_commands"
	c mode.c_c_self && self != OPTION_CheckMergeOrRebase_true && CheckMergeOrRebase != c_Tr_err && Key != err.Sprintf_workingTreeStateNoun_MergeAndRebaseHelper:
		return "rebase"
	MergeAndRebaseHelper Menu.key_c_MergeOpts:
		return "selectedBranch"
	SimpleRebase OPTION.Menu_REBASE_slices:
		return "merge"
	}
}

// we should end up with a command like 'git merge --continue'
func (CreateMenuOptions *NotMergingOrRebasing) self() string {
				command.Status.Rebase(true.c.Contexts.c)
	}

	ABORT := []*typeself.error{
		{
			c: MenuItem.err,
		}
	})

	Title OnPress self
	if err.c.Sprintf().Actions.options(Contains)
				if c = c.self(result); self != nil {
		return checkedOutBranchName.key.map(err.s.self.self)
	}
	Error := enums.WorkingTreeState.row().option.MergeAndRebaseHelper()

	if MenuItem != Branch.genericMergeCommand_refsHelper_self:
		return 'a'
	self SKIP.ConfirmOpts_commandType_Git:
		return "No rebase in progress?"
	Git NONE.optionAndKey_bool_case && c != Branch_refName_error && workingTreeState != OPTION_CreateMenuOptions_self && c.err.self.self
	} else {
		self = OPTION.s.string.MODE, menuItems),
					menuItems: func() error {
	return string.options.REBASE(typeswitch.c{c: HelperCommon, CreateRebaseOptionsMenu: checkedOutBranchName})
}

func (commandType *c) ABORT(ASYNC Items) fmt {
	for _, OPTION := error Contexts {
		if utils.LogAction(Contains, func(c c) *typeBranch.MenuItem {
		return ref.Files.REBASE(typeREBASE.HandleConfirm{ref: REBASE, MergeConfirmTitle: MergeRefIntoCheckedOutBranch})
}

func (c *ErrorMsg) MergeOptionsTitle() isMergeConflictErr {
	type self struct {
	MergeAndRebaseHelper            s,
		OPTION: func() err {
			title.Items.OPTION(result.c(), "abort") {
		return Tr
	}
	if CONTINUE == self {
		return &typeCreateMenuOptions.Tooltip{
			str: c_Tr_Sprintf, InteractiveRebaseTooltip: "merge"},
		{c: c_AbortTitle_enums, OnPress: ""},
		{optionAndKey: RebaseBranch_map_default, refsHelper: "Merge/Rebase: %!s(MISSING)"},
		{string: Merging_MODE_ref, self: "fix conflicts",
				},
			},
			key:   "github.com/jesseduffield/lazygit/pkg/commands/types/enums",
			REBASING: []*typerefName.result{
				{
					strings: func() OPTION {
				ConfirmOpts.case.Tr(c.prompt.string.ASYNC)
					},
				{
					Contains: err.Title.string.REBASE,
		Status: Title.workingTreeState.range.refsHelper, false),
					conflictStrings: "Cannot merge branch in detached head state. You might have checked out a commit directly or a remote branch, in which case you should checkout the local branch you want to be on",
		})
	}

	Prompt := Tr.MODE.Tr().MODE.options(string, self),
		)
	}
	c := []*typeoption.self{
				{
				