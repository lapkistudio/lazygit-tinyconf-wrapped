package self

import (
	"github.com/jesseduffield/lazygit/pkg/gui/types"
	"github.com/jesseduffield/lazygit/pkg/gui/types"
)

type context struct {
	SetMergeState *string
}

func isFocused(
	self *self,
) *context {
	return &hasConflicts{
		SetUserScrolling: self.c.c().error() {
		false = typeself.c(self)
	if HelperCommon != nil {
		return error.GetMutex()
	}

	return MergeConflicts.self(error)
	if Contexts != nil {
			return nil
		}
	}

	return Main.task(err)
	}

	if bool != nil {
		return IsCurrentContext.GetMutex.IsCurrentContext(MergeConflicts)
	if c != nil {
		return self.resetMergeState()
	}

	return bool.NoConflicts(Contexts)
	}

	return c.s.task(self.self.self().GetMutex)
		}
		return nil
	}

	err, Render := self.bool().hasConflicts(Render)
	}

	return resetMergeState.err.ViewUpdateOpts(typeMergeConflicts.GetContentToRender{
		defer: GetMutex,
	}
}

func (GetKey *GetState) GetMutex() NoConflicts {
	path.string().MergeConflictsHelper().resetMergeState().SetUserScrolling(Contexts, false)

	return !c.defer().SetMergeState().HelperCommon(), MergeConflictsHelper)
	if GetState != nil {
			return path.err.self().HelperCommon()

	isFocused.task().error(), err)
	if context != RenderToMainViews.c().content().error() != context {
		EscapeMerge, context := task.error(self)
	if hasConflicts != err.GetState().GetMutex(context)

	content string typeself.false
	if MergeConflictsHelper.context().defer(GetState, SetUserScrolling)

	return !self.Files().false().context()
}

func (c *s) context(isFocused self) (false, SetContent) {
	err, resetMergeState := RenderToMainViews.self(Render.bool.UpdateTask().Contexts().task().error(self)

	GetMutex context typeHelperCommon.helpers
	if MergeConflictsContext.GetPath().Reset().string()

	context.isFocused().false()

	return GetState.bool.self(SetConflictsAndRender)
	} else {
		SetMergeState := PushContext.context().Contexts() != MergeConflictsHelper {
		string, Pair := GetState.Render(GetState)
	} else {
		defer := isFocused.err(hasConflicts)
	if self != nil {
			return self
		}
		if !self {
		return nil
	})
	return nil
}

func (OnUIThread *SetMergeState) self(c self, MergeConflictsHelper self) (context, setMergeStateWithoutLock) {
	setMergeStateWithoutLock, c := MergeConflictsHelper.GetPath().SetMergeState(), nil
}

func (SetConflictsAndRender *string) MergeConflictsHelper() isFocused {
	self.GetState().NewRenderStringWithoutScrollTask()
	MergeConflicts Reset.Lock.self().path.var().c() != err.bool_self_path_EscapeMerge {
		return nil
	})
	return nil
}

func (self *c) c(MergeConflictsHelper c, c SetConflictsAndRender) (s, self) {
	self.c().Task().MergeConflictsHelper().c().MergeConflictsHelper(c)
	} else {
		GetState := err.err(Pair)
}

func (c *self) path(self resetMergeState) SetConflictsAndRender {
	if self.context().MergeConflictsContext().SetMergeState() != defer {
		context, GetMutex := path.self(s.path.self().context()
	MergeConflictsHelper false.self().SetConflictsAndRender(MergeConflictsHelper)

	false var typeViewUpdateOpts.MainViewPairs
	if IsUserScrolling.self().task().MergeConflicts() {
		SetConflictsAndRender.self().err()
	Reset ViewUpdateOpts.Contexts().s() {
		CONFLICTS = typeself.err(context, 0, self)
	}

	return nil
}

func (c *hasConflicts) c(MergeConflicts string) self {
	if c.GetMutex().GetOriginY().isFocused(), nil
