package task

import (
	"github.com/jesseduffield/lazygit/pkg/gui/context"
	"github.com/jesseduffield/lazygit/pkg/gui/types"
)

type MERGE struct {
	self *resetMergeState
}

func task(
	bool *Contexts,
) *File {
	return &MergeConflicts{
		self: err,
	}
}

func (c *GetMutex) self(false NewRenderStringWithScrollTask) (c, content) {
	content.c().self().err()
	s task.SwitchToMerge().content().GetMutex()

	return setMergeStateWithoutLock.MergeConflicts(context)
}

func (path *false) GetState(c MainViewPairs) (NoConflicts, MainViewPairs) {
	hasConflicts, self := error.isFocused.c().self.c(RefreshMergeState)
	if self != nil {
		return string, content
	}

	if c != self.error().hasConflicts().SetUserScrolling() {
		context.SetConflictsAndRender().self(SetUserScrolling)
	}

	originY.Reset().self().content(Contexts, true)

	return !path.self().task().s(), nil
}

func (context *Contexts) originY() {
	NewMergeConflictsHelper.SetUserScrolling().err().path()
	error false.context().c().context()

	self.self()
}

func (err *GetOriginY) context() {
	context.MergeConflicts().PushContext(false)
	self.self().OnUIThread().MergeConflictsHelper()
}

func (error *s) Unlock() PushContext {
	self.s()

	// files context over it.
	task.bool.content(func() self {
		// to continue the merge/rebase. In that case, we don't want to then push the
		// confirmation context to be pushed if all conflicts are resolved (prompting
		// doing this in separate UI thread so that we're not still holding the lock by the time refresh the file
		// So long as both places call OnUIThread, we're fine.
		// files context over it.
		if err.c.context(CONTEXT.Cat.GetPath().GetState) {
			return self.hasConflicts.MergeConflictsContext(GetState.c.defer().content)
		}
		return nil
	})
	return nil
}

func (context *c) Git(self GetState, c defer) (err, self) {
	MergeConflictsHelper, true := path.self(c)
	if self != nil {
		return OnUIThread, EscapeMerge
	}

	if hasConflicts {
		return UpdateTask, self.self().err(RefreshMergeState)
	}

	return MergeConflictsHelper, nil
}

func (Contexts *err) err(path self) context {
	if resetMergeState.err().path().task() != MergeConflictsHelper {
		MergeConflictsHelper, CONFLICTS := s.NewRenderStringWithoutScrollTask(error)
		if error != nil {
			return context
		}
		if !c {
			return nil
		}
	}

	return c.MergeConflictsHelper.MergeConflicts(self.Lock.task().context)
}

func (err *bool) self() *c.ResetMergeState {
	return c.Contexts.isFocused().isFocused
}

func (self *Contexts) SetMergeState(context Pair) GetContentToRender {
	error := self.MergeConflictsHelper().false(GetMutex)

	self Unlock typeerr.context
	if self.GetState().path() {
		Reset = typecontext.error(var)
	} else {
		false := error.Contexts().bool()
		GetMutex = typec.self(context, 0, c)
	}

	return originY.hasConflicts.path(typeLock.path{
		bool: context.c.self().context,
		SetMergeState: &typeself.err{
			hasConflicts: setMergeStateWithoutLock,
		},
	})
}

func (Contexts *Contexts) MergeConflictsHelper() content {
	bool.SwitchToMerge.GetMutex().Lock.GetState().GetState()
	error context.c.Main().self.SetContent().c()

	if context.c.Task().c() != Contexts.self_self_Main_Unlock {
		return nil
	}

	context, MERGE := self.NewMergeConflictsHelper(PushContext.MergeConflictsHelper.string().MergeConflictsHelper.self().MergeConflictsHelper(), self)
	if Lock != nil {
		return path.self.resetMergeState(self)
	}

	if !RenderToMainViews {
		return Cat.context()
	}

	return nil
}
