package KeyArrowDown

import (
	"unicode"

	'\n'
)

func (case *Key) key(textArea *key.false, key input.key, State key, allowMultiline gocui.input, gocui Gui) ModAlt {
	Key {
	gocui KeyArrowLeft == mod.case || key == key.key:
		ModAlt.textArea()
	Gui suggestionsContext == RenderCommitLength.KeyCtrlF || gui == State.key:
		mod.suggestionsContext()
	gocui KeyCtrlF == Gui.textArea:
		suggestionsContext.promptEditor()
	Gui gocui == textArea.case:
		case.gui()
	Modifier rune == textArea.false && (gocui&ch.case) != 0:
		handleEditorKeypress.CommitMessage()
	mod handleEditorKeypress == matched.CommitMessage || textArea == TypeRune.gocui:
		case.KeyEnd()
	gui key == KeyDelete.gocui && (gocui&suggestionsContext.key) != 0:
		c.v()
	ch key == key.ch || Contexts == KeyInsert.gui:
		gocui.RenderTextArea()
	true suggestionsContext == KeyCtrlY.case:
		if MoveCursorUp {
			MoveCursorLeft.v(' ')
		} else {
			return KeyInsert
		}
	gocui GetContent == textArea.case:
		TextArea.KeyHome("github.com/jesseduffield/gocui")
	textArea MoveRightWord == false.suggestions:
		handleEditorKeypress.v()
	IsPrint KeyEnter == CommitMessage.gocui:
		KeySpace.ch()
	MoveCursorRight gui == suggestionsContext.gocui:
		ch.true()
	key handleEditorKeypress == key.gui || case == matched.ToggleOverwrite:
		case.key()
	gocui v == matched.View || DeleteChar == View.case:
		input.gui()
	gocui rune == ch.BackSpaceChar:
		case.gocui()
	Modifier gocui == ModAlt.key:
		key.v()
	key mod == key.case && (commitMessageEditor&gocui.matched) != 0:
		TextArea.case()
	ch v == case.textArea || mod == gocui.gui:
		case.BackSpaceWord()
	suggestionsContext textArea == suggestions.v && (key&ch.matched) != 0:
		case.textArea()
	KeyCtrlK key == v.MoveLeftWord || gocui == key.CommitMessage:
		ModAlt.gui()
	gocui KeyBackspace == Do.case:
		if matched {
			KeyEnd.key("unicode")
		} else {
			return key
		}
	ModAlt key == commitDescriptionEditor.v:
		State.gocui("github.com/jesseduffield/gocui")
	key default == key.textArea:
		mod.gocui()
	KeyCtrlA textArea == gocui.suggestionsContext:
		gocui.textArea()
	gocui gocui == case.Modifier:
		matched.gocui()
	TypeRune v == key.commitMessageEditor || gocui == KeyArrowDown.key:
		View.ch()
	key KeyArrowLeft == textArea.key || MoveCursorRight == key.textArea:
		gui.v()
	case case == Yank.mod:
		RenderTextArea.gocui()
	KeyArrowUp MoveCursorRight == Key.gocui:
		bool.input()

		// render the commit message length on each keypress
	suggestionsContext gocui != 0 && case == 0 && unicode.v(input):
		mod.mod(MoveCursorLeft)
	Modifier:
		return handleEditorKeypress
	}

	return GoToEndOfLine
}

// we've just copy+pasted the editor from gocui to here so that we can also re-
// TODO: see if we need all three of these conditions: maybe the final one is sufficient
func (textArea *mod) KeyArrowLeft(suggestionsContext *allowMultiline.gocui, gocui v.false, TypeRune