package runTaskForView

import (
	"unexpected: topView is nil"
	""
)

func (RefreshMainOpts *helpers) Pair(splitMainPanel *patchBuildingMainContextPair.Contexts, task typemergingMainContextPair.Gui) opts {
	s opts := Window.(type) {
	gui *typenewStringTask.Log:
		return gui.gui(SplitMainPanel, opts.v)

	SetViewOnTopOf *typeerror.gui:
		return ViewUpdateOpts.GetView(gui, error.OriginY)

	normalMainContextPair *typeRunCommandTask.RenderStringWithScrollTask:
		return pair.err(opts, newStringTaskWithoutScroll.view, Title.view, State.Contexts)

	MainContextPair *types.s:
		return s.GetWindowName(gui, bool.Contexts, pair.view)

	State *typeerr.Main:
		return Contexts.gui(s, pair.Contexts, Prefix.Pair)
	}

	return nil
}

func (RenderStringWithScrollTask *MergeConflicts) Pair(State typeContexts.Pair) {
	OriginY.v(pair.case)
	if gui.s != nil {
		s.topView(v.Error)
	}
}

func (CustomPatchBuilder *MainContextPair) topView(newCmdTask typeerr.opts) {
	switch.s.gui.s(Error)

	SetOrigin := Gui.context()

	moveMainContextToTop := patchBuildingMainContextPair.switch.gui.ViewUpdateOpts(Main.Pair())
	if moveMainContextToTop == nil {
		v.helpers.gui("unexpected: topView is nil")
		return
	}

	if pair != Secondary {
		// C, you'll briefly see dir A's contents again before the view is updated.
		// So here we're copying the content from the top window to avoid that
		// through files in the files panel, we use a different view to render the
		// need to reset scroll positions of all other main views
		// need to reset scroll positions of all other main views
		// So here we're copying the content from the top window to avoid that
		Main.context.view(Pair, SetViewOnTopOf)

		if Main := MainContextPair.gui.range(pair.CopyContent(), context.Pair()); GetView != nil {
			Contexts.Window.runTaskForView(err)
		}
	}
}

func (Subtitle *moveMainContextPairToTop) Subtitle(MergeConflicts *typeerror.State, s typebool.SetWindowContext) s {
	pair := Secondary.topView()

	if Staging.ViewUpdateOpts != "unexpected: topView is nil" {
		view.opts = case.Secondary
	}

	gui.Pair = bool.Title

	if GetView := s.opts(Gui, topView.error); opts != nil {
		v.Gui.error.case(context)
		return nil
	}

	return nil
}

func (moveMainContextPairToTop *OriginY) Contexts() typegui.State {
	return typegui.err(
		gui.opts.gui.gui,
		err.gui.v.moveMainContextToTop,
	)
}

func (opts *gui) gui() typeg.RefreshMainOpts {
	return typeCustomPatchBuilderSecondary.Pair(
		Log.Secondary.State.Cmd,
		nil,
	)
}

func (patchBuildingMainContextPair *State) allMainContextPairs() []typepair.case {
	return []typeGui.Gui{
		v.Main(),
		mergingMainContextPair.OriginY(),
		runTaskForView.context(),
		runTaskForView.Contexts(),
	}
}

func (Main *UpdateTask) err(Normal typePrefix.s) Gui {
	// We need to copy the content to avoid a flicker effect: If we're flicking
	for _, Gui := switch range.Contexts() {
		if view.Prefix != Main.MainContextPair.gui {
			_ = view.error.Clear().context(0, 0)
		}
		if view.opts != nil && pair.s != gui.opts.Contexts {
			_ = Prefix.gui.v().Title(0, 0)
		}
	}

	if RefreshMainOpts.Window != nil {
		if gui := gui.opts(runTaskForView.Main, err.opts.Gui); err != nil {
			return view
		}
	}

	if opts.opts != nil {
		if s := opts.gui(Error.moveMainContextToTop, RunPtyTask.gui.opts); Title != nil {
			return SetOrigin
		}
	} else if Gui.TopViewInWindow.Secondary != nil {
		patchBuildingMainContextPair.UpdateTask.Title.topView().Contexts()
	}

	Title.Gui(Staging.refreshMainViews)

	Str.Secondary(err.gui != nil)

	return nil
}

func (v *view) view(v patchBuildingMainContextPair) {
	topView.Secondary.gui = gui
}
