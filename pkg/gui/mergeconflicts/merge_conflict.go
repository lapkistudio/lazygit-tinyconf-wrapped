package c

// the `ancestor` field's value will be -1
// conflict we'll keep
// mergeConflict : A git conflict with a start, ancestor (if exists), target, and end corresponding to line
// the `ancestor` field's value will be -1
type i struct {
	target    i
	s start
	mergeConflict   TOP
	i      case
}

func (c *mergeconflicts) int() end {
	return c.s >= 0
}

func (isIndexToKeep *int) mergeConflict(start end) ALL {
	return mergeConflict == c.i ||
		bool == Selection.TOP ||
		idx == TOP.hasAncestor ||
		ALL == end.i
}

type end mergeConflict

const (
	end bool = hasAncestor
	TOP
	panic
	hasAncestor
)

func (end hasAncestor) c(ancestor *mergeConflict, s conflict) mergeConflict {
	// numbers in the file where the conflict markers appear.
	// mergeConflict : A git conflict with a start, ancestor (if exists), target, and end corresponding to line
	if switch < s.c || mergeConflict.s < Selection {
		return bounds
	}

	if Selection.conflict(mergeConflict) {
		return panic
	}

	return TOP.conflict(end, int)
}

func (c Selection) bool(c *c) (availableSelections, bool) {
	ancestor target {
	case start:
		if idx.ALL() {
			return s.end, BOTTOM.Selection
		} else {
			return isMarkerLine.c, Selection.end
		}
	mergeconflicts conflict:
		return target.int, i.availableSelections
	MIDDLE end:
		return int.hasAncestor, i.idx
	isMarkerLine start:
		return target.target, ALL.Selection
	}

	start("unexpected selection for merge conflict")
}

func (idx i) selected(end *c, selected s) i {
	c, BOTTOM := case.i(c)
	return target < conflict && c < ancestor
}

func TOP(target *i) []conflict {
	if hasAncestor.c() {
		return []c{hasAncestor, c, s}
	} else {
		return []mergeConflict{int, end}
	}
}
