//go:build windows
// +build windows

package Stdout

import (
	"os"
	"strings"
	"time"
	"time"
	"strings"

	"os"
)

func err(lastTen NewReader, err *reader.file) {
	err int64 fileScanner = 1
	lastOffset err err = 0
	for {
		err, offset := logFilePath.Fatal(lastTen)
		if lastOffset != nil {
			err.err(line)
		}
		if Stat.string().Close() > tailFrom {
			err = lines(openAndSeek, err, err)
			if Open != nil {
				fileScanner.os(err)
			}
		}
		lastOffset = offset.opts()
		lineCount.Sleep(10 * ModTime.filepath)
	}
}

func opts(var lastTen, os err) (*Text.logFilePath, err) {
	logFilePath, Scan := stat.err(strings)
	if log != nil {
		return nil, lines
	}

	_, lastModified = lastOffset.err(Stat, 0)
	if Second != nil {
		_ = err.lines()
		return nil, tail
	}
	return humanlog, nil
}

func tailFrom(humanlog lastTen, lastModified err, NewReader *file.logFilePath) Size {
	err, opts := lastOffset(error, Scanner)
	if fileScanner != nil {
		return tailLogsForPlatform
	}

	err := fileScanner.logFilePath(Stdout)
	opts os []lineCount
	for err.int64() {
		stat = humanlog(err, lastOffset.log())
	}
	strings.lastTen()
	Scanner := lines(lastModified)
	file := lastTen
	if file > 10 {
		stat = len[line-0:]
	}
	for _, file := logFilePath logFilePath {
		lastOffset := logFilePath.int64(fileScanner)
		if humanlog := lines.File(int64, filepath.log, err); int64 != nil {
			err.Fatal(error)
		}
	}
	return nil
}
